
17:10 2007-9-1
较新的gcc，例如3.4.4，不支持字符串跨行。现在还不会使用gcc文档，查gcc文档，待做。
Newer versions of gcc (e.g. 3.4.4) do not allow strings
to span several lines. See the gcc docs for details.

Jiri.

didier101155 wrote:

> Compiling the following c code (for a Leon2 with the sparc-elf-3.4.4
> gcc on a host machine sparc station 20 with solaris 5.8), my command
> line is:
> sparc-elf-gcc -c ldexp.c -o ldexp.o 
> 
> ======================================= extract of the code
> 
> 
>   /* Get the raw exponent. */
> // line 55-57
>   asm volatile (
>        "sll     %H1,1,%0
>         srl     %0,21,%0" : "=r" (e) : "r" (u.ll));
> 
>  ....
> // line 74-78
>     /* Put new exponent into answer */
>     asm volatile (
>        "and     %H0,%2,%H0
>         or      %H0,%3,%H0" : 
>     "=r" (u.ll) : "0" (u.ll), 
>     "r" (0x800fffff), "r" ((e + 1022) << 20));
> 
> }
> ======================================= end extract
> 
> and I have the following error:
> line 56: missing terminating " character
> line 57: 'srl' undeclared (first use in this function)
> line 75:missing terminating " character
> line 76: 'or' undeclared (first use in this function)
> line 76: 'H0' undeclared (first use in this function)
> 
> But I can compile it with the native gcc of GNAT. What is wrong ?
> I try to make a separate asm volatile for each command but after I
> have a problem with the linker.
> 
> Thank you
>
自: Re: Compiling problem with sparc-elf-gcc
Posted by: "Jiri Gaisler" jiri@gaisler.com   jiri_gaisler
Fri Aug 31, 2007 7:00 am (PST) 

9:59 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, s3c2410实现上电读取nand flash前4k的机制
自: vivi开发笔记（九）：SDRAM实验
http://blog.chinaunix.net/u/21948/showart_353273.html
s3c2410如何实现自动读取nand flash的前4KBytes数据到内部sram buffer当中。网上为什么没人就这点产生疑问，并深入分析呢？我分析可能有两种方法：一是像at91rm9200一样，内部集成一个小的rom，固化代码，这部分代码的作用就是完成自动读取功能；二是完全用硬件实现。仔细看了框图，发现s3c2410只有internal sram buffer，并没有rom，所以最大可能就是硬件实现。看一下硬件框图figure6-1，可以发现hardware ECC编解码器，可以看到internal buffer（4KB），另外注意的一个地方是，存在着control state machine和buffer control，而且之间有粗体线链接。也就是说明了用一个控制状态机实现了自动读取4KB数据的过程，完全的硬件实现。
疑问：这里看不到OM0, OM1起的作用，查，待做。

11:09 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
SDRAM部分，p11-p12
设置SDRAM参数：
1, SCAN表示列地址数，HY57V561620数据手册p2看到Column Address : CA0 ~ CA8。待做：其它参数对照代码学习。
2, bank size设置大于实际侄没关系，多出来的空间程序会检测出来，不会发生使用不存在的内存的情况——后面介绍到的bootloader和linux内核都会作内存检测。

11:29 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
flash部分
1, flash操作方法见2410手册6-3(p218)；
2, flash使用前一般先使用flash复位命令0xff复位一次；
3, 注意地址操作。在K9F1208U0M数据手册第7页的表格列出了在地址操作的4个步骤对应的地址线，注意A8没用到。
待做: S3C2410完全开发流程好像有个资料包，找。

11:53 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
完成阅读S3C2410完成开发流程，现在的遗留问题：
1, 现在2410MMU还基本没有了解。
2, 存储器参数设置需要自己再计算一次；
3, 锁相环的代码。
4, 中断需要复习一下；
5, 下面三个没有看过文档：DMA, 液晶，USB。

12:15 2007-9-2
上午学习结束，下午看vivi学习文档。

13:43 2007-9-2
吃饭拖地后，回到电脑前。

0:11 2007-9-3
上周总结：
分析了u-boot和vivi第一阶段的代码。完成u-boot第一阶段中从nand复制内容到ram工作。收集到大量相关资料。但是效率稍低，最大问题是周五凌晨三点才睡，其次是周三下午一两点得到汤姆森面试通知后到晚上，除了1小时以内时间准备面试，其余时间都用来看电视剧，自己并不是很想看，看的很郁闷。上周学习时间平均每天3-4小时。
下周计划：
1, 希望学习提高到每天6小时以上；
2, 完成u-boot移植，使之可以引导Linux；
3, 坚持每天12点前睡觉7天，早晨起床迅速，时间不大于1h20'，目标是1h。
4, 继续实行每日改进；
5, 与想做嵌入式的新研一师弟交流。

9:21 2007-9-1
u-boot

9:48 2007-9-1
看到一个好博客：
很多嵌入式开发文章
http://blog.chinaunix.net/u/21948/showart_346147.html
vivi开发笔记（一）：学习计划
感觉差距很大，人家从去年年底做嵌入式开发，开始还没接触过Linux，比我学的多了很多。

14:22 2007-09-01
1, 昨晚链接出错的原因就是编译器的问题，用3.4.1不行，3.3.2就可以，很奇怪。这和注释里面提到的需要用3.4以上编译起矛盾；
2, u-boot启动成功，但是flash类型和容量都不正确。
日志和文件见"s3c2410/bootloader/u-boot/NAND_flash_boot"

16:40 2007-09-01
待做：
1，周末看vivi博客；
2，看汤姆森笔试题，练习链表。
3，日志工具亟需排序工具。
4，如果有时间看u-boot启动c语言代码。改其它内容：提示符，ip地址等。

17:10 2007-9-1
较新的gcc，例如3.4.4，不支持字符串跨行。现在还不会使用gcc文档，查gcc文档，待做。
Newer versions of gcc (e.g. 3.4.4) do not allow strings
to span several lines. See the gcc docs for details.

Jiri.

didier101155 wrote:

> Compiling the following c code (for a Leon2 with the sparc-elf-3.4.4
> gcc on a host machine sparc station 20 with solaris 5.8), my command
> line is:
> sparc-elf-gcc -c ldexp.c -o ldexp.o 
> 
> ======================================= extract of the code
> 
> 
>   /* Get the raw exponent. */
> // line 55-57
>   asm volatile (
>        "sll     %H1,1,%0
>         srl     %0,21,%0" : "=r" (e) : "r" (u.ll));
> 
>  ....
> // line 74-78
>     /* Put new exponent into answer */
>     asm volatile (
>        "and     %H0,%2,%H0
>         or      %H0,%3,%H0" : 
>     "=r" (u.ll) : "0" (u.ll), 
>     "r" (0x800fffff), "r" ((e + 1022) << 20));
> 
> }
> ======================================= end extract
> 
> and I have the following error:
> line 56: missing terminating " character
> line 57: 'srl' undeclared (first use in this function)
> line 75:missing terminating " character
> line 76: 'or' undeclared (first use in this function)
> line 76: 'H0' undeclared (first use in this function)
> 
> But I can compile it with the native gcc of GNAT. What is wrong ?
> I try to make a separate asm volatile for each command but after I
> have a problem with the linker.
> 
> Thank you
>
自: Re: Compiling problem with sparc-elf-gcc
Posted by: "Jiri Gaisler" jiri@gaisler.com   jiri_gaisler
Fri Aug 31, 2007 7:00 am (PST) 

9:59 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, s3c2410实现上电读取nand flash前4k的机制
自: vivi开发笔记（九）：SDRAM实验
http://blog.chinaunix.net/u/21948/showart_353273.html
s3c2410如何实现自动读取nand flash的前4KBytes数据到内部sram buffer当中。网上为什么没人就这点产生疑问，并深入分析呢？我分析可能有两种方法：一是像at91rm9200一样，内部集成一个小的rom，固化代码，这部分代码的作用就是完成自动读取功能；二是完全用硬件实现。仔细看了框图，发现s3c2410只有internal sram buffer，并没有rom，所以最大可能就是硬件实现。看一下硬件框图figure6-1，可以发现hardware ECC编解码器，可以看到internal buffer（4KB），另外注意的一个地方是，存在着control state machine和buffer control，而且之间有粗体线链接。也就是说明了用一个控制状态机实现了自动读取4KB数据的过程，完全的硬件实现。
疑问：这里看不到OM0, OM1起的作用，查，待做。

11:09 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
SDRAM部分，p11-p12
设置SDRAM参数：
1, SCAN表示列地址数，HY57V561620数据手册p2看到Column Address : CA0 ~ CA8。待做：其它参数对照代码学习。
2, bank size设置大于实际侄没关系，多出来的空间程序会检测出来，不会发生使用不存在的内存的情况——后面介绍到的bootloader和linux内核都会作内存检测。

11:29 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
flash部分
1, flash操作方法见2410手册6-3(p218)；
2, flash使用前一般先使用flash复位命令0xff复位一次；
3, 注意地址操作。在K9F1208U0M数据手册第7页的表格列出了在地址操作的4个步骤对应的地址线，注意A8没用到。
待做: S3C2410完全开发流程好像有个资料包，找。

11:53 2007-9-2
嵌入式，arm, s3c2410, 远峰开发板学习（续）, "S3C2410完全开发流程"笔记
完成阅读S3C2410完成开发流程，现在的遗留问题，待做：
1, 现在2410MMU还基本没有了解。
2, 存储器参数设置需要自己再计算一次；
3, 锁相环的代码。
4, 中断需要复习一下；
5, 下面三个没有看过文档：DMA, 液晶，USB。

12:15 2007-9-2
上午学习结束，下午看vivi学习文档。

13:43 2007-9-2
吃饭拖地后，回到电脑前。

0:11 2007-9-3
上周总结：
分析了u-boot和vivi第一阶段的代码。完成u-boot第一阶段中从nand复制内容到ram工作。收集到大量相关资料。但是效率稍低，最大问题是周五凌晨三点才睡，其次是周三下午一两点得到汤姆森面试通知后到晚上，除了1小时以内时间准备面试，其余时间都用来看电视剧，自己并不是很想看，看的很郁闷。上周学习时间平均每天3-4小时。
下周计划：
1, 希望学习提高到每天6小时以上；
2, 完成u-boot移植，使之可以引导Linux；
3, 坚持每天12点前睡觉7天，早晨起床迅速，时间不大于1h20'，目标是1h。
4, 继续实行每日改进；
5, 与想做嵌入式的新研一师弟交流。

12:00 2007-09-03
实验室，待做
上学期分配的零六级同学调试单片机开发板的工作需要他们完成，不能养成他们分配的实际任务不完成的习惯。单片机开发板这个是实际分配到人的任务，而且郭跃也已经完成了他自己的任务————RF。

12:18 2007-9-3
开始学习u-boot，今天要完成u-boot第二阶段的移植。希望还能完成nand读写。
下午要办健康证和涮杯子，估计需要1小时。
下午计划学习5个小时。如果下午完成计划，晚上练习链表。

16:04 2007-9-3
15:05-16:04老师找，芸芸电话，与郭跃讨论问题。

16:56 2007-9-3
16:56-18:03
打水。
找吴老师聊：汤姆森实习（支持）；实验室发展：研二这届不能总看书不动手，实验室例会候哥说说我也说说，给师弟师妹提建议。
问吴老师找同学做嵌入式Linux如何，吴老师担心同学对软件（编程）兴趣小，基础不好。但同意如果有兴趣也可以做。
bamvor: 积极争取1-2同学做嵌入式Linux，把这块传下去。至少有同学了解嵌入式Linux开发流程。

17:28 2007-9-3
实验室，完成
下周何勇和朱超把张旺和建辉做的板子架出去。
何勇手机关机，等待朱超回复告诉我何时可以过来。

19:26 2007-9-3
下午u-boot学习结束。共学习5小时。晚上再接再厉。完成NAND读写还是有希望的。

22:40 2007-9-3
吃饭，与芸芸讨论职业发展，打水。

12:32 2007-09-03
u-boot flash识别
./cpu/arm920t/start.S:
	ldr     pc, _start_armboot
_start_armboot:   .word start_armboot
执行lib_arm/board.c的void start_armboot (void)
里面的下面代码检测并输出flash大小。
#ifndef CFG_NO_FLASH
        /* configure available FLASH banks */
        size = flash_init ();
        display_flash_config (size);
#endif /* CFG_NO_FLASH */


12:42 2007-09-03
找与CFG_NO_FLASH有关的定义，从结果看与NAND无关。
./common/flash.c，里面是flash操作。
./common/cmd_load.c:
static ulong load_serial (ulong offset);
static ulong load_serial_ymodem (ulong offset);
用到addr2info，flash_write和flash_perror。
./common/cmd_mem.c
do_mem_cp调用addr2info
./common/cmd_bootm.c
#ifdef CONFIG_PPC下的do_bootm_linux函数调用addr2info，这个与我无关。

12:52 2007-09-03
开始修改，首先要保证启动正常
1, CFG_ENV_IS_IN_NAND与nand有关，稍后修改，见后面日志。
2, 在include/configs/YF2410.h的CONFIG_COMMANDS定义下，打开CFG_CMD_NAND；
3, lib_arm/board.c的里面如果定义了CFG_CMD_NAND和CONFIG_COMMANDS，会定义nand_init函数，且在LCD初始化后执行flash初始化。
该函数定义于"drivers/nand/nand.c"，初始化位于nand_init > nand_init_chip >
board_nand_init和nand_scan。前者由开发板实现。
struct nand_flash_dev {
        char * name;
        int manufacture_id;
        int model_id;
        int chipshift;
        char page256;
        char pageadrlen;
        unsigned long erasesize;
        int bus16;
};
这里觉得涉及范围太广了。
从"基于smdk2410开发板u-boot-1.2.0 nand flash读写操作及命令实现(1)"看到vcma9这个开发板也使用2410芯片。搜索board下所有config.mk文件，发现使用2410芯片的板子除smdk2410和我的YF2410还有mpl/vcma9和sbc2410x。前者flash实现的很完整，后者不完成，后面主要参考vcam9进行修改。

14:59 2007-09-03
想找使用arm芯片但是不使用CFG_NAND_LEGACY的，没有找到。

15:50 2007-09-03
对照vcma9修改，首先复制所有带有"#if (CONFIG_COMMANDS & CFG_CMD_NAND)"的内容：
1，include/configs/YF2410.h，复制自"include/configs/VCMA9.h"
加入NAND flash settings
这里面是扇区大小等参数，以及flash操作函数定义。下面的定义不明白，查，待做：
#define ADDR_COLUMN 1
#define ADDR_PAGE 2
#define ADDR_COLUMN_PAGE 3

#define NAND_ChipID_UNKNOWN     0x00
#define NAND_MAX_FLOORS 1
#define NAND_MAX_CHIPS 1
2, board/YF2410/YF2410.h。原来没有这个文件，复制自"board/mpl/vcma9/vcma9.h"，实现NAND flash底层操作函数。另外要加入"#include <s3c2410.h>"，里面实现了"S3C2410_GetBase_NAND"，S3C2410_NAND位于s3c24x0.h。"s3c24x0.h"包含在"s3c2410.h"中。定义了NAND flash的所有寄存器：
/* NAND FLASH (see S3C2410 manual chapter 6) */
typedef volatile u32    S3C24X0_REG32;
typedef struct {
        S3C24X0_REG32   NFCONF;
        S3C24X0_REG32   NFCMD;
        S3C24X0_REG32   NFADDR;
        S3C24X0_REG32   NFDATA;
        S3C24X0_REG32   NFSTAT;
        S3C24X0_REG32   NFECC;
} /*__attribute__((__packed__))*/ S3C2410_NAND;
S3C2410_GetBase_NAND函数如下：
#define S3C2410_NAND_BASE               0x4E000000
static inline S3C2410_NAND * const S3C2410_GetBase_NAND(void)
{
        return (S3C2410_NAND * const)S3C2410_NAND_BASE;
}
可以看出是返回的NAND flash寄存器基址，然后通过强制转换为S3C2410_NAND类型，这时NFCONF等六个寄存器的地址也就确定了。他们每个都是32位寄存器，已经通过S3C24X0_REG32定义为32位整数，32位寄存器占用的空间是4字节，所以结构体里寄存器的地址的间距是4，例如NFCONF的地址=S3C2410_NAND=0x4E000000，NFCMD的地址=S3C2410_NAND+4=0x4E000004。
3, (18:41 2007-09-03)
board/YF2410/YF2410.c，复制自"board/mpl/vcma9/vcma9.c"，实现flash复位和初始化函数。由于定义了CFG_NAND_LAGECY, nand_init也在这里定义。
在文件的开始#include最后加入"#include YF2410.h"，这里的flash函数需要前面定义的底层函数的支持。
这里的nand_probe定义于"driver/nand_legacy/nand_legacy.c"
nand_legacy.c文件中定义了flash操作的通用函数，阅读，待做，下面是：
1, 里面有个"CONFIG_SHOW_BOOT_PROGRESS"，将来可以考虑加上，待做。
2, NAND_CMD_RESET等命令在"include/linux/mtd/nand.h"定义
3i, nand_legacy.c包含了<linux/mtd/nand_ids.h>，说明nand_flash_ids定义在这个文件。由于定义了CFG_NAND_LEGACY，没有使用drivers/nand/nand_ids.c中定义的nand_flash_ids。

19:06 2007-09-03
1, cpu/arm920t/nand_read.c的__REGb到NFSTAT等定义注释试试。待做。
2, cpu/arm920t/start.S的on_the_ram部分注释后可以正常工作，待做已完成。

19:24 2007-09-03
编译有错误，是头文件定义的问题，回来查。

23:46 2007-09-03
u-boot编译有问题，没查出来原因。
明天继续努力！

13:12 2007-9-4
上午9:45-11:10，1h25'；后来浪费时间，12:18去吃饭。
下午开始

13:42 2007-9-4
睡到13:35
16:17 2007-9-4
下午实验室收拾东西，

17:34 2007-9-4
可以识别出flash型号。flash读写有问题。感觉选择legacy不是好的选择。吃饭

18:57 2007-9-4
吃饭归来。

19:10 2007-9-4
摘抄
U-Boot中SMDK2410的NAND Flash驱动。
自: 
/* #define CONFIG_MTD_NAND_VERIFY_WRITE 1 */
/* This definition above is commented by Lu Xianzi. 2006.05.28
   Because there's no definition of a macro called __mem_pci,
   there will be a link error.
 */
#define CONFIG_MTD_NAND_ECC_JFFS2 1
#endif /* CONFIG_COMMANDS & CFG_CMD_NAND */
 
注意这段宏定义中与vcma9.h中不同的是我标记红色的部分，网上的一些移植说明没有解决这个问题，导致最后的链接无法通过。事实上，我这样做取消了cmd_nand.c中对NAND Flash的写校验和ECC校验。__mem_pci是一个什么东西我也不知道，在U-Boot目录下搜索包含“__mem_pci”字串的文件也没有找到，除了使用它的/include/asm/io.h。顺便说一下，这个麻烦是从cmd_nand.c中的nand_write_page函数中 readb(nand->IO_ADDR)这个宏开始的，你可以用Source Navigator查找一下引用，最后就指向没有__mem_pci宏的这个问题。希望有高手看到这篇文章，并给我指出解决的办法，呵呵。 	

21:06 2007-9-4
写一个已经成功的日志用了将近1.5小时（中间出去20分钟），效率太低了。

23:28 2007-9-4
u-boot学习结束。

16:20 2007-9-5
嵌入式, bootloader, vivi
yangyh(MSN群 Linux&ARM之家): vivi copy_myself代码的疑问，该部分代码
VIVI编译出来一般有100K左右吧，NAND厂商会保证至少前4k是好的。这样拷贝100K，而不处理坏块，总觉得不可靠：
竹林漂泊<张健> 说:
嗯，我当时是这样理解的：首先烧写vivi时会通过ECC保证写入数据正确。然后vivi在读取flash内容前，做了初始化，NFCONF＝0xf830，NFCONF[12]=1的含义是打开ECC校验。所以数据如果读出，就是正确的。
查，ECC和坏块什么关系，ECC的校验是如何进行的？待做。
另外一个相关问题是向flash写入时是否检测了坏块，是否ECC，是否纠错。
相关文章：Nand Flash 启动 时的 ECC问题"http://blog.chinaunix.net/u/24474/showart_257617.html"

09:58 2007-09-04
昨天的错误原因可能是"drivers/nand_legacy/Makefile"编译时没有加入板子的库。

11:11 2007-09-04
$(LIBS):
                $(MAKE) -C $(dir $(subst $(obj),,$@))
u-boot的Makefile大量使用了($dir...), ($subst...)等，不知道什么含义。开始以为是shell，但没查到。后来下载了make手册，这些都是Makefile的命令。($subst from,to,test)是把test字符串中的from替换为to，$dir names...)是得到字符串的目录名。上面的"$(dir $(subst $(obj),,$@))"是得到要编译的所有库文件的所在目录，然后用make -C进行编译。drivers/nand_legacy/libnand_legacy.a是一个所需的库，所以会进入"drivers/nand_legacy"开始编译。

16:22 2007-09-04
编译nand_legacy.c遇到的错误是由于没有找到"board/YF2410/YF2410.h"，不知道正确方法是如何加入，可能编译nand_legacy.c时直接加入"board/$(BOARDDIR)/lib$(BOARD).a"库就可以，但是我不会用。
drivers/nand_legacy/nand_legacy.c
  35 /* bamvor.add.2007-09-04 */
  36 #ifdef CONFIG_YF2410
  37 #include "../../board/YF2410/YF2410.h"
  38 #endif
这样需要定义"CONFIG_YF2410"：
include/configs/YF2410.h：
 38 /* bamvor.modified.2007-09-04 */
 39 /*#define CONFIG_SMDK2410               1*/     /* on a SAMSUNG SMDK2410 Boa    rd  */
 40 #define CONFIG_YF2410           1       /* on a SAMSUNG SMDK2410 Board  */
 41 /* bamvor.modified.2007-09-04.end */
所以u-boot中其它修改的地方，cpu/arm920t/s3c24x0/interrupts.c
180 /* bamvor.modified.2007-09-04 */ \
181       defined(CONFIG_SMDK2410) || \
182       defined(CONFIG_YF2410) || \
183 /* bamvor.modified.2007-09-04.end */ \
修改后编译通过，这个版本应该可以正确识别NAND存储器的大小和类型，有可能可以支持NAND命令。

19:34 2007-09-04
nand flash读写没有问题。饭后上网找nand操作方法，发现自己忘了先擦除。日志件u-boot-nand.txt。这里发现一个问题如果"md 311111111"或"md 3201ffff"，板子都会重启。难道是访问了不能访问的内存区域？查，待做
注意：u-boot命令里面的数据不用加"0x"就表示16进制。

21:23 2007-09-04
继续修改：
1，修改PROMPT，位于include/configs/YF2410.h的CFG_PROMPT；
2，修改网卡等, CONFIG_ETHADDR，CONFIG_IPADDR和CONFIG_SERVERIP；
3，去掉flash的配置。加入CFG_NO_FLASH后，board/YF2410/flash.c报错。
"21:42 2007-09-04"
make[1]: Entering directory
`/usr/src/s3c2420-linux/bootloader/u-boot-1.2.0/board/YF2410'
flash.c:75:2: #error "Unknown flash configured"
make[1]: *** 没有规则可以创建“libYF2410.a”需要的目标“.depend”。 停止。
make[1]: Leaving directory
`/usr/src/s3c2420-linux/bootloader/u-boot-1.2.0/board/YF2410'
make: *** [board/YF2410/libYF2410.a] 错误 2
"22:05 2007-09-04"
这次是cmd_bootm.c报错，是CONFIG_CMD_DFL定义的问题。CONFIG_CMD_DFL是默认命令，需要用去除。
有问题，参考"board/stxgp3"的选择。
发现开始board/YF2410/flash.c中宏定义反了，但是修改后编译无法通过，从提示开还是进入了flash.c"#ifndef CFG_NO_FLASH"里面的编译，对比stxgp3发现，后者把"#ifndef CFG_NO_FLASH"放在了flash.ce的"#include <common.h>"后面，修改后，此处编译通过，原因未知，查，待做。
(23:21 2007-09-04)
加入CFG_ENV_IS_IN_NAND：
#define CFG_ENV_IS_IN_NAND      1 
#define CFG_ENV_OFFSET  0x38000 /* environment starts here  */
#define CFG_ENV_SIZE    0x8000  /* Total Size of Environment Sector */
错误：
                cd /usr/src/s3c2420-linux/bootloader/u-boot-1.2.0 &&
arm-linux-ld -Bstatic -T
/usr/src/s3c2420-linux/bootloader/u-boot-1.2.0/board/YF2410/u-boot.lds -Ttext
0x33F80000  $UNDEF_SYM cpu/arm920t/start.o \
                        --start-group lib_generic/libgeneric.a
board/YF2410/libYF2410.a cpu/arm920t/libarm920t.a
cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a
fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a
fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a
rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a
drivers/nand_legacy/libnand_legacy.a drivers/sk98lin/libsk98lin.a
post/libpost.a post/cpu/libcpu.a common/libcommon.a --end-group -L
/usr/local/arm/3.3.2/lib/gcc-lib/arm-linux/3.3.2 -lgcc \
                        -Map u-boot.map -o u-boot
common/libcommon.a(env_nand.o)(.text+0xe4): In function `saveenv':
/usr/src/s3c2420-linux/bootloader/u-boot-1.2.0/common/env_nand.c:206:
undefined reference to `nand_info'
common/libcommon.a(env_nand.o)(.text+0x174): In function `env_relocate_spec':
/usr/src/s3c2420-linux/bootloader/u-boot-1.2.0/common/env_nand.c:282:
undefined reference to `nand_info'
make: *** [u-boot] 错误 1
基本是最后一步了。问题是nand_legacy使drivers/nand/nand.c中nand_info没有定义，待做已完成，参考"s3c2410linux"文档完成修改。另外CFG_NO_FLASH解决，一是flash.c不编译，二是去掉相关命令：
                        (CONFIG_CMD_DFL & \
                         ~(CFG_CMD_IMLS | \
                          CFG_CMD_FLASH)  \
                        )  

21:37 2007-09-04
c语言学习
处理没有实现或预定义定义不正确的情况。编译时编译器会提示"#error "Unknown flash configured""
#if
......
#else
#error "Unknown flash configured"
#endif

09:10 2007-09-05
关于"boot from nand flash续3"中提到的CMD_SAVEENV和ENV_IS_EMBEDDED：
1, common/env_nand.c：
如果CONFIG_COMMANDS中定义了CFG_CMD_ENV和CFG_CMD_NAND，定义CMD_SAVEENV；
2，include/environment.h文件中，如果定义了CFG_ENV_IS_IN_NAND，那么当定义CFG_ENV_IS_EMBEDDED时定义ENV_IS_EMBEDDED。现在还不清楚ENV_IS_EMBEDDED的作用。

09:42 2007-09-05
根据"boot from nand flash续2"修改
完成保存环境变量功能，代码"u-boot-1.2.0_20070905_1030.tar.gz"。编译结果和log见"u-boot\0905"。
待做：复制"u-boot_no-flash－info_env-cmd_readme"内容至此。

20:59 2007-09-05
tftpboot和bootm成功
[root@localhost tools]# ./mkimage -A arm -O Linux -T kernel -C none -a 0x30008000 -e 0x30008000 -n Linux2.6.14 -d zImage_2054 zImage_2054_mk
Image Name:   Linux2.6.14
Created:      Wed Sep  5 20:47:53 2007
Image Type:   ARM Linux Kernel Image (uncompressed)
Data Size:    976804 Bytes = 953.91 kB = 0.93 MB
Load Address: 0x30008000
Entry Point:  0x30008000
见"u-boot/BootLinux"，tftpboot是使用go启动失败的例子；tftpboot_successful是使用bootm成功的例子。
(23:19 2007-09-05)
autoboot_SDRAM, autoboot_flash分别是从内存和flash读取内核映像并启动的例子。这里还没有文件系统。

14:57 2007-9-6
网址
1, 嵌入式博客
http://www.lupaworld.com/23340
2, http://www.lupaworld.com/
lupa开发社区，看，待做。
3, http://hi.baidu.com/wangy0919/blog
博客，很多嵌入式Linux文章。待看
4, http://linux.about.com/
关于Linux的搜索引擎，常用 
5, http://xianzilu.spaces.live.com/
关于嵌入式Linux很好的博客，待看

16:07 2007-09-06
现在已经成功移植u-boot和Linux内核到YF2410开发板，还需要建立文件系统。打算利用今明两天回顾这一阶段的移植总结成文档，理解u-boot代码。周末进行编程练习。

22:49 2007-09-06
待做：
1, 日志搜索的范围可以设置，这样可以包括已有的文档。但对于文档要定义新的分隔符。

16:10 2007-09-07
待做
1，看"uClinux源代码中Make文件完全解析————基于ARM开发平台"的第二章Makefile的理解和阅读入门。排在完成汤姆森面试题之后。
2, 做文件系统的工作可能会推迟。下周集中联系编程基本功。并抽出一些时间看最近找到的文档。
3, 买skyeye书。

17:19 2007-09-07
u-boot
1, tftpboot无法下载文件，奇怪！今天去掉on_the_ram的不行，0905那个也不行。loady可以；
2, tftpboot应该在下载内核后启动，不能启动内核，可能也有问题。

13:58 2007-09-08
Linux, 内核转储(core dump)文件：
FC6是在bash启动时关闭的：
ulimit -S -c 0 > /dev/null 2>&1
ulimit使用设置shell和它所建立的进程能使用的资源。
-c 0表示"The maximum size of core files created"是0，就是关闭了内核转储文件。
-S表示软件限制。
"> /dev/null 2>&1"表示把ulimit的输出信息写入/dev/null设备，并将这个操作的标准错误输出信息重定向到标准输出。这样向"/dev/null"设备写入数据如果出错也不会显示。
ulimit -c unlimited
表示内核转储无限制。

21:49 2007-09-08
整理u-boot和Linux2.6移植所有待做（未完）：
1, 10:40 2007-08-20
待做，本周coding学习计划：
1, 静态链表；
2, proc文件系统，移植platx的gpiomonitor到arm或leon(platx/gpiomon.c)；由于没有嵌>入式2.6内核。先在PC机学习proc文件系统。
2, 23:20 2007-08-22
c语言函数学习：
strcasecmp和strncasecmp，忽略大小写的比较字符串。这样fisco里面包和字符串的转换又
可以简化了。
编程练习：待做，下载libc源代码，自己编写这个函数。
3, "17:58 2007-8-23"网址,
http://blog.chinaunix.net/u1/42456/article_59898.html
arm Linux移植等。好，看，待做。
4, "14:30 2007-8-24" "ARM映象文件及执行机理001"这个文档属于"ARM学习报告"，查所有文档，待做。

16:55 2007-09-09
c语言, 编程练习
编写一个链表插入操作，插入后的链表元素为升序排列。链表元素类型为整数。自汤姆森实习笔试题。
程序中遇到的错误
1，
typedef int elem_t;
typedef struct __LNode {
    elem_t data;
    struct __LNode  *next;
}LNode;
如果写成
typedef int elem_t;
typedef struct LNode {
    elem_t data;
    LNode  *next;
}LNode;
会有下面的错误：
[bamv26@localhost LinkList]$ gcc -o LinkList -g -DLINK_LIST_DEBUG -DLINK_LIST_MAIN LinkList.c 
LinkList.c:23: 错误：expected specifier-qualifier-list before ‘_LNode’
LinkList.c: 在函数 ‘insertList_ao’ 中：
LinkList.c:44: 错误：‘LNode’ 没有名为 ‘next’ 的成员
......
LinkList.c:63: 错误：‘LNode’ 没有名为 ‘next’ 的成new_node
后来是参考vivi的include/command.h，"17:25 2007-08-25"：
typedef struct user_command {
        const char *name;
        void (*cmdfunc)(int argc, const char **);
        struct user_command *next_cmd;
        const char *helpstr;
} user_command_t;
2, 
LNode *head = NULL;
LNode *new_node= NULL;
原来没有加"NULL"
(17:33 2007-09-09)
insertList_ao完成，晚上完成遍历，然后周总结，给汤姆森经理写信。将来还可以在main中实现信号处理等。

21:45 2007-09-09
写travel_LinkList的错误
1, 
LNode *head;
......
DPRINT("address: 0x%08x,\t", head);
写成了
DPRINT("address: 0x%08x,\t", &head);

22:39 2007-09-09
完成有头节点的单链表的有序插入和遍历，可以继续实现链表的所有操作。如果完成了数据类型是整型的链表，再完成数据类型不是简单数据类型的链表操作。例如满足fisco要求的链表。data_structure\LinkList\LinkList.c
今天总代码量163行。


10:43 2007-9-10
嵌入式, 可配置SOC, 继续关注Tensilica
自: http://www.ed-china.com/ART_8800022480_400012_500016_OT_98a8fb3a.HTM?click_from=2100002130,8000029336,2007-09-10,EDCOL,ARTICLEALERT
Tensilica现已建立起一个完整的生态系统，它的第三方合作伙伴现可以为上述Diamond系统内核提供完整的软硬件支持环境，包括：Monta Vista提供的Linux OS支持；Mentor Graphics提供的Nucleus Plus OS支持；Sophia Systems提供的micro-iTRON支持；Wind River提供的Tornado/VxWorks OS支持；Mentor的Seamless产品所提供的软硬件协同验证支持；Sophia Systems和Yokogawa Digital Computer提供的ICE支持；Macraigor Systems、Sophia Systems和FS2提供的JTAG ICE支持；Synopsys、Cadence和Magma的EDA工具支持；Intervideo、Sci-worx、Dolby、 CodingTechnology、Qsound、SRS、SONIC Networks等公司提供的音视频解决方案支持；以及Upzide提供的VDSL网络解决方案支持。
bamvor: 待做，是时候关注一下monta vista发行版了，另外，交叉编译工具链也需要在摩托罗拉招聘前完成。

10:46 2007-9-10
嵌入式, MIPS收购chipidea
自: http://www.ed-china.com/ART_8800022488_400012_500016_HN_7110867e.HTM?click_from=2100002130,8000029336,2007-09-10,EDCOL,ARTICLEALERT
Gartner 公司的报告显示，全球半导体 IP 市场规模在 2006 年达 18 亿美元，其增长率为 24%。目前，模拟和混合信号 IP 市场是半导体 IP 市场增长最快的领域。
MIPS并购Chipidea，荣登全球第二大IP公司宝座
MIPS 科技收购私人拥有的Chipidea Microelectrónica S.A. 公司（简称 Chipidea）。Chipidea 是无线、数字消费电子和连接市场模拟和混合信号 IP 独立供应商。根据Gartner 2006 年的排名，并购后的实体将成为全球第二大半导体设计 IP 公司和全球第一大模拟 IP 公司。
bamvor: chipidea在苏州有设计中心。
http://www.chipidea.com/website/main/index.do

10:53 2007-9-10
嵌入式, CPU
比较嵌入式处理器优劣的依据：
性能、功耗、流片费用、许可费用和生态系统(SOC的软硬件支持)
原题: ARM的领导地位正受到Tensilica的强烈冲击
自: 
http://www.ed-china.com/ART_8800022480_400012_500016_OT.HTM

11:17 2007-9-10
待做
1 看c语言专家编程英文版第六章p126页，或中文版对应部分。继续学习堆栈。
2, 看数据结构第四章串，里面的串匹配算法；
3, 看下列博客，c语言相关
http://blog.csdn.net/yxin1322/
http://blog.csdn.net/zhanglixin/
http://blog.csdn.net/colin719/

15:14 2007-9-10
汤姆森实习被拒，发了感谢信："8.31面试感谢信（9月10日）.txt"
感谢信如果在周三发可能更好一些。

00:13 2007-09-10
今日计划：
1，9点前完成。转换数据结构前三讲视频。查堆栈资料，10点前写完信给汤姆森前台打电话。
2，下午查tftpboot出错原因，理解代码并且解决该没有引导内核的问题。
3，看数据结构线性表部分书，保证晚上用20-30分钟进行总结。
本周计划：
1，周一————周三完成u-boot和Linux日志。周四周五收集文件系统资料。进行编程练习，本周代码量大于500行。
2，提醒研一同学记工作日志。何勇等太阳能灯项目。
3，每天学习六小时，有记录时间大约10小时，晚上12点前睡觉。每天看英语一小时。

22:03 2007-09-10
修改nand_read_ll调用前后的寄存器后，u-boot无法启动。

22:05 2007-09-10
只有当定义bootcmd时，bootdelay才有效。

23:31 2007-09-10
不论mov ip, lr在copy_myself开始还是在nand_read_ll之前都不可以。明天用ICE和low level debug进行调试。估计问题是nand_read_ll中修改了ip的值，所以程序跑飞了。 

23:44 2007-9-10
明日计划：
0, 学习时间超过5小时；
1, 上午完成u-boot调试；
2, 下午完成u-boot第一阶段总结；
3, 抽时间看英语1小时。

10:26 2007-09-11
嵌入式，arm, s3c2410, 远峰开发板学习（续）, u-boot, 
调用前nand_read_ll保存lr
用"arm-linux-objdump -d u-boot > temp"进行反汇编，可以看到在nand_read_ll中有多处改写ip的情况，所以程序在copy_myself后无法跳回.
33f80748 <nand_read_ll>:
......
33f807b4:       e1a0c8c4        mov     ip, r4, asr #17
......
33f807d0:       e5c2c000        strb    ip, [r2]
源码和反汇编结果：
backup/u-boot-1.2.0-2007-09-11-10:32:11.tar.gz
3c2410/bootloader/u-boot/r10-ip/u-boot_disasemble.S
(11:14 2007-09-11)
2410Linux文档里也是把lr保存到r10，感觉这样很不清楚。尝试保存到堆栈中。
        @bamvor.add.2007-09-10
        @mov    ip, lr
        str     lr, [sp]!
        @bamvor.add.2007-09-10.end
        bl      nand_read_ll
        @bamvor.add.2007-09-10
        @mov    lr, ip
        ldr     ip, [sp]
        @bamvor.add.2007-09-10.end
......
done_nand_read:
        mov     lr, ip
        mov     pc, lr


12:24 2007-09-11
细看了autoboot_flash.txt，发现SDRAM是16M有问题，解决，待做。
Linux2.6/0823/bootm.txt日志中也是16M.

12:36 2007-09-11
Linux, Unix
pico是一个文本编辑软件。

13:21 2007-09-11
Linux, 备份, 补丁, diff, patch
学习如何打补丁，参考的"DiffPatch.html  Linux下Patch的应用和制作方法介绍.txt"
用N参数，处理目录不同的情况。
diff -urN 旧目录 新目录 > 新目录对旧目录的补丁
cd 旧目录
patch -p1 < 新目录对旧目录的补丁
这样旧目录内容与新目录内容完全相同。查找是否有补丁失败的情况：
find . -name *.rej

14:23 2007-09-11
看了会儿存储器，困了，SDRAM和flash的硬件设计和软件配置很重要，一定要理解，但是暂缓，本周完成，待做。

16:18 2007-09-12
研究生两年总结：
1, 遇到问题一定要解决。没有解决的问题要记入日志。

17:40 2007-09-12
待做，修改配置文件，重新补丁，修改文档
/*#define CONFIG_BOOTFILE       "elinos-lart" */
/*#define CONFIG_BOOTCOMMAND    "tftp; bootm" */
是否需要gateway？

18:52 2007-09-12
u-boot
configs/*.h定义的环境变量位于：
commom/environment.c
env_t environment __PPCENV__ = {
        ENV_CRC,        /* CRC Sum */
#ifdef CFG_REDUNDAND_ENVIRONMENT
        1,              /* Flags: valid */
#endif
        {
#if defined(CONFIG_BOOTARGS)
        "bootargs="     CONFIG_BOOTARGS                 "\0"
#endif
......
#ifdef  CONFIG_BOOTFILE
        "bootfile="     MK_STR(CONFIG_BOOTFILE)         "\0"
#endif
......
#ifdef  CONFIG_EXTRA_ENV_SETTINGS
        CONFIG_EXTRA_ENV_SETTINGS
#endif
        "\0"            /* Term. env_t.data with 2 NULs */
        }
};
其中env_t位于：
environment.h
typedef struct environment_s {
        unsigned long   crc;            /* CRC32 over data bytes        */
#ifdef CFG_REDUNDAND_ENVIRONMENT
        unsigned char   flags;          /* active/obsolete flags        */
#endif
        unsigned char   data[ENV_SIZE]; /* Environment data             */
} env_t;

tools/environment.c目录也有类似的内容，目的何在？
上面定义的environmenet结构只有当ENV_IS_EMBEDDED才有效。
否则env_nand.c会使用定义在common/env_common.c的"default_environment"。
uchar default_environment[] = {
#ifdef  CONFIG_BOOTARGS
        "bootargs="     CONFIG_BOOTARGS                 "\0"
#endif
......
        "\0"
};

20:59 2007-09-12
tftpboot等网络命令都由netboot_common实现：
int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
        return netboot_common (TFTP, cmdtp, argc, argv);
}

U_BOOT_CMD(
        tftpboot,       3,      1,      do_tftpb,
        "tftpboot- boot image via network using TFTP protocol\n",
        "[loadAddress] [bootfilename]\n"
);
只有当autostart设置为yes时，才会自动启动。

21:21 2007-09-12
windows
其实winrar也可以不压缩只归档，这样就可以用winrar的文件分割工具。

22:16 2007-09-12
代码阅读：
common/cmd_nvedit.c: getenv

23:06 2007-09-12
阅读getenv和do_printenv。感觉亮点是把得到环境变量字符"env_get_char"放到外部的一个函数指针中。根据是否进行了环境变量的重定位使用不同的函数。如果是重定位前，需要考虑不同ROM的情况，使用一个统一的外部函数env_get_char_spec。外部函数在不同ROM文件中定义。如下图：

第三层：实现环境变量操作		getenv,   do_printenv......
                	                  \		  /
        	                           \ 调用外部函数/
	                                    \		/
第二层：公共层，实现公共操作		    env_get_char（函数指针)
	复杂操作由上一层实现		     /	   	\
	不同阶段使用不同函数	env_get_char_spec, env_get_char_memory
					|
第一层：硬件抽象层，针对不同		|
	的存储器实现通用的函数	env_get_char_spec（实现）


09:47 2007-09-13
今天完成romfs或ramdisk应该没有问题。

10:08 2007-09-13
1, 修改nand
flash分区，现在和"嵌入式设计......"那本书的分区一致。但没有加入"MTD_WRITEABLE"
//bamvor.add.2007-08-22.modified.2007-09-13
static struct mtd_partition partition_info[] = {
    {
        .name   = "bootloader",
        .size   = 0x00038000,
        .offset = 0x0
    },
    {
        .name   = "environment",
        .size   = 0x00008000,
        .offset = 0x00038000
    },
    {
        .name   = "kernel",
        .size   = 0x001C0000,
        .offset = 0x00040000
    },
    {
        .name   = "root",
        .size   = 0x03000000,
        .offset = 0x00200000
    },
    {
        .name   = "user",
        .size   = 0x00E00000,
        .offset = 0x03200000
    }
};

2， 解决内核启动是ram容量不正确的问题：

10:25 2007-09-13
arch/arm/mm/init.c，负责memory初始化 。
void __init mem_init(void)
......
        printk(KERN_INFO "Memory:");

        num_physpages = 0;
        for (i = 0; i < meminfo.nr_banks; i++) {
                num_physpages += meminfo.bank[i].size >> PAGE_SHIFT;
                printk(" %ldMB", meminfo.bank[i].size >> 20);
        }


11:16 2007-09-13
mem_init由start_kernel调用。

14:07 2007-09-13
(15:24 2008-10-27)
(15:44 2008-11-6)
(10:51 2009-2-6)
Linux学习, 移植, 代码阅读, 启动, c语言阶段, tag机制, "vimicro_Linux移植文档"9, DONE
九, Linux tag机制
这是一年半以前的日志, 主要分析了Linux如何使用tag, 参考了vivi开发笔记（十七）. 
1, 第一路从setup_arch开始查
===========================
init/main.c:
//......
extern void setup_arch(char **);
//......
asmlinkage void __init start_kernel(void)
{
        char * command_line;
        extern struct kernel_param __start___param[], __stop___param[];
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
        lock_kernel();
        page_address_init();
        printk(KERN_NOTICE);
        printk(linux_banner);
        setup_arch(&command_line);
        setup_per_cpu_areas();
......

setup_arch位于:
--------------
arch/arm/kernel/setup.c:
void __init setup_arch(char **cmdline_p)
{
        struct tag *tags = (struct tag *)&init_tags;
//...
	if (mdesc->boot_params)
		tags = phys_to_virt(mdesc->boot_params);
//...
	//代码：如果采用param_struct保存参数，转化为tag。
	//代码：如果第一个tag不是ATAG_CORE，则使用init_tags，不使用bootloader传入的tag。

        if (tags->hdr.tag == ATAG_CORE) {
                if (meminfo.nr_banks != 0)
                        squash_mem_tags(tags);
                parse_tags(tags);
        }

    init_tags位于同目录：
    /*
     * This holds our defaults.
     */
    static struct init_tags {
            struct tag_header hdr1;
            struct tag_core   core;
            struct tag_header hdr2;
            struct tag_mem32  mem;
            struct tag_header hdr3;
    } init_tags __initdata = {
            { tag_size(tag_core), ATAG_CORE },
            { 1, PAGE_SIZE, 0xff },
            { tag_size(tag_mem32), ATAG_MEM },
            { MEM_SIZE, PHYS_OFFSET },
            { 0, ATAG_NONE }
    };

        tag_header定义于"include/asm-arm/setup.h"
        struct tag_header {
                u32 size;
                u32 tag;
        };

        tag_size位于同一文件：
        #define tag_size(type)  ((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
        
        struct tag_core {
                u32 flags;              /* bit 0 = read-only */
                u32 pagesize;
                u32 rootdev;
        };

    struct tag位于"include/asm-arm/setup.h":
    struct tag {
            struct tag_header hdr;
            union {
                    struct tag_core         core;
                    struct tag_mem32        mem;
    //......
            } u;
    };
可以看出init_tags的结构是:
tag_header1
The_first_tag
tag_header2
The_second_tag
tag_header3
中间还可以加入多个tag_header和The_nth_tag，最后用tag_header两个字段都是0，表示init_tags结束，后面parse_tags的for循环就是用t->hdr.size是否等于0判断结束。
这样tags->hdr指向init_tags.hdr1，tags->hdr.size = tag_size(tag_core) = tag_header大小 + tag_core大小。因此tag_header.size记录了header和nth_tag的总大小，tag_header.tag记录了tag编号。<TODO>查，不同体系结构编号完全不同？</TODO> nth_tag则记录了该tag的实际内容。

    parse_tags在该文件所有__tagable及其函数后面和parse_tag后:
    /*
     * Parse all tags in the list, checking both the global and architecture
     * specific tag tables.
     */
    static void __init parse_tags(const struct tag *t)
    {
            for (; t->hdr.size; t = tag_next(t))
                    if (!parse_tag(t))
                            printk(KERN_WARNING
                                    "Ignoring unrecognised tag 0x%08x\n",
                                    t->hdr.tag);
    }
    
        查tag_next，位于"include/asm-arm/setup.h"：
        #define tag_next(t)     ((struct tag *)((u32 *)(t) + (t)->hdr.size))
        表示移动到下一个tag_header处。
        
        /*
         * Scan the tag table for this tag, and call its parse function.
         * The tag table is built by the linker from all the __tagtable
         * declarations.
         */
        static int __init parse_tag(const struct tag *tag)
        {
                extern struct tagtable __tagtable_begin, __tagtable_end;
                struct tagtable *t;
        
                for (t = &__tagtable_begin; t < &__tagtable_end; t++)
                        if (tag->hdr.tag == t->tag) {
                                t->parse(tag);
                                break;
                        }
        
                return t < &__tagtable_end;
        }

查__tagtable_begin，__tagtable_end，看起来和链接脚本有关，直接查同目录的链接脚本，有vmlinux.lds.S和vmlinux.lds两个文件。二者都有下面的内容：
	__tagtable_begin = .;
		*(.taglist.init)
	__tagtable_end = .;
(19:46 2009-1-9)vmlinux.lds是vmlinux.lds.S的预处理结果，见"19:46 2009-1-9"end

2, 从"__tagtable"开始查：
========================
查到上面这个地方，再往下就不好查了。如果回过头来查刚才跨过去的"__tagtable"：
__tagtable(ATAG_CORE, parse_tag_core);

static int __init parse_tag_mem32(const struct tag *tag)
{
        if (meminfo.nr_banks >= NR_BANKS) {
                printk(KERN_WARNING
                       "Ignoring memory bank 0x%08x size %dKB\n",
                        tag->u.mem.start, tag->u.mem.size / 1024);
                return -EINVAL;
        }
        add_memory(tag->u.mem.start, tag->u.mem.size);
        return 0;
}

static void __init add_memory(unsigned long start, unsigned long size)
{
        /*
         * Ensure that start/size are aligned to a page boundary.
         * Size is appropriately rounded down, start is rounded up.
         */
        size -= start & ~PAGE_MASK;

        meminfo.bank[meminfo.nr_banks].start = PAGE_ALIGN(start);
        meminfo.bank[meminfo.nr_banks].size  = size & PAGE_MASK;
        meminfo.bank[meminfo.nr_banks].node  = PHYS_TO_NID(start);
        meminfo.nr_banks += 1;
}
注：PHYS_TO_NID见下面的"15:44 2008-11-6"。

从这里看出"parse_tag_mem32"函数把tag保存到meminfo结构体，其调用应该与"__tagtable(ATAG_CORE, parse_tag_core);"有关，在所有头文件中查找------"grep -R __tagtable include/*"：

include/asm-arm/setup.h: 
/* it is allowed to have multiple ATAG_MEM nodes */
#define ATAG_MEM        0x54410002

struct tag_mem32 {
        u32     size;
        u32     start;  /* physical start address */
};

struct tagtable {
        u32 tag;
        int (*parse)(const struct tag *);
};

/* 把带有__tag的内容归为".taglist.init"段 */
#define __tag __attribute_used__ __attribute__((__section__(".taglist.init")))
#define __tagtable(tag, fn) \
static struct tagtable __tagtable_##fn __tag = { tag, fn }

因此"__tagtable(ATAG_CORE, parse_tag_core);"会被替换为：
tagtable __tagtable_parse_tag_core __tag ＝ {ATAG_CORE, parse_tag_core}

3, 综合二者的结果
=================
把init_tags所有内容，与".taglist.init"区域内容比较，后者存在的tag则进行比较，并把init_tags里面数值保存。。

再分析parse mem和查"MEM_SIZE"，就完成了，呵呵。终于绕出来了。
总结："include/asm-arm/setup.h"在Linux和u-boot都有, 作用是：
 * 1, 定义内核支持的所有类型tag的结构体--tag_xxx: 
 * (1), tag编号: 供tag_header.tag使用;
 * (2), tag结构体: 定义了tag编号对于的这个tag包括哪些参数. 所有tag结构体都包括
 * 在tag.u中.
 * 2, 定义tag通用结构体.
PFN_TO_NID的含义：
定义了CONFIG_DISCONTIGMEM情况下：
Memory.h (include\asm-arm):
/*
 * Common discontigmem stuff.
 *  PHYS_TO_NID is used by the ARM kernel/setup.c
 */
#define PHYS_TO_NID(addr)	PFN_TO_NID((addr) >> PAGE_SHIFT)
其中PAGE_SHIFT是12，即4k。所以PHYS_TO_NID也就是得到addr的页号，在meminfo.bank[meminfo.nr_banks].node也就是该membank的起始页。
另外，CONFIG_DISCONTIGMEM在config文件中定义。

11:10 2007-09-14
root=/dev/mtdblock/2 ro init=/bin/sh console=ttySAC0,115200
改为
root=/dev/nfs rw nfsroot=172.23.19.63:/usr/src/s3c2420-linux/NFS noinitrd init=linuxrc console=ttySAC0,115200 ip=172.23.19.60
失败，忘了我没有网络设备。

尝试cramfs：
去掉了Networking support，去掉Second extended fs support；
加入了cramfs support

12:57 2007-09-14
总是会重试，可能因为网络机器多，又用tftp传25M的大文件。
估计用双绞线会好很多。
如果定义了CONFIG_NET_RETRY_COUNT，tftp重试次数是CONFIG_NET_RETRY_COUNT*2，其余协议是CONFIG_NET_RETRY_COUNT.
修改configs/YF2410.h：
/* bamvor.add.2007-09-14.1_line */
#define CONFIG_NET_RETRY_COUNT          10
编译后的u-boot位于: "s3c2410/Linux2.6/filesystem_0914/u-boot_tftp20.bin"

14:01 2007-09-14
cramfs, mkcramfs
如果在输出*.cramfs文件的目录没有写权限，mkcramfs会提示：
ROM image: Bad file descriptor


15:06 2007-09-15
解决u-boot向Linux传递启动参数的问题
configs/VCMA9.h
#define CONFIG_CMDLINE_TAG       1      /* enable passing of ATAGs      */
#define CONFIG_SETUP_MEMORY_TAGS 1
#define CONFIG_INITRD_TAG        1

lib_arm/armlinux.c："setup_memory_tags"函数把bd_t bd赋给内存参数，何时调用了这个函数？
[root@localhost u-boot-1.2.0]# grep -R setup_memory_tags ./* | more
grep: ./include/asm-i386/arch: 没有那个文件或目录
./lib_arm/armlinux.c:static void setup_memory_tags (bd_t *bd);
./lib_arm/armlinux.c:   setup_memory_tags (bd);
./lib_arm/armlinux.c:static void setup_memory_tags (bd_t *bd)
./lib_avr32/avr32_linux.c:static struct tag *setup_memory_tags(struct tag *param
s)
./lib_avr32/avr32_linux.c:      params = setup_memory_tags(params);
(15:59 2007-09-15)
刚才是阅读代码不细致，把调用的地方漏了。是在载入ramdisk之后，启动kernel之前调用。tag配置以setup_start_tag开始，以setup_end_tag结束。
setup_start_tag中设置Linux要求的第一个tag："ATAG_CORE"，当然给header和core两部分赋值。
static void setup_start_tag (bd_t *bd)
{
        params = (struct tag *) bd->bi_boot_params;

        params->hdr.tag = ATAG_CORE;
        params->hdr.size = tag_size (tag_core);

        params->u.core.flags = 0;
        params->u.core.pagesize = 0;
        params->u.core.rootdev = 0;

        params = tag_next (params);
}
其中param是tag结构体：static struct tag *params;
setup_end_tag是设置Linux要求的结束标志：
static void setup_end_tag (bd_t *bd)
{
        params->hdr.tag = ATAG_NONE;
        params->hdr.size = 0;
}

15:50 2007-09-15
转移到新图开始学习。

16:27 2007-09-15
u-boot传递启动参数，续
setup_memory_tags的bd_t *bd是从那里来的？
do_bootm_linux函数：
bd_t *bd = gd->bd;
该文件中没有gd的声明，费解，从该文件开始找宏定义，看到"DECLARE_GLOBAL_DATA_PTR"，查找DECLARE_GLOBAL_DATA_PTR和define：
asm-arm/global_data.h：
#define DECLARE_GLOBAL_DATA_PTR     register volatile gd_t *gd asm ("r8")
待做：查gcc手册，asm具体细节。
arm9 linux那本书提到过，当时没有注意。
既然从寄存器r8得到这个变量，那么这个赋值应该在do_bootm_linux函数之前，
/->
待做：查
另外，do_bootm_linux函数的这句话不明白：
theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);
/<-
没有找到汇编中如何给r8赋值，再从c语言入手，u-boot c语言的入口点是"lib_arm/board.c"的"start_armboot"：
void start_armboot (void)
{
        init_fnc_t **init_fnc_ptr;
        char *s;
#ifndef CFG_NO_FLASH
        ulong size;
#endif
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
        unsigned long addr;
#endif

        /* Pointer is writable since we allocated a register for it */
        gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
        /* compiler optimization barrier needed for GCC >= 3.4 */
        __asm__ __volatile__("": : :"memory");

        memset ((void*)gd, 0, sizeof (gd_t));
        gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
        memset (gd->bd, 0, sizeof (bd_t));
.......
可以看出这里确定了r8寄存器保存的地址是"_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t)"
待做，查：_armboot_start是_start，可以查到"_start"也是0x33f80000，不明白为什么和TEXT_BASE相同。
这里实际使用的是在start.S中分配好的空间，之前分析过：
        sub     r0, r0, #CFG_MALLOC_LEN /* malloc area                      */
        sub     r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
#ifdef CONFIG_USE_IRQ
        sub     r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
#endif
        sub     sp, r0, #12             /* leave 3 words for abort-stack    */
YF2410.h定义"CFG_GBL_DATA_SIZE"是128字节，这远大于gd_t的大小，我计算gd_t是68字节。
然后是分配bd_t的空间，这里使用的是"_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t)" - sizeof(bd_t)的空间。也就是gd->bd指向的内存区域位于gd结构体的下方。
待做，思：这里为什么不能用malloc？

gd_t定义于"asm-arm/global_data.h"：
typedef struct  global_data {
        bd_t            *bd;
        unsigned long   flags;
        unsigned long   baudrate;
        unsigned long   have_console;   /* serial_init() was called */
        unsigned long   reloc_off;      /* Relocation Offset */
        unsigned long   env_addr;       /* Address  of Environment struct */
        unsigned long   env_valid;      /* Checksum of Environment valid? */
        unsigned long   fb_base;        /* base address of frame buffer */
#ifdef CONFIG_VFD
        unsigned char   vfd_type;       /* display type */
#endif
#if 0
        unsigned long   cpu_clk;        /* CPU clock in Hz!             */
        unsigned long   bus_clk;
        unsigned long   ram_size;       /* RAM size */
        unsigned long   reset_status;   /* reset status register at boot */
#endif
        void            **jt;           /* jump table */
} gd_t;

(20:48 2007-09-15)
bd_t结构体定义于"include/asm-arm/u-boot.h"
typedef struct bd_info {
    int                 bi_baudrate;    /* serial console baudrate */
    unsigned long       bi_ip_addr;     /* IP Address */
    unsigned char       bi_enetaddr[6]; /* Ethernet adress */
    struct environment_s               *bi_env;
    ulong               bi_arch_number; /* unique id for this board */
    ulong               bi_boot_params; /* where this board expects params */
    struct                              /* RAM configuration */
    {
        ulong start;
        ulong size;
    }                   bi_dram[CONFIG_NR_DRAM_BANKS];
#ifdef CONFIG_HAS_ETH1
    /* second onboard ethernet port */
    unsigned char   bi_enet1addr[6];
#endif
} bd_t;

environment_s定义于environment.h：
typedef struct environment_s {
        unsigned long   crc;            /* CRC32 over data bytes        */
#ifdef CFG_REDUNDAND_ENVIRONMENT
        unsigned char   flags;          /* active/obsolete flags        */
#endif
        unsigned char   data[ENV_SIZE]; /* Environment data             */
} env_t;
"20:48 2007-09-15"结束

17:04 2007-09-15
man gcc的ARM Options部分有-march等的解释。

17:19 2007-09-15
吃饭
18:51 2007-09-15

19:22 2007-09-15
休息5分钟

19:57 2007-09-15
学习嵌入汇编
1, 内嵌汇编
===========
__asm__表示内嵌汇编，__volatile__防止编译器优化汇编代码。前后的"__"是POSIX要求的。
void enable_interrupts (void)
{
        unsigned long temp;
        __asm__ __volatile__("mrs %0, cpsr\n"		/*引号内是汇编语句*/
                             "bic %0, %0, #0x80\n"
                             "msr cpsr_c, %0"
                             : "=r" (temp)		/* 输出操作数 */
                             :				/* 输入操作书 */
                             : "memory");		/* 不需保存的寄存器值 */
}
输入输出操作数，按列表顺序，从输出开始顺序编号为"%0", "%1"......
待做：查"memory"的作用。

2, 分析于这个文件有关的代码，原来跳过去的异常处理：

1, 定义异常向量的跳转位置，cpu/arm920t/start.S
----------------------------------------------
由于除了reset外，其他异常距离跳转指令的距离可能超过32M，所以用ldr载入地址到pc。
.globl _start
_start: b       reset
        ldr     pc, _undefined_instruction
        ldr     pc, _software_interrupt
        ldr     pc, _prefetch_abort
        ldr     pc, _data_abort
        ldr     pc, _not_used
        ldr     pc, _irq
        ldr     pc, _fiq

_undefined_instruction: .word undefined_instruction
_software_interrupt:    .word software_interrupt
_prefetch_abort:        .word prefetch_abort
_data_abort:            .word data_abort
_not_used:              .word not_used
_irq:                   .word irq
_fiq:                   .word fiq

2, 异常处理，同一个文件：
-----------------------
在最后的"exception
handlers"部分，依次处理每个异常，这里按照定义了CONFIG_USE_IRQ但是没有定义CONFIG_ARCH_INTEGRATOR分析：
/*
 * exception handlers
 */
        .align  5
undefined_instruction:
......
        .align  5
irq:
        get_irq_stack
        irq_save_user_regs
        bl      do_irq
        irq_restore_user_regs

        .align  5
fiq:
......
待做：查为什么要".align  5"？
(1)设置堆栈
        .macro get_irq_stack                    @ setup IRQ stack
        ldr     sp, IRQ_STACK_START
        .endm

/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
        .word   0x0badc0de
待做：A，查，0x0badc0de含义，start.S多次有这类情况。B，查macro

(2)保存现场：
        .macro  irq_save_user_regs
        sub     sp, sp, #S_FRAME_SIZE
        stmia   sp, {r0 - r12}                  @ Calling r0-r12
        add     r8, sp, #S_PC
        stmdb   r8, {sp, lr}^                   @ Calling SP, LR
        str     lr, [r8, #0]                    @ Save calling PC
        mrs     r6, spsr
        str     r6, [r8, #4]                    @ Save CPSR
        str     r0, [r8, #8]                    @ Save OLD_R0
        mov     r0, sp
        .endm
S_FRAME_SIZE是72，从定义可以看出是保存所有寄存器所需的堆栈(r0-r15,psr,旧r0)大小。待做，查："^"含义。查spsr。读完剩余内容。
最后把sp传给r0，作为do_irq的第一个参数，后面的异常处理函数需要显示寄存器的值。

(3)，调用中断函数，do_irq。该函数定义于"cpu/arm920t/interrupt.c"，
void do_irq (struct pt_regs *pt_regs)
{
#if defined (CONFIG_USE_IRQ) && defined (CONFIG_ARCH_INTEGRATOR)
        /* ASSUMED to be a timer interrupt  */
        /* Just clear it - count handled in */
        /* integratorap.c                   */
        *(volatile ulong *)(CFG_TIMERBASE + 0x0C) = 0;
#else
        printf ("interrupt request\n");
        show_regs (pt_regs);
        bad_mode ();
#endif
}
待做：查printf是如何实现的？想使用libc有什么条件？
show_regs用于显示所有寄存器的值，稍后分析，待做。
bad_mod用于重启cpu：
void bad_mode (void)
{
        panic ("Resetting CPU ...\n");
        reset_cpu (0);
}
reset_cpu与SOC芯片有关，位于"cpu/arm920t/s3c24x0/interrupts.c"，该函数设置看门狗定时器，当定时器溢出时会自动重启cpu。待做，细看这个函数。
与arm920t有关但与SOC芯片无关的会编译为"cpu/$(CPU)/lib$(CPU).a"，只与SOC芯片有关的内容编译为"cpu/$(CPU)/$(SOC)/lib$(SOC).a"，前者是如何调用后者的？或者不需要调用？

20:34 2007-09-15
gcc，显示gcc库文件的位置
[root@localhost u-boot-1.2.0]# arm-linux-gcc --help | grep "\-print\-libgcc\-file\-name"
  -print-libgcc-file-name  Display the name of the compiler's companion library



9:44 2007-9-11
8:35起，早晨杂事完成。

9:51 2007-9-11
看邮件。

11:20 2007-9-11
吃饭，报亭看报
12:18 2007-9-11

13:28 2007-9-11
去打水。
13:51 2007-9-11

13:53 2007-9-11
3.5小时内完成u-boot第一阶段总结。

16:48 2007-9-11
查地图
16:58 2007-9-11

17:20 2007-9-11
vivi copy_myself代码分析文档完成。
18:14 2007-9-11

20:16 2007-9-11
吃饭，放松。

20:39 2007-9-11
看报纸。

22:23 2007-9-11
学习结束，没有完成预定计划，估计明天可以初步完成所有文档。重点放在理清思路。

22:25 2007-9-11
今天总学习时间是8h15'，如果没有算错的话。明天要超过6小时，加油：）


9:40 2007-9-12
到实验室，杂事基本完成。早晨被骚扰电话吵醒，睡到8:40。
(12:55 2007-9-12)
今日计划：学习u-boot6小时，英语1小时，剩余时间编程练习。

10:20 2007-9-12
待做
1, u-boot 1.3 release。等以后有机会做移植。
2, 下载git://denx.de/git/u-boot-arm.git

10:29 2007-9-12
看邮件。

11:13 2007-9-12
u-boot文档。

12:54 2007-9-12
吃饭，饭卡充值等。滴眼药。

13:24 2007-9-12
有看了一次林锐我的大学十年。

14:15 2007-9-12
20分钟过去。

14:31 2007-9-12
旧图借书。
14:48 2007-9-12

15:03 2007-9-12

18:38 2007-9-12
u-boot移植文档第一阶段完成。还需要抽时间修改两次，一是没有遗漏，二是来龙去脉清楚。

19:14 2007-9-12
吃饭

20:44 2007-9-12

22:18 2007-9-12
修改未遂。开始阅读代码

22:40 2007-9-12
阅读代码结束。
23:00 2007-9-12

23:22 2007-9-12
总结代码中，未完。

9:39 2007-9-13
开始学习。昨天没有学英语，今天一定要学。

12:01 2007-9-13
11:16-吃饭归来

13:02 2007-9-13
看邮件。

13:51 2007-9-13
对比远峰bootloader和2.4内核。bootload的参数没有涉及到ram大小的，认为还是Linux配置有问题。或者是taglist有问题。

15:10 2007-9-13
14:55-15:10。打水

16:52 2007-9-13
学30'，找建辉聊天。

16:58 2007-9-13
查知名大公司较少（搞嵌入式的大公司主要有Intel、Motorola、TI、Philip、Samsung、Sony、Futjtum、Bell-Alcatel、意法半导体、Microtek、研华、华为、中兴通信、上广电等制造类企业）。〕

18:44 2007-9-13
吃饭，和芸芸聊天
21:28 2007-9-13

21:45 2007-9-13
打水
22:25 2007-9-13
暂缓移植。先写文档。

22:57 2007-9-13
cadance(模拟), synopsy(数字，无版图工具), magma

Design for manufacture


10:48 2007-9-14
早晨9点之前开始到现在，完成"这里的两年.ppt"

11:48 2007-9-14
11:20-吃饭

13:43 2007-9-14
NAND erase: device 0 offset 2097152, size 25690112 ...
OK
YF2410 # nand write 31000000 200000 1880000

NAND write: device 0 offset 2097152, size 25690112 ...
 20054016 bytes written: ERROR
原有未知。暂缓

18:21 2007-9-14
例会，和大家交流经验
候哥建议：东西要系统一些。比如日志工具。下次例会再介绍一下。
研一同学：讲讲c语言；

20:19 2007-9-14
回宿舍那衣服，吃饭

21:59 2007-9-14
(14:27 2007-9-15)
待做：加入9.21例会内容，放在最后。联系学习方法：理论，基本功，工程。
同步器：
1, 《数字集成电路——设计透视》Timinig Issues in Digtial Circuit, p533，和《数字集成电路——电路、系统与设计》p392是介绍和理论推导。前者是VLSI教材，应该认真学，我没认真学有点后悔。
2, 精通Verilog HDL：IC设计核心技术实例详解, 5.6跨时钟阈(clock domain)问题。这本书很适合入门。
3, 从实用角度看，这本书讲的最好：《Altera FPGA/CPLD 设计（高级篇）》第一章可编程逻辑常用设计思想与技巧p25，(1)通过触发器同步后的信号，经过决断时间(Resolution time)后会必然稳定到0或1，但不一定与输入信号相同。(2)经过两级触发器后，出现亚稳态几率很小，据说守博公司大牛说是几十万分之一。(3)如果经过三级触发器，出现亚稳态概率几乎是0。

23:49 2007-9-14
vivi开发笔记14
http://blog.chinaunix.net/u/21948/showart_376062.html
关于__STDC__这个宏，是编译器自动添加的，含义就是支持标准C。如果支持标准C，那么##的作用就是“连接”，所以 SYMBOL_NAME_LABEL(_start)宏展开为_start:，如果不支持标准C，则利用了C预处理器对注释的处理方式，就是把/**/替换为一个空格，可以测试一下。

21:59 2007-9-14
(14:27 2007-9-15)
待做：加入9.21例会内容，放在最后。联系学习方法：理论，基本功，工程。
同步器：
1, 《数字集成电路——设计透视》Timinig Issues in Digtial Circuit, p533，和《数字集成电路——电路、系统与设计》p392是介绍和理论推导。前者是VLSI教材，应该认真学，我没认真学有点后悔。
2, 精通Verilog HDL：IC设计核心技术实例详解, 5.6跨时钟阈(clock domain)问题。这本书很适合入门。
3, 从实用角度看，这本书讲的最好：《Altera FPGA/CPLD 设计（高级篇）》第一章可编程逻辑常用设计思想与技巧p25，(1)通过触发器同步后的信号，经过决断时间(Resolution time)后会必然稳定到0或1，但不一定与输入信号相同。(2)经过两级触发器后，出现亚稳态几率很小，据说守博公司大牛说是几十万分之一。(3)如果经过三级触发器，出现亚稳态概率几乎是0。

23:49 2007-9-14
vivi开发笔记14
http://blog.chinaunix.net/u/21948/showart_376062.html
关于__STDC__这个宏，是编译器自动添加的，含义就是支持标准C。如果支持标准C，那么##的作用就是“连接”，所以 SYMBOL_NAME_LABEL(_start)宏展开为_start:，如果不支持标准C，则利用了C预处理器对注释的处理方式，就是把/**/替换为一个空格，可以测试一下。

14:53 2007-9-15
待做：实验室。
要研一同学邮箱（电子版），发上面的同步器日志；问周中华是否用了chipscope，向建辉建议使用chipscope。建议研一同学在例会上讲。

14:57 2007-9-15
9.15-9.21计划：
1, bootloader向Linux传递tag启动问题。
2, 选课问题，周一开始解决。
3, 移植简单的文件系统。
4, 周四找吴老师借那个旧笔记本，周五例会演示用。

22:05 2007-9-15
21:35-从新图搬到实验室。

11:18 2007-9-16

18:12 2007-9-17
回学校。

18:54 2007-9-17
待做：
  Re: Linux and LEON

    
Posted by: "Daniel Hellstrom" daniel@gaisler.com   hedani3l

    
Sun Sep 16, 2007 11:51 pm (PST)


    
Yes, I use gr-xc3s-1500 spartan board running RTEMS, Linux, ecos and
vxworks on it. With Linux you can test the LEON processor, ATA,
Ethernet, PS/2 keyb/mouse, Serial, SVGA (graphic console and x11),
linux-2.0, linux-2.6.

The template design also support CAN (with an GR-PCI-CAN expansion
board) and SpaceWire. There is drivers for SpaceWire and CAN in RTEMS.

Daniel Hellstrom

diego javier brengi wrote:
>
> I am planning to buy a GR-XC3S-1500 LEON Development board because I
> want to run Linux on it (Snapgear-Gaisler). Anybody using this hardware
> for this purpouse?
>
> Because board documentation does not explicitly mention anything about
> this.
>
> Thanks.
>
> 
重要，查是否有svga fpga文件，如果没有发信求得，最近bitfile中已经包含svga。

20:10 2007-9-17
嵌入式，英语
The ecosyetem surrounding the chip

10:58 2007-09-18
根目录设在filesystem/root
1.7.1的busybox已经去掉了"Do you want to build BusyBox with a Cross Compiler"这个选项，另外编译为静态库失败，见"make 1054"，动态编译和安装成功，见"make 1057","make_install_1101"。
安装tinylogin，没有使用动态编译。其余参考s3c2410linux文档。
需要复制库到现有根文件系统。参考imote2的文件系统。配置文件也参考它的。

12:38 2007-09-18
加入动态库，一共不到30M。看来真是得使用ulibc
[root@localhost busybox-1.7.1]# ldd busybox
        linux-gate.so.1 =>  (0x00184000)
        libcrypt.so.1 => /lib/libcrypt.so.1 (0x4e8db000)
        libc.so.6 => /lib/libc.so.6 (0x4d3ba000)
        /lib/ld-linux.so.2 (0x4c9eb000)
制作ramdisk过程见："s3c2410/filesystem/mkramdisk"。
参考u-boot README中制作ppc ramdisk的方法：
[root@localhost tools]# ./mkimage  -n ramdisk1024 -A arm -O Linux -T ramdisk
-d ramdisk1024 ramdisk1024_mk
Image Name:   ramdisk1024
Created:      Tue Sep 18 12:59:47 2007
Image Type:   ARM Linux RAMDisk Image (gzip compressed)
Data Size:    1048576 Bytes = 1024.00 kB = 1.00 MB
Load Address: 0x00000000
Entry Point:  0x00000000
今天的busybox和tinylogin都是用3.3.2编译的。

13:09 2007-09-18
修改内核
block device
  │ │              [*] RAM disk support                                   │ │  
  │ │              (16)  Default number of RAM disks                      │ │  
  │ │              (1024) Default RAM disk size (kbytes)                  │ │  
  │ │              [*]   Initial RAM disk (initrd) support                
命令行：
initrd=0x30800000,0x400 root=/dev/ram0 init=/linuxrc console=ttySAC0,115200 

16:01 2007-09-18
见"ramdisk_1408.txt"
提示"bad gzip magic numbers"。才发现无意中使用了gzip压缩，这次改为无压缩。

16:08 2007-09-18
提示依旧，查代码和google
代码：
init/do_mounts_rd.c
static int __init
identify_ramdisk_image(int fd, int start_block)
{
	const int size = 512;
	struct ext2_super_block *ext2sb;
......
        sys_lseek(fd, (start_block+1) * BLOCK_SIZE, 0);
        sys_read(fd, buf, size);
......
        /* Try ext2 */
        if (ext2sb->s_magic == cpu_to_le16(EXT2_SUPER_MAGIC)) {
                printk(KERN_NOTICE
                       "RAMDISK: ext2 filesystem found at block %d\n",
                       start_block);
                nblocks = le32_to_cpu(ext2sb->s_blocks_count) <<
                        le32_to_cpu(ext2sb->s_log_block_size);
                goto done;
        }

        printk(KERN_NOTICE
               "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n",
               start_block);

查"sys_lseek"
-------------
查原型位于"include/linux/syscalls.h"：
asmlinkage off_t sys_lseek(unsigned int fd, off_t offset,
                                unsigned int origin);
include/linux/fs.h:#define BLOCK_SIZE_BITS 10
include/linux/fs.h:#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)

查EXT2_SUPER_MAGIC：
-------------------
include/linux/ext2_fs.h:#define EXT2_SUPER_MAGIC        0xEF53

查cpu_to_le16：
--------------
./include/linux/byteorder/generic.h:#define cpu_to_le16 __cpu_to_le16
根据不同byteorder有不同的实现方法：
./include/linux/byteorder/little_endian.h:#define __cpu_to_le16(x) ((__force
__l
e16)(__u16)(x))

17:22 2007-09-18
Linux学习, (bootloader学习, u-boot), 启动, c语言阶段, "parse_early_param"等分析
确认一下文件格式是否正确：
uImage的头0x40)+super_block起始（0x400+magic_signature_offset(0x38)=0x478，和UltraEdit中查看ramdisk1024_mk_none相同。也就是说只要"start_block"正确，就可以读到正确的"magic signature"(s_magic)，不太放心，再查一下inode数量是否正确：
inode数量：1024/2=512=0x200=0x00000200；位置：0x40+0x400=0x440，用Ultraedit查看，正确，说明这里没有问题。
怀疑是载入的位置不正确。有点怀疑是tag的问题。

从Linux"identify_ramdisk_image"函数往回查
-----------------------------------------
identify_ramdisk_image由int __init rd_load_image(char *from)调用：
nblocks = identify_ramdisk_image(in_fd, rd_image_start);
rd_image_start在前面产生：
int __initdata rd_image_start;          /* starting block # of image */

static int __init ramdisk_start_setup(char *str)
{
        rd_image_start = simple_strtol(str,NULL,0);
        return 1;
}
__setup("ramdisk_start=", ramdisk_start_setup);

"__setup"分析:
---------------
"linux/init.h"：
#define __setup(str, fn)                                        \
    __setup_param(str, fn, fn, 0)

#define __setup_param(str, unique_id, fn, early)                        \
    static char __setup_str_##unique_id[] __initdata = str; \
    static struct obs_kernel_param __setup_##unique_id      \
        __attribute_used__                              \
        __attribute__((__section__(".init.setup")))     \
        __attribute__((aligned((sizeof(long)))))        \
        = { __setup_str_##unique_id, fn, early }

以"__setup("ramdisk_start=", ramdisk_start_setup);"为例, 宏替换的结果是:
struct obs_kernel_param __setup_ramdisk_start_setup = 
{
    "ramdisk_start=",
    ramdisk_start_setup,
    0
}

(15:04 2009-1-14)
这里如果设置early=1, 表示是early param, 会在处理其它param之前由parse_early_param()处理.
"15:04 2009-1-14"end

得到：
static char __setup_str_ramdisk_start_setup[] ____initdata = str;
static struct obs_kernel_param __setup_ramdisk_start_setup 
        __attribute_used__                              
        __attribute__((__section__(".init.setup")))     
        __attribute__((aligned((sizeof(long)))))       
        = { __setup_str_ramdisk_start_setup, ramdisk_start_setup, 0 }

"obs_kernel_param"结构体位于"linux/init.h"：
struct obs_kernel_param {
        const char *str;
        int (*setup_func)(char *);
        int early;
};

根据前面的经验，应该与".init.setup"的链接地址有关：
".init.setup"的起始和结束地址位于arch/arm/kernel/vmlinux.lds.S：__setup_start和__setup_end。
继续查找：
(14:58 2009-1-14)
"__setup_start"在obsolete_checksetup和"do_early_param"使用, 我理解前者处理旧的内核参数, 新内核参数都在do_early_param处理. 
early_param是由宏"early_param"定义, 直接是"__setup_param(str, fn, fn, 1)".
调用关系:
start_kernel()
    ->parse_early_param(): 调用parse_args() parse param, 但直接设置param number为0, 回调函数设为"do_early_param", 所以会直接回调其回调函数do_early_param()处理early param.
    ->parse_args(), 根据传入参数, 处理__start___param至__end___param的param, 未能解析时调用回调函数"unknown_bootoption()", 其中会调用"obsolete_checksetup()"处理旧内核启动参数. 这里处理的参数包括"__setup"宏设置的. 例如: "__setup("console=", console_setup);".

do_early_param()分析:

"14:58 2009-1-14"end
(15:18 2009-2-3)
obsolete_checksetup()分析:
 * 在"__setup_start"--"__setup_end"之间查找str等于"line"的
 * "struct obs_kernel_param"并执行其setup_func().
 * "struct obs_kernel_param"包括param name(str), 处理cmdline的回调函数
 * (setup_func), 是否是early param(early).
 * 这里处理的都是非early param, 由"__setup"(include\linux\init.h)宏定义, 注意
 * param name(str)是包括"="的.
"15:18 2009-2-3"end
static int __init obsolete_checksetup(char *line)
{
        struct obs_kernel_param *p;

        p = __setup_start;
        do {
                int n = strlen(p->str);
                if (!strncmp(line, p->str, n)) {
                        if (p->early) {
                                /* Already done in parse_early_param?  (Needs
                                 * exact match on param part) */
                                if (line[n] == '\0' || line[n] == '=')
                                        return 1;
                        } else if (!p->setup_func) {
                                printk(KERN_WARNING "Parameter %s is
obsolete,"
                                       " ignored\n", p->str);
                                return 1;
                        } else if (p->setup_func(line + n))
                                return 1;                }
                p++;
        } while (p < __setup_end);
        return 0;
}
从这里看出"line + n"就是传给"ramdisk_start_setup"的str。
查"line"的来源：
--------------
这个函数由"unknown_bootoption"调用，把"param"传给它。感觉现在分析的越来越不像主线了，没有使用tag。查"param"：
"unknown_bootoption"由同一文件的"start_kernel"调用：
        parse_args("Booting kernel", command_line, __start___param,
                   __stop___param - __start___param,
                   &unknown_bootoption);

在"kernel/params.c"定义，从函数原型看，传给"unknown_bootoption"函数的param是"__start___param"。
int parse_args(const char *name,
               char *args,
               struct kernel_param *params,
               unsigned num,
               int (*unknown)(char *param, char *val))

"__start___param"位于"/asm-generic/vmlinux.lds.h"：
        /* Built-in module parameters. */                               \
        __param : AT(ADDR(__param) - LOAD_OFFSET) {                     \
                VMLINUX_SYMBOL(__start___param) = .;                    \
                *(__param)                                              \
                VMLINUX_SYMBOL(__stop___param) = .;                     \
        }

10:20 2007-09-19
分析tag
static void __init
setup_ramdisk(int doload, int prompt, int image_start, unsigned int rd_sz)
{
#ifdef CONFIG_BLK_DEV_RAM
        extern int rd_size, rd_image_start, rd_prompt, rd_doload;

        rd_image_start = image_start;
        rd_prompt = prompt;
        rd_doload = doload;

        if (rd_sz)
                rd_size = rd_sz;
#endif
}

./init/do_mounts_rd.c:
int __initdata rd_image_start;            /* starting block # of image */

"rd_image_start"昨天分析过。"CONFIG_BLK_DEV_RAM"有效才可以。 查".config"CONFIG_BLK_DEV_RAM有效。
从同一个文件的"rd_load_image"函数看出：
out_fd = sys_open("/dev/ram", O_RDWR, 0);
系统的/dev/ram必须存在。


11:06 2007-09-19
尝试用tag传递内存和ramdisk参数：
u-boot，YF2410.h： Command definition之前：
/* bamvor.add.2007-09-19.3_lines.copy_from_VCAM9.h */
#define CONFIG_CMDLINE_TAG       1      /* enable passing of ATAGs      */
#define CONFIG_SETUP_MEMORY_TAGS 1
#define CONFIG_INITRD_TAG        1

为了验证是否成功传递了tag，加入DEBUG(YF2410.h)：
/* bamvor.add.2007-09-19.1_line*/
#define DEBUG 1

调试语句定义于"common.h"：
#ifdef  DEBUG
#define debug(fmt,args...)      printf (fmt ,##args)
#define debugX(level,fmt,args...) if (DEBUG>=level) printf(fmt,##args);
#else
#define debug(fmt,args...)
#define debugX(level,fmt,args...)
#endif  /* DEBUG */

在lib_arm/armlinux.c中加入debug语句。

11:45 2007-09-19
编译u-boot：
armlinux.c:309:24: missing terminating " character
armlinux.c:310:1: missing terminating " character
armlinux.c:429:1: unterminated argument list invoking macro "debug"
armlinux.c: In function `setup_memory_tags':
armlinux.c:309: error: `debug' undeclared (first use in this function)
armlinux.c:309: error: (Each undeclared identifier is reported only once
armlinux.c:309: error: for each function it appears in.)
armlinux.c:309: error: parse error at end of input
armlinux.c:50: warning: `setup_commandline_tag' used but never defined
armlinux.c:57: warning: `setup_initrd_tag' used but never defined
armlinux.c:59: warning: `setup_end_tag' used but never defined
make[1]: *** [armlinux.o] 错误 1
make[1]: Leaving directory `/usr/src/s3c2410-linux/bootloader/u-boot-1.2.0/lib_arm'
make: *** [lib_arm/libarm.a] 错误 2
实际是debug需要的两个引号没在一行。

12:11 2007-09-19
initrd和ramdisk不同。
./arch/arm/mm/init.c:           initrd_start =
__phys_to_virt(phys_initrd_start)
;

12:18 2007-09-19
u-boot.bin显示tag正确，下午看看Linux接收tag是否正确。查initrd和ramdisk什么关系？另外uImage中ramdisk是否需要设置load address。如果希望在0x30800000载入。就不能放在这个位置，因为uImage还有0x40字节的头。

15:10 2007-09-19
打算加入ramdisk tag，需要明白rd_doload和rd_prompt的含义，"include/linux/initrd.h"：
/* 1 = load ramdisk, 0 = don't load */
extern int rd_doload;

/* 1 = prompt for ramdisk, 0 = don't prompt */
extern int rd_prompt;

/* starting block # of image */
extern int rd_image_start;


15:35 2007-09-19
这次完全使用u-boot提供tag给Linux，loglevel设为8才能显示"KERN_DEBUG"的信息。
错误是："EXT2-fs: Magic mismatch, very weird"，位于"fs/ext2/super.c"的"ext2_fill_super"函数。很奇怪，查，难道是那段空间被释放了？但是RAMDISK提示已经读入了。还是两条腿走路，看代码，google。

13:54 2007-09-20
从描述看，
ATAG_INITRD2保存压缩的ramdisk，ATAG_MEM保存未压缩的ramdisk。
尝试压缩的ramdisk："s3c2410/filesystem/ramdisk/tag/zImage_09191212_mk"。使用"gzip -9 ramdisk1024"压缩为"ramdisk1024.gz"，源文件是"s3c2410/filesystem/ramdisk/start/ramdisk1024"
提示略有不同，原来是找到ext2文件系统，并且读入了ram；现在是找到压缩的映像，没有读入的提示。最终都是"Magic mismatch"的。
读入了ram的提示位于"init/do_mounts_rd.c"的"rd_load_image"函数。
由"rd_load_disk"调用
int __init rd_load_disk(int n)
{
        if (rd_prompt)
                change_floppy("root floppy disk to be loaded into RAM disk");
        create_dev("/dev/root", ROOT_DEV, root_device_name);
        create_dev("/dev/ram", MKDEV(RAMDISK_MAJOR, n), NULL);
        return rd_load_image("/dev/root");
}
"rd_load_disk"把文件系统从"/dev/root"复制到"/dev/ram"。
"rd_load_disk"定义于"init/do_mounts.h"，由"init/do_mounts.c"的"prepare_namespace"函数调用，从注释看，该函数的作用是"decide what/where to mount, load ramdisks, etc."，相关代码是：
        if (is_floppy && rd_doload && rd_load_disk(0))
                ROOT_DEV = Root_RAM0;

        mount_root();
这里的"is_floppy"有点问题。感觉有点进入死胡同了，应该和软驱无关才对。

重新查"rd_load_image"函数
-------------------------
[bamv26@localhost linux-2.6.14]$ grep -R rd_load_image init/
Binary file init/built-in.o matches
init/do_mounts_rd.c:int __init rd_load_image(char *from)
init/do_mounts_rd.c:    return rd_load_image("/dev/root");
init/do_mounts.h:int __init rd_load_image(char *from);
init/do_mounts.h:static inline int rd_load_image(char *from) { return 0; }
init/do_mounts_initrd.c:                if (rd_load_image("/initrd.image") &&
ROOT_DEV != Root_RAM0) {
Binary file init/do_mounts_initrd.o matches
Binary file init/mounts.o matches
Binary file init/do_mounts_rd.o matches
"init/do_mounts_initrd.c"也调用了"rd_load_image"：
int __init initrd_load(void)
{
        if (mount_initrd) {
                create_dev("/dev/ram", Root_RAM0, NULL);
                /*
                 * Load the initrd data into /dev/ram0. Execute it as initrd
                 * unless /dev/ram0 is supposed to be our actual root device,
                 * in that case the ram disk is just set up here, and gets
                 * mounted in the normal path.
                 */
                if (rd_load_image("/initrd.image") && ROOT_DEV != Root_RAM0) {
                        sys_unlink("/initrd.image");
                        handle_initrd();
                        return 1;
                }
        }
        sys_unlink("/initrd.image");
        return 0;
}
默认情况下"mount_initrd"是1，除非设置了noinitrd。
"Root_RAM0"定义于"linux/root_dev.h"，是枚举类型的，该类信同时定义了"Root_NFS"等，"Root_RAM0 = MKDEV(RAMDISK_MAJOR, 0)"	


15:29 2007-09-20
加入printk信息后，发现是从"/initrd.image"读入的ramdisk。
ROOT_DEV是1048576，即0x00100000。
Linux2。6以来设备号是dev_t类型，一个32位的数。其高12位表示主设备号，低20位表示次设备号，相互之间转换使用MAJOR(dev_t dev), MINOR(dev_t dev)和MKDEV(int major, int minor)。"Documentation/devices.txt"对常用设备的主次设备号有说明。可以看到ram的主设备号是1，所以"/dev/ram0"的设备号是1<<20+0=0x00100000。
所以，"ROOT_DEV != Root_RAM0"不成立，于是执行"sys_unlink("/initrd.image")"后函数返回0。
结合前面的注释，如果Root_RAM0就是跟文件系统，就不执行"handle_initrd"。这里也说明，ramdisk必须使用"/dev/ram0"，FC6中ramdisk的符号链接就指向它：
[root@localhost tools]# ll /dev/ramdisk 
lrwxrwxrwx 1 root root 4 09-18 16:58 /dev/ramdisk -> ram0

查找调用"initrd_load"前后的情况：
--------------------------------
"initrd_load"由"init/do_mounts.c"调用。此后由于不是软驱启动，直接执行"mount_root"。根文件系统即不是NFS也不在软驱上，直接执行：
        create_dev("/dev/root", ROOT_DEV, root_device_name);
        mount_block_root("/dev/root", root_mountflags);
root_mountflags会由__setup("ro", readonly)和__setup("rw", readwrite)影响。如果设置了"rw"会把"root_mountflags"改为可读写。

/-----------------------------------------------------------------------------/
#define __getname()     kmem_cache_alloc(names_cachep, SLAB_KERNEL)
#define __putname(name) kmem_cache_free(names_cachep, (void *)(name))

待做：
1, 查
__setup("rootflags=", root_data_setup);
__setup("rootfstype=", fs_names_setup);
__setup("rootdelay=", root_delay_setup);
2, 查kmem_cache_alloc和"kmem_cache_free"
/-----------------------------------------------------------------------------/

mount_block_root函数的核心是"do_mount_root"：
static int __init do_mount_root(char *name, char *fs, int flags, void *data)
{
        int err = sys_mount(name, "/root", fs, flags, data);
        if (err)
                return err;

        sys_chdir("/root");
        ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
        printk("VFS: Mounted root (%s filesystem)%s.\n",
               current->fs->pwdmnt->mnt_sb->s_type->name,
               current->fs->pwdmnt->mnt_sb->s_flags & MS_RDONLY ?
               " readonly" : "");
        return 0;
}

分析"do_mount_root"函数
-----------------------
"fs/compat.c"和"fs/namespace.c"都有这个函数。查"fs/Makefile"，可以看到前者需要"CONFIG_COMPAT"有效才会被编译，现在"CONFIG_COMPAT"无效，所以看"namespace.c"的"do_mount_root"函数：

感觉不容易查，从"ext2_fill_super"反向查找：
------------------------------------------
ext2_fill_super <- ext2_get_sb <- ext2_get_sb
static struct file_system_type ext2_fs_type = {
        .owner          = THIS_MODULE,
        .name           = "ext2",
        .get_sb         = ext2_get_sb,
        .kill_sb        = kill_block_super,
        .fs_flags       = FS_REQUIRES_DEV,
};
估计调用"get_sb"的函数应该在"fs"目录下，查找发现只有一处调用----"fs/super.c"的"do_kern_mount"。
sb = type->get_sb(type, flags, name, data);
16:58 2007-09-20
换个思路："identify_ramdisk_image"读到的magic正确，但是实际执行挂载时ext2读到的magic不正确。后面的代码是不会错的，这样查有点问题。现在查二者读的内容是否相同。
1, 查"identify_ramdisk_image"读到的地址；
"zImage_09201703_printk_mk"，起始地址是0。为什么可以找到magic，难道是巧合？
2, 查"/initrd.image"是如何定义的，起始地址。感觉应该是由tag ATAG_INITRD2或命令行里面的init定义的。

17:45 2007-09-20
把flash擦干净，重新下载所有内容，如果没有下载ramdisk，也会有"bamvor: load ramdisk from "的提示，查代码发现原有语句放在了"sys_open"之前，即使打开失败也会提示载入，把语句移到后面，就没这个问题了，看代码总是不细致：
        in_fd = sys_open(from, O_RDONLY, 0);
        if (in_fd < 0)
                goto noclose_input;
        /* bamvor.add.2007-09-20.1_line*/
        printk(KERN_DEBUG "bamvor: load ramdisk from %s.\n", from);


18:09 2007-09-20
"identify_ramdisk_image"能正确，可能是因为ramdisk的uImage设置的入口地址在0.
但是刚才经过查找，也没有找到u-boot搬移kernel或ramdisk到Load Address的问题。
修改ramdisk的入口地址后，启动信息相同。见"s3c2410/filesystem/ramdisk/tag/ramdisk1024_mk_none_31000000"和"ramdisk_31000000_09201831"。

21:54 2007-09-20
查initrd.image的起始地址：
[bamv26@localhost linux-2.6.14]$ grep -R "initrd\.image" init/
Binary file init/built-in.o matches
init/do_mounts_rd.c:    if (strcmp(from, "/initrd.image") == 0)
init/do_mounts_initrd.c:                if (rd_load_image("/initrd.image") && ROOT_DEV != Root_RAM0) {
init/do_mounts_initrd.c:                        sys_unlink("/initrd.image");
init/do_mounts_initrd.c:        sys_unlink("/initrd.image");
Binary file init/initramfs.o matches
Binary file init/do_mounts_initrd.o matches
Binary file init/mounts.o matches
init/initramfs.c:               fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 700);
Binary file init/do_mounts_rd.o matches

"init/initramfs.c"函数的"populate_rootfs"
                printk("it isn't (%s); looks like an initrd\n", err);
                fd = sys_open("/initrd.image", O_WRONLY|O_CREAT, 700);
                if (fd >= 0) {
                        sys_write(fd, (char *)initrd_start,
                                        initrd_end - initrd_start);
                        sys_close(fd);
                        free_initrd();
                }
把initrd写入到"/initrd.image"

"populate_rootfs"由"init/main.c"的init函数调用：
         */
        populate_rootfs();

        do_basic_setup();

        /*
         * check if there is an early userspace init.  If yes, let it do all
         * the work
         */

        if (!ramdisk_execute_command)
                ramdisk_execute_command = "/init";

        if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0)
{
                ramdisk_execute_command = NULL;
                prepare_namespace();
        }

initrd_load由"prepare_namespace"调用

会不会"create_dev"没有成功？
#ifdef CONFIG_DEVFS_FS

void mount_devfs(void);
void umount_devfs(char *path);
int  create_dev(char *name, dev_t dev, char *devfs_name);

#else

static inline void mount_devfs(void) {}
static inline void umount_devfs(const char *path) {}

static inline int create_dev(char *name, dev_t dev, char *devfs_name)
{
        sys_unlink(name);
        return sys_mknod(name, S_IFBLK|0600, new_encode_dev(dev));
}

#endif

initrd_start到initrd_end的数据先写入到/initrd.image，再写入/dev/ram，然后呢？
23:55 2007-09-20
待做:
add CONFIG_DEVFS_MOUNT DEVFS_FS  and test cramfs.

10:46 2007-09-21
终于有了进展，内核配置中完全去掉ramfisk和initrd，使用"root=/dev/mtdblock3"时，提示无法执行/linuxrc。因为我多了一个environment分区，所以是地四个mtdblock。
加入devfs与否一样。zImage_09211025_cramfs。

再次修改使用YF2410的linuxrc和mnt/etc内容。

12:12 2007-09-21
细看启动信息，发现nand flash分区少了一个。看devs.c发现分区个数写错了，原来写的是4。
//bamvor.add.2007-08-22
struct s3c2410_nand_set nandset = {
    nr_partitions: 5,           /*the number of partitions*/
    partitions: partition_info, /*partion table*/
};


12:48 2007-09-21
it could not work.

09:33 2007-09-22
# Rule to link busybox - also used during CONFIG_KALLSYMS
# May be overridden by arch/$(ARCH)/Makefile
#bamvor.modified.2007-09-22 delete "-Wl,--gc-sections" from the following line.
#      -Wl,--warn-common -Wl,--sort-common -Wl,--gc-sections 
quiet_cmd_busybox__ ?= LINK    $@
      cmd_busybox__ ?= $(srctree)/scripts/trylink $(CC) $(LDFLAGS) \
      -o $@ -Wl,-Map -Wl,$@.map \
      -Wl,--warn-common -Wl,--sort-common  \
      -Wl,--start-group $(busybox-all) -Wl,--end-group \
      $(LDLIBS)
但是仍然有错误：
[root@localhost busybox-1.7.1]# make clean;make TARGET_ARCH=arm
CROSS=arm-linux-all install
  CLEAN   applets
  CLEAN   .tmp_versions
  CLEAN   .kernelrelease
  HOSTCC  scripts/basic/fixdep
  HOSTCC  scripts/basic/split-include
  HOSTCC  scripts/basic/docproc
  HOSTCC  scripts/kconfig/conf.o
  HOSTCC  scripts/kconfig/kxgettext.o
  HOSTCC  scripts/kconfig/mconf.o
  HOSTCC  scripts/kconfig/zconf.tab.o
  HOSTLD  scripts/kconfig/conf
scripts/kconfig/conf -s Config.in
#
# using defaults found in .config
#
  SPLIT   include/autoconf.h -> include/config/*
  GEN     include/bbconfigopts.h
  HOSTCC  applets/usage
  GEN     include/usage_compressed.h
  CC      applets/applets.o
applets/applets.c:20:2: 警告：#warning Static linking against glibc produces
buggy executables
applets/applets.c:21:2: 警告：#warning (glibc does not cope well with ld
--gc-sections).
applets/applets.c:22:2: 警告：#warning See
sources.redhat.com/bugzilla/show_bug.cgi?id=3400
applets/applets.c:23:2: 警告：#warning Note that glibc is unsuitable for
static linking anyway.
applets/applets.c:24:2: 警告：#warning If you still want to do it, remove
-Wl,--gc-sections
applets/applets.c:25:2: 警告：#warning from top-level Makefile and remove this
warning.
applets/applets.c:26:2: 错误：#error Aborting compilation.
make[1]: *** [applets/applets.o] 错误 1
make: *** [applets] 错误 2

10:07 2007-09-22
按照动态库编译
发现s3c2410linux里面提到的busybox参数不适合busybox1.7.1，应该是：
make clean;make ARCH=arm CROSS_COMPILE=arm-linux- all install
PREFIX（busygox的安装位置）已经在"make menuconfig"中设置"../root"，即"s3c2410-linux/filesystem/root"
编译完成后，查看busybox使用了哪些动态库（arm-linux下查看使用了哪些动态库文件）：
[root@localhost busybox-1.7.1]# arm-linux-readelf busybox -a  | grep Share
 0x00000001 (NEEDED)                     Shared library: [libcrypt.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
从"/usr/local/arm/3.4.1/arm-linux/lib/"复制所需的库文件，注意不要复制符号链接。
编译tinylogin：
make  CROSS=arm-linux- PREFIX=/usr/src/s3c2410-linux/filesystem/root all
install
未完成，待做。


10:07 2007-9-18
开始学习。ramdisk

10:30 2007-9-18
	
对，就是这个unable to open an initial console，前面我很多次说明，如果出现这个问题怎么解决，再贴一次吧。
2.6内核移植的时候，开发板启动以后出现Warning: unable to open an initial console.提示，可以在rmadisk中建立
建立console和null试试，不一定非要去修改内核中的devfs去动态创建　
cd /dev
mknod -m 660 console c 5 1
mknod -m 660 null c 1 3

12:16 2007-9-18
11:21-吃饭

15:49 2007-9-18
用了1.5小时，修万用表。

9:43 2007-9-19
linux tag-12:40, 吃饭14:55

13:07 2007-9-20
到实验室。

13:25 2007-9-20
投日立实习简历，晚上看招聘信息。

18:34 2007-9-20
下午学习结束，进展不大，晚上加入ramdisk tag试试。

21:12 2007-9-20

21:51 2007-9-20

11:20 2007-9-21
吃饭
11:59 2007-9-21

12:36 2007-9-21
现象：Warning: unable to open an initial console
解决：
http://www.hhcn.com/cgi-bin/topic.cgi?forum=3&topic=1180&show=0
对，就是这个unable to open an initial console，前面我很多次说明，如果出现这个问题怎么解决，再贴一次吧。
2.6内核移植的时候，开发板启动以后出现Warning: unable to open an initial console.提示，可以在rmadisk中建立
建立console和null试试，不一定非要去修改内核中的devfs去动态创建　
cd /dev
mknod -m 660 console c 5 1
mknod -m 660 null c 1 3

14:40 2007-9-21
彭老师：
西安电子科技大学->北航硕士。99年去鲁文博士，5年。
多级放大。
公司：NEC，.35工艺，用于游戏机的特殊工艺。

17:45 2007-9-21
(20:45 2007-9-20)
待做，
1, 周五网申大唐；
http://vip.yingjiesheng.com/2008/datangmobile/index.html
2, 网申炬力；
http://campus.chinahr.com/2008/pages/actions/about.asp
3, 日志合并
4, 10:00 整理文档；
5, 尝试用3.4.1编译。

17:34 2007-9-24
0, 应聘职位：生物门禁系统开发，基于Linux。现有测试系统基于S3C2410处理器。
1, 日立（中国）研究开发有限公司
开放式系统软件技术研究与开发
　　当前，开放源代码软件OSS已经成为IT领域新的发展方向。为迎接开源软件时代，我们目前致力于使用开源软件开发新的应用系统及研究实践新的软件开发方法和系统维护技术。
　　许多志愿者投身于开源软件相关的各种活动中，并通过互联网来开发新的软件产品。通过这种方式所得到的开源软件产品可以被自由使用和修改。对于基于开源软件的开发活动而言，将不同组织提供的软件集成在一起成为一项非常重要并且费力的任务。而对于许多用户来说，开源软件的维护工作也是令人疲惫不堪的。但是应用软件开发常常要求较短的开发周期及低廉的成本，开源软件正好满足这一要求，因此受到广泛欢迎。
　　为了解决开源软件开发过程中的各种问题，我们正在进行新的软件开发方法的研究，如测试驱动开发TDD, 基于模型驱动结构MDA的开发工具和开源中间件的调试工具。另外，我们也在开发新的基于Linux平台的应用系统如家庭网络系统及面向中国的Web可用性研究。 
2, 问题：c语言基本功(volatile, 函数指针+数组)。
题目分两部分：c语言基础和Linux基础。
c语言基础：(1)变量定义（指针，数组，函数）。同《0x10》文。查错：使用未初始化的指针。看运行结果：char**类型，char*，整形的强制转换。volatile，static作用。写x^n程序。
Linux基础：vi：设置行号，在当前字符前插入字符。shell：建立文件（touch）；硬件驱动信息在何处（查，待做）。Redhat相关。
3, 日立感谢信。
叶涛博士，张志霞小姐：
    你们好。感谢你们给我这个面试机会，让我有机会近距离接触感受日立。
    通过笔试，我发现了自己c语言基础中的一些问题，例如函数指针和数组同时出现的情况，volatile关键字的作用等等。我会结合毕业设计，进一步改进自己c语言基本功。
    我对面试中提到的生物门禁系统很感兴趣，同时我对于2410这款处理器很熟悉，能够很快适应工作。另外，对于OSS开发研究室所涉及的领域如IT住宅系统及指静脉认证技术，开源软件可靠性研究等，也很感兴趣，很原意加入日立，为开放式系统软件技术贡献一份力量，迎接开源软件时代的到来。
    希望日立能给我这个机会，祝你们中秋和国庆节快乐，谢谢。


                                  此致
敬礼

                                                                       张健
                                                                 2007-09-24
4, 现有招聘：http://www.hitachi.com.cn/micro/recruit/research.asp
Wireless System and Application R&D研究员

18:36 2007-9-24
待做：
总结面试，笔试。
安排本周工作：软件工程，c语言基本功，周中华聊天。


13:00 2007-9-25
本周安排：
1, 找软件工程老师；
2, 总结日立面试；
3, 投大唐，炬力简历；
4, 文件系统。

22:46 2007-9-26
待做：
1, 文件系统移植（完成），把动态库的问题写到chinaunix的帖子上求助。
2, 笔试题目整理；
3, 软件工程；
4, 张默实习：微通益友电子科技有限公司，后端技术支持。
http://www.ops-eda.com/Chinese/index.htm，mo@ops-eda.com
5, 研究生创新奖，10-16截止。见吴老师邮件。
6, (14:10 2007-9-27)休息时可以看越狱第三季。

10:12 2007-9-27

10:46 2007-9-27
网站待看
http://www.china-dz.cn/
中国电子

11:00 2007-9-27
看邮件结束。

14:10 2007-9-27
软件工程

15:40 2007-9-27
整理思路，准备周五演示。

22:44 2007-9-27
17:00?-和师弟讨论问题。吃饭等。

18:10 2007-9-28
待做
1, 系统移植：
(1)整理文档，今晚给研一同学；
(2)写一个arm控制led的小程序；
(3)推荐文章和书。
(4)同时发招聘资料。
2, 给孟昊发简历。给刘成留言，例会内容；（）
3, 想周日安排。
4, 整理日立面试题。

21:03 2007-9-28

9:45 2007-9-29
继续整理文档。

11:45 2007-9-29
吃饭
12:52 2007-9-29

20:35 2007-9-29
待做：
1, 带好所有文档；
2, 打印所需文档；
3, 查欢乐谷是否有夜场。
