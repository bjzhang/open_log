
10:53 2014-05-12
snapshot

[RFC v3] vm snapshot documents
Hi,

here is the third version about vm snapshot documents, the second version and
the first version is here[1][2].

there are two types of snapshots supported by libxl: disk snapshot and vm
snapshot. The following subcommands management the snapshot of a domain,
including create, delete, list and apply.
a domain snapshot(or a vm snapshot) means save the domain config, memory and
disk snapshot.

a disk snapshot will only be crash-consistent if the domain is
running. Disk snapshots can also be internal (qcow2) or external
(snapshot in one file, delta in another).

Domain snapshots include disk snapshots and domain state, allowing to
resume the domain from the same state when the snapshot was created.
This type of snapshot is also referred to as a domain checkpoint or
system checkpoint.

there are live flag in snasphot configuration file, i do not want to implement
in my first verion of patch.

1, new api and struct
1), new struct
(1), libxl_snapshot struct store a disk snapshot information, for disk snapshot
create and delete.
libxl_disk_snapshot = Struct("disk_snapshot",[
    ("device",        string),
    ("name",          string),
    ("file",          string),
    ("format",        string),
    ])

device: device name to snapshot. e.g. sda, hda...
name: snapshot name given by user. it will the be same name as domain snapshot
name.
the following val is only useful for external snapshot.
file: external snapshot file.
format: the format of external snapshot file

(2), libxl_domain_snapshot store domain snapshot information which store in the
path shown above. i add some api for create, delete and list these information.
libxl_domain_snapshot = Struct("domain_snapshot",[
    ("name",          string),
    ("creation_time", uint64),
    ("save",          string),
    ("disks", Array(libxl_disk_snapshot, "num_disks")),
    ])

name: snapshot name given by user. if user do not provide the name, it will be
the epoch seconds.
creation_time: the epoch seconds.
save: the memory save file during snapshot.
disks: disk snapshot assoiate with this domain.

2), new functions
there is no common api like libxl_snapshot_xxx. the reason is that different
toolstack may need to different event handling machnism(sync or ao). and
obviously, i at least need async handler during create. so i decide to only
provide the sub api for xl and other toolstack(e.g. libvirt).

(1), in libxl/libxl.h
the implementation will be located in libxl_snapshot.c
/* disk snapshot api
 * support create for external and internal disks, support delete for internal
 * snapshot of disks.
 */
/* create disk snapshot according to the device name in snapshot array. nb is
 * the number of snapshot array.
 * use the qmp transaction to ensure all snapshot of disk is coherence.
 */
int libxl_disk_snapshot_create(libxl_ctx *ctx, int domid,
                               libxl_disk_snapshot *snapshot, int nb,
                               const libxl_asyncop_how *ao_how);
/* delete number of nb disk snapshot describe in snapshot array
 */
int libxl_disk_snapshot_delete(libxl_ctx *ctx, int domid,
                               libxl_disk_snapshot *snapshot, int nb);

2), xl_cmdimpl.c
int libxl_snapshot_create(int domid, libxl_domain_snapshot *snapshot);
int libxl_snapshot_delete(int domid, libxl_domain_snapshot *snapshot);
int libxl_snapshot_get(int domid, libxl_domain_snapshot *snapshot, int nb);
int libxl_snapshot_revert(int domid, libxl_domain_snapshot *snapshot);

support create, delete, list and revert for domain snasphot. because some
limitation on qemu qmp support. not all api could support internal and external
domain snapshot.


                                create        revert      mem save api
without external disk snasphot  savevm        loadvm      qemu_save_device_state

with external disk snasphot     save_domain   no support  qemu_savevm_state
                                +transaction

there is not delete external disk snapshot api in qemu qmp. so, delete could
only support internal support.

libxl_snapshot_get will read the domain snapshot configuration file stored in
disk and list snapshot information in simple or long format.

there is not revert support for external snapshot file. so only internal
snapshot is supported.

2, snapshot information file
i will write manpage for this with patch.

i found the Wei v5 patch about xl json format.
http://lists.xen.org/archives/html/xen-devel/2014-05/msg01670.html
i do not know how could i use it but i will try the use these in my code.

the vm snapshot information will store in the follow path:
/var/lib/xen/snapshots/<domain_uuid>/snapshotdata-<snapshot_name>.xl

here is an example for snapshot information file:
description="a snapshot after installation"
name="1397207577"
creationtime="1397207577"
save="1397207577.save"
type="internal"/"external"
live="no"
disk_only="no"
disk=[ 'hda=disk_hda.qcow2,type=qcow2', 'hdc=disk_hdc.qcow2,type=qcow2']

the save and disk image file base on the path of "/var/lib/xen/snapshots/<domain_uuid>"

the user could give a snapshot name when vm snapshot created. if not, the epoch
seconds will set as name as the above examples.


3, new command
i will write manpage for this with patch.
1), xl snapshot-create
Usage: xl snapshot-create <ConfigFile> [options] [Domain]

create domain snapshot with ConfigFile or options

Options:
-n                snapshot name
--live            do live snapshot
--disk-only       only disk snapshot, do not save memory.

2), xl snapshot-list [options] [Domain]

--long            list full snapshot information
-n                snapshot name

xl snapshot-delete
-n                snapshot name
--disk-only       only disk snapshot, do not save memory.

xl snapshot-revert
-n                snapshot name

=item B<vm-snapshot-create> [I<OPTIONS>] I<domain-id>

create vm snapshot.
it will call the qmp transaction for creating the disk snapshot in order to
ensure the disk snapshot is coherence.
vm is paused during snapshot create, and is unpause after take snapshot
finished.

B<OPTIONS>

=over 4

=item B<-n>

vm snapshot name

=back

=item B<vm-snapshot-delete> [I<OPTIONS>] I<domain-id>

delete vm snapshot.
delete the saved memory file and snapshot information file created by
vm-snapshot-create.

B<OPTIONS>

=over 4

=item B<-n>

vm snapshot name

=back

=item B<vm-snapshot-list> I<domain-id>

list vm snapshot for the dedicated domain including snapshot name and creation
time which stored in the vm snapshot information file.

=item B<vm-snapshot-apply> [I<OPTIONS>] I<domain-id>

apply vm snapshot for the dedicated domain.

B<OPTIONS>

=over 4

=item B<-n>

vm snapshot name

=back

=item B<disk-snapshot-create> [I<OPTIONS>] I<domain-id>

create disk snapshot.

B<OPTIONS>

=over 4

=item B<-n>

disk snapshot name

=back

=item B<disk-snapshot-delete> [I<OPTIONS>] I<domain-id>

delete disk snapshot by snapshot name or snapshot id.

B<OPTIONS>

=over 4

=item B<-i>

disk snapshot id

=item B<-n>

disk snapshot name

=back

=item B<disk-snapshot-list> I<domain-id>

list disk snapshot including snapshot id, tag, vm size, date, vm clock.

=back

[1] http://lists.xen.org/archives/html/xen-devel/2014-04/msg00414.html
    http://lists.xen.org/archives/html/xen-devel/2014-04/msg00244.html
[2] http://lists.xen.org/archives/html/xen-devel/2014-04/msg02549.html

===============================================================
(1), create domain snapshot.
int libxl_snapshot_create(int domid, libxl_domain_snapshot *snapshot);
create domain snasphot according to the name, device parameter defined in
snapshot. the implementation will be:
prepare libxl_domain_snapshot
save_domain(leave domain paused after save domain return)
if internal snapshot
    call savevm hmp through libxl qmp api.
else
    libxl_disk_snapshot_create

(2), delete domain snapshot.
int libxl_snapshot_delete(int domid, libxl_domain_snapshot *snapshot);


(3), list
int libxl_snapshot_list(int domid, libxl_domain_snapshot *snapshot);
int libxl_snapshot_revert(int domid, libxl_domain_snapshot *snapshot);

