#!/usr/bin/perl
#change function prototype. get function name from function_list
#-fTagHeader (tvbuff_t *tvb, guint offset, guint8 *tag_no, guint8* class_tag, guint32 *lvt);
#+fTagHeader (tvbuff_t *tvb, packet_info *pinfo, guint offset, guint8 *tag_no, guint8* class_tag, guint32 *lvt);

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_f $opt_s);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $source;          #source file name
my $func_list_file;
my @result;
my @func;

getopts('f:s:');
if ( $opt_f ) {
    $func_list_file = $opt_f;
    print "function list is $func_list_file\n";
} else {
    die "no function list";
}
if ( $opt_s ) {
    $source = $opt_s;
    print "source file is $source\n";
} else {
    die "no source file";
}

my $result = $source.".result";

open FUNCTION_LIST, "$func_list_file";
@func = <FUNCTION_LIST>;
my @func_new;
foreach (@func) {
     push @func_new, split /\s+/,$_;
}
print "functions: @func_new";
print "end\n";
@func = @func_new;
close FUNCTION_LIST;

open SOURCE, $source;
open RESULT, ">$result";
my $i = 0;
my $line;

my $func_comment = 0;
my @func_comment = ();
while($line=<SOURCE>) {
    my $func;
    my $match = 0;

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
    $i++;

    #search function prototype, definition or call
#    if ( $line =~ /(f[^\ ^\(]*)/ ) { 
    if ( $line =~ /^.*\b(\w+)\ *\(/ ) { 
        $func = $1;
#        print "$i: $func: $line\n";
    } else {
        print RESULT $line;
        next;
    }

    #match with func_list_file. 
    foreach my $f (@func) {
        if ( $func eq $f ) {
            print "match!! $i: $f\n";
            print $line;
            $line =~ s/($f[^,]*)/$1, packet_info *pinfo/; 
        }
    }
    print RESULT $line;
}


close SOURCE_FILE;
close RESULT; 

