#!/usr/bin/perl

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_p $opt_s);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $src;            #source filename
my $patch;          #patch filename
my @func;           #full function list

getopts('p:s:');
if ( $opt_p ) {
    $patch = $opt_p;
    print "patch file is $patch\n";
} else {
    die "no patch file";
}

if ( $opt_s ) {
    $src = $opt_s;
    print "source file is $src\n";
} else {
    die "no source file";
}

open SOURCE_FILE, $src;
open FUNCTION_LIST, ">function_list";

#get the function list
my $j = 0;
open PATCH_FILE, $patch;
while(<PATCH_FILE>) {
    s/^([^\ ^\(]*).*/$1/;
    my $func = $_; 
    push @func, $func;
    $j++;
}
close PATCH_FILE;

my $i = 0;
my $line;
while($line=<SOURCE_FILE>) {
    my $f_line;

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
    $i++;
    #search function prototype or definition
    if ( $line =~ /^(f[^\ ^\(]*).*/ ) { 
        $f_line = $1;
    } else {
        next;
    }
    #match with patch file. find out the valid function name which need to be 
    #patched
    while (my $f=<@func>) {
        if ( $f_line eq $f ) {
            print "match!! $i: $f\n";
            print FUNCTION_LIST "$f\n";
            last;
        }
    }
    print $line;
}

#open STDOUT, ">1.temp";
#print @patch_buffer;
#close STDOUT;

close SOURCE_FILE;
close FUNCTION_LIST;

