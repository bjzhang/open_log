#!/usr/bin/perl
#extract the function name with pinfo parameter. 

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_f $opt_s);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $func_list_file; #function list file name
my $src;            #source code file name
my @func;           #full function list
my @result;
my %func;

getopts('f:s:');
if ( $opt_f ) {
    $func_list_file = $opt_f;
    print "output function list is $func_list_file\n";
} else {
    die "no function list";
}

if ( $opt_s ) {
    $src = $opt_s;
    print "source file is $src\n";
} else {
    die "no source file";
}

open SOURCE_FILE, $src;
my $i = 0;
my $j = 0;
my $line;
while($line=<SOURCE_FILE>) {
    my $func;       #the function name
    my $argv_2;     #the first argument of "func"

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
    $i++;
    #search function prototype or definition
    if ( $line =~ /([\w]+)\ *\(\ *[\w]+\ *,\ *([\w]+)/ ) { 
        $func = $1;
        $argv_2 = $2;
        if ( $argv_2 =~ /pinfo/ ) {
            print "$func\n";
            push @func, $j, $func;
            $j++;
        }
    }
}

close SOURCE_FILE;

%func = @func;
%func = reverse %func;
@func = keys %func;
@func = sort @func;
open FUNCTION_LIST, ">$func_list_file";
foreach my $f (@func) {
    print FUNCTION_LIST "$f ";
    print "$f ";
}
close FUNCTION_LIST;

