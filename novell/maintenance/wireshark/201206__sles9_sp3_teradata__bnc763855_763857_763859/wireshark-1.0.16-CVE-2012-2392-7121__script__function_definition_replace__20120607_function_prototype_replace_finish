#!/usr/bin/perl

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_p $opt_s);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $src;            #source filename
my $patch;          #patch filename
my @func;           #full function list

getopts('p:s:');
if ( $opt_p ) {
    $patch = $opt_p;
    print "patch file is $patch\n";
} else {
    die "no patch file";
}

if ( $opt_s ) {
    $src = $opt_s;
    print "source file is $src\n";
} else {
    die "no source file";
}

open SOURCE_FILE, $src;
open SOURCE_FILE_RESULT, ">$src".".new";

#get the function list
my $j = 0;
open PATCH_FILE, $patch;
while(<PATCH_FILE>) {
#    print "j = $j\n";
#    print $_;
    s/^([^\ ^\(]*).*/$1/;
    my $func = $_; 
    push @func, $func;
#    print $func;
    $j++;
}
close PATCH_FILE;

my $i = 0;
my $line;
while($line=<SOURCE_FILE>) {
    my $f_line;

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
#    print $line;
    $i++;
    if ( $line =~ /^(f[^\ ^\(]*).*/ ) { 
        $f_line = $1;
#        print "$1";
    } else {
        print $line;
        print SOURCE_FILE_RESULT $line;
        next;
    }
#    print "$f_line\n";
    while (my $f=<@func>) {
#        print "$f_line vs $f\n";
        if ( $f_line eq $f ) {
            print "match!! $i: $f\n";
            $line =~ s/proto_tree/packet_info\ \*pinfo,\ proto_tree/;
            last;
        }
    }
    print $line;
    print SOURCE_FILE_RESULT $line;
}

#open STDOUT, ">1.temp";
#print @patch_buffer;
#close STDOUT;

close SOURCE_FILE;
close SOURCE_FILE_RESULT;

