--- wireshark-1.0.16.orig/epan/dissectors/packet-diameter.c	2010-08-30 06:01:24.000000000 +0800
+++ wireshark-1.0.16/epan/dissectors/packet-diameter.c	2012-06-06 16:12:48.000000000 +0800
@@ -174,9 +174,7 @@ typedef struct _proto_avp_t {
 
 static const char* simple_avp(diam_ctx_t*, diam_avp_t*, tvbuff_t*);
 
-static value_string no_vs[] = {{0, NULL} };
-static GArray no_garr = { (void*)no_vs, 1 };
-static diam_vnd_t unknown_vendor = { 0xffffffff, &no_garr, &no_garr };
+static diam_vnd_t unknown_vendor = { 0xffffffff, null, null, null };
 static diam_vnd_t no_vnd = { 0, NULL, NULL };
 static diam_avp_t unknown_avp = {0, &unknown_vendor, simple_avp, simple_avp, -1, -1, NULL };
 static GArray* all_cmds;
@@ -1033,6 +1031,14 @@ static gboolean strcase_equal(gconstpoin
 	return g_ascii_strcasecmp(a,b) == 0;
 }
 
+/*
+ * note: dynamic "value string arrays" (e.g., vs_cmds, vs_avps, ...) are 
+ * constructed using "zero-terminated" garrays so that they will have the same
+ * form as standard value_string arrays created at compile time. since the last
+ * entry in a value_string array must be {0, null}, we are assuming that
+ * null == 0 (hackish).
+ */
+
 extern int dictionary_load(void);
 extern int dictionary_load(void) {
 	ddict_t* d;
@@ -1061,6 +1067,9 @@ extern int dictionary_load(void) {
 	dictionary.vnds = pe_tree_create(EMEM_TREE_TYPE_RED_BLACK,"diameter_vnds");
 	dictionary.avps = pe_tree_create(EMEM_TREE_TYPE_RED_BLACK,"diameter_avps");
 
+
+	unknown_vendor.vs_cmds = g_array_new(true,true,sizeof(value_string));
+	unknown_vendor.vs_avps = g_array_new(true,true,sizeof(value_string));
 	no_vnd.vs_cmds = g_array_new(TRUE,TRUE,sizeof(value_string));
 	no_vnd.vs_avps = g_array_new(TRUE,TRUE,sizeof(value_string));
 
