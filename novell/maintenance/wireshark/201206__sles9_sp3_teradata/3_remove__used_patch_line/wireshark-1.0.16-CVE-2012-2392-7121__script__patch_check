#!/usr/bin/perl

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_p);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $patch;          #patch file name
my @result;

getopts('p:');
if ( $opt_p ) {
    $patch = $opt_p;
    print "patch file is $patch\n";
} else {
    die "no patch file";
}

my $result = $patch.".result";

#delete two form of function name. 
#1, 
# fTagHeaderTree (tvbuff_t *tvb, proto_tree *tree, guint offset,
#     guint8 *tag_no, guint8* tag_info, guint32 *lvt)
#2, 
#             offset += fTagHeaderTree(tvb, tree, offset, &tag_no, &tag_info, &lvt);

open PATCH, $patch;
open RESULT, ">$result";
my $i = 0;
my $line;
while($line=<PATCH>) {

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
    $i++;

    #remove "+ * @param pinfo"
    if ( $line =~ s/\+\ \*\ \@param\ pinfo/  * \@param pinfo/ ) {
        print RESULT $line;
        next;
    }

    #search function prototype or definition
    if ( $line =~ /(f[^\ ^\(]*)\ *\(\ *([^\,]*)/ ) { 
        if ( $2 =~ /tvb/ ) {
            if ( $line =~ /^-/ ) {
                $line = "";
            }
            if ( $line =~ s/^\+// ) {
                print "$i: $line";
            }
        }
    } else {
        print RESULT $line;
        next;
    }
    print RESULT $line;
}

close SOURCE_FILE;
close RESULT; 

