#!/usr/bin/perl

use strict;
use Encode;
use Getopt::Std;    #for getopts
use vars qw($opt_f $opt_s);
use IO::Handle;     #for autoflush
use File::Basename; #for basename

#global variable declaration
my $func_list_file; #function list file name
my $src;            #source code file name
my @func;           #full function list
my @result;

getopts('f:s:');
if ( $opt_f ) {
    $func_list_file = $opt_f;
    print "function list is $func_list_file\n";
} else {
    die "no function list";
}

if ( $opt_s ) {
    $src = $opt_s;
    print "source file is $src\n";
} else {
    die "no source file";
}

my $result = $src.".result";

open FUNCTION_LIST, "$func_list_file";
@func = <FUNCTION_LIST>;
my @func_new;
foreach (@func) {
     push @func_new, split /\s+/,$_;
}
print "functions: @func_new";
print "end\n";
@func = @func_new;
close FUNCTION_LIST;

#replace two form of function name. 
#1, 
# -fTagHeaderTree (tvbuff_t *tvb, proto_tree *tree, guint offset,
# -    guint8 *tag_no, guint8* tag_info, guint32 *lvt)
# +fTagHeaderTree (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,
# +    guint offset, guint8 *tag_no, guint8* tag_info, guint32 *lvt)
#2, 
# -            offset += fTagHeaderTree(tvb, tree, offset, &tag_no, &tag_info, &lvt);
# +            offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt);

open SOURCE_FILE, $src;
open RESULT, ">$result";
my $i = 0;
my $line;
while($line=<SOURCE_FILE>) {
    my $func;       #the function name
    my $argv_1;     #the first argument of "func"

    if ( $i % 100 == 0 ) {
        my $time = `date +%H%M%S`;
        chomp $time;
        print "$time: i = $i\n";
    }
    $i++;
    #search function prototype or definition
    if ( $line =~ /(f[^\ ^\(]*).*\(\ *([^\,]*)/ ) { 
        $func = $1;
        $argv_1 = $2;
    } else {
        print RESULT $line;
        next;
    }
    #match with patch file. find out the valid function name which need to be 
    #patched
#    while (my $f=<@func>) {
    my $j = 0;
    foreach my $f (@func) {
#        print "$j: $f\n";
#        $j++;
        if ($func eq $f) {
            print "match!! $i: $f, $argv_1\n";
#            print $line;
            if ( $argv_1 =~ /\ / ) {
#                print "definition or prototype\n";
                $line =~ s/($f[^,]*)/$1, packet_info *pinfo/; 
            } else {
#                print "call\n";
                $line =~ s/($f[^,]*)/$1, pinfo/; 
            }
            last;
        }
    }
    print RESULT $line;
}

close SOURCE_FILE;
close FUNCTION_LIST;
close RESULT; 

