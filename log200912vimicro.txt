11:14 2009-12-1
时间管理
0, 9:35-

1, 计划
1), VC0882 mas review: axi master template. 
2), VC0816量产. 
3), coresight总结. 时间比较长了, 今天必须整理. 

2, 执行
1), 9:40-10:06 VC0882例会.
2), 11:15-11:35 VC0882 mas review: axi master template. 
3), -12:15 午饭
4), 12:34-13:15 杂. 
5), -13:41 午休. 
6), -13:59 注册mailiist, 见"13:53 2009-12-1"
7), 14:04-15:10 VC0882 mas review: axi master template, 续. 被8)打断. 
8), 14:17-14:41 liaozhicheng VC0816量产. 
9), -16:04(20') cortex-a8调试, openocd. 
10), 16:28- VC0882 mas review: axi master template, 续.

3, 明日计划:
今天不再工作状态, 明天要完成AXI Master DMA Template review, 开始816量产测试. 
最好用我原来哪个板子. 方便一些. 

12:45 2009-12-1
项目, VC1600, VC0882, 计划, 思考
最近进行时间管理的实践, 虽然记录了每天做的事情, 但是缺乏整理的规划. 今天开会时aiguo提到计划. 很有感触. 
最近这段时间主要是研究cortex-a8, coresight, omap3530等开发和调试等. 已经有段时间没有coding了. 其实和coding相关的工作是有的, 只是没顾上: sd代码整理, Linux移植总结. 另外现在新增的VC0816量产也是熟悉cache的好机会. 
关于Linux移植总结: 考虑结合omap3530 Linux移植进行分析. 
其实每周发的总结应该是阶段性的总结文档结合.
现在比较需要整理的有:
1), omap3530调试: 需要知道从外部SWD/JTAG能访问和控制的资源. 
2), cortex-a8, omap3530软硬件环境: 优先画两个硬件框图: OMAP3530内部, OMAP3530板子.
3), Linux移植总结.
4), sd移植. 
这四个都希望VC0882 FPGA开始前完成. 

13:53 2009-12-1
VC1600, VC0882, VC0718, arm debug, Linux, android
1, 注册了openocd maillist, 关注openocd进展:
To post to this list, send your email to:
openocd-development@lists.berlios.de
General information about the mailing list is at:
https://lists.berlios.de/mailman/listinfo/openocd-development
If you ever want to unsubscribe or change your options (eg, switch to
or from digest mode, change your password, etc.), visit your
subscription page at:
https://lists.berlios.de/mailman/options/openocd-development/bamv2005%40gmail.com
You can also make such adjustments via email by sending a message to:
Openocd-development-request@lists.berlios.de
2, 注册了rowboat maillist:
http://groups.google.com/group/rowboat?hl=en&lnk=

15:36 2009-12-1
软件技巧, VC1600, VC0882, VC0718, arm debug, gdb, 执行jtag特有指令, 查看寄存器
参见"http://elinux.org/BeagleBoardOpenOCD"
1, 执行jtag特有指令
(gdb) monitor scan_chain                                                 
2, 查看寄存器.
(gdb) info registers

16:00 2009-12-1
VC1600, VC0882, VC0718, arm debug, cortex-a8
默认情况下, 任何情况下都可以访问debug register, User模式事都访问可以通过写DSCR[12]控制. 自Cortex-a8 TRM 12.3.2, p437.
By default, you can access all CP14 debug registers from a nonprivileged mode. However, you can program the processor to disable user-mode access to all coprocessor registers using bit [12] of the DSCR, see CP14 c1, Debug Status and Control Register on page 12-21 for more information.

17:45 2009-12-1
VC0816, SV, 量产, spi与jtag share
奇怪现象, 816 cpu板, 在romboot时jlink能扫到, spiboot时jlink扫不到正确的结果.
换fib 816 cpu板同样. 但是romboot下用jlink command认出后, 改为spiboot可以认出, 此时再启动rvdebugger1.8可以连上. 
后来问zhicheng, 发现816 spiboot无法调试. 

9:52 2009-12-2
时间管理
0, 9:26-21:46

1, 计划
1), 完成AXI Master DMA Template review: 看着比较困难, 这周需要抽空继续看. 
2), 开始816量产测试.

2, 执行.
1), 20' Linux进程调度
2), -10:10 邮件. "瑞芯微RK2728与中星微VC0831芯片比较", 见"9:53 2009-12-2".
3), 10:10-10:36 VC0830量产BGA181机台测试总结. 见"10:21 2009-12-2"
4), 10:50-11:10 VC0816 cache量产测试. 见"11:04 2009-12-2"
5), -11:36 Linux kernel "11:05 2009-12-2"
6), 午饭.
7), 12:38-13:07 VC0882 绩效和计划, 见"11:05 2009-12-2"
8), 午休. 
9), 14:10-21:46 VC0816 cache量产测试, 续. 见"11:04 2009-12-2"
(18:27-19:32 晚饭)
别忘了发今天进展. 

3, 明日计划(2), 3)作为后天计划):
1), 816量产. 
2), VC0882 test plan review: timer. 见LiXueLian邮件"882 testplan review"20091202_1714.
3), Linux进程(ULK3 chapter3).

9:53 2009-12-2
VC0830, SV, 量产, 瑞芯微RK2728与中星微VC0831芯片比较
1, 位置: D:\work\VC0830\SV\RK与中芯微功能对比测试报告091110.xls, 
2, 总结果看, 2728上市比830早. 这是很大的优势. 
2728有支持视频格式多和功耗略低的优势. 前者对于830来说是硬伤, 后者优化后可能还是有希望的. 如果830 arm和vdec的设计频率后端做的好一些, 用1.2v供电功耗可能会2728低. 因为报告中条RK2806 SDK为49ma, 831是89.5ma. 
3, 结论: 产品delay, 产品定位不准是主要问题. 

10:21 2009-12-2
VC0830, SV, 量产, BGA181, dft, 量产测试, 切频, 续, 总结
10月份做完忘了总结, 今天zhicheng问我一时没想起来. 
1, 测试方式: 
830 xclk=24Mhz(需要拉对应strap pin), 机台模拟baseband通过biu初始化sdram, 然后把代码下载到830sdram中, 放开830.
830运行: 先切频到pll1: 480_240_120, 然后测试audio等, 最后测试usb. 
2, 在实验室测试时, 首先zhangjian在其它封装(这里选择的是BGA282)的spi boot情况下测试基本环境和切频. 然后用44b0x作为baseband初始化830 sdram并下载代码. 
3, baseband代码: 
1), 用宏"_181_jitai_test"表示机台测试代码. 
Register_V830()(D:\VC0830\baseband\trm830\registerV830.c)根据是否是机台测试走的流程有差异. 例如memory参数不同. 下载映像方式不同(baseband模拟机台测速时映像直接把830映像编译到baseband映像中, baseband正常使用时把文件系统的问下下载到830sdram).
最后下载的函数是"V830_CpBoot("me.bin");".
V830_CpBoot()(D:\VC0830\baseband\trm830\v830cpmode\v830_cpmode.c), 这个函数对机台和normal不同. 同样通过"_181_jitai_test"区分. 
这个函数把ptr开始的fszie大小的数据(即830映像)通过"HAL_WRITE_MEM(0x40000000, ptr, fsize);"下载到830sdram中, 下载后读出比较是否相同. 
    fsize = input_data_end - input_data;
	ptr = (char *)input_data;

2), input_data_end和input_data在"D:\VC0830\baseband\trm830\packbin\bin_include.s"定义: 
	AREA    BIN_FILE, DATA, READWRITE
	EXPORT	input_data
input_data
	INCBIN	bootloader.BIN
	EXPORT	input_data_end
	
input_data_end

	END

这里已经指定了"bootloader.BIN"是映像名称. 编译好的830映像复制到目录"D:\VC0830\baseband\trm830\packbin\"即可. 

11:04 2009-12-2
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 spi boot测试
0, 每天报告发给: daichunquan, chenying, dongxin, wally, aiguo, fengbeizhan, liaozhicheng
1, 死在"MCR p15, 0, r0, c1, c0, 0", 这是开mmu. 映射有问题? 
2, 目前代码超过了0xa00, 将来copy时需要做处理, 否则copy到sram后会覆盖0x20000a00已有的mmu表.
3, 查资料, 发现ttb基址需要[13:0]都是0, 即16k(0x4000)对齐, 但是sram一共才4k, 这如何处理呢? 只能是把ttb地址设为0x20000000. 映射0x0和0x20000000, 不再映射0x40000000
4, lsl, lsr与移位位数之间没有",":
lsl #2
如果加上",", 会提示ADS会提示"bad symbol". 

5, 切频备份: 

	;=======切频开始===========
	ldr r0, =0x60000004
	ldr r1, =0x001400c8
	str r1, [r0]
	
	ldr r0, =0x60000000
	ldr r1, =0x26a
	str r1, [r0]
	
	ldr r0, =0x60000000
	ldr r1, =0x262
	str r1, [r0]
	
	ldr r0, =0x60000014
	ldr r1, =0x1fff
	str r1, [r0]
	
	ldr r0, =0x60000000
	ldr r1, =0x266
	str r1, [r0]
	
	ldr r0, =0x60000000
	ldr r1, =0x262
	str r1, [r0]

1	
	ldr r0, =0x60000010
	ldr r1, [r0]
	tst r1, #0x1
	beq %BT1
	
	ldr r0, =0x60000000
	ldr r1, =0x260
	str r1, [r0]
	
	mov r0, #0x800
loop_1
	subs r0, r0, #1
	bgt loop_1
	
	
	ldr r0, =0x6000002c
	ldr r1, =0xffffffff
	str r1, [r0]

	ldr r0, =0x60000030
	ldr r1, =0xffffff7f
	str r1, [r0]

	ldr r0, =0x60000040
	ldr r1, =0x1100
	str r1, [r0]

	ldr r0, =0x60000044
	ldr r1, =0x1
	str r1, [r0]

	ldr r0, =0x60000048
	ldr r1, =0x8d
	str r1, [r0]

	ldr r0, =0x60000058
	ldr r1, =0x44
	str r1, [r0]

	ldr r0, =0x6000005c
	ldr r1, =0x99
	str r1, [r0]

	ldr r0, =0x60000024
	ldr r1, =0xffffffff
	str r1, [r0]

	ldr r0, =0x6000002c
	ldr r1, =0x2a3
	mvn r1, r1
	str r1, [r0]

	ldr r0, =0x60000030
	ldr r1, =0x269a0
	mvn r1, r1
	str r1, [r0]

	
	ldr r0, =0x60011028
	ldr r1, =0x0
	str r1, [r0]
	
	;//切频	
	ldr r0, =0x60000020
	ldr r1, =0x0
	str	r1,[r0]
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop	
	
	mov r0, #0x800
loop_2
	subs r0, r0, #1
	bgt loop_2
	;============================

6, 发现有memory时写入正确, 没有memory时写入数据不稳定, 最终会变为0xffffffff.

7, 今日结论:
由于816 spiboot不能用jtag. 所以只能用830 BGA282封装测试cache测试代码. 
目前代码只包括dcache测试, 不包括切频. 代码编译通过. 测试遇到问题, 情况如下:
1), 在跳转到sram后, 查看映射情况, mmu未映射的sdram无法访问, 说明sdram映射正常. sram访问正常, 说明sram映射正常.
2), 跳转到sram后, 有memory情况下向锁入dcache memory读写, 正常. 去掉memory后写入数据开始不稳定, 最后稳定到0xffffffff. 
锁dcache是否正确还需要确认. 

11:05 2009-12-2
VC1600, VC0882, VC0718, Linux版本选型, Linux kernel版本差异(changelog), human readable changelog, ftrace
1, kernel human readable changelog
http://kernelnewbies.org有很多资料, 例如"http://kernelnewbies.org/LinuxChanges"是最新kernel changelog, "http://kernelnewbies.org/Linux_2_6_28"是2.6.28的changlog.
注意到ftrace是2.6.27加入的. 
2, 2.6大致进化过程(具体版本有误差)
1), 2.6.10: ldd3, ulk3. 
2), 2.6.21: platform bus. 
3), 2.6.31 测试. 移植架构清楚, 调度算法改进. 
830 Linux: 2.6.27.

12:39 2009-12-2
VC1600, VC0882, 绩效, 奖金, 
1, 各Team前30%奖金见YangZuoXing邮件"vc0882:about 10~11 bonus of 882"20091201_2028.
邮件中列出的ICD平均工作时间是245小时(除去中午1小时), 平均奖金是3287. 相当于平均加班77小时. 我的工作时间是210小时, 加班42小时. 从加班时间看, 我们组最多的是dashan 90小时. 我自己的目标是做到60小时左右. 这样加上绩效, 希望奖金在2500以上. 

2, 本组考核:
1), AiGuo邮件"882 ICP这个月的奖金原则"20091201_2006
在882大的奖金原则下，结合ICP工作的具体目标，奖金原则如下：
(1), Mas review，继续Review没有完成的mas，performance根据mas review quality来决定；
(2), Test plan，在12月低到1月初，给出一版完整的test plan，performance根据大家对test case构建，计算方法参照882 mas的计算方法；
(3), 882项目的提前准备工作：
A）882基本软件环境的建立；
B)  ARM调试环境的研究，通过ARM RealView ICE去debug A8
C）USB Host/OTG研究，熟悉IP相关资料
D）Video decode的研究，熟悉ffmpeg，对一些高清电影进行分析
E）学习3D/2D
(4), 加班时间也作为大家的一个重要考核指标

2), 对我来说, 有mas和test plan review; 和arm调试环境(realview ICE). 
原来计划zhicheng和我做的882基本环境目前是beizhan做. 
除了aiguo列出的, 我还有VC0816量产, sd代码整理和Linux移植总结. 这些任务都是比较紧急的, 因为之前1-2周大量精力放在omap3530各种实验. 考虑到1月份就要上VC0882 FPGA到时既要调试882环境又要建立Linux环境. 本月希望这些任务都能基本完成. 

3, 结合前面aiguo邮件和"12:45 2009-12-1"思考, 我有如下工作: 
1), review: VC1600 mas review, VC0882 test plan review; 
2), coding类: sd代码移植到830 Linux, 再从kernel移植mmc/sd协议栈到nucleus. 
3), 总结: Linux移植总结, omap3530调试架构和板子硬件总结;
4), 其它: VC0816量产. 
5), 长远: kernel分析, coding练习. 一直计划的perl语言的日志辅助工具也需要做了.
这些工作中, 4)必须本周完成(周五是12月4日). 此外2)和3)是我参与VC0882 FPGA环境前要完成的. 估计也就只有1.5月左右. 1)按部就班做就可以. 每周预计1.5工作日. 5)的规划也要做. 
现在比较缺的是项目整体需要和schedule.

14:38 2009-12-2
VC1600, VC0882, VC0718, mas review, DMAC, 讨论
1, YiNong邮件"答复: DMAC problem"20091202_1401
882是8 byte,  718是16 byte?
既然要限制granularity,  starting address 和 length是不是也可以做成和8/16 aligned的？  这样design & verification的corner cases可以减少很多。
2, YouHai邮件"答复: DMAC problem"20091202_1434
1), 其实这个限制应该是AE 工程师自己需要考虑的事，需要考虑的事情很多，一是临界点选择，在2k附近，低于2k ，都是arm copy 快，不过ic用16没啥不可以，但ae 不可以这么直接拿过来用，需要实测，820，830都是在1~2k，cortexA8 还没测过。二是ｃａｃｈｅ维护。三是并行处理。
2), Yinong　推荐的是方式是８２０采用的，当时觉得软件在做判断的环节比较多，当时传输数据量概率分布需要ｄｍａ的还不是特别多，而且不对齐的很多。所以没法用。下面的代码是两年前写的，但也没用起来的。

9:58 2009-12-3
时间管理
0, 9:32-21:12

1, 计划
1), 816量产. 
2), 要lingming memory测试结果.
3), VC0882 test plan review: timer. 见LiXueLian邮件"882 testplan review"20091202_1714.
4), Linux进程(ULK3 chapter3).

2, 执行
1), 20' cache锁定. 
2), 10:00-17:30 VC0816 cache量产测试, 续. 见"10:53 2009-12-3"
(15' trace PCB资料, 见"10:37 2009-12-3")
(11:30-14:12 午饭, 休息)
3), 晚饭. 等.
4), 19:35-21:06 VC0816 cache量产测试, 续. 见"10:53 2009-12-3"

3, 明日计划:
1), 找示波器探头. 
2), VC0816优先级放低, 先把testplan review完成. 

10:37 2009-12-3
VC1600, VC0882, VC0718, arm debug, trace, cortex-a8, PCB设计参考资料
找到部分资料供参考.  例如
“DUI0155I_rvi_user_guide.pdf”的附录D Designing the Target Board for Tracing有trace设计的注意事项. 
“DUI0417B_PB-A8_UserGuide.pdf”是arm cortex-a8 fpga板的文档, 里面有debug和trace的接口定义.
Trace接口见” A.13.4 Trace Connectors”, p257

10:53 2009-12-3
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 spi boot测试, 续
1, 看了看"ARM嵌入式开发", 做几个修改: 
1), 不准备锁cache的设为ncnb, 这样可以保证invalidate cache后cache是干净的. <DONE>
2), 是否需要invalidate cache? 
3), 原来zhicheng的代码似乎有问题. "mcr p15, 0, rd, c9, c0, 0/1"的用法需要再查. 
(1), ARM_ARM提到至少有一路不能锁, 如果都锁了结果不可预测. 参见p815:
A cache way based lockdown implementation must not lock down the entire cache. At least one cache way block must be left for normal cache operation. Failure to adhere to this restriction results in UNPREDICTABLE behavior.
所以先实验锁3路, 看能不能筛出片子, 不行就得想办法锁两轮cache(锁不同的路).
(2), 用法和cache type有关, arm926ej-s:
	; returns Cache Type register
	MRC p15, 0, r0, c0, c0, 1 
0x1D152152
高8位是: 0x1d=b00011101, [24]=1说明是指令数据分开的cache. [28:25]=b1110说明是formatC. 
(3), 顺便确认一下cache大小:
Cache size = ASSOCIATIVITY × NSETS × LINELEN
= NWAYS × NSETS × LINELEN
= NWAYS × 2^S × 2^L bytes
816/830 cache都是16k. arm926ej-s: 32 bytes per line, 4ways. 
\todo 查sets.
4), 昨天的想法: 不配置memory, 直接切频. 这样memory就不能用了. 
并且切频前使memory进入self-refresh. 

2, 主要问题是锁cache方法:
1), 只能是一个way一个way锁. 
\todo 别忘了4).
\todo 完成这段代码后打算写个锁cache的总结. 
2), 锁cache的代码要么不可cache, 要不已经锁入cache. 并且不能发生异常. 
3), Use the register c7 clean and/or invalidate operations to ensure 要锁入cache的代码或数据必须是可cache的, 而且必须没有在cache中.

3, 问题: 
切频时代码已经开了mmu, 这时由于0x60000000地址未映射造成. 只能将来也把这部分也锁入cache. 而且锁tlb. 
先调试锁dcache: 
	;==================切频=====================
	;产生pll
	;复制自 VC0830_bootloader Pll_GenPll1 反汇编
	 ;pll=480MHz@xclk=12Mhz(0x00140190)
	 ;\todo 根据strap pin休息
	 ldr	r0, =0x00140190
     ldr	r3, =0x00004e68
     mov	r2, #0x60000000
     str	r0, [r2, #4]
     str	r3, [r2]
     sub	r3, r3, #8	; 0x8
     str	r3, [r2]
     add	r3, r3, #6	; 0x6
     str	r3, [r2]
     sub	r3, r3, #4	; 0x4
     str	r3, [r2]
     ldr	r3, =0x00001fff
     str	r3, [r2, #20]
5
     mov	r2, #0x60000000
     ldr	r3, [r2, #16]
     tst	r3, #1	; 0x1
     beq	%BT5
     ldr	r3, =0x00004e60
;     mov	r0, #0x800
;     str	r3, [r2]
;     b	144 <Delaycycle>

	;\todo 配置sdram进入self-refresh
		
	
	;配置cpu,bus divider, 参考vc0830_bootloader Pll_GenModuleClk
 	;cpu_bus_div
 	ldr r0, =0x60000040
 	ldr r1, =0x1100
 	str r1, [r0]
 	;cpu_bus_ratio
 	ldr r0, =0x60000044
 	ldr r1, =0x1
 	str r1, [r0]
 	;set switch type
 	ldr r0, =0x60000018
 	ldr r1, =0x0
 	str r1, [r0]
 	;switch
 	ldr r0, =0x60000020
 	ldr r1, =0x0
 	str r1, [r0]
	;===========================================
4, 仍然是拔掉memory后有问题. 

5, (15:27 2009-12-4修改)静下心来思考, 现在这种方式调试会很困难. 原来的思路也有问题.
目前遇到问题较多, 我把原来思路列出来再详细解释. 之前的思路是:
启动 -> 映射0x0和0x20000000 -> 开icache,dcache和mmu -> 锁icache和dcache -> 跳转到sram运行 -> 切频到cpu=240, bus=120 -> 此时sdram已经不可用, 通过访问已经锁入cache的指令和数据测试icache, dcache.
注: mmu按大页(1M)映射. 
除了昨天的问题, 还有如下问题: 
1), 在开启mmu之后切频, 这样必须映射0x60000000开始的寄存器空间. 这样映射0x0, 0x20000000, 0x60000000或映射0x20000000, 0x40000000, 0x60000000所需要的mmu表长都会超过4kByte, sram放不下. 只能把表放在sdram中, 为了保证切频后arm可以访问这个表, 把需要访问的表项锁到tlb中.
这样又增加了锁tlb的代码. 代码更复杂.
2), 从arm文档看, arm926ej-s四路组相联的cache同时最多锁3路, 所以至少需要测试两轮才能测试完cache.
这个问题LiaoZhiCheng之前提过. 
3), 之前为了简单, 小巧, 直接用汇编编程, 现在流程有变化, 将来可能流程还会有调整, 再考虑到sdram使用没有限制. 计划把代码用c语言重新实现, 只有锁cache部分仍用汇编实现. 
上面这些问题其实都是由于816机台测试用sdram是模拟的, 只能在低频用, 如果可以在120Mhz工作, 测试cache会很简单. 
如果问题无法解决, 816 cache测试代码需要更多时间. 具体时间不好估计. 实现中可能还会有没考虑到的问题. 

20:54 2009-12-3
VC1600, VC0882, VC0718, arm, SOC, 竞争对手调查, TI很贵, RK2806, 2728胜在支持h.264 main profile, 展讯被踢出中国IC十强
1, TI的omap3530目前价格是32-38.4$, 约合220-280RMB. 
http://focus.ti.com/docs/prod/folders/print/omap3530.html
2, zhangpu今晚邮件"2009年度“中国原创”本土热门IC产品推荐", "2009 年中国 IC 设计公司调查". 后者提到"2009十大中国IC设计公司品牌", 包括中星微, 瑞芯微等, 不包括展讯. 
3, 测试报告:
1), rockchip报告:
(1), YiNing邮件"答复: 882 ICP这个月的奖金原则"20091202_0318
加一条，反思830，598等的测试，提合理化建议，看怎么能把882的测试做得更好。
发一份Mark转来的Rockchip的人做的他们的芯片与830的芯片的功能和性能比对,  请ICP, ICV, ICD所有相关人员仔细阅读， 看看我们的问题在哪里。
这里面的问题，当然很多是software 层面的。作为IC team的人，你们先把注意力放在RTL的层面上。 有些问题，也许瑞星微的人测我们的东西没配对，你们看了以后，也要逐条标出来，提供给AE team作为反馈。 如果有我们测试中没有cover到的环节，请你们务必加到882的test plan 里。
Zuoxing, Aiguo, Wright,  请安排一个时间，开会逐条讨论这个报告。对来自于竞争对手的东西，我们要认真对待。 起码我看我们自己这里，对竞争对手的东西，从没有做过这么详细的competitor analysis.  而我们831才推出去没几天，Rockchip的报告就写出来了。这个就是差距！
(2), 从报告看, 瑞芯微胜在支持h.264 main profile, 其余还有jpeg支持好等小细节. 我们830的优势是rmvb解码高分辨率大码率的文件也流畅. 
\todo 需要了解瑞芯微到底用的什么方案, 瑞芯微当初做芯片MRD的时候是否考虑到了720p的要求. 感觉瑞芯微似乎用的dsp方案, 这样更容易适应市场需求. 
2), vimicro报告:
(1), StevenLiu邮件"答复: vc0830: about the report from rochchip"20091202_1628. 
竞争对手对比测试报告放在: "\\10.20.8.196\QC Database\测试报告备份\竞争对手对比测试报告".
zhangjian: 已复制到"D:\work\VC0830\方案比较".
(2), 感觉公司自己测的方案有些细节没有照顾到, 例如jpeg解码的问题, 不管是瑞芯微还是第三方测试都测到了. 我们自己没测到. 

9:34 2009-12-4
时间管理
0, 9:22-

1, 计划<DONEor转移>
1), 找示波器探头. 
2), VC0816(优先级放低). <转移>
3), VC0718 mas review: pmu, clkrst.<转移>
4), VC0882 test plan review: timer. <DONE>.
5), 带工作日志回家.

2, 执行
1), -9:35 杂;
2), 9:35-10:05 整理未读邮件. 未完. 
3), -10:58 816量产会议
4), 11:00-11:15 VC0816 cache量产测试, 续. 见"11:08 2009-12-4"
5), 15:17-18:07 VC0816 cache量产测试, 续. 见"11:08 2009-12-4"2
6), 晚饭.
7), 20' VC0830 clkrst模块注意事项总结, 见"19:21 2009-12-4"
8), 15' VC0882 testplan review: timer.

3, 次日计划<转移>:
1), VC0718 mas review: pmu, clkrst
2), VC0816量产cache测试. 下周一定完成. 希望还有时间看arm debug东西.
3), 有空关注minigui mstudio, 有windows和ubuntu版本. 
4), 周工作总结, 月工作总结.
5), option:
(1), omap3530, beagleboard系统硬件框图整理
(2), openocd调试omap3530机制分析. 
(3), arm会议总结. 

9:51 2009-12-4
VC1600, VC0882, VC0718, HPCC environment
FanZhiJun邮件"VC1600: HPCC environment"20091202_1655
882环境使用步骤
1，   copy /home/fanzhijun/module_cshrc 到自己的home下作为.cshrc，如
copy /home/fanzhijun/module_cshrc  /home/yangzuoxing/.cshrc
2，   重新启动一个xterm即调用882的环境；
会自动调用下面这个公共文件
/doing/project/vc0882/module_files/ vc0882
内容包括
1，   cvs path
可在/work/user/project路径下， 
cvs co vc0882，check out cvs内容；
2，   EDA工具
3，部分alias
可在各自/home/user/.cshrc的底部添加个人习惯的alias.

HouHuaMin邮件"RE: VC1600: HPCC environment"20091202_1701
最好能加上下面的，的有很多utility。
source /tools/vimbin/flowbin/flow.cshrc

10:01 2009-12-4
VC1600, VC0882, test plan review, CVS
CVSROOT
:ext:zhangjian@10.0.31.4:/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY
module: VC0882

11:08 2009-12-4
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 spi boot测试, 续
0, 上午讨论中得知, 
816 sdram padc还测试了AC特性, 830没有测试. 所以830测试没有816严谨. 
816如果接sdram, 就没法测试AC特性了. 
1, 发现原来cache line写的是3, youhai写的是5. 
看来是以byte为单位. 
修改后现象依旧. 
2, (15:18 2009-12-4)用完整板代码实验锁cache. 
现在的思路是首先解决难以解决的问题: lockdown icache and dcache, lockdown tlb. 至于我开始考虑的启动环境问题稍后解决. 
3, 从816 sram_memsram复制程序. 
环境还是有问题. 直接用VC0816 panda project实验.
4, 会议讨论结论:
(1), houpeixin: 为了不锁tlb, 切频代码可以在锁cache后, 关闭mmu再做. 这样mmu表就可以放在sram中了. 不确定的是关闭mmu后cache的状态会不会乱. houpeixin问arm, 会找shujie仿真. 找huangwei讨论.
(2), youhai: 通过访问0x0, 0x20000000, 0x60000000等让arm自动把信息保存到tlb中. 

15:12 2009-12-4
VC1600, usb3.0, 1G Ethernet demo
Aiguo转发邮件"转发: USB3.0 研發工具、Ethernet"20091204_1502
Hi Mr. Wan , 
I have arranged the online demo. Now,Absolute Analysis invites you to attend this online meeting. The detail information is shown in below.
Topic: Flash Demo 
Date: Friday, December 4, 2009 
Time: 5:00 pm, China Time (Beijing, GMT+08:00) 
Meeting Number: 801 429 804 
Meeting Password: Probe123 
------------------------------------------------------- 
To join the online meeting (Now from iPhones too!) 
------------------------------------------------------- 
1. Go to https://absoluteanalysis.webex.com/absoluteanalysis/j.php?ED=130809452&UID=1088243882&PW=NZGUyMDNjMjYy&RT=MiM0NQ%3D%3D 
2. Enter your name and email address. 
3. Enter the meeting password: Probe123 
4. Click "Join Now". 

19:21 2009-12-4
VC0830, SV, clkrst, clkswitch, 几个注意事项
1, clkrst模块可以通过两种方式获得VC0830 memory参数. 
1), include\sys.h中配置封装, SYSTEM_MEM, BOARD_TYPE组合.
2), 打包传入. 文档见"D:\VC0830\VC0830\clkrst\notes.txt"二'切频打包工具'
2, 由于830切频流程缺陷和产品特殊要求, 有些memory需要在sram中完成部分切频流程. 
这部分切频流程由include\sys.h的"CLKRST_SRAM_SWITCH_FUNC_SUPPORT"开关控制. 目前只有"dram32M_4bank_dynamic.lds"链接脚本支持此功能. 其它链接脚本需要不定义include\sys.h的"CLKRST_SRAM_SWITCH_FUNC_SUPPORT", 否则编译时会提示"__clkrst_sram_switch_start"和"__clkrst_sram_switch_start"变量未定义. 
3, 切频API使用方法见"D:\VC0830\VC0830\clkrst\notes.txt"一'切频API'

10:01 2009-12-7
VC1600, VC0882, testplan review, 882 test plan难易程度
我负责的模块中sdio属于难度中等, aiguo认为主要是兼容性问题. 
详见Aiguo邮件"882 test plan难易程度"20091205_1746:
根据882中test plan难易程度我做一下基本的分类，大家参考：
1）难度较大的模块有：
a)DE
b)CIF
c)EMI：这个模块对我们来说非常陌生
d)USB（USB Host/USB OTG），Host和OTG的测试项需要我们摸索
e)NandFlash，新加如了好多功能，采用了新的ECC算法，这个模块暂时还没有定下来
f)Video decode，支持了好多新的视频压缩格式
g)2D/3D，现在还没有拿到IP资料，但这个模块很复杂，挑战很大
2）难度中等的：
a)Video encode，和598一样的IP
b)Sdio，主要是兼容性
c)TV
d)Lcdif
e)Audio
f)Dmac
g)Spi
h)Uart
i)TPI
3）比较简单模块：
a)Timer
b)Interrupt
c)Pwm
d)I2c
e)Kpd
4）后期需要验证和测试的模块：
a)PMU
b)Padc
c)Clkrst
d)Sdrc，主要是兼容性
总共的test plan大概20多个左右，有难度的有7个。

10:10 2009-12-7
VC1600, VC0882, VC0718, arm SOC, cortex-a8, freescale i.mx 515 feature
Cortex-A8 module ships with baseboard, Linux BSP
http://www.linuxfordevices.com/c/a/News/Direct-Insights-TritonTX51/
The i.MX515 offers a Cortex-A8 core clocked to 800MHz, and is equipped with a NEON floating point unit, a PowerVR graphics engine supporting OpenGL ES 2.0, and a hardware-implemented video codec. These capabilities are said to provide the Triton-TX51 with D1 encode (at 30fps) and 720p decode for MPEG-4/H264 video. The SoC's image processing unit also includes a CMOS sensor input, 24-bit LCD controller, and TV out, says Direct Insight.

10:22 2009-12-7
VC0816, SV, 量产, cache测试, arm回信
Aiguo邮件"转发: ARM's feedback on disabling MMU when ARM926 MMU/DCache being lock down"20091205_1032
Q(HouPeiXin): The question is: In ARM926, we have some code and data running and LOCKed in I and D caches, then the execution jumps to a non-cacheable location, then I just disable the MMU (CP15, C1, bit0) and do some operations. Then MMU is re-enabled again, and the execution is jumped back to the code locked in cache. Is this OK? Will the contents and status of I/D cache be kept when the MMU is disabled? The page table is configured as VA=MVA=PA.

A(ARM): 
If the MMU is disabled, the Cache/TLB contents are not affected, so that would be ok as long as the TLB entries are still valid (are you not using translation, you say VA=MVA=PA ?) (If the TLB entries are now invalid, then the TLB must be invalidated before re-enabling the MMU)
Note that when the MMU is disabled you will get this flat mapping of VA=MVA=PA anyway.
Also the Dcache is no longer accessible when the MMU is disabled.

10:43 2009-12-7
VC1600, VC0882, VC0718, arm debug, cortex-a8, debug架构讨论
1, 回复HuangWei邮件"Re: 关于A8"20091207_1026
下图是arm "Multi source trace in a multi-core system" examples, 我理解882/718调试架构会比这个简单, 比huangwei邮件中"Single source trace"复杂. 这样需要更多的component(DAP, TPIU, ITM, HTM, ETM, replicator): 
1), DAP: DAP-lite没有jtag-ap, 无法访问SOC内部jtag协议的core. 要看718 dsp是否使用jtag调试. 
2), TPIU: tpiu-lite不支持multi-source trace. 如果希望支持ITM或HTM, 就必须用TPIU: 
(1), HTM: 可以监测总线上的访问, 但是这个接口是AHB的, arm公司资料是通过AXI2AHB bridge可以抓AXI总线的数据. 由于AXI和AHB协议不同, 不清楚硬件是否容易实现. 
(2), ITM: 软件写给硬件的调试信息(类似pirntf), 和ETM信息一起汇总到TPIU. 对于axi上多个master复杂场景的调试有帮助.
2), ETM: 相比TPIU trace数据量大小受trace pin count影响, ETM可以全速运行, 可以保存更多trace信息, 但需要占4k多更多sram.
3), AHB-AP: 通过外部调试接口在arm不停止情况下直接访问memory. 读写memory速度比通过arm访问快很多(便于调试时下载映像).

2, 进一步查资料: 
1), data suppression mechanism: 查ETM资料, 见"9:42 2009-11-26"2
2), PTM. 见"DDI0401B_coresight_ptm_a9_r1p0_trm.pdf".
这个资料只是用于cortex-a9的, 看来到了更高速度, ETM也追不上. 
PTM只是输出waypoint, 而不是ETM那样完整的指令数据. 所以trace工具需要有一份代码(原文如此, 我理解是需要有代码编译成的映像).
3), HTM, 见"DDI0328E_amba_htm_r0p4_trm.pdf". 文中没有说明如何trace AXI总线上的数据. 

15:16 2009-12-7
软件技巧, rvds, arm debug
运行rvds setup.exe后有时提示重启, 如果重启后仍然不行, 可以在安全模式下安装. 

15:17 2009-12-7
时间管理
0, 9:18

1, 计划<转移>
1), 816量产.

2, 执行.
1), -10:15 邮件整理.
2), -11:45 VC1600, VC0882 arm cortex-a8 debug, 见"15:21 2009-12-7"1
3), 14:15-15:05 arm cortex-a8 debug, 见"15:21 2009-12-7"2,3
4), -15:35 帮lixuelian安装rvds3.0
5), -21:17 816量产, 见"16:34 2009-12-7"
其中吃饭50'

3, 明日计划<转移>
1), 问VC0882 IC dual timer 进位如何测试. 

16:34 2009-12-7
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 spi boot测试, 续
1, error: can't find a register in class 'GENERAL_REGS' while reloading 'asm'
优化从-O0改为-O2后问题解决. 
参"http://archives.devshed.com/forums/development-94/can-t-find-a-register-in-class-general-regs-while-2309058.html"
2, 锁cache:
今天实验锁icache, 还是不行, 估计是自己代码有问题.
3, 实验锁tlb
ADR r1,LockAddr ; set r1 to the value of the address to be locked down
MCR p15,0,r1,c8,c7,1 ; invalidate TLB single entry to ensure that
; LockAddr is not already in the TLB
MRC p15,0,r0,c10,c0,0 ; read the lockdown register
ORR r0,r0,#1 ; set the preserve bit
MCR p15,0,r0,c10,c0,0 ; write to the lockdown register
LDR r1,[r1] ; TLB will miss, and entry will be loaded
MRC p15,0,r0,c10,c0,0 ; read the lockdown register (victim will have
; incremented)
BIC r0,r0,#1 ; clear preserve bit
MCR p15,0,r0,c10,c0,0 ; write to the lockdown register

"ADR r1,LockAddr;"可以用"ldr r1, =0x60000000"伪指令代替, 这里0x60000000是要锁入tlb的地址. 倒数第三句"MRC p15,0,r0,c10,c0,0"会读出victim(c10[28:26]), 每次lockdown, victim都会加一. 大于victim的是tlb中可以替换的. 
4, (21:09 2009-12-7)
今日进展:
1), tlb lowndown:
把0x20000000(sram)和0x60000000(寄存器)锁入tlb成功. 
2), cache lockdown: 锁dcache似乎可以: 
把数据锁入dcache, 在打开memory自动自刷新后访问锁入dcache的memory数据. 数据读写正常且memory没有退出自栓新. 
但这个时候拔下memory, 锁入dcache的数据会变为全0xfffffffff.

明天会继续做icache, dcache lock down实验.

17:23 2009-12-7
VC1600, VC0882, 测试, sdio测试内容
见YangZuoXing邮件"答复: 882需要测试的外设有"20091207_1717
SDIO:		CMMB
			WIFI
			8BIT MMC CARD
			SD CARD (32G/64G/128G, HIGH SPEED)

9:57 2009-12-8
时间管理
0, 9:42-19:05

1, 计划<DONEor转移>
0), 希望今天或明天完成perl搜索工具.
1), VC0816量产, cache测试. 本周一定完成.
2), 问VC0882 IC dual timer 进位如何测试. 
3), 上周总结.
4), VC0718 mas review: pmu, clkrst
5), 希望还有时间看arm debug东西.
6), 有空关注minigui mstudio, 有windows和ubuntu版本. 
7), 周工作总结, 月工作总结.
8), option:
(1), omap3530, beagleboard系统硬件框图整理
(2), openocd调试omap3530机制分析. 
(3), arm会议总结. 
9), 上周其它计划

2, 执行
1), -10:17 杂, 邮件, 讨论. 
2), 10:18-11:38 VC0816量产, cache测试. 被3)打断. 见"10:19 2009-12-8"1,2
3), 25' 向zhicheng介绍TI OMAP3530资料.
4), 午饭.
5), 13:40- VC0816量产, cache测试. 见"10:19 2009-12-8"3,4
6), 14:07-15:30 打甲流疫苗.
7),  VC0816量产, cache测试.

10:19 2009-12-8
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续
1, tlb downlock and invalidate
1), The fully-associative part, also referred to as the lockdown part of the TLB, is used to store entries to be locked down. Entries held in the lockdown part of the TLB are preserved during an invalidate TLB operation. Entries can be removed from the lockdown TLB using an invalidate TLB single entry operation.
2), lockdown参见p61-p62, 代码见p62.
3), invalidate见p54.

2, disable cache再enable cache, cache数据不会丢, arm926ej-s trm p45:
If either the DCache or the ICache is disabled, then the contents of that cache are not accessed. If the cache is subsequently re-enabled, the contents are unchanged. To guarantee that memory coherency is maintained, the DCache must be cleaned of dirty data before it is disabled.

3, 访问memory会退出自刷新, 说明还是访问了memory. 
会不会是用rvdebug查看memory造成的影响呢? 

4, 改用完整的锁dcache程序. 

11:23 2009-12-8
软件技巧, 正则表达式, editplus, 搜索, perl
在用户工具中可以选择输出方式, 这样用perl搜索的结果也可以支持跳转很方便. 
实现见"11:37 2009-12-29"--"软件技巧, 正则表达式, editplus, 搜索, perl, logAssistant"

9:25 2009-12-9
时间管理
0, 9:16

1, 计划<DONEor转移>
-1), VC0718 mas review: pmu, clkrst, padc. \todo 看sunhongli邮件padc是否是我. 计划今晚完成. 
0), 希望今天或明天完成perl搜索工具.
1), VC0816量产, cache测试. 本周一定完成.
2), 问VC0882 IC dual timer 进位如何测试. 
3), 上周总结: 改为给aiguo发邮件, 问总体安排. 11月工作总结.
5), 希望还有时间看arm debug东西.<DONE>
6), 有空关注minigui mstudio, 有windows和ubuntu版本. 
7), option:
(1), omap3530, beagleboard系统硬件框图整理
(2), openocd调试omap3530机制分析. 
(3), arm会议总结. 
8), 上周其它计划

2, 执行
1), 9:30-10:52 arm debug coresight cortex-a8 被2)打断. 见"9:42 2009-11-26"2.
2), 30' VC0830量产, BGA181. 见"10:13 2009-12-9"
3), -11:20 封装资料: 各种封装介绍, 图鉴, 见"\\10.0.2.36\sqmshare\Share\Linux\doc\package_封装"
4), 20' arm debug 见"9:42 2009-11-26"3; arm cache test 见"10:35 2009-12-9".
5), 10' beizhan转发video基础知识邮件. 见"15:00 2009-12-9"
6), 15:12-17:59 VC0816量产, cache测试. 见"15:12 2009-12-9"

10:13 2009-12-9
VC0830, SV, 量产, BGA181, 机台
1, 今天还是环境问题. 机台程序要求必须是spi boot和24Mhz晶振(strap pin)跳线正确.
选择spi boot有两个原因: 1), 机台环境是spi boot; 2), 如果不用spi boot, 181走rom boot时会初始化pll并切频. 
24Mhz晶振也是机台测试要求. 对切频代码实际没有影响. 
注: vc0830_dft_usb for BGA181假设环境如下: spi boot, 24MHz xclk(strap pin)正确. 程序启动后会先切频到pll1_480, cpu 240, bus 120. 

2, 调试时判断环境是否正确:
1), 0x600000020=1, 0x600000018=0表示cpu,bus在xclk上.
2), "0x60050004=0x00000302"的3表示sdram0x40000000映射到0x0地址,

10:35 2009-12-9
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续
原文见Support-cores邮件"RE: questions on trace  (442930)"20091208_2308
Dhrystone的代码很小所以I-cache总是命中, 这样是在最坏情况下测试I-cache.
> Why do you think Dhrystone a fairly worst-case benchmark to trace? 
> Because it has small I/D size and always has cache-hit so the whole 
> CPU pipeline always works in full speed?
Yes, the I-cache will always hit since it entirely fits in the cache.

15:00 2009-12-9
VC1600, VC0882, VC0718, vdec, video基础知识
FengBeiZhan转发邮件"转发:  答复: vdec mas 0.30 review in ic/ae/icv/icp"20091209_1102
经过这几天的沟通，和大家分享以下关于video的几个基本观点：
１．frame和mb的观点．
答：到目前为止，所有的video标准都没有摆脱这两个观点frame和mb．　编码的时候基本都是I,P,B，而且只能一帧一帧的编码．与此同时，到目前为止所有的标准都是采用mb(macro block)的编码方法，也就是说每次编码１个宏块，而且只能一个一个的编码．每个宏块的大小为16x16，这个是业内的约定，至少到目前为止都是这样的．　依据２个观点，解释一下，为什么要求码流是１６pixel对齐的问题，比如，我们要编码31x32的图象，宽不是１６象素的整数倍，先编码１个mb后，还剩下１５个象素，那该怎么编码？没办法解决这个问题啊，要不就是丢弃１５个象素，要不就是补充１个象素再编码．
２．profile和level的观点．
答：每个标准都会对应profile和level．　那profile和level到底有什么不同呢．　profile是规定一个标准所用到的算法，它限制了算法集．通俗的说，相同的profile所用到的算法都是一样的, 这个算法集与level无关．　例如：h264　baseline profile只有I,P,cavlc．到了main profile就包含了B,cabac．这中算法上的差异，只能是有profile的改变而带来．　那level是干什么的呢？level是对video传输参数的一个限定，比如说Max macroblocks/s, Max sample/s, sample format等等一些限定速率，buffer大小的参数有关，该参数与video的算法无关．  所以可以得到这样一个结论，只要是profile相同，h264 level5的码流，９１９０也能解，但是９１９０肯定不能保证实时的．
３．profile和level是否有向下兼容的问题．
答：这个问题是没有统一规定的，一般标准的profile都不是向下兼容的，前天说了，Mpeg2是向下兼容的．level也没有这样的规定，不过根据我的经验，level有向下兼容的特性，level级别高的往往参数高．关于兼容性问题，在没有统一规定的情况下，还是参看标准为主吧．
另外，我觉得大家对于video还是比较有兴趣的，为什么不建议算法组的同事，对每个标准进行公司内部培训呢？

15:13 2009-12-9
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续
1, b和bl的区别:
bl会把返回地址(bl所在地址+4)写入lr(r14), b会把0写入. 这样返回时"mov pc,lr"就会出错. 
2, 切频有问题. 
3, 今天进展: \todo 上传. 
调整代码结构, 原来切频代码有问题. 

9:50 2009-12-10
时间管理
0), 9:44

1, 计划
-2), VC0718 mas review: pmu, clkrst, padc. 
-1), VC0882 test plan dmac, irq. dmac前面有测试考虑, 查, 问zhangqian确认是否llitable 16bytes对齐. 
0), 希望今天或明天完成perl搜索工具.
1), VC0816量产, cache测试. 本周一定完成. 见"10:15 2009-12-10"
2), 问VC0882 IC dual timer 进位如何测试. 
3), 上周总结: 改为给aiguo发邮件, 问总体安排. 11月工作总结.
4), 有空关注minigui mstudio, 有windows和ubuntu版本. <DONE>: 已申请.
5), option:
(1), omap3530, beagleboard系统硬件框图整理
(2), openocd调试omap3530机制分析. 
(3), arm会议总结. 
6), 上周其它计划

2, 执行
1), -10:10 杂, 邮件.
2), 10:10-11:28 VC0816量产, cache测试. 见"10:16 2009-12-10"

10:15 2009-12-10
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续, dcache lockdown初步ok
1, 把cpu,bus切到480_240_240. 
1), 在rvdebug中直接改cpu_bus_div=0(此时cpu_bus_ratio=1), jlink报错.
2), 直接改代码: 切频时切到480_240_240.
2, 重新检查代码. 实验锁ICache代码. 
1), 执行锁定的代码必须是不可cache的或者已经锁入的cache. 要锁入cache的代码或数据必须是cacheable区域的. <DONE: yes>
2), 确认是否开了cache和mmu. <DONE: 新加>
3), 原来锁dcache的代码adr没有变化, 把add语句放到if后面. 
IF "$op" = "Icache"
    MCR     p15, 0, adr, c7, c13, 1    ; load code cacheline
ENDIF
IF "$op" = "Dcache"
    LDR     tmp1, [adr], #1<<CLINE ; load data cacheline 
ENDIF
ADD     adr, adr, #1<<CLINE        ; cline addr =+ 1
4), 查锁cache代码是否正确. 
5), 确认"DCD ((0x001<<20) | (MMU_AP_FULL<<10) | ((MMU_CACHED | MMU_BUFFERED)<<2) | 0x2)"是否正确. 
3, 修改后实验.
1), 发现在写入memory(已锁入cache)时用rvdebug查看这段memory会出问题. 
2), 第一个地址(0x100000)比对就不正确. 预期是0x55, 实际是0. 但这时用rvdebug写入数据是稳定的. 前8个word都是如此(一个cache line). 
另外fc0-fde这8个word数据是0x55是正确的. 
3), 上面2-3)改错了, 原来写法没问题. 因为ldr中已经包含了自增32byte.

10:25 2009-12-10
VC1600, VC0882, VC0718, arm architecture, cortex-a8, power management, IEM, DVFS
DVFS: DVFS dynamic voltage and frequency scaling
动态电压与频率调节在降低功耗中的应用. 文中提到了ARM IEM.
http://blog.ednchina.com/firephoenix/36216/message.aspx

13:54 2009-12-10
VC1600, VC0882, VC0718, VC0830, 竞争对手调查, 瑞芯微
1, 瑞芯微RK27xx, 28xx是arm+dsp架构. 
见: "36: Linux\doc\杂\做好“一件事”：精心打造音视频领域的中国芯——访福州瑞芯微电子有限公司运营总监谢青山=++RK27xx28xx是arm+dsp架构.txt"
2, 从下文看和"36: Linux\doc\杂\ZSP800.pdf" RK2806的dsp擅长音频解码. 视频疑似也是这个dsp解的. 
自: http://bbs.imp3.net/viewthread.php?action=printable&tid=635441
作者: 海边吹风    时间: 2009.8.9 12:46     标题: 瑞芯微 rk2806 芯片 详细技术规格--datasheet (持续更新中)
本帖最后由 海边吹风 于 2009.8.10 08:02 编辑
双核架构, arm+dsp+硬件加速器
arm: arm926ejs ,最高频率600MHz,
       内部cache: ???? K Byte
       内部TCM:   ???? Byte
dsp: 国内芯原微电子的ZSP800, 最高频率450MHz
       采用几级cache, ZSP800有什么样的性能?
硬件加速器: 韩国CHIPS&MEDIA公司的h264 IP硬核（估计标称H264能力480P）,
                 有网友反映说rk2806 h264 480p效果不好,至少不如其它芯片好,
                 究其原因是因为rk2806做h264解码时没有做deblock.
                 据查, H.264中的deblocking filter是必需的.
memory为64M

附: ZSP800
For a 65nm generic process, the eight-stage ZSP800 delivers approximately 450MHz under worst case operating conditions with standard cell libraries.
8-stage pipeline
4+1 instructions per cycle
4-MAC,6-ALU
450MHz @ 65nm
zsp800 files link: http://www.verisilicon.com/vsi/vsiadmin/upfile/ZSP800.pdf

转贴:

貌似不同的DSP运算能力也不一样
DM6441的C64x+ 可以做到4104 MMACS@513MHz
ADI的BF533是1200 MMACS@600MHz

RK用的ZSP，RK27用的貌似是ZSP500,
RK28如果还是ZSP500，就难了。
不过可能用了ZSP800，貌似ZSP800是65nm的，
RK买来后为了配合这个，整个芯片就65nm了
芯原网站说ZSP800在65nm下能跑450MHz，
含4个MAC，那么就是1800MMACS @ 450MHz
这样看RK28应该是配了硬解H264的加速器了.

14:02 2009-12-10
VC1600, VC0882, memory, memory map, register map, umonitor definition
1, YangZuoXing邮件"vc0882: memory and register map"20091210_1341
sdram从830 0x4000000改为0x80000000. 原有0x4000000改为emi_cs0. 也许将来会接norflash. 启动映射增加了emi_cs0, 我理解将来这里可以加boot from norflash or ethernet.
1), memory map
sdram	2GB	0x8000,0000	0xffff,ffff
reserved	256MB	0x7000,0000	0x7fff,ffff
register	256MB	0x6000,0000	0x6fff,ffff
emi_cs1	256MB	0x5000,0000	0x5fff,ffff
emi_cs0	256MB	0x4000,0000	0x4fff,ffff
spi_boot	256MB	0x3000,0000	0x3fff,ffff
sram	32KB	0x2000,0000	0x2000,7fff
rom	32KB	0x1000,0000	0x1000,7fff
2), 启动映射: 
remap to sdram, emi_cs0, spi_boot, rom

2, YangZuoXing"vc0882; umonitor definition"20091210_1342

16:39 2009-12-10
资产, 示波器, 昨天从xuelian处领了示波器(C041898)

9:44 2009-12-11
体系结构, mips, M14K, M14Kc, 0.13工艺
MIPS科技推出新款处理器内核M14K和M14Kc
见"36: \Linux\doc\杂"


10:19 2009-12-11
时间管理
0, 9:22-

1, 计划
1), 816量产.
2), 昨日计划. 

2, 执行
1), -10:20 杂, 邮件, 怀念钱学森先生
2), 10:50-18:59 VC0816量产, cache测试. 见"10:51 2009-12-11"
(11:33-12:35 午饭)

10:51 2009-12-11
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续, dcache lockdown ok, icache lockdown试验中
今天要完成代码, 这样下周机台测试, 估计1-2天可以完成. 
1, 如何访问cache才能都预读进去? 
昨天发现如果不是cache line(32bytes)对齐, 而是64bytes对齐访问, 锁dcache操作会失败. 今天实验小于cache line是否可以. icache是否相同. \todo 看arm cache行为资料. 
2, 实验
1), 修改一次锁cache大小为4k, 然后锁12k dcache. 
(1), 12k dcache测试正确. 
3, 锁icache
1), liaozhicheng原有测试代码: 
c=(((((a<<4)*a)>>2)|b)/d)&a; if (c!=1) goto error_icache;count++;
去掉了其中除法, 改为:
	ICACHE_TEST
	mov r5, r0
	mov r0, r0, lsl #4
	mul r0, r0, r5
	mov r0, r0, lsr #2
	orr r0, r0, r1
	and r0, r0, r5
	cmp r0, #1
	bne icache_error
2), 锁12k icache, 在12k末尾(0x203ffc)加入跳转指令. 试验中没有跳转到指定位置. 每次都是运行过跳转位置后, 出data abort. 
3), 加入uart代码, 便于查看. 
(1), 代码中利用0x60000058写入0x44是否是0x44判断是816还是830. 
(2), 'adr r1, TTB_000_START"改为"adrl r1, TTB_000_START", 加入大量代码后"TTB_000_START"与adr语句偏移过大.
adr只能处理word对齐正负1020, word不对齐正负255范围内的偏移. adrl地址范围大. 
(3), 取ascii字符的编码: 
mov r0, #'\n'
(4), 没有堆栈情况下, 函数调用多了就难以处理. 
把0x20000efc-0x20000ffc做为堆栈, 函数进入退出采用:
    str lr, [sp], #-4
	ldr	pc, [sp, #4]!
(5), (18:58 2009-12-11)加入uart代码后, 死的时候lr是0x2000018. 
(6), 锁12k dcache成功. 
初步实验锁12k icache成功, 进一步测试中. 

9:14 2009-12-13
时间管理
0, 8:59-

1, 计划
1), 816量产, 希望实际实验坏片子. 
2), 其它, 见"9:50 2009-12-10"
3), 下周一计划: 882 test plan review, arm rvi(问国内代理的售前技术支持, 不行问aiguo, 我们应该问谁), 发信和aiguo讨论下一阶段安排. 周三718 mas review.

2, 执行
1), -9:22 杂, 邮件
2), 9:22-15:08 VC0816量产, cache测试. 见"9:23 2009-12-13"
(12:31-13:13 午饭)

9:23 2009-12-13
VC0816, SV, 量产, cache测试, 用VC0830的BGA282 rom boot测试, 续, icache lockdown, 续
1, 12k cache lockdown完成后, \todo
1), 加入16k cache lockdown. 
2), 加入异常向量表, 关中断.
3), 切频时没有考虑xclk表示12MHz的情况. 确认机台环境xclk频率. 

2, 暂时不用uart方式, 直接加入counter(r12), 程序出错后看count是否正常. 
1), "Stopped on Illegal Instruction"时r12=0x155.
目前测试程序是9个word=36bytes, 12k=12288是341个=0x155. 说明完整执行了12k锁入icache的指令, 问题是为什么没有跳转到预期的cache_successful语句呢? 
2), 仔细看原来代码, "000008B4 EA000068  B        cache_successful           <0xa5c>", 是用pc+/-偏移方式跳转的, 我需要绝对跳转. 
if ConditionPassed(cond) then
    if L == 1 then
        LR = address of the instruction after the branch instruction
        PC = PC + (SignExtend_30(signed_immed_24) << 2)
所以: pc = (0x8b4+0x8) + 0x68 << 2 = 0xa5c
希望绝对跳转可以用mov指令, 把上面语句改为:
mov pc, #reture_address
3), 修改后, icache测死进入0x200000就出错. 查了查没查到原因. 发现周五即没有备份代码也没有上传CVS. 
4), 后来不知改了什么, 会跳到其它地方. 把icache lockdown测试代码简化, 只剩一个r12++, 测试:
从r12=0xbff看, icache 12k lockdown测试通过. 现在需要修改代码使正确错误时能跳转到不同地址. 上传CVS(mmu_cache.S 1.6)
6), 12k icache lockdown 测试成功, 测试结束后会跳转到0x20000eec. 下一步是软件判断是否正确. 并打印和拉gpio.
上传cvs: mmu_cache.S ver1.6
代码, 映像已保存到: "D:\work\VC0816\阶段性代码和映像\20091213_12k_d_i_cache_lockdown_pass". 注意ads工程中选择代码偏移是0x400, 需要在Setting->ARM assembler->Architechture or Processor设为"ARM926EJ-S"
3, 12k cache测试成功后uart打印字符串. 
4, 加入4k cache测试. 
1), 切频到xclk, 清cache, 锁第三路cache. 
2), 测试最后一路cache锁定代码基本完成, 差解锁已锁定的数据. 

5, 最后别忘了完成收尾工作--1. 

9:38 2009-12-14
时间管理
0, 9:32-

1, 计划
1), 816量产
2), 其它, 见"9:50 2009-12-10"
3), 882 test plan review, arm rvi(问国内代理的售前技术支持, 不行问aiguo, 我们应该问谁), 发信和aiguo讨论下一阶段安排. 周三718 mas review.

2, 执行
1), -10:14 杂, 邮件, 和liaozhicheng, boxue讨论830量产.
2), 10:15-22:40 VC0816量产, cache测试. 见"10:13 2009-12-14"
(其中晚饭, 休息1.5小时)

10:13 2009-12-14
VC0816, SV, 量产, cache测试, VC0816 SV筛片子
1, 程序完成后, 
1), 总结: ads汇编: dcd定义word, dcb定义byte, 字符串. APCS(参数, 返回值, lr等规定). 现在函数内部没有保护现场. blx.
2), 完成"9:23 2009-12-13"1 \todo
3), 816程序中uart_init, PADC_FS_UART0[8:0]应该是0x0不是0xcc. 实验原来代码是否可用. 修改. 
2, 12k+4k共4路cache测试程序在BGA282上完成. 
next: 在816板子实验筛片子
上传CVS. 完整工程文件: "D:\work\VC0816\阶段性代码和映像\20091214_12k+4K_cache_test_pass"
3, 四个cache有问题的片子中. 
1), dcache中有两片可以筛出来. 一片有20%概率筛不出来(4of20)(降压到1.1v也不行). icache筛不出来. 
2), 加压力
(1), 修改icache测试程序为liaozhicheng原有c语言中移位加与或的方式. 担心原有的累加方式压力太小. 
(2), cpu切到336. 
3), 修改后发现切到336_336, 336_168好片也死在icache测试中. 先把频率降低, 看看是否icache测试程序有问题. 
(1), 恢复回CVS最新版本. 
(2), icache加压代码改动多, 暂时不改. 
(3), 切频到672_336_336, uart无打印, 会进入0x10异常.
改为切频到672_336_168, 切频后居然原来能筛出来的那片也不行了. 明天仔细查程序.
4), 今日总结:
用16k cache测试程序, 5片坏片中2片可以筛出. 
目前程序切频到480_240_240, icache测试程序仅仅是i++. 
正在修改切频到cpu频率为336, 并且icache程序改为与之前liaozhicheng, daichunquan使用的测试程序. 
4, (10:37 2009-12-15)分析与计划
1), 240_240能筛出部分片子可能是bus=240总线压力大. 
2), icache测试程序按路保存, 最后未对齐的部分用i++代替. 

11:04 2009-12-14
VC0830, SV, 量产, audio, 音频配置与预期结果不同
1, audio clock path
1), xclk --> audio程序根据strap pin配置pll2, 不同晶振配置的pll2频率相同-> audio input clock应该与xclk无关 -> audio clock
2), 流程
(1), 看寄存器: 确认audio clock在pll2上, 且pll2频率配置正确. 
STRAP_PIN: 0x60051700[5:3]=0b000 12MHz, 0b111 24MHz.
pll2_ckd: 0x60000008. pll2频率=xclk/高十六位 * 2 *  低十六位. 例如pll2_ckd=0x00140190, xclk=12Mhz, pll2=xclk/0x14*2*0x190=480Mhz. 
FUNC_MUX_CTRL: 0x60000080[5:4]=0x01, CKD_AUDC, CKD_AUDS input clock是pll2 div5. 
(2), 查程序.
(3), 筛片子. 

15:12 2009-12-14
同事信息, DaiChunQuan, 电话, 8944

10:23 2009-12-15
时间管理
0, 9:50

1, 计划
1), 见昨日计划.
2), 月末zhangwei会给我开户证明单. 等邮件.

2, 执行
1), 9:55-10:23 arm cortex-a8 debug: 与LiaoZhiCheng讨论RVI连接omap3530. 计划问arm公司的人RVI硬件是否支持, OMAP3530是否需要其它配置. 
2), -19:40 VC0816量产, cache测试. 见"10:34 2009-12-15"

10:34 2009-12-15
VC0816, SV, 量产, cache测试, VC0816 SV筛片子, 续
今天测试结果, 代码已上传CVS. 附件是完整工程文件, 映像, 打包/rvdebug脚本. 
从目前看, 用我目前程序在336_168降压时可以测出70%坏片, 好片正常, 具体如下.
分正常电压和降压(1.1v)测试, 336_168表示cpu=336MHz, bus=168MHz
a/b表示有a次fail
l: 表示需要降压才能测出的片子.
i: 表示liaozhicheng程序测试icache fail. 
d1, d2, d3: 表示liaozhicheng程序测试dcache fail. 

结果如下: 
            i   d1  d2  d3  l   g1  g2
336_168     p   p   p   p   p   NA  NA
336_168low  p   f   3/10 f  f   p   p
240_240     NA  f   4/10 f  p   NA  NA
240_240low  p   f   7/10 f  p   p   p
12MHz晶振. 跳线: usb boot. 

d2 fail的情况和复位时间有关系. 

hi, daichunquan
坏片摆放位置: 
l       i
d3 d2  d1
好片: 中间左下两片"g1 g2"

代码, 映像, 打包文件和工程: "D:\work\VC0816\阶段性代码和映像\20091215_icache_lockdown_test"

16:02 2009-12-15
arm公司, arm debug讲座
秦好亮 010-82603570x11, 13910035216, haoliang.qin@arm.com
技术支持热线: 021-62292003
技术支持邮箱
Support-cards@arm.com, Bobby.huang@arm.com

17:54 2009-12-16
VC0816, SV, 量产, cache测试, 讨论, 切频实验
1, 下午DongXin, DaiChunQuan, FengBeiZhan, Zhangjian讨论, 有些有意义的东西.
会议记录在小本p36-p37. \todo 整理.
下一步:
daichunquan实验把icache测试程序锁入icache后执行. 
zhangjian实验切频能否筛出昨天无法肯定筛出的片子. 
2, FengBeiZhan提供的切频频点: 
// __672M_336M_168M__
pll1Ckd[10]=0x140230;               
ckdCpuBusSdrc[10]=0x1100;
ckdPer[10]=0x66;       
refresh[10]=8*168;

// __480M_240M_60M__
pll1Ckd[20]=0x140190;
ckdCpuBusSdrc[20]=0x3300;
ckdPer[20]=0x44;
refresh[20]=8*60;

// __504M_252M_126M__
pll1Ckd[16]=0x1401a4;               
ckdCpuBusSdrc[16]=0x1100;
ckdPer[16]=0x44;       
refresh[16]=8*126;

// __672M_336M_168M__
pll1Ckd[10]=0x140230;               
ckdCpuBusSdrc[10]=0x1100;
ckdPer[10]=0x66;       
refresh[10]=8*168;

// __576M_144M_72M__
pll1Ckd[37]=0x1401e0;               
ckdCpuBusSdrc[37]=0x3311;
ckdPer[37]=0x55;       
refresh[37]=8*72;

// __528M_264M_132M__
pll1Ckd[21]=0x1401b8;               
ckdCpuBusSdrc[21]=0x1100;
ckdPer[21]=0x55;       
refresh[21]=8*132;

// __576M_288M_144M__
pll1Ckd[13]=0x1401e0;               
ckdCpuBusSdrc[13]=0x1100;
ckdPer[13]=0x55;       
refresh[13]=8*144;

// __672M_336M_168M__
pll1Ckd[10]=0x140230;               
ckdCpuBusSdrc[10]=0x1100;
ckdPer[10]=0x66;       
refresh[10]=8*168;

// __560M_280M_140M__
pll1Ckd[1]=0x180230;                  
ckdCpuBusSdrc[1]=0x1111;
ckdPer[1]=0x55;
refresh[1]=8*140;

// __672M_336M_168M__
pll1Ckd[10]=0x140230;               
ckdCpuBusSdrc[10]=0x1100;
ckdPer[10]=0x66;       
refresh[10]=8*168;

// __576M_288M_144M__
pll1Ckd[12]=0x1401e0;               
ckdCpuBusSdrc[12]=0x2200;
ckdPer[12]=0x55;       
refresh[12]=8*144;

3, 频点加入测试程序. cache测试通过后一直切频.
1), 切频用TSystemInfo结构体, TSystemInfo数组和切频顺序index数组及访问代码完成, 
2), 明天修改switch_cpubus_xclk2pll后测试. 

9:43 2009-12-17
时间管理
0, 9:32-20:56

1, 计划
1), VC0816量产, 切频. fengbeizhan整理量产代码映像邮件. 
2), VC0882 test plan review.
3), arm debug, 发邮件问RVI调试OMAP3530.
4), 816文档.
5), 其它计划, 见"9:38 2009-12-14". 希望把beagleboard整理完成. 
6), 本周一定把3)完成. beagleboard框图整理要完成. 

2, 执行
1), 杂, 邮件. 
2), 10:05-10:56 vimicro/socle会议. 见p38. \todo 整理
3), 10:57-11:35 VC0816量产, 切频. 见"11:34 2009-12-17"
4), 14:10-18:20 VC0816量产, 切频. 见"11:34 2009-12-17"

3, 明日计划:
1), VC0816量产, 切频; 明天用beizhan"mini_clkswitch"实验. 

11:34 2009-12-17
VC0816, SV, 量产, 切频, load/store
1, load,store
1), single
	str lr, [sp], #-4
	ldr	pc, [sp, #4]!
2), multi
	stmda sp!, {r0,r1,r2,lr}    ; decrease after
	ldmib sp!, {r0,r1,r2,pc}    ; increase before
3), (20:33 2010-4-21)multi, new
用multi的时候要注意和c语言及其它汇编增减/满空一致, 例如rvds4.0中一般用"3)"而不是上面的"2)", 从armv4开始引入了pop和push用于堆栈:
	push {r0,r1,r2,lr}
	pop  {r0,r1,r2,pc}
"(20:33 2010-4-21"end

2, 切频代码初步完成. 由于830没法稳定跑到336_168. 只能在816上面测试. 
3, (17:53 2009-12-17)现在似乎切频次数多了会死. 实验少切几次. 
目前代码加入了nop. 实验切100次停止, 但是程序跑飞, 感觉是超过了100次. 
4, 改为10轮切频, 切频前后5个nop. 一个好片5/10fail. 两个坏片(icache, d2)能过. 
5, (20:56 2009-12-17)明天用beizhan"mini_clkswitch"实验. 

13:28 2009-12-18
时间管理
2, 执行
1), 13:15- VC0816量产, 切频. 见"13:29 2009-12-18"

3, 计划
1), VC0816量产,切频, 继续修改uart_init

13:29 2009-12-18
VC0816, SV, 量产, 切频, 续
1, FengBeiZhan切频程序测试好片和坏片.
1), #1, #2, #3好片0x500次pass
#1-#3指左下的三个片子.
2), 坏片
icache: fail@0xe8,0x156,0xbc, fail@0x242(约)
d1: pass: 0x600
d2: pass: 0x600, x0x500
d3: fail@0x1e3,0x198,0xd1
l: pass 0x1000
2, 在我的程序中加入delay. 仍然无法区分好片坏片. 好片坏片都是绝大多数测试通过. 
现在才知道subs的s表示会映像cpsr. 
Delaycycle
10
	subs r0, r0, #1
	bne %BT10
	mov pc, lr
3, 每个频点都加入per_div和uart_baud. 为了816/830配置一致, 固定per一级div必须是2(因为816里面per一级定死是2). 
\todo 把816/830鉴别往前放一些. 从clock_init中择出来. 修改clock_init和uart_init代码. (18:45 2009-12-18)继续修改uart_init. 

9:52 2009-12-21
时间管理
0, 9:40-19:04

1, 计划
0), 882 jtag, trace fpga板 check, yangzuoxing今天邮件.<转移>
1), VC0816量产, 切频, uart打印.<转移>
2), VC0830量产, 保证最新代码181可以切频. 实验5月19日代码+最新clkrst代码切频. 原因: beizhan, zhicheng需要切频到pll2. <转移>
3), 请16日两小时事假. <转移>
4), 查报销是否到账. <DONE>

2, 执行
1), 10:24-19:04 VC0816量产, 切频, uart打印. 见"10:24 2009-12-21"
(11:35-14:00 午饭, 休息)

10:24 2009-12-21
VC0816, SV, 量产, 切频, 续, 每个频点都加打印
1, 关注"mul"指令:
编译器提示"UNPREDICTABLE results", 查ARM_ARM, 发现在armv4, v5, v6都应该是没问题的. armv3(arm7)有问题. 
Operand restriction Specifying the same register for <Rd> and <Rm> was previously described as producing UNPREDICTABLE results. There is no restriction in ARMv6, and it is believed all relevant ARMv4 and ARMv5 implementations do not require this restriction either, because high performance multipliers read all their operands prior to writing back any results.
2, 程序编译通过, 下午测试, 切频测试循环中的函数都需要注意. 
3, (15:51 2009-12-21)
1), 切频后有delay情况下. i和好片(左下最右)0x500次测试都pass.
2), 切频后无delay情况下(测试0x2000次切频三轮, 第一次是上电, 第二第三是reset)
左下三片好片pass. 其中最左一片跑到0x123c4未死. 
i: 0x17b, 0x493, 0x2e6, 0x236, 0x123
d1: pass
d2: pass
d3: 0x184, 0x559, 0x1038, 0xf5, 0x26b
l: pass. 最长0x18437.
注: 切频0x500次约需要5秒. 
4, 之前我的程序需要降压才能筛出icache/dcache问题(0.85概率). 降压到1.1v. 
(1), 
左下三片好片: 左1: pass. 
i: fail. 最长一次0x366. 
d1: fail@dcache
d2: 50%pass. fail都在dcache.  
d3: fail@dcache.
l: 起不来. 可能是1.1v电压有点低了. 
(2), 去掉部分打印. 
clock switch times: xxxxxxxx
改为
times: xxxxxxxx
测试时间变化不大. 一般1-2s会死. 20次中有一次5秒, 一次10秒. 90%可能在3秒内完成. 
(3), 切频10次打印一次, 好片坏片都会死, 次数差异不大.
5, (19:02 2009-12-21)明天实验
1), dcache连续测试, 看d2(50%pass)会不会死. i片(fail@icache)同理. 
2), 如果1)没有进展, 实验修改cpu,bus频率到720_360_120测试. 可能还要加上降压. 
3), (10:00 2009-12-22)和beizhan讨论, 感觉也是降压. 
6, 代码总结, 上传CVS(mmu_cache.S ver1.11):
1), 相比之前代码, 切频函数有调整, 现在更符合APCS.
2), 目前代码是通过459-460行判断切频10次打印一次信息. 好片坏片都会死.
目前结论仍然是每次切频需要打印才能保证好片不死. 
459  and r6, r5, #0xf
460  tst r6, #0xf

9:58 2009-12-22
时间管理
0, 9:51-21:40

1, 计划
1), 816量产.<DONE>
2), 882 jtag, trace fpga板 check, yangzuoxing12月21日邮件.<转移>
3), arm926总结.<转移>
4), 请16日上午2小时假. <转移>
5), VC0830量产, 保证最新代码181可以切频. 实验5月19日代码+最新clkrst代码切频. 原因: beizhan, zhicheng需要切频到pll2. <转移>

2, 执行
1), 20' 学习perl, 为重写logAssistant做准备. 
2), -11:35 816量产. 
3), 13:35-16:56 看"OMAP3530 L2是否支持parity, ECC", 见"13:48 2009-12-22"
4), -18:08 杂.
5), 1小时 830量产. 
6), 1小时 816量产.

3, 明日:
1), 整理816代码文档. 说明切频和其它可配置参数.
2), "10:17 2009-12-22"6
3), 整理之后计划, 给aiguo, beizhan发信. 

10:17 2009-12-22
VC0816, SV, 量产, 连续dcache测试.
1, 昨日总结见"10:24 2009-12-21"6
2, 昨天的打印频率用定义为SWITCH_PRINT_FREQ:
;print frequecy = SWITCH_PRINT_FREQ + 1. eg. SWITCH_PRINT_FREQ = 0xf means print counter per 16 times. =0 means print counter everytimes.
;cuurently only everytimes print can distinguish between good chip and bad chip.
3, dcach多测几次:
1), 测试100次, 一次测试7次未死. 一次测试6次死. 
4, (11:36 2009-12-22)\todo 修改代码. i/dcache测试10次. 切频测试0x200次. 实验结果. 完成后发信.
5, 时间关系先发了信, 稍后做4的测试(mmu_cache.S ver1.12):
降压到1.1v情况下: 
1), Dcache多次测试可以测试dcache坏片: 
最多重复测试前3路dcache十次. 可以测出所有dcache坏片. 
2), 通过切频可以测试icache坏片, 但时间稍长: 
20次实验中18次在3秒内出错. 1次在6秒, 1次在10秒出错.
6, (18:06 2009-12-22)
1), 实验dcache, icache需要的时间. 实验切频需要的时间. 
2), 和daichunquan讨论发现. rvd dsm显示的指令可能是当作数据读出来的(因为指令没法读出?). 实验到底能不能单步跟踪icache测试程序. \todo
7, (20:54 2009-12-22)
1), 测试10秒: 12k i/dcache测试次数: 0x154, 0x14b, 0x160, 0x150.
所以16k cache测试速度 (0x154+0x14b+0x160+0x150)/4/10/3*4=45.3次/秒. 
如果测试10次需要220毫秒. 
2), 发现切频测试如果没有加入cache lockdown测试, 好片也会死. 
i: 0x2be, 0x165, 0x82, 0x1d7, 0x11c, 0x1cc, 0x7d0, 0x6e0, 0x49, 0x226.
20s切频: 0x1bdc, 0x1ae4, 0x1b72. 350次/秒
最长需要5.7秒. 80%在1.57秒内. 加上dcache测试时间, 在1.8秒内. 
3), 结论:
确定了一下测试时间. 
cache测试10次约需要0.22秒, 切频连续测试: 350次/秒. icache片子测试10次, 8次在1.8内. 最长是5.7秒死. 
1000片中4个dcache坏片可以在0.22秒内筛出. icache坏片有80%可能在1.8秒内筛出. 这样看如果测试程序是2秒, 漏筛是万分之五. 
8, 上传CVS, mmu_cache.S ver1.13. 
代码和映像: "D:\work\VC0816\阶段性代码和映像\20091222_量产程序基本完成_1.8秒漏筛万分之五"

13:48 2009-12-22
VC1600, VC0882, VC0718, arm cortex-a8, 配置, SOC: OMAP3530 L2是否支持parity, ECC, debug: openocd(使用方法)
1, cortex-a8 TRM:
1), 8.7 Parity and error correction code
The L2 memory supports parity detection on the tag arrays. The data arrays can support parity or Error Correction Code (ECC). If ECC support is implemented, two extra cycles are added to the L2 pipeline to perform the checking and correction functionality. In addition, ECC introduces extra cycles to support read-modified-write conditions when a subset of the data covered by the ECC logic is updated. The ECC supports single-bit correction and double-bit detection. The L2 Cache Auxiliary Control Register bits [28] and [21] control the parity and ECC support.
If a cache access result is a parity error or double bit ECC error in the L2 Cache, then both the L1 data cache and the L2 cache are unpredictable. No recovery is possible. The abort handler must:
• disable the caches
• communicate the fail directly with the external system
• request a reboot.
2), 判断是否支持
To access the L2 Cache Auxiliary Control Register, read or write CP15 with:
MRC p15, 1, <Rd>, c9, c0, 2 ; Read L2 Cache Auxiliary Control Register
MCR p15, 1, <Rd>, c9, c0, 2 ; Write L2 Cache Auxiliary Control Register
If you have not configured the processor to include parity and ECC RAM, then software
cannot set bit [21] to 1, parity or ECC enable bit. The following code sequence shows
how to determine if the processor was configured to include parity and ECC RAM.
MRC p15, 1, <Rd>, c9, c0, 2 ; Read L2 Cache Auxiliary Control Register
ORR <Rd>, <Rd>, #0x0020_0000; Set parity/ECC enable
MCR p15, 1, <Rd>, c9, c0, 2 ; Write L2 Cache Auxiliary Control Register
MRC p15, 1, <Rd>, c9, c0, 2 ; Read L2 Cache Auxiliary Control Register
TST <Rd>, #0x0020_0000 ; Test for parity/ECC enable
BEQ no_parity_ram_setup
parity_ram_setup:
;<do parity RAM setup>
B done_parity_RAM_setup
no_parity_ram_setup:
;<do no parity/ECC RAM setup>
done_parity_RAM_setup:
;<continue>
2, 查TI OMAP3530是否支持. 
1), openocd能否读到.
(1), omap3530停在u-boot command line.
(2), 开启openocd
[dec@localhost tcl]$ pwd
/usr/src/embedded/jtag/openocd/tcl
[dec@localhost tcl]$ sudo ../src/openocd -s  /home/dec/bin/openOCD4Cortex-a8/share/openocd/scipts -f interface/100askjtag.cfg -f board/ti_beagleboard.cfg 
(Windos下: D:\Software\MinGW\home\bin\openOCD4Cortex-a8>bin\openocd.exe -s share\openocd\scripts -f  interface/100askjtag.cfg -f board/ti_beagleboard.cfg
或者完整路径:
D:\>D:\Software\MinGW\home\bin\openOCD4Cortex-a8\bin\openocd.exe -s D:\Software\MinGW\home\bin\openOCD4Cortex-a8\share\openocd\scripts -f  interface/100askjtag.cfg -f board/ti_beagleboard.cfg)
如果提示打不开, 在Linux下可能是需要root权限(sudo)访问设备文件. Windows可能是已经有openocd运行杀死即可. Window错误提示可能如下: 
trst_only separate trst_push_pull
Warn : Unable to open FTDI Device tried: 'USB<=>JTAG&RS232' and 'USB<=>JTAG&RS232 A'
Error: unable to open ftdi device: 2
Error: ListDevices: 2
Error: 0: "USB<=>JTAG&RS232 B"
Error: 1: "x"
Runtime error, file "command.c", line 590:
(3), telnet localhost 4444
omap3_dbginit omap3530.cpu
#相当于下面两句: 
#cortex_a8 dbginit
#mww 0x5401d030 0x00002000
(4), 语法
mcr <cpnum> <op1> <op2> <CRn> <CRm> <value>
      write coprocessor
mrc <cpnum> <op1> <op2> <CRn> <CRm>
      read coprocessor
(5), 先读main id试试
#MRC p15, 0, <Rd>, c0, c0, 0
mrc 15 0 0 0 0
应该是0x413fc082, 读出是0x411FC082, 说明我们这个omap3530是r1p2版本的. 
(6), 
#MRC p15, 1, <Rd>, c9, c0, 2 ; Read L2 Cache Auxiliary Control Register
#ORR <Rd>, <Rd>, #0x0020_0000; Set parity/ECC enable
#MCR p15, 1, <Rd>, c9, c0, 2 ; Write L2 Cache Auxiliary Control Register
#MRC p15, 1, <Rd>, c9, c0, 2 ; Read L2 Cache Auxiliary Control Register

mcr 15 1 9 0 2 2097218
mrc 15 1 9 0 2
结果是66, 说明omap3530不支持. 

2), 编程实现. 
程序会死在写L2 auxiliary处. 
(16:55 2009-12-22)已经发了信. 晚上继续实验. 

16:33 2009-12-22
VC1600, VC0882, VC0718, 北京瑞泰, 虚拟机, 软件技巧, sun virtualbox, 共享文件夹
mount -t vboxsf sharename mountpoint

19:12 2009-12-22
VC1600, VC0882, VC0718, arm, dsp, cache, dsp L2 cache
1, ZhangXueQian邮件"ARM L2 cache"20091222_1812
今天去看了ARM L2 cache的源代码。有如下的印象：
1) ARM 的源代码相比synopsys的代码，比较接近我们公司的coding style。可读性相对好
2) ARM代码结构划分很详细，例如220的源代码包含38个文件。有的文件代码量非常少。
3) 注释不多，但因为单位文件代码量较少，对可读性影响不大。
4) 线宽之类的端口描述没有采用宏定义，如果我们需要修改线宽，需要特别注意。
ARM提供了两款L2 cache，310与220，如下是两者的一些对比。
item                310                     220
容量                128kB~8MB               16kB~2MB
路                  8, 16                   8
与CPU clock的关系   1:1,N:1,(N+1/2):1       1:1
与system clock的关系 1:1, N:1, (N+1/2):1    N:1, asynchronous
其他                Parity, ECC             none
2, YuLiJie邮件"答复: ARM L2 cache"20091223_0939
感谢xuejian提供的对比。
补充一点，PL310支持AXI总线，PL210支持AHB总线。由于SQUID采用了7个ID，所以，建议在PL310的基础上修改，可以充分利用AXI总线的并发能力。
另外，由于PL310在LINEFILL的时候会发出critical word first的WRAP请求，所以需要修改REQUEST生成的逻辑，即将生成64-bit WRAP4的逻辑改成生成128-bit的WRAP2的逻辑。
这点建议xuejian在评估的时候特别注意。其它的请求，如read/write from line buffer和eviction之类的，都是INCR4请求，应该还比较容易转换。
附上PL310的TRM供参考。

10:03 2009-12-23
时间管理
0, 9:40

1, 计划
0), 816实验i++, j++. 
1), 整理816代码文档. 说明切频和其它可配置参数.
2), "10:17 2009-12-22"6: 锁入cache的程序和数据到底能不能用rvdebug调试.
3), 整理之后计划, 给aiguo, beizhan发信. 
4), 882 jtag, trace fpga板 check, yangzuoxing12月21日邮件.
5), 请16日上午2小时假. 如果10月25日请假, 一同请教.
6), VC0830量产, 
(1), dashan在扫描新参数. 临时把参数加入5月19日代码. 将来希望(2)解决后加入181最新参数. 
(2), 保证最新代码181可以切频. 实验5月19日代码+最新clkrst代码切频. 原因: beizhan, zhicheng需要切频到pll2. 
难道是pll_sdrc_adj赋值有变化造成的?!
(3), 181也要提供memory参数打包工具. 

2, 执行
1), 上午, 816量产, 830量产. 见"11:17 2009-12-23"
2), 下午, 晚上, 830量产. 见"11:17 2009-12-23"
3), 帮fanxiaofan debug sd问题, 见"18:56 2009-12-23"
4), perl学习, 30'. 见"20:52 2009-12-23"

11:17 2009-12-23
VC0830, SV, 量产, BGA181, 更换memory参数
1, 昨天LiaoZhiCheng实验发现60-120MHz memory参数不好. dashan晚上扫描了memory参数. 
2, 更换新的memory参数.
1), 分析变化
(1), sdrc_mode有变化, 但是5月19日代码不支持此流程. 只能是先把sdrc_mode和rd_path_control都加1. 
(2), refresh比原来大一倍. dashan说是64ms刷4096. 
所以CALCULATE_SDRC_REFRESH宏需要关闭. 
(3), 120MHz参数有变化, 实验通过后需要修改baseband代码. 
3, 测试
1), 为了加入5月19日代码方便, 直接修改了 get_sdramInfo()(sdram_config.c). 
并根据新参数改写了inc脚本.
初步测试切频通过, 测试vdec. 
2), 编译vdec, 96_96播a.rm屏幕无显示. 264_88做dma发现很慢. 查看cache发现cache是关的. 执行"cache on"会死(rvdebug找不到arm).
3), 编译me实验. 
4, 频点.
rvdebug: vdec播放200 frame: 216_72 pass, 288_96 pass, 240_120 pass, 264_132 pass, 144(无参数).
切频: 96_96, 192_96, 288_96(fail).
5, 实验旧baseband 旧me. 
电压1.10v, 1.15v, 830跑起来之后.
6, 新bandband, 新me
1), vdec 1000 frame 264_96_96 fail. 252_126_126 pass.
528_132_132_105. 252_84_84. 256_85_85
2), fat copy(vdec gate): 264_132 pass.
3), 大量测试
264_132_0(模拟camera场景), 252_126_126(模拟video conference场景), 132_132_105(模拟vdec decoder场景).
pass: 2
fail: A(252_126_126), B(252_126_126), C(252_126_126)
发现B开cache后电压从1.14降到1.107. 实验244_122 rvplay data abort, 264_132切频后很快死. 240_120 rvplay pass. 说.明这片对于132Mhz参数不适合. 
升压到1.15pass(252_126_126 pass). 测试文件读写: gate vdec前1.105, gate vdec后1.120, pass. 
C片132_132_105 fail: data abort. 252_84_84 只能227-597 frame.
总结: 264_132_0: 4/5. 252_126_126: 2/5.
4), 升压到1.15:
C片: 252_126_126 vdec HW_timeout. 252_126_100 pass
7, 代码修改说明
1), 新memory参数在get_sdramInfo()(clkrst\app\sdram_config.c), 包括72, 96, 120, 132四个频点. 使用中对应[60,72], (72,96], (96, 120], (120, 144]区间. 
2), 同样baseband代码也做了修改, 注释了原有0611参数. 
3), rvdebug调试时使用的初始化脚本位于"VC0830_090519/sv_init_script/VC0830init_181_new4_20090519.inc".
8, 邮件:
今天dashan提供的memory参数已经加入到5月19日代码中, 映像脚本和完整的代码已经上传到: 
\\10.0.2.36\sqmshare\Projects\Mobile BU\VC0830\SV20091223_用于0519代码的BGA181新参数.rar
具体说明压缩包的readme.txt.
目前最新代码中BGA181切频有问题. 我会尽快解决

14:54 2009-12-23
http://code.google.com/p/rowboat/wiki/DSP 大致说明了如何使用TI Linux DVSDK. 

18:56 2009-12-23
VC0830, VC0816, SV, storage, sd, 供电问题, ACMD41_SD_SEND_OP_COND, 总结
参见"11:35 2009-6-24"
FanXiaoFan的JMP31,32,35, VDD_IO_HOST, VDD_NS没有接造成acmd41 timeout. 只插JMP35, VDD_IO_HOST, VDD_NS也不行. 
原来也遇到过这个问题, 如果供电电压过低, 前面初始化命令没问题, 到acmd41就会超时. 因为当初beizhan设置的timeout较长, 所以看到sd初始化中越到长timeout就可以猜测是acmd41无响应造成的. 估计将来sdio卡也会遇到类似问题, 那时可能是CMD5_SET_OP_COND timeout. 

11:03 2009-12-24
VC1600, VC0882, VC0718, arm SOC, board, cortex-a8, WinCE6.0, jtag
zhangjian至HouPeiXin邮件"TI OMAP3530 WINCE6.0 bsp"
hi, peixin
TI OMAP3530 bsp已经放在"\\10.0.2.208\share\zhangjian\TI_OMAP3530_WINCE600_BSP", 解包后bsp位于"S1SDKOMAP_DVSDK_OMAPWINCE_EA_06_12_03\DVSDK\6.12.03\BSP".

我们了解到OMAP3530板子有国外beagleboard(软件, sch, gerber都开源). 国内北京瑞泰, 天漠(英倍特). 三家基本配置都是1000元. 我们买的瑞泰. 如果你们买天漠的, 大家可以互换一下资料. 

除了arm RVI, 能调试a8的jtag还有: openocd jtag, 华恒hammer_a8, BDI3000, Track-32, code viser. 
其中openocd jtag是开源方案: gdb+openocd调试代理+ftdi2232(usb2jtag转换板, 国内卖100多RMB), 但目前只支持mmu,cache关闭下的调试. 
华恒hammer-a8大约3000RMB, 调试软件是"ADS 1.2, RVDS2.2", 感觉不支持v7和neon指令. 
其余jtag大约2-3万.

14:41 2009-12-24
12月加班日期(12月25日前): 2,3,4,7,9,10,13,14,17,22,23,24.

16:51 2009-12-24
VC0830, SV, rvdebug
帮fanxiaofan一起查问题: 
板子没有正常复位造成rvdebug找不到: 一定要看到是ap mode打印才可以使用rvdebug.
memory是16Mbyte, 跑32Mbyte映像有风险. 

17:07 2009-12-24
找师弟帮zhicheng查论文检索:  MCMC-based iterative method for mixed spectrum estimation

17:23 2009-12-24
VC0816, SV, 量产, arm版本, 读816 处理器版本, cp15 c0, r0p5
main id是: 0x41069265.
用jlink读的. 一定要先halt在读. 否则数据不正确.
arm命令: mrc p15, 0, r0, c0, c0, 0
jlink命令: rce 0 0 0 0 (不写p15, r0)

17:28 2009-12-24
VC0830, SV, 量产, BGA181(VC0898), 场景, zte
注: 如下邮件都是FengBeiZhan邮件"答复: 598芯片1.1v工作情况"20091224_1545的摘录.
另注: VC030 BGA181内部的sdram是32bit 8Mbyte 133MHz. 所以bus跑144MHz完全不保险. 不应该有人提这个case, 说明流程上有问题. 
1, 应用需求
1), HeJu邮件"答复: 598芯片1.1v工作情况"20091221_2204
频率lifei已经发出了，如下，请注意量产的频率有好几个场景。
             Cpu           bus            vdec
VP：         132           132            80
Camera：     288           96             96
VidRec：     240           120            80（关闭）
MediaPlay：  96            96             80
2), ZhouZhiTao邮件"答复: 598芯片1.1v工作情况"20091221_2216
hi,beizhan：
刚跟Dr yang讨论了一下，
目前比较crtical的是：
             Cpu           bus            vdec
CMMB ：      132           132            132
Camera：     288            96             96
录像/拍照：  288           144              0
想造一种case尽量将三种应用的坏片都筛出来， 目前比较倾向于288/96/96的量产case。
我们可以采取一定基数的片子，譬如100片，CMMB fail的定位坏片一类， camera fail的定位坏片二类， 录像/拍照 fail的定位坏片三类。
看看是否坏片一类和坏片三类 都能用camera的程序筛出来，如果筛不出来，概率有多大。
3), YangZuoXing邮件20091223_2128
beizhan
能测试一下1.15V的情况么？在这种情况下，只能给DCDC留2.5%， 温度留2.5%了。

2, beizhan 898测试情况.
运行时core 1.15v测试情况如下：
table 3 
No cpu：bus：vdec 运行时core电压1.15v
1 264 : 132 : 132 1）测试总量30片；
                  2）vdec rv解码播放正常 27 片
                  3）vdec rv解码播放失败 3 片
2 264 ：132 ：105 1）测试总量30片；
                  2）vdec rv解码播放正常 30 片
因为我们的内存要求是bus 133m，所以最好不要用bus 144M的case;
由于我们在1.1v下情况不理想，把core 提高到了 1.15v做的这次试验，这样就存在风险，所以不建议cpu 用 288； 

17:44 2009-12-24
VC0816, SV, 量产, cache测试, \todo
daichunquan邮件"答复: 816量产进展（会议纪要）"20091223_1740, 20091224_1518
1, 和zhangjian讨论发现他的测试程序都是放在ncnb的memory中，就是程序是不可cache的，包括测dcache的程序，如果程序不可cache，读取就会减慢，这样可能也会影响到data的访问，使data的读取也变慢。我觉得这可能是他的测试程序需要降压的原因。同样的现象我也遇到了，我的测试dcache的程序在不降压的情况下可以测出3片有问题，但是如果把程序设置成ncnb，那么就只能测出1片了。所以我希望程序在测试dcache的时候不要设置成ncnb，在完成dcache的测试后，要测icache时再改成ncnb。
DaiChunQuan邮件"答复: 816量产进展（会议纪要）"
2, DDI0198C_926_trm.pdf文档的附录B有一些mmu操作的指令，其中有tlb lock区域读写的指令，你可以试一下。

17:58 2009-12-24
项目, VC1600, VC0882, VC0718, VC0830, VC0816, 优先级
1, zhangjian至aiguo邮件
项目	优先级	具体内容	情况和思路				时间	备注			
VC0816		量产	比较大小程序差异, daichunquan希望能不降压把片子筛出来. 我会实验把dcache测试程序锁入icache. 				短期不会结束	个人感觉现在样本太少总是这样测意义不大. 			
VC0830		切频	最新代码BGA181切频有问题. 今天和zhicheng沟通发现, 可能是参数问题.				预计一天解决问题. 	所谓有问题是264_132会切死, 但是切到240_120没事. dashan新扫的参数切到264_132也不稳定.			
		量产	VC0830_dft_usb代码是我负责维护, 估计没什么事. 								
		sd代码整理	sd卡代码整理. 这个事情已经做了一半, 放下不做将来又得重来. 希望是有时间尽量完成. 				预计10-15天工作量. 				
	高	VC0830 Linux移植总结. 	对VC0882 Linux环境很重要	 Linux移植准备: VC0830 Linux移植总结. 							
VC0882	高	arm debug	RVI调试 bootloader和Linux kernel. openocd调试u-boot. 这个现在感觉是飞线造成的问题, 等转接板				有转接板后可能会很快				
		arm环境	通过OMAP3530 两级bootloader研究cortex-a8启动流程. 这个可以结合qemu omap3530模拟器对比分析. 在模拟器上通过arm gdb调试效率高很多. 								
		OMAP3530学习	前段时间学习总结: omap3530软件资源, 调试架构和板子硬件总结;					将来有时间希望分析omap3530在2d/3d, power manager, video codec, video dsp for VC0718等方面的内容.			
		mas review	只有clkrst未开始review								
		Linux环境					预计1月开始? 				
VC0718			最近是mas review meeting. 时间关系没怎么参加. 					

2, aiguo邮件"答复: zhangjian工作内容"20091224_1947
总结的非常好，但目前比较重要的工作：
1) 816，830的量产事情，以后慢慢我们辅助，但工作被打断是不可避免的；
2) A8相关的东西必须先研究清楚，如A8的基本知识，工具链，仿真器（RV ICE买了5套，肯定不够用），其他软件环境；
3) Sd card的driver code，先598上调通，这个不仅对598很重要，同时也对882的最小环境非常重要；
4) Linux的总结和882 linux porting；

11:37 2009-12-28
VC0830, SV, 量产, BGA181
1, 现象(xclk=24MHz): 量产程序(vc0830_dft_usb)切频后死. 大程序运行没问题. 
问题复现和分析: 
1), 量产程序切频后发现memory向后串数. 以及0x40000000数据错误.
怀疑是memory参数有问题. 
2), 大程序dashan是先静态切频再跑的. 
2, 24MHz的sdrc_cfg是0x28a21070, dashan 132MHz参数是0x28a21170. 只是比前者多了auto-entry self-refresh. 
3, sdrc_rd_path_control从0x32改为0x30可以: 
const static TMemoryParm mem_SdramVimicroBGA181_132 = {
	.name = "121_134",
	.range = {
		.min = 121 * MHZ,
		.max = 134 * MHZ,
	},
	.clkSrc = {PLL1_ID, PLL2_ID, INVALID_CLKSOURCE_ID, INVALID_CLKSOURCE_ID},
	.sdrc_adj0		= 0x70,
	.sdrc_adj1		= 0x8f,
	.sdrc_adj2		= 0x18,
	.sdrc_adj3		= 0x48,
	.sdrc_refresh	= 0x514,
	.phy_mux_sel	= 0x00021113,
	.sdrc_mode		= 0x00000033,
	.sdrc_rd_path_control = 0x32,
	.sdrc_timing	= 0x4b6faf75,
	.clkrst_pll_sdrc_adj = 0xe98d,
};
修改per和uart, 测试机台程序. 
为了简化删除了"Uart_base_set_baudrate_with_divider"和clk_module_clock_init_base()中无用代码. 
4, memory参数修改后. 机台测试程序通过. CVS log: 
baseband:
为了配合量产(vdec crc, clkswitch_528_264_132)加入机台jtag测试宏。
打开_181_jitai_jtag_debug表示baseband不会下载bin到BGA181 sdram. 只是放开BGA181. 放开会可以由jtag接管BGA181
vc0830_dft_usb:
添加BGA181量产测试(vdec crc, clkswitch_528_264_132_105).
528_264_132频点由OP_528_264_132(incldue\system.h)定义。

代码映像: D:\work\VC0830\SV\阶段映像和log\20091228_mp_vdec_clkswitch528_264_132_105
同时复制bin到"\\10.0.2.36\sqmshare\share\fengbeizhan\181量产\091228"

14:43 2009-12-28
VC0830, SV, 环境, reset, SW14
SW14-1: 一端连接RC复位电路, 一端连接复位按键S32.
SW14-2: pmu芯片reset. 
SW14-3: baseband控制830复位. 

17:13 2009-12-28
VC1600, VC0882, 绩效
aiguo邮件"882的工作时间"20091228_1634
Team 员工姓名 分配 考勤 882时长
ICP 艾国 50% 236.63 118.315 
ICP 吕博学 10% 210.58 21.058 
ICP 凌明 10% 223.86 22.386 
ICP 张健 70% 230.45 161.315 
ICP 张浦 10% 235.91 23.591 
ICP 蔡进 20% 240.52 48.104 
ICP 冯备战 85% 242.2 205.87
ICP 李栋梁 10% 246.21 24.621 
ICP 舒予 10% 252.18 25.218 
ICP 孙光跃 100% 252.34 252.34
ICP 廖志城 75% 257.43 193.0725 
ICP 周大山 100% 273.29 273.29 

17:42 2009-12-28
mcr p15, 0, rd, c15, c1, 0 

11:37 2009-12-29
软件技巧, 正则表达式, editplus, 搜索, perl, logAssistant; perl技巧, 文档: 查看库和内部函数帮助, 字符集转换和perl内部编码
1, find_keyword完成但是editplus中没有输出. 
2, 原因是参数设置有问题
command: D:\softare\Perl\bin\perl.exe
arguments: h:\test\log\logAssistant\find_keyword.pl $(FilePath) $(CurSel)
其中"$(FilePath)"是包括文件完整路径的文件名. "$(CurSel)"是当前选择的内容.

3, utf-8乱码问题, 用iconv转换.
1), 仍然是从"14:38 2009-11-11"3-1)提到的mingW网站下载的iconv, 运行时提示没找到"libintl-8.dll", 根据"http://gqview-win.sourceforge.net/"提示, libintl-8.dll是gettext的一部分:
Users report the new version cannot start with error message "libintl-8.dll was not found". The issue is caused by my new setup compiling environment. "libintl" is a library in gettext.
2), 
把
print "line $i: find $regexp in $_";
改为
print "line $i: find $regexp in";
system "echo $_ | iconv -f utf\-8 -t gb18030 -c";
其中iconv的-c是忽略非法字符

4, 修改输出方式:
参考现在editplus的方式: 
"D:\Personnal\log\log_test_pattern.txt"(27,80):perl h:\test\log\logAssistant\find_keyword.pl h:\test\log\log_test_pattern.txt VC0830
只是没有colume, 正在表达式: 
^"(.+)"\((.+)\)

5, perl与字符集
1), http://fuzhong1983.blog.163.com/blog/static/16847052009085482194/
2), 转换输入参数为utf8: 
#convert keyword format from gb2312 to utf8. do nothing while it is already utf8.
eval {my $str = $regexp; Encode::decode("gb2312", $str, 1)};
my $cur_env_locale = "utf8";
if ( !$@ ){
	Encode::from_to($regexp, "gb2312", "utf8");
	$cur_env_locale = "gb2312";
}
print "current environment locale is $cur_env_locale.\n";

Encode::from_to($regexp, "gb2312", "utf8");
开始写的是:
$regexp = Encode::decode("gb2312", $regexp);
Encode::_utf8_off($regexp);
注意decode和from_to的区别. decode是把某种编码(这里是gb2312)转为perl内部编码(取决于perl代码的编码?). decode会打开UTF8 flag. from_to仅仅转换字符集. UTF8 flag不会打开. 相当于"$data = encode("utf8", decode("iso-8859-1", $data));"
(17:54 2010-2-22)原文(perldoc Encode):
 CAVEAT: The following operations look the same but are not quite so;
   from_to($data, "iso-8859-1", "utf8"); #1
   $data = decode("iso-8859-1", $data);  #2
Both #1 and #2 make $data consist of a completely valid UTF-8 string
but only #2 turns UTF8 flag on.  #1 is equivalent to
   $data = encode("utf8", decode("iso-8859-1", $data));
See "The UTF8 flag" below.

"17:54 2010-2-22"end

6, perl技巧
"perldoc Encode": 查看Encode模块帮助. 
"perldoc -f print": 查看内部函数print的帮助.

7, (18:10 2009-12-29)代码基本完成. 下一步用参数加入"不区分大小写"和查找段内文字. 

8, (20:37 2009-12-29)不区分大小写完成. 计划明天晚上加入"查找段内文字"----可能要搜索两次, 第一次找到keyword section, 第二次在section中查找content_keyword(改名为section_keyword似乎更好)

9, perl处理参数方法:
A.pl -f "test.txt" -k 123 -i
1), shift
my $value1 = shift @ARGV;
my $value2 = shift @ARGV;
my $value3 = shift @ARGV;
my $value4 = shift @ARGV;
my $value5= shift @ARGV;
value1-5别是-f, "test.txt", ...
2), getopts
use strict;
use Getopt::Std;	#for getopts
use vars qw($opt_f $opt_k $opt_i);

#get and process arguments.
print "argument is \"@ARGV\".\n";
getopts('f:k:ic:');

#filename
#print "$opt_f\n";
my $filename = $opt_f;  #$filename=test.txt

#keyword
#print "$opt_k\n";
my $regexp=$opt_k;      #$regexp=123

#ingore case or not
if ($opt_i) {           #如果有"i"选项, $opt_i为真
	print "ingore case.\n";
} else {
	print "not ingore case.\n";
}

18:01 2009-12-29
VC0816, SV, 量产, \todo
1, tlb读写.<取消, 原因见"7:56 2009-12-30"1
2, sdrc发d powerdown.<完成>, 见"7:56 2009-12-30"
3, 加入24MHz参数.<转移>见"7:56 2009-12-30"6

7:55 2009-12-30
时间管理
0, 7:45

1, 计划
1), VC0816量产.
2), 晚上: perl搜索keyword section中subkeyword.<部分完成, 转移>

2, 执行
1), 20' perl语言学习;
2), 7:56-17:53 VC0816量产, 修改tlb, 支持24MHz. 见"7:56 2009-12-30"
(11:33-14:27, 午饭, 午休)
3), 17:53- 晚饭
4), perl学习, logAssistant, 完成多关键字搜索. 见"19:35 2009-12-30"

3, 明日计划:
1), VC0816. 现有代码测试通过. 加入tag 0x555000000, 0xaaa00000测试. 
2), perl学习, logAssistant: 
(1), 加入keyword section内subkeyword搜索. 
(2), 测试Linux下情况, 需要兼容Linux, Windows, utf8, ansi环境. 

7:56 2009-12-30
VC0816, SV, 量产, 修改tlb, dcache测试时使用cb区域
1, 比较dachunquan大程序, 为了加大dcache测试压力, dcache测试程序空间是cacheable的. 
2, 开始分析时, 在机台小程序中, dcache测试程序在sram中, 没法直接映射为cb是因为锁cache程序必须是non-cacheable的. 后来发现跳转到sram时其实已经完成了锁cache操作. 所以sram区域可以映射为cb的. 
这样就不需要使用cp15, c15 test寄存器修改tlb entry了. 
3, 实验
1), sram开cache后, 除了l(需要降压那个片子), 其余都可以测出. 
l片有三种情况(按次数由多到少排列): 
(1), go后无打印.
(2), dcache测试通过. 
(3), 死在dcache测试. 看到的一次是死在第10次.
2), 查"go后无打印"原因:
(1), 电压(c42-c46). go后无打印时1.170v. 切频时1.197. cache测试时出错时1.149v.
看来cache出错和电压也有关系. 
\todo 回忆一下原来调电压是在什么时候调的. 
3), cache测试次数改为100次. 1000次. 
0x3e8, pass(切频0x2300), pass(切频0x5000), 0x3e8, pass(切频0x3900), pass(切频0x6000), pass(切频0x6600), pass(切频0x5800), pass(切频0xd900). 最近这10次测试又没有出现go后无打印的情况. 
发现目前"l"片所有死的位置都是第4路开始的时候死的, 不论单次测试次数是10, 100, 1000都是. 
4, 如果跳转到sram后发了power down entry(cmd: 0x60011018=0x1001), 拔掉sdram cache测试正常. 
不发powerdown也可以. 原来不行可能是cache lockdown程序有问题. 
5, 发信
回复FengBeiZhan邮件"答复: 816量产进展（会议纪要）"20091225_1127. 每条内容后面的内容是我新增的. 
今天早上我和aiguo、zhicheng、dongxin、xiaodai、开会讨论了一下816量产的事情，还需要如下项需要完成；
1）	验证zhangjian的小程序，是否真正的把sdram剥离开了，因为我们在试验的中间，以拔sdram就会导致死机，而最终的程序在高频运行时，是没有sdram的； 
重做实验. 无论是否发power down, 拔掉sdram都不影响cache测试. 之前可能是程序问题.
2）	目前测试dcache 的小程序运行在sram里是ncnb的， 需要测试d cache 的程序是cb的，这个难点是对tlb的锁定，将尝试xiaodai发的修改指令是否会成功；
之前考虑复杂了. 由于锁cache在sdram完成. 所以直接把sram设为cb就可以达到上面目的. 测试结果:
5片坏片中除了daichunquan需要降压的片子, 其余都在dcache测试中死. 
降压片子多数情况不会死. 10次中有1-2次会在前3路cache测试结束后, dcache第4路测试开始时死. 无论cache测试10次, 100次, 1000次都是. 
3）	对tag的测试，尝试用0x55555000 以及 0xaaaaa000等来测试tag；
按现在这种情况, 只有1/1000的可能是tag的问题. 单独的tag测试只是相对提高了tag测试覆盖率(不单独加tag测试时可以测试2/128的tag). 对量产有没有帮助要看tag坏片占总坏片比例. 
我个人认为目前最着急的扩大样本. 如果新的坏片能由daichunquan大程序筛出来, 再加到汇编小程序中比较合适. 
上传CVS. mmu_cache.S ver1.16

6, 下一步:
1), 支持xclk=24MHz. 2), 最后一路可以用宏控制编译. 

7, 支持24MHz xclk
1), (11:33 2009-12-30)程序有问题. 下午继续. 
2), 完成. 

8, 整理代码.
1), 原来dcache访问是word写的0x55, 0xaa. 今天讨论tag测试时发现其实是想每个byte写0x55, 0xaa.
2), 删除无用注释. 合并同类功能. 
(1), 加入部分部分offset和mask的宏定义.
(2), 从sdram到sram复制代码改为用mem_cpy实现. 
(3), 优化"clkrst_get_cpu_bus_ratio()"中计算cpu_bus_ratio的算法: 用循环实现. 
3), 完成修改. (17:53 2009-12-30)晚上测试. 
4), 前三路, 后四路可以独立编译. 

19:10 2009-12-30
VC0816, SV, 环境, Makefile, perl, Error Parser
1, 对于编译C语言的情况. 只要把
C_CMD   = $(CC) $(CCFLAGS) $(OLevel) -c $< -o $@
修改为
C_CMD   = @perl *.pl "$(CC) $(CCFLAGS) $(OLevel) -c $< -o $@"
可以获得全部参数, 并且Makefile的变量已经替换.
后来发现直接修改config.ads.mk更简单:
CC  := armcc
改为
CC  := perl perl_argv.pl armcc

*.pl需要:
1), 区分armcc, gcc. 只对armcc处理. gcc照常运行. <DONE>: 只有armcc才调用perl.
2), 执行编译命令.
3), 处理输出结果. 

19:35 2009-12-30
软件技巧, 正则表达式, editplus, 搜索, perl, logAssistant, 续, 未完成功能整理
1, 现在需要加入两个内容
1), 多个关键字搜索(不限制顺序).
2), keyword段内关键字搜索.
2, 多个关键字搜索.
开始修改后遇到不支持中文搜索的问题. 后来发现还是字符匹配问题. 
目前我读入的文件是utf8. 内部@keyword_list是utf8(flag on), 所以匹配时需要关闭uft8 flag:
#encode perl internel code with utf8. it only close the utf8 
#flag because the internel charset already utf8(utf8 flag on)
my $keyword_utf8 = Encode::encode("utf8", $keyword);

代码位置: "D:\work\Documentation\perl\logAssistant". "find_keyword_multikeywordOK.pl"是支持多关键字的版本. 

目前支持: 
#find keyword(use -i to ingore case). keyword is the word at the next line of the date.
#-f search file. support globbing
#-k keyword, "A B" for match A and B. 
#-i ignore case

editplus output pattern:
^"(.+)"\(([0-9]+),([0-9]+),?.+\)

3, 未完成功能
0), 测试case
(1), 日期组合. 找到形如"15:10 2009-12-31\n(15:10 2009-12-31)"的应该把最后一个日期后一行看成是关键字行. 日期组合可能不限于两个. 
(2), 搜索830或816项目"sd"的电压问题;
(3), 搜索项目中上传CVS情况. 
(4), 不限制keyword, 搜索多个subkeyword. "-k ."表示任意keyword
1), 加入keyword section内subkeyword搜索. 
2), 测试Linux下情况, 需要兼容Linux, Windows, utf8, ansi环境. 
3), 显示搜索行还是整个文本. 前者用于编辑器(如editplus), 后者用于命令行使用或输出给其他人参考. 
4), 支持脚本组合/递归调用. 例如搜索VC0830量产中sd问题, 可能需要搜索"VC0830"关键字section内的"sd", 还需要搜索"时间管理"关键字section内的"VC0830" && "sd", 搜索"项目总结"关键字section内的"VC0830" && "sd", 
5), 支持日期条目定位, 例如给出'"19:35 2009-12-30"-3-5)', 输出窗口给出的定义定义应该可以定位到当前行. 目前脚本是关键字搜索, 对日期行只匹配格式. 
6), section起始最好可以由list定义. 这样便于选择不同section起始标志. 

9:44 2009-12-31
时间管理
0, 9:35-

1, 计划
1), VC0816. 现有代码测试通过. 加入tag 0x555000000, 0xaaa00000测试. 是否需要做0x55555400, 0xaaaaa400这样的地址? 这样就需要做到细页的映射. 
2), perl学习, logAssistant: 加入多重日期处理, 加入keyword section内subkeyword搜索. 完整\todo见"19:35 2009-12-30". 

2, 执行
1), 30' 阅读<程序员修炼之道>
2), 9:59-11:43 VC0816, 量产, 代码整理. 见"10:00 2009-12-31"
3), 午饭, 银行还款. 
4), 14:50-17:35 VC0816, 量产, cache tag测试. 见"15:38 2009-12-31"
5), 晚饭.
6), -21:06 perl学习, logAssistant. 见"19:05 2009-12-31"

3, 次日计划
1), VC0816, 量产
2), perl学习, 根据"19:05 2009-12-31"3)的状态转移图重写代码, 并按计划完善. 

10:00 2009-12-31
VC0816, SV, 量产, 代码整理, 续, \todo
1, 测试"7:56 2009-12-30"8中已整理部分.
1), 原来dcache访问是word写的0x55, 0xaa. 今天讨论tag测试时发现其实是想每个byte写0x55, 0xaa.<DONE>
2), 删除无用注释. 合并同类功能. 
(1), 加入部分部分offset和mask的宏定义.<DONE>
(2), 从sdram到sram复制代码改为用mem_cpy实现. <DONE>
(3), 优化"clkrst_get_cpu_bus_ratio()"中计算cpu_bus_ratio的算法: 用循环实现. <DONE>
3), 测试时同时发现, 拔掉memory后, 跳转到icache测试位置时, 虽然读出数据不正确, 但是指令执行是正常的, 这与DaiChunQuan实验结果一致. 当时是用VC0830测试的. 难道结果不同? 
4), 上传CVS. mmu_cache.S ver1.17

2, 还需要(\todo)
1), 优化dcache测试代码. 这个修改要小心. 如果用mem_set, mem_cmp重新实现将来可能不容易调整cb属性. 
2), cpyIcacheTestCode, cpyIcacheSimpleTestCode等都可以用mem_cpy实现. 

14:56 2009-12-31
同事信息, 电话, DongXin, 8703

14:58 2009-12-31
VC830, SV, 量产, BGA181, VC0898, 最高工作频点, 264_132_105
注: VC0830 BGA181称为VC0898
XiangZhiHong邮件"答复: 898/898工作频率"20091231_1255
目前正在做的工作有两方面：
ItemA：ICV/ICP/TE正在基于1.15V和264：132：105做新的Pattern；以判断这个条件下的Yield和误杀率；
ItemB：产品QA正在EVB板上基于实际的ZTE-XA软件的最Critical环境(拍照)，降低Core电做测试。其中Core电1.15V500片全部正常，1.1V 测试刚过半，有一篇不能启动。
我们会将这一片以及随后出来的若干坏片焊接到EVB上，基于1.15V做高低温试验。如果高低温正常，则说明ItemA的Pattern可以满足ZTE-XA的需求。
ZTE-NJ和其它客户将最Critical应用的频率会全部现在在264:132:105以内。

15:38 2009-12-31
VC0816, SV, 量产, cache测试, tag, arm学习, mmu, tlb, tlb lockdown
1, tlb structure
tlb分为两部分, 8 entries 用于lockdown. 是fully-associative; 其它entry都是二组相联的共2way x 32 entry(64个entry)
2, 测试cache tag
1), 希望是测试所有ram数据的反转. 测试类似0x555..., 0xaaa...的pattern. 能测多少位得看映射区域大小. 目前按1MByte映射就只能测0x55500000, 0xaaa00000. tag的读写都要测试. 也就是映射和访问都需要在高频进行. 
2), 分析(仅仅是思路, 不一定正确):
测试tag只能是通过修改tlb完成么? 
如果不修改tlb. 是否一定需要sdram? 

高频只有sram(暂时不想把cache ram测试和tag ram测试放一起), 所以只能把sram映射到待测址(例如0x55500000). 为了映射需要先关闭mmu. 

3), 具体步骤(仅仅是思路, 不一定正确):
get map_addr
disable mmu;
bl 0x200000xxx

addr 0x200000xxx: 
map 0x20000000 to map_addr;
enable mmu;
ldr r0, [pc]
add pc, pc, #4
one word data(0x55aa55aa)
ldr r1, [pc]
add pc, pc, #4
one word data(0x55aa55aa)
cmp r0, r1
moveq r2, #1
disable mmu;
mov pc, lr

test another addr oir end.

19:05 2009-12-31
软件技巧, 正则表达式, perl, logAssistant, android, sl4a, 续
1, 支持多个日期
1), 开始日期正则表达式用的双引号, 发现搜不到, 后来发现需要用单引号. 
注意双引号与单引号字符串的区别. 前者会处理字符串中转义等. 后者不会. 
2), 测试通过. 
3), 发现现在代码写的有点乱. if语句套的太多了. 而且读文件从很多地方读也有点乱. 
感觉用状态机会好些. 
状态转移图见"状态转移图 viso". 代码描述见下, 感觉基本没有问题. 元旦回来实现. 
state = search_section_start
last_state = undef
while (读文件) {
    if ( state == search_section_start ) {
        if ( match section start ) {
            state = search_section_start
            if ( last_state != search_section_start ) { #first time match  
                $date_line = $_
            }
        } else {
            last_state = state
            state = search_keyword
        }
    } elseif ( state == search_keyword ) {
        if ( match section start ) {
            $date_line = $_
            last_state = state
            state = search_keyword
        } elseif ( match keyword ) {
            $keyword_line = $_
            last_state = state
            state = search_section
        } else {
            last_state = state
            state = search_section_start
        }
    } elseif ( state == search_section ) {
        if ( match section start ) {
            $date_line = $_
            last_state = state
            state = search_keyword
        } elseif ( match section_keyword ) {
            last_state = state
            state = search_section_start
            output result
        } else {
            last_state = state
            state = search_section
        }
    }
}
