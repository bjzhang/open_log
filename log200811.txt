1:22 2008-11-2
(2:06 2008-11-13)
课余学习，arm开发板购买
1, 北京大道纵横科技有限公司
http://www.study-kit.com/
北京，arm板，问有没有底板核心板的2440板子；
销售电话:010-82623343  传真：010－82533223 
地址: 北京市海淀区中关村大街32号中发新市场地下一层精品间B1029号(中发南面)   邮编：100086
QQ:18525046,187221877,308304450   MSN: studykit@hotmail.com 
Email:studykit@vip.sina.com  studykit@vip.163.com 
联系人：霍志强
2, 优龙：
http://www.ucdragon.com
3, 北京蓝海微芯科技发展有限公司
http://www.bluemcu.com/ProductView.aspx?bid=2&sid=20&id=88
是nor flash的方案，这点不理想。
地址： 北京市海淀区中关村大街32号和盛大厦 0918-0919室
电话： 010-52926768
Email： bomc@vip.163.com  
 （和盛大厦6-21层为5A级写字楼  B1- 5层为新中发电子市场） 
 门市1: 北京精品展示厅
地址： 北京市海淀区中关村大街32号新中发电子市场2楼2102室 
 门市2: 中发电子市场
地址： 北京市海淀区知春路28号中发电子市场2楼2087柜台

4, http://www.yctek.com/shop/view_62.html
北京杨创科技，看介绍东西还不错，但网上有人说不稳定，光盘内容不对应。
2440板子980。实际看了，感觉做的一般。
5, http://auction1.taobao.com/auction/item_detail-0db1-f000f2ed14ebd3e34fe68a98f61bfacd.jhtml#
飞凌北京
6, 
知春大厦A座606
7, 
http://auction1.taobao.com/auction/item_detail-0db2-ce69e6af8e857b38605fa8ef0c85e1dc.jhtml
LCD 转 VGA 视频加速卡 -- 无TV输出版，260元。
8,北京革新科技
北京中关村苏州街 18 号长远天地大厦 A2 座 609
82608898, 82608676, 82608677。

10:46 2008-11-3
思想，最近需要关注的时事
1, 陈云林访台；
2, 世界金融危机。
2008-11-3的参考消息文章“中东欧经济开始‘失速’ 欧洲可能出现真正混乱”，原题“依赖外资的中东欧经济开始失速”。
文中提到，
1, 中东欧经济以民营化和引进外资为特点。金融危机开始后，外资撤离造成本国汇率急剧下跌，“这种情况已经开始影响居民生活”。
2, 由于这些国家市场开放，
1), 有用外币结算的贷款
2), 很多当地重要银行是欧洲大型银行的子行。
bamvor: 这里指的中东欧应该就是原来东欧社会主义阵营国家。这些国家在苏东剧变后完全转向资本主义，按照西方建议进行改革。可以说是“最资本主义”的地区。现在的金融危机对这些国家影响很大，这说明什么呢？
能否说明这些国家这些“彻底”的资本主义改革是不正确的？为时尚早。
但至少能说明，过于依赖外资是不行的，就像97年亚洲金融危机中的东南亚国家一样。
关注进一步的消息。

11:43 2008-11-3
(13:39 2008-11-20)
嵌入式Linux，ARM学习相关图书，推荐书
注：排名部分先后；有精力情况下多看英文版的书。
1, 嵌入式Linux入门类：
1), 嵌入式Linux应用开发完全手册，这本书我没看过。
我看的网上评论：http://www.china-pub.com/member/bookpinglun/viewpinglun.asp?bookname=&reader=0&gid=0&id=41512&Curpage=3。和百问网：http://www.100ask.net/showforum-2.aspx的勘误和问题讨论。感觉作者还比较负责。
2), 实验室已有的书，skyeye等等
注：其实嵌入式Linux包含的内容很广，一本书写不完。所以名为嵌入式Linux的书一般都是入门类的书，感觉自己对嵌入式Linux有些了解后，建议深入看各类的书籍。例如Linux开发，arm体系结构等等。另外，Linux内核代码和文档是很经典的资料，可以结合看书和做项目多看。
2, Linux学习类
1), 驱动
Linux设备驱动，第三版，即LDD3；
bamvor: 其实讲驱动的书是围绕驱动讲内核。
2), 内核
Linux内核设计与实现，第二版；
深入理解Linux内核，第三版，即ULK3；
前一本书比较基础，后一本比较深入。
3), 应用
UNIX/LINUX编程实践教程
实战Linux编程精髓
前一本书比较基础，后一本比较深入。
3, ARM学习类
1), ARM SOC体系结构
2), ARM嵌入式系统开发：软件设计与优化
前一本书比较基础，后一本比较深入。

相关链接，ARM学习相关图书
1, ARM Architecture Reference Manual (2nd Edition)，Known as the "ARM ARM。
http://www.manley.com.cn/bbs/dispbbs.asp?boardID=15&ID=3174&page=1
http://www.altera.com/literature/third-party/ddi0100e_arm_arm.pdf
http://www.arm.com/community/university/eulaarmarm.html
2, Arm system developer's giude
http://forum.eviloctal.com/read-htm-tid-23998.html
[转载]《ARM嵌入式系统开发：软件设计与优化》中文版PDF格式

13:39 2008-11-3
Linux内核，调试，oops，风河&群硕面试总结
1, 文档：oops-tracing.txt
(3) Use Kdump (see Documentation/kdump/kdump.txt), extract the kernel ring buffer from old memory with using dmesg
    gdbmacro in Documentation/kdump/gdbmacros.txt.

13:49 2008-11-3
Linux，导出符号表，风河&群硕面试总结
1, 阅读内核"scripts/mksysmap"，学习如何输出符号表：
nm -n是导出符号表，待做：看nm所有命令。看skyeye书的相关部分。
#   The second row specify the type of the symbol:
#   A = Absolute
#   B = Uninitialised data (.bss)
#   C = Comon symbol
#   D = Initialised data
#   G = Initialised data for small objects
#   I = Indirect reference to another symbol
#   N = Debugging symbol
#   R = Read only
#   S = Uninitialised data for small objects
#   T = Text code symbol
#   U = Undefined symbol
#   V = Weak symbol
#   W = Weak symbol
#   Corresponding small letters are local symbols

# For System.map filter away:
#   a - local absolute symbols
#   U - undefined global symbols
#   w - local weak symbols

# readprofile starts reading symbols when _stext is found, and
# continue until it finds a symbol which is not either of 'T', 't',
# 'W' or 'w'. __crc_ are 'A' and placed in the middle
# so we just ignore them to let readprofile continue to work.
# (At least sparc64 has __crc_ in the middle).

$NM -n $1 | grep -v '\( [aUw] \)\|\(__crc_\)\|\( \$[adt]\)' > $2

13:59 2008-11-3
编程，各种符号位置，风河&群硕面试总结
待做：编程实验，全局，局部auto和static等各种类型变量，是否在elf文件中，在哪个段？

17:09 2008-11-3
(11:32 2008-11-6)
求职进展，续
1, 汉王笔试
http://jobs.chinahr.com/html/2008-10/07/22200200370115000732.htm?prj=cvapplied
1), 岗位描述：
1、负责嵌入式应用软件的开发；
2、进行软件设计、编码以及测试工作；
3、负责研发文档编写。
应聘人员素质要求：
1、计算机及相关专业，本科以上学历；
2、熟练Wince/Linux操作系统，熟悉嵌入式Wince/Linux开发调试方法及工具；
3、熟练掌握C/C++及VC++；
4、工作踏实、认真，有良好的团队合作精神，虚心好学；
5、有一定的项目经验。 

2), 笔试题目（2008年11月4日）
=============================
位置：bamvor张健的文档\micro微电子与计算机\career个人发展 厂商资料 求职招聘\厂商资料_求职招聘\公司资料\嵌入式系统及其相关公司\汉王\20081104\笔试题目.txt

3), 面试（2008年11月5日）
=========================
bamvor: 这个项目是做电纸书，目前是linux方案，过段时间会做wince方案。
两轮面试：
第一轮是部门经理和两个leader。
----------------------------
shiyu@hanwang.com，应该是做驱动的负责人，目前有三个人做驱动，再招一个人。
面试时又偷懒了，没有完整介绍自己项目经验，以后一定注意。
昨天面试完又修改了简历，加入了了解工作队列机制的描述。今天要完成这个，这样有利于引导面试官发问。
平台：目前是pxa270(blob+linux2.6)，要转到君正的平台（u-boot+linux2.6.20)。查君正平台近况。
提问：
a, Linux内核中使用的"do () while(0)"起什么作用。
bamvor: 呵呵，这个真是不知道，当时说感觉是可能会改为while(1)，进行调试。回来一查发现完全不对，简单说就是保证代码的独立性，详见"23:17 2008-11-5"6。
b, 在不同的SOC间移植驱动需要注意什么。
bamvor: 感觉没什么需要注意的。
c, fb TFT驱动中与硬件有关的结构体。
这部分看s3c2410fb.c。

第二轮是王邦江副总裁，他主管包括电纸书在内的多个项目。
-----------------------------------------------------
问题：
a, cpu读写寄存器时序；待做：看datasheet。
b, 扑克牌。54张牌4个人分剩几张，83个人分138付牌剩几张。
聊了聊待遇：和我现在差不多，加上项目绩效和年底绩效可能能到达年薪140k。试用期80%工资，可以提前转正。
补助：餐补200多，100元电话费，40元交通费。
电纸书：会加上汉王的电磁板技术。bamvor: 虽然东西不错，而且加上电磁板后还可以加汉王的手写识别技术，但是这和我没关系啊，呵呵。

最后等董事长面试，他比较忙，没安排出时间。易先生说董事长过了后HR会和我谈待遇。
最新进展：等待董事长面试中，最可能是下周。
感想：对我来说，今后5年内，可能都是风河这种深入研究Linux内核的公司适合我，这几天面试闪联和汉王感觉他们只是用现成的技术，现成的东西，改改出产品就行。相比之下，风河，群硕这些公司面试问题比较深入，要求了解内核机制实现。

2, 面试准备
待做：打印：pxafb代码。
先看完调度算法和相关代码，然后学习oops调试，解决xia问题；gdb调试；pxafb代码。
3, 待做：加入纸上的今日面经和pxafb基本介绍；汉王笔试题编程练习。

17:58 2008-11-3
Linux，GNU工具学习，ojbdump
ojbdump -S，如果加入了-g，可以显示出c源代码和反汇编的对于关系。

17:11 2008-11-4
各种计算器，包括贷款计算器，提前还款计算器，个人所得税计算器等等。
http://www.boc.cn/cn/common/fourth.jsp?category=1142474796100

11:36 2008-11-5
网址，电子墨水，电子书
1, 电纸书厂商
http://www.irexreader.cn/，飞利浦的子公司；
http://www.jinke.com.cn
2, 电子书论坛
http://bbs.mobread.com/index.php
3, e-link，电子墨水提供商
http://www.eink.com

23:17 2008-11-5
求职进展，续，待做
1, 芸芸帮我建行和招行还款。
2, 联系朋友：新洲，豆豆，敏悦等；
4, 总结工作队列机制；
5, 学习do{}while(0)作用，Memory.txt是内存映射，理解后记忆。
下载工作队列相关网页
http://misuland.com/HTML/1180403166496.html
http://www.lupaworld.com/26540/viewspace-85167.html
http://blog.chinaunix.net/u2/69889/showart_971040.html
http://tech.ddvip.com/2007-05/117946628824884.html
http://www.bitscn.com/linux/kernel/200604/7556.html
http://blog.ednchina.com/tiloog/133368/message.aspx
6, do{} while(0)的作用
http://blog.ednchina.com/fpga2006/34658/message.aspx
http://www.cnblogs.com/flying_bat/archive/2008/01/18/1044693.html
简单说有两方面作用：
a，宏定义中：
a), 空的宏定义避免warning:
#define foo() do{}while(0)
b)，存在一个独立的block，可以用来进行变量定义，进行比较复杂的实现。
c)，如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现：
b, 函数中：用do...while(0)中break语句，消除goto语句。
详见:bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\软件设计\语言\c语言\do{}while(0)宏定义的好处=++.txt

6, 三个网站和水木论坛投简历。
7, 总结风河和群硕面试。

14:24 2008-11-6
汽车卡，比较
http://www.cardcmb.com/carcard/fun.html
招行主要是加油1%优惠。
http://creditcard.cmbchina.com/products/intro/car/1236.htm
需要看会员章程。
http://www.ccb.com/portal/cn/mini_set/second.jsp?column=ROOT%3E%B9%FA%C4%DA%D7%DC%D0%D0%3E%B8%F6%C8%CB%B7%FE%CE%F1%3E%B2%FA%C6%B7%3E%C1%FA%BF%A8%D0%C5%D3%C3%BF%A8%3E%B2%FA%C6%B7%BD%E9%C9%DC%3E%C1%FA%BF%A8%C6%FB%B3%B5%BF%A8&miniset_column=ROOT%3E%B9%FA%C4%DA%D7%DC%D0%D0%3E%B8%F6%C8%CB%B7%FE%CE%F1%3E%B2%FA%C6%B7%3E%C1%FA%BF%A8%D0%C5%D3%C3%BF%A8#
建行是一年6次免费洗车。

14:36 2008-11-6
求职进展，续，面试，风河
kmalloc返回的是什么地址？逻辑地址。

15:24 2008-11-6
Linux学习，移植，arm，存储器(memory)空间, memory.txt分析, 文档
分析arm存储空间分配。这里分析的都是有MMU的arm芯片，对于没有MMU的arm芯片差异很大。例如：
PAGE_OFFSET在无MMU的ARM上是PHYS_OFFSET，无MMU的PHYS_OFFSET是CONFIG_DRAM_BASE。
PAGE_OFFSET在有MMU的arm上是0xc0000000.

Linux内核中文档memory.txt：
Kernel Memory Layout on ARM Linux
Russell King <rmk@arm.linux.org.uk> November 17, 2005 (2.6.15)
This document describes the virtual memory layout which the Linux kernel uses for ARM processors.  It indicates which regions are free for platforms to use, and which are used by generic code.
The ARM CPU is capable of addressing a maximum of 4GB virtual memory space, and this must be shared between user space processes, the kernel, and hardware devices.
As the ARM architecture matures, it becomes necessary to reserve certain regions of VM space for use for new facilities; therefore this document may reserve more VM space over time.
Start           End             Use
--------------------------------------------------------------------------
ffff8000        ffffffff        copy_user_page / clear_user_page use. For SA11xx
                                and Xscale, this is used to setup a minicache 
                                mapping.
ffff1000        ffff7fff        Reserved. Platforms must not use this address 
                                range.
ffff0000        ffff0fff        CPU vector page. The CPU vectors are mapped here 
                                if the CPU supports vector relocation (control
                                register V bit.)
ffc00000        fffeffff        DMA memory mapping region.  Memory returned by                                  the dma_alloc_xxx functions will be dynamically 
                                mapped here.
ff000000        ffbfffff        Reserved for future expansion of DMA mapping                                    region.
VMALLOC_END     feffffff        Free for platform use, recommended. VMALLOC_END
                                must be aligned to a 2MB boundary. 暂时不知道有
                                何用处.待做: 查.
VMALLOC_START   VMALLOC_END-1   vmalloc() / ioremap() space. Memory returned by	
                                vmalloc/ioremap will be dynamically placed in 
                                this region. VMALLOC_START may be based upon the	
                                value of the high_memory variable.
PAGE_OFFSET     high_memory-1   Kernel direct-mapped RAM region. This maps the 
                                platforms RAM, and typically
                                maps all platform RAM in a 1:1 relationship.
TASK_SIZE       PAGE_OFFSET-1   Kernel module space Kernel modules inserted via	
                                insmod are placed here using dynamic mappings.
00001000        TASK_SIZE-1     User space mappings Per-thread mappings are
                                placed here via the mmap() system call.
00000000        00000fff        CPU vector page / null pointer trap CPUs which
                                do not support vector remapping place their 
                                vector page here.  NULL pointer dereferences by 
                                both the kernel and user space are also caught 
                                via this mapping.
Please note that mappings which collide with the above areas may result in a non-bootable kernel, or may cause the kernel to (eventually) panic at run time.
Since future CPUs may impact the kernel mapping layout, user programs must not access any memory which is not mapped inside their 0x0001000 to TASK_SIZE address range.  If they wish to access these areas, they must set up their own mappings using open() and mmap(). 

1, VMALLOC_START:
================
(17:16 2009-1-16)修改:
1), porting(documentation\arm):
VMALLOC_START
VMALLOC_END
	Virtual addresses bounding the vmalloc() area.  There must not be
	any static mappings in this area; vmalloc will overwrite them.
	The addresses must also be in the kernel segment (see above).
	Normally, the vmalloc() area starts VMALLOC_OFFSET bytes above the
	last virtual RAM address (found using variable high_memory
2), memory.txt(documentation\arm):
VMALLOC_START	VMALLOC_END-1	vmalloc() / ioremap() space.

3), 定义
pgtable.h(include\asm-arm)
/*
 * Just any arbitrary offset to the start of the vmalloc VM area: the
 * current 8MB value just means that there will be a 8MB "hole" after the
 * physical memory until the kernel virtual memory starts.  That means that
 * any out-of-bounds memory accesses will hopefully be caught.
 * The vmalloc() routines leaves a hole of 4kB between each vmalloced
 * area for the same reason. ;)
 *
 * Note that platforms may override VMALLOC_START, but they must provide
 * VMALLOC_END.  VMALLOC_END defines the (exclusive) limit of this space,
 * which may not overlap IO space.
 */
#ifndef VMALLOC_START
#define VMALLOC_OFFSET		(8*1024*1024)
#define VMALLOC_START		(((unsigned long)high_memory + VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
#endif

VMALLOC_OFFSET是8M, 目的是为物理地址空间和kernel 虚拟地址空间留个空洞, 这样即使访问内核直接映射的物理sdram越界, 也不会影响到vmalloc/ioremap区域的数据. vmalloc函数为每个区域留4k也是这个目的.

vmalloc.h(include\asm-arm\arch-s3c2410)
#define VMALLOC_END	  (0xE0000000)
在arm其它arch中也有用"PAGE_OFFSET+偏移"表示VMALLOC_END的。待做：移植machine相关.
"17:16 2009-1-16"end

2, high_memory
===============
1), 定义
--------
Memory.c (mm):
void * high_memory;
EXPORT_SYMBOL(high_memory);

struct meminfo定义在include\asm-arm\setup.h，描述所有的物理内存。
struct meminfo {
	int nr_banks;
	struct membank bank[NR_BANKS];
};

2), 结合代码分析：
----------------
"high_memory"在"bootmem_init()"函数中根据"struct meminfo"相加得到.
start_kernel()
    ->setup_arch()(arch\arm\kernel\setup.c)
        ->paging_init()
            ->bootmem_init()

bootmem_init()分析:
void __init bootmem_init(struct meminfo *mi)
{
	unsigned long memend_pfn = 0;
	int node, initrd_node, i;

	/*
	 * Invalidate the node number for empty or invalid memory banks
	 */
	for (i = 0; i < mi->nr_banks; i++)
		if (mi->bank[i].size == 0 || mi->bank[i].node >= MAX_NUMNODES)
			mi->bank[i].node = -1;

	memcpy(&meminfo, mi, sizeof(meminfo));

	/*
	 * Locate which node contains the ramdisk image, if any.
	 */
	/*
	   通过查找meminfo中所有bank，确定initrd在哪个bank中，返回该bank的起始页号。若initrd指定的地址不在所有的meminfo bank中，说明initrd不在实际的物理内存中，Linux会关闭initrd(phys_initrd_start = phys_initrd_size = 0;)
	*/
	initrd_node = check_initrd(mi);

	/*
	 * Run through each node initialising the bootmem allocator.
	 */
	for_each_node(node) {
		unsigned long end_pfn;

		end_pfn = bootmem_init_node(node, initrd_node, mi);

		/*
		 * Remember the highest memory PFN.
		 */
		if (end_pfn > memend_pfn)
			memend_pfn = end_pfn;
	}

	high_memory = __va(memend_pfn << PAGE_SHIFT);

	/*
	 * This doesn't seem to be used by the Linux memory manager any
	 * more, but is used by ll_rw_block.  If we can get rid of it, we
	 * also get rid of some of the stuff above as well.
	 *
	 * Note: max_low_pfn and max_pfn reflect the number of _pages_ in
	 * the system, not the maximum PFN.
	 */
	max_pfn = max_low_pfn = memend_pfn - PHYS_PFN_OFFSET;
}


for_each_node (include\linux\nodemask.h):
#define for_each_node(node)	   for_each_node_mask((node), node_possible_map)
for_each_node宏的作用就是循环访问每个node，例如littleton中node_possible_map是0x1111 1111。

#if MAX_NUMNODES > 1
#define for_each_node_mask(node, mask)			\
	for ((node) = first_node(mask);			\
		(node) < MAX_NUMNODES;			\
		(node) = next_node((node), (mask)))
#else /* MAX_NUMNODES == 1 */
#define for_each_node_mask(node, mask)			\
	if (!nodes_empty(mask))				\
		for ((node) = 0; (node) < 1; (node)++)
#endif /* MAX_NUMNODES */

first_node函数最终使用在findbit.S (arch\arm\lib)的_find_first_bit_le汇编代码查找第一个置一的位。
next_node则是寻找下一个置一的位。

PAGE_SHIFT:
-----------
#ifndef PAGE_SHIFT
#define PAGE_SHIFT		12
#define PAGE_SIZE		(1UL << PAGE_SHIFT)
#define PAGE_MASK		(~(PAGE_SIZE-1))
#endif

MAX_NUMNODES是(1 << NODES_SHIFT)，若未定义NODES_SHIFT，则NODES_SHIFT是0。

NUMA(Documentation\vm):
NUMA是一个体系结构，这种体系结构中cpu访问不同内存区域的“距离”（bamvor: 我理解就是速度）不同。
cpu访问时间相等的一个内存区域成为一个节点（node）。

3), 结论
--------
发现arm中就是把所有memory size加在一起得到的memory结束位置就是high_memory的位置。ULK3中提到的如果内存大于896M不能完全进行1:1映射的情况是针对x86而言的, 对于arm平台一般不会有如此大的ram, 所以暂时没有考虑.
这时与jack一起看i386的代码，发现里面mem_init是起类似bootmem_init作用。但"mem_init"会限制high_memory的大小。

3, PAGE_OFFSET
==============
memory.h (include\asm-arm)
#ifndef PAGE_OFFSET
#define PAGE_OFFSET		UL(0xc0000000)
#endif

4, TASK_SIZE	PAGE_OFFSET-1	Kernel module space Kernel modules inserted via insmod are placed here using dynamic mappings.
这个区域保存insmod插入模块后kernel module使用的空间, 是动态映射的. Linux内核模块是位于下面这个地址空间的，不在原来以为的0xc0000000上面。

5, 异常向量表(CPU vector page)
==============================
即ffff0000-ffff0fff, 见"17:06 2009-1-12"2

11:25 2008-11-7
c语言，编程练习
代码和测试代码：reverse_linklist.c,bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\软件设计\语言\c语言\c_study.
将单向链表reverse，如ABCD变成DCBA，只能搜索链表一次
typedef struct __linkList
{
	int data;
	struct __linkList * next;
} linkList;

void reverse(linkList *list)
{
	if list or list->next is NULL, return
	prev = list;
	
	while( list->next is not NULL ) {
		next = list->next;
		if ( prev == list ) 
			list->next=NULL;
		else
			list->next = prev;
		prev=list;
		list=next;
	}
	prev=list;
	list=list->next;
	list->next=prev;

}

11:25 2008-11-7
待做：51job简历，水木简历。

17:40 2008-11-7
求职进展，中星微
周二（11月11日）下午2点。北航东门世宁大厦15层，技术面试。
电话：8610-68948888-8480王
北京市海淀区学院路35号
世宁大厦15层，100083

18:11 2008-11-7
14家银行信用卡任意分期成本评比
http://www.bankrate.com.cn/cms/2008/11/14_6.php

18:11 2008-11-7
中星微：
1, oops；
2, 工作队列；
3, gdb调试共享库。

10:25 2008-11-8
(16:47 2008-11-10)
(10:26 2008-11-11)
Linux内核学习，工作队列，使用
1, 建立工作队列。create_singlethread_workqueue
##############################################
FM驱动中使用的是create_singlethread_workqueue，其余函数类似。
FM_wq = create_singlethread_workqueue("FM_Work");
-> workqueue.h (include\linux):
	#define create_singlethread_workqueue(name) __create_workqueue((name), 1, 0)
-> workqueue.c (kernel):
	struct workqueue_struct *__create_workqueue(const char *name,
						int singlethread, int freezeable)
分析：__create_workqueue函数：
1), 用kzalloc分配workqueue_struct *wq；
kzalloc根据使用使用slab(CONFIG_SLAB)，有不同的定义。呵呵，一看内核的代码，东西联系都很紧密，等后面分析slab机制时再看kzalloc代码。待做。
可以看到在littleton和s3c2410的配置文件都开启了slab功能，slab机制是一定要分析的。
2), 用alloc_percpu分配cpu_workqueue_struct结构体: wq->cpu_wq。
alloc_percpu
->	percpu.h(include\linux):
	#define alloc_percpu(type)	(type *)__alloc_percpu(sizeof(type))
->	#define __alloc_percpu(size)	percpu_alloc_mask((size), GFP_KERNEL, \
							  cpu_possible_map)
->	#define percpu_alloc_mask(size, gfp, mask) \
		__percpu_alloc_mask((size), (gfp), &(mask))
->	__percpu_alloc_mask根据是否SMP有不同定义，由于littleton和s3c2410都不是SMP，所以这里只分析单CPU情况：
	static __always_inline void *__percpu_alloc_mask(size_t size, gfp_t gfp, cpumask_t *mask)
	{
		return kzalloc(size, gfp);
	}
3), wq->name = name;
4), 互斥信号量：mutex_lock(&workqueue_mutex);和mutex_unlock(&workqueue_mutex);。待做：学习与down_xxx, up的差异。
(1), 单线程情况：
a, 初始化wq->list，单CPU情况这个list是空，SMP中则是把workqueues加入到wq->list中。
===============================================================================
list.h(include\linux):
static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
}
b, p = create_workqueue_thread(wq, singlethread_cpu, freezeable);
=================================================================
其中p是task_struct。singlethread_cpu是在init_workqueues中通过first_cpu宏得到的。对于单CPU，first_cpu(src)是0。
create_workqueue_thread首先得到针对本CPU的cpu_workqueue_struct *cwq，然后对cwq初始化，并利用kthread_create建立内核线程p。cwq->thread中保存p的地址。函数create_workqueue_thread返回p。
对于单CPU情况（根据wq->list是否为空判断是否是单CPU）：
p = kthread_create(worker_thread, cwq, "%s", wq->name);
建立一个名字是'"%s", wq->name'，回调函数是worker_thread，回调函数的数据是cwq。
待做：分析内核线程相关函数。

create_workqueue_thread得到cpu所属cpu_workqueue_struct的方法：
------------------------------------------------------------
struct cpu_workqueue_struct *cwq = per_cpu_ptr(wq->cpu_wq, cpu);
percpu.h: #define per_cpu_ptr(ptr, cpu)	percpu_ptr((ptr), (cpu))
对于单CPU（未定义SMP）：#define percpu_ptr(ptr, cpu) ({ (void)(cpu); (ptr); })
从这个宏看，应该就是返回的ptr这个指针，不过不明白(void)(cpu)起什么作用。
所以per_cpu_ptr(wq->cpu_wq, cpu);应该返回wq->cpu_wq。
-------------------------------------------------------------

c, 如果建立内核线程成功，wake_up_process(p);否则设置destroy = 1，在mutex_unlock后destroy_workqueue(wq);

(a), wake_up_process(p)


(b), destroy_workqueue()
destroy_workqueue函数首先调用flush_workqueue运行全部未运行的工作队列，而后调用cleanup_workqueue_thread停止cwq->thread线程。

d, 分析前面提到的worker_thread：
工作者线程是实际执行工作队列的线程，主要工作是检查cwq->worklist是否为空，若非空则执行全部（全部是哪些？！）。否则进行调度。

static int worker_thread(void *__cwq)
{
	struct cpu_workqueue_struct *cwq = __cwq;
//建立等待队列
	DECLARE_WAITQUEUE(wait, current);
	struct k_sigaction sa;
	sigset_t blocked;
//a),
 	if (!cwq->freezeable)
		current->flags |= PF_NOFREEZE;
//b),设置当前线程优先级为-5。set_user_nice是改变静态优先级。
	set_user_nice(current, -5);
//c),
	/* Block and flush all signals */
	sigfillset(&blocked);
	sigprocmask(SIG_BLOCK, &blocked, NULL);
	flush_signals(current);

	/*
	 * We inherited MPOL_INTERLEAVE from the booting kernel.
	 * Set MPOL_DEFAULT to insure node local allocations.
	 */
	numa_default_policy();

	/* SIG_IGN makes children autoreap: see do_notify_parent(). */
	sa.sa.sa_handler = SIG_IGN;
	sa.sa.sa_flags = 0;
	siginitset(&sa.sa.sa_mask, sigmask(SIGCHLD));
	do_sigaction(SIGCHLD, &sa, (struct k_sigaction *)0);

//d), 设置当前内核线程为可中断线程
	set_current_state(TASK_INTERRUPTIBLE);
/**
e), 判断当前工作者线程是否需要停止，若需要停止直接返回。
参考："16:56 2008-11-10"分析。
*/
	while (!kthread_should_stop()) {
		if (cwq->freezeable)
			try_to_freeze();
//把新建立的等待队列wait加入到cwq->more_work等待队列中。
//add_wait_queue的主要功能是在自旋锁的保护下通过__add_wait_queue()调用list_add函数把等待队列项wait_queue_t *wait加入到某个等待队列中wait_queue_head_t *q。
		add_wait_queue(&cwq->more_work, &wait);
//若cwq->worklist空，则执行调度，工作者线程会睡眠。queue_work函数会把需要推迟的工作加入到cwq->worklist中。
//	所以，当queue_work加入需要推迟工作前，工作者线程处于睡眠状态。
//若cwq->worklist非空，设置当前工作者线程为运行状态。为后面执行需要推迟的工作做准备。
		if (list_empty(&cwq->worklist))
			schedule();
		else
			__set_current_state(TASK_RUNNING);
//把wait从cwq->more_work移除。
		remove_wait_queue(&cwq->more_work, &wait);
//如果有需要执行的工作，则调用run_workqueue函数执行这些工作，
//run_workqueue会执行cwq->worklist中所有工作(work_struct)。
//如果run_workqueue调用深度大于3，内核打出提示信息和dump_stack。
//wake_up(&cwq->work_done);把cwq->work_done中每个等待任务都加入运行队列。
		if (!list_empty(&cwq->worklist))
			run_workqueue(cwq);
		set_current_state(TASK_INTERRUPTIBLE);
	}
	__set_current_state(TASK_RUNNING);
	return 0;
}

注：相关结构体分析
1), cpu_workqueue_struct分析，未完，待做：
struct cpu_workqueue_struct {

	spinlock_t lock;

	//每运行一个工作，remove_sequence增一。run_workqueue和__run_work。
	//queue_work每加入一个工作，就会把insert_sequence增一。
	//remove_sequence和insert_sequence都在flush_cpu_workqueue函数中使用，判断是否处理了所有工作。
	//详见flush_cpu_workqueue函数。
	long remove_sequence;	/* Least-recently added (next to run) */ 
	long insert_sequence;	/* Next to add */ 

	struct list_head worklist;	//参见见workstruct.entry
	//工作者线程把自己加入more_work等待queue_work把自己唤醒，
	//通过run_workqueue执行queue_work加入到cwq->worklist中的工作。
	wait_queue_head_t more_work;
	//用于flush_cpu_workqueue()等待__run_work或run_workqueue完成工作。
	wait_queue_head_t work_done;

	//cwq所属的workqueue_struct。
	struct workqueue_struct *wq;
	struct task_struct *thread;	//工作者线程

	int run_depth;		/* Detect run_workqueue() recursion depth */

	//与电源管理有关，似乎是可以freeze，降低功耗。待做：补充，查如何唤醒freeze的进程。
	int freezeable;		/* Freeze the thread during suspend */
} ____cacheline_aligned;

2), work_struct分析，未完，待做：

struct work_struct {
	//data包括flag和cpu_workqueue_struct两部分。使用set_wq_data和get_wq_data访问cwq，
	//使用Linux位操作函数访问flag。
	atomic_long_t data;
#define WORK_STRUCT_PENDING 0		/* T if work item pending execution */
#define WORK_STRUCT_NOAUTOREL 1		/* F if work item automatically released on exec */
#define WORK_STRUCT_FLAG_MASK (3UL)
#define WORK_STRUCT_WQ_DATA_MASK (~WORK_STRUCT_FLAG_MASK)
	//加入到cwq->worklist中，两个作用：
	//1, 用list_empty判断entry是否为空（也就是是否加入了cwq->worklist中）确定是否已经加入了工作队列
	//2, run_workqueue中，完成cwq->worlist中所有工作。
	struct list_head entry;
	//工作队列执行函数。2.6.20开始（具体版本可能不对），去掉了工作队列中func所操作的数据。
	//改由包含work_struct的用户结构体提供，这样结构更清楚。另外这个版本的工作队列中定时器也移到了
	//work_struct结构体外：
	//struct delayed_work {
	//	struct work_struct work;
	//	struct timer_list timer;
	//};
	work_func_t func;
};

2, 推迟所需的工作，queue_work.
###############################
queue_work主要工作由__queue_work完成。
调用__queue_work之前主要是检查是否确实由工作需要执行。
__queue_work是在自旋锁保护下：
1), 	set_wq_data(work, cwq);
2), 把工作加入到cwq->worklist队列
	list_add_tail(&work->entry, &cwq->worklist);
3), insert_sequence++，
	cwq->insert_sequence++;
4), 唤醒cwq->more_work等待队列，先前睡眠都工作者线程会继续执行。
	wake_up(&cwq->more_work);

3, 工作队列机制总结：
######################################
create_singlethread_workqueue，create_workqueue，create_freezeable_workqueue等函数建立workqueue_struct结构体并初始化，建立工作者线程，工作者线程在无工作情况下睡眠。
queue_work加入需要处理的工作后唤醒工作者线程执行所需工作。
这样看来__queue_work中的wake_up会导致调用wake_up的线程睡眠。
workqueue_struct是工作队列，每个cpu都会分配一个cpu_workqueue_struct，用于管理该cpu上的workqueue_struct，每个cpu_workqueue_work都有个thread，指向这个cpu上的工作者线程。这个工作队列上面可以处理多个需要延时的工作，没有工作都是由queue_work加入的。
工作队列机制: worker_thread把自己的wait等待队列加入到cwq->more_work中, 若cwq->worklist空则睡眠, 否则运行工作队列.
queue_work把工作加入cwq->worklist链表, 唤醒cwq->more_work.
待做：
1), 目前分析的都是单cpu的情况，所以workqueue_struct，cpu_workqueue_struct，工作者线程数量相等。有时间分析不等的情况。
1), 查create_freezeable_workqueue的作用。现在对于工作队列中所有和freezeable相关都没有分析。
2), 查wake_up到底会不会导致睡眠。

10:25 2008-11-8
Linux内核学习，工作队列，机制，待做。
void init_workqueues(void)
{
	singlethread_cpu = first_cpu(cpu_possible_map);
	hotcpu_notifier(workqueue_cpu_callback, 0);
	keventd_wq = create_workqueue("events");
	BUG_ON(!keventd_wq);
}
singlethread_cpu是在init_workqueues中通过first_cpu宏得到的。对于单CPU，first_cpu(src)是0。
init_workqueues的运行：
init\main.c: init()->do_basic_setup()->init_workqueues()。
其中do_basic_setup后，主要就是执行用户指定或默认的init程序/脚本了。
待做：完成。

22:53 2008-11-9
Linux，内核调试函数
1, BUG_ON
如果出现bug，而且影响内核运行，需要打出back trace，然后内核停止运行。

#ifndef HAVE_ARCH_BUG_ON
#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
#endif
注：待做：查HAVE_ARCH_BUG_ON是谁定义的。

bug.h(include\asm-arm)
#define BUG()		__bug(__FILE__, __LINE__)

traps.c(arch\arm\kernel)
void __attribute__((noreturn)) __bug(const char *file, int line)
{
	printk(KERN_CRIT"kernel BUG at %s:%d!\n", file, line);
	*(int *)0 = 0;

	/* Avoid "noreturn function does return" */
	for (;;);
}
EXPORT_SYMBOL(__bug);

2, 如果出现bug，不影响内核运行。
则使用dump_stack，打出back strace。不过，目前没有找到里面实际代码，可能是汇编语言，文件没加全，所以找不到。
待做，补充完整。

16:45 2008-11-10
Linux内核学习，工作队列，使用，待做。
1, 分析函数的代码加入日志.
分析create_workqueue中SMP情况:
查wq->list起什么作用. kthread_bind作用. 
5, queue_delay_work 也是工作队列通用函数, 待做:分析.
6, 分析内核链表用法. 到了该学的时候. 
7, wake_up应该不能进入睡眠, 因为queue_work中wake_up在自悬锁中.
8, 也可以结合工作队列学习定时器的使用

16:45 2008-11-10
Linux，存储器管理，待做
1,把ULK3中x86存储器管理和arm memory.txt内容对比.

16:56 2008-11-10
Linux代码分析，kernel\kthread.c
关键字：内核线程，完成变量
1, kthread_stop函数：
使用kthread_should_stop判断是否需要退出的threadfn()，不应该调用do_exit。
待做：看do_exit()函数。似乎是会杀死自己这个kthread？
/**
 * kthread_stop - stop a thread created by kthread_create().
 * @k: thread created by kthread_create().
 *
 * Sets kthread_should_stop() for @k to return true, wakes it, and
 * waits for it to exit.  Your threadfn() must not call do_exit()
 * itself if you use this function!  This can also be called after
 * kthread_create() instead of calling wake_up_process(): the thread
 * will exit without calling threadfn().
 *
 * Returns the result of threadfn(), or %-EINTR if wake_up_process()
 * was never called.
 */
/**
kthread_stop函数分析：
在mutex保护下：
1), 设置task_struct任务k是需要停止的线程。
kthread_stop_info.k = k
2), 通过wake_up_process把任务k加入到运行队列中。
3), 等待任务k停止：
wait_for_completion(&kthread_stop_info.done);
wait_for_completion函数会把自己所在的当前任务加入等待队列，设置为不可中断模式，然后schedule（进入睡眠）。完成变量x->done设置后退出。
注：由于wait_for_completion会睡眠，所以kthread_stop()使用是mutex，不能用自旋锁。
同时，wait_for_completion()中使用了自旋锁，所以在睡眠前释放自旋锁，睡眠后再得到锁。
可以做为需要内核同步的参考代码：spin_lock，mutex。
*/
int kthread_stop(struct task_struct *k)
{
	int ret;

	mutex_lock(&kthread_stop_lock);

	/* It could exit after stop_info.k set, but before wake_up_process. */
	get_task_struct(k);

	/* Must init completion *before* thread sees kthread_stop_info.k */
	init_completion(&kthread_stop_info.done);
	smp_wmb();

	/* Now set kthread_should_stop() to true, and wake it up. */
	kthread_stop_info.k = k;
	wake_up_process(k);
	put_task_struct(k);

	/* Once it dies, reset stop ptr, gather result and we're done. */
	wait_for_completion(&kthread_stop_info.done);
	kthread_stop_info.k = NULL;
	ret = kthread_stop_info.err;
	mutex_unlock(&kthread_stop_lock);

	return ret;
}

2, kthread_should_stop()
/**
 * kthread_should_stop - should this kthread return now?
 *
 * When someone calls kthread_stop() on your kthread, it will be woken
 * and this will return true.  You should then return, and your return
 * value will be passed through to kthread_stop().
 */
int kthread_should_stop(void)
{
	return (kthread_stop_info.k == current);
}
判断当前任务是否是需要停止的任务，如果是返回1。
kthread_should_stop一般是内核线程的threadfn()使用。这种线程一般都有很多工作需要处理（可能是无限个任务），每次处理工作前都查询kthread_should_stop是否为真，如果为真则直接返回，也就是kthread()继续执行。如果不为真，则处理这项工作，处理后调用scheduel()，让出控制权，自己睡眠。睡眠时如果希望可以由信号中断则设置为TASK_INTERRUPTIBLE。从睡眠中被唤醒时要修改状态为TASK_RUNNING。
例如：
workqueue.c(kernel)的worker_thread()。
fmr_pool.c (drivers\infiniband\core)的ib_fmr_cleanup_thread()。

3, 建立内核线程：
kthread_create()根据helper_wq()是否存在采用不同的方式。若helper_wq()存在，则可以由工作队列负责建立内核线程，其回调函数是keventd_create_kthread。否则直接执行工作函数"create.work.func(&create.work);"，就是keventd_create_kthread。
bamvor: 感觉二者的区别是使用helper_wq()可以减轻系统负载，等系统“有空”时再建立内核线程。
kthread_create自己则用完成变量(create->done)等待keventd_create_kthread完成。
keventd_create_kthread()调用kernel_thread()建立线程，等待完成变量(create->started)完成后返回。由于kernel_thread()建立线程后会唤醒新建的线程，也就唤醒了回调函数。这里的回调函数是kthread()。kthread()会执行"complete(&create->started);"。这样内核线程建立过程结束。
内核线程建立完成后，kthread首先调用schedule()然后控制权，当内核再次调度kthread运行时，kthread()检测该内核线程是否需要停止(kthread_should_stop)，如果不需要停止则执行回调函数。执行完成后再次判断是否需要停止(kthread_should_stop)，如果是设置内核线程回调函数threadfn的返回值ret给kthread_stop_info.err，并通过完成变量kthread_stop_info.done唤醒发送kthread_stop的任务(task_struct)：
	kthread_stop_info.err = ret;
	complete(&kthread_stop_info.done);
如果kthread_should_stop不为真，kthread是直接返回。感觉设置kthread_should_stop的作用是为了同步：让其它等待这个内核线程完成的任务（task_struct，可能也是内核线程）知道已经完成了，等待中的进程可以进行后续操作。

0), helper_wq的建立：
static __init int helper_init(void)
{
	helper_wq = create_singlethread_workqueue("kthread");
	BUG_ON(!helper_wq);

	return 0;
}

core_initcall(helper_init);


1), kthread()
static int kthread(void *_create)
{
	struct kthread_create_info *create = _create;
	int (*threadfn)(void *data);
	void *data;
	sigset_t blocked;
	int ret = -EINTR;

	kthread_exit_files();

	/* Copy data: it's on keventd's stack */
	threadfn = create->threadfn;
	data = create->data;

	/* Block and flush all signals (in case we're not from keventd). */
	sigfillset(&blocked);
	sigprocmask(SIG_BLOCK, &blocked, NULL);
	flush_signals(current);

	/* By default we can run anywhere, unlike keventd. */
	set_cpus_allowed(current, CPU_MASK_ALL);

	/* OK, tell user we're spawned, wait for stop or wakeup */
	__set_current_state(TASK_INTERRUPTIBLE);
	complete(&create->started);
	schedule();

	if (!kthread_should_stop())
		ret = threadfn(data);

	/* It might have exited on its own, w/o kthread_stop.  Check. */
	if (kthread_should_stop()) {
		kthread_stop_info.err = ret;
		complete(&kthread_stop_info.done);
	}
	return 0;
}

2), kthread_create()
/**
 * kthread_create - create a kthread.
 * @threadfn: the function to run until signal_pending(current).
 * @data: data ptr for @threadfn.
 * @namefmt: printf-style name for the thread.
 *
 * Description: This helper function creates and names a kernel
 * thread.  The thread will be stopped: use wake_up_process() to start
 * it.  See also kthread_run(), kthread_create_on_cpu().
 *
 * When woken, the thread will run @threadfn() with @data as its
 * argument. @threadfn() can either call do_exit() directly if it is a
 * standalone thread for which noone will call kthread_stop(), or
 * return when 'kthread_should_stop()' is true (which means
 * kthread_stop() has been called).  The return value should be zero
 * or a negative error number; it will be passed to kthread_stop().
 *
 * Returns a task_struct or ERR_PTR(-ENOMEM).
 */
struct task_struct *kthread_create(int (*threadfn)(void *data),
				   void *data,
				   const char namefmt[],
				   ...)
{
	struct kthread_create_info create;

	create.threadfn = threadfn;
	create.data = data;
	init_completion(&create.started);
	init_completion(&create.done);
	INIT_WORK(&create.work, keventd_create_kthread);

	/*
	 * The workqueue needs to start up first:
	 */
	if (!helper_wq)
		create.work.func(&create.work);
	else {
		queue_work(helper_wq, &create.work);
		wait_for_completion(&create.done);
	}
	if (!IS_ERR(create.result)) {
		va_list args;
		va_start(args, namefmt);
		vsnprintf(create.result->comm, sizeof(create.result->comm),
			  namefmt, args);
		va_end(args);
	}

	return create.result;
}
EXPORT_SYMBOL(kthread_create);

3), 
/* We are keventd: create a thread. */
static void keventd_create_kthread(struct work_struct *work)
{
	struct kthread_create_info *create =
		container_of(work, struct kthread_create_info, work);
	int pid;

	/* We want our own signal handler (we take no signals by default). */
	pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);
	if (pid < 0) {
		create->result = ERR_PTR(pid);
	} else {
		wait_for_completion(&create->started);
		read_lock(&tasklist_lock);
		create->result = find_task_by_pid(pid);
		read_unlock(&tasklist_lock);
	}
	complete(&create->done);
}

4), kernel_thread()。待做：补充。
kernel_thread()(arch\arm\kerenl\process.c)与体系结构相关，似乎主要是kernel_thread_helper不同，待做，看。
主体是调用do_fork()(kernel\fock.c)建立新进程：
do_fork(flags|CLONE_VM|CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
copy_process()复制和父进程一样的子进程，然后用wake_up_new_task唤醒该进程。wake_up_new_task()中会调用__activate_task()。
注：do_fock()中只要没有设置CLONE_STOPPED都会调用wake_up_new_task()。

23:31 2008-11-10
Linux内核学习，工作队列，其余函数
1, set_wq_data, get_wq_data
分别是设置和得到workstruct.data。
workstruct.data保存了cpu_workqueue_struct *cwq和flag(PENDING(有work需要执行)和NOAUTOREL(非自动释放))。其中低两位保存flag，其余位保存cwq的地址。可以这样做的原因是cpu_workqueue_struct都是4字节地址对齐的，也就是指向cpu_workqueue_struct的指针的低两位必然是0，（指针中保存地址，1位表示一个字节，例如二进制100表示第四字节）。所以用workstruct.data的低两位保存flag没有问题:)
workqueue.h(include\linux):
#define work_data_bits(work) ((unsigned long *)(&(work)->data))

struct work_struct {
        atomic_long_t data;
#define WORK_STRUCT_PENDING 0           /* T if work item pending execution */
#define WORK_STRUCT_NOAUTOREL 1         /* F if work item automatically
released on exec */
#define WORK_STRUCT_FLAG_MASK (3UL)
#define WORK_STRUCT_WQ_DATA_MASK (~WORK_STRUCT_FLAG_MASK)
        struct list_head entry;
        work_func_t func;
};

workqueue.c(kernel):
/*
 * Set the workqueue on which a work item is to be run
 * - Must *only* be called if the pending flag is set
 */
static inline void set_wq_data(struct work_struct *work, void *wq)
{
        unsigned long new;

        BUG_ON(!work_pending(work));

        new = (unsigned long) wq | (1UL << WORK_STRUCT_PENDING);
        new |= WORK_STRUCT_FLAG_MASK & *work_data_bits(work);
        atomic_long_set(&work->data, new);
}

static inline void *get_wq_data(struct work_struct *work)
{
        return (void *) (atomic_long_read(&work->data) &
WORK_STRUCT_WQ_DATA_MASK);
}

2, flush_workqueue和flush_cpu_workqueue：
flush_cpu_workqueue用于释放所有当前cpu上的未完成工作：
1), 如果工作者线程正在运行（cwq->thread == current），使用run_workqueue完成cwq->worklist上所有工作；
2), 若1)不成立，睡眠等待所有工作（cwq->insert_sequence - cwq->remove_sequence =0 0）完成。

10:49 2008-11-11
Linux内核学习，代码阅读，wait.h，sched.c，待做，补充
1, wait.h(include\linux)
#define wake_up(x)			__wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1, NULL)

2, __wake_up(kernel\sched.c):
__wake_up->__wake_up_common->用list_for_each_safe遍历wait_queue_head_t中所有等待中的任务，每个等待的任务都执行curr->func(curr, mode, sync, key)。
对于使用DECLARE_WAITQUEUE宏建立的等待队列wait_queue_t，func是default_wake_function。

3, default_wake_function(kernel\sched.c):
default_wake_function()
	->try_to_wake_up(curr->private, mode, sync);

4, wake_up_process(kernel\sched.c):
wake_up_process()->
	->try_to_wake_up(p, TASK_STOPPED | TASK_TRACED | TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE, 0);

5, try_to_wake_up(kernel\sched.c):
		->activate_task(p, rq, cpu == this_cpu);
try_to_wake_up()主要工作是通过activate_task()把进程加入运行队列。本身并不主动让出控制权。
activate_task()
---------------
activate_task()->__activate_task()->enqueue_task(p, target);
activate_task()函数的作用是：把任务加入到运行队列并重新计算优先级。会更新所有调度相关统计信息，例如平均睡眠师姐，优先级等等。由于实时任务不计算动态优先级，所以activate_task()中用rt_task(p)判断是否是实时进程，如果是实时进程直接执行__activate_task。

enqueue_task()
--------------
enqueue_task的作用是把进程(task_struct *p)加入到运行队列的活动数组中(target=rq->active)

判断实时优先级：
--------------
判断依据是优先级是否是实时优先级(实时优先级范围0-99, 判断是否小于100即可)
sched.h(include\linux)
#define MAX_USER_RT_PRIO	100
#define MAX_RT_PRIO		MAX_USER_RT_PRIO
#define MAX_PRIO		(MAX_RT_PRIO + 40)
#define rt_prio(prio)		unlikely((prio) < MAX_RT_PRIO)
#define rt_task(p)		rt_prio((p)->prio)
从中也可以看出普通优先级占用MAX_RT_PRIO~~MAX_PRIO-1的实时范围。

6, 调度策略：
sched.h(include\linux)
/*
 * Scheduling policies
 */
#define SCHED_NORMAL		0
#define SCHED_FIFO		1
#define SCHED_RR		2
#define SCHED_BATCH		3

18:09 2008-11-11
Linux，调试，内核调试，oops
1, 关键是明白oops中地址含义，回家编译内核，与今天得到的backtrace比较。
2, 在程序中不通过GDB来获得backtrace 
http://blog.chinaunix.net/u2/72383/showart_1106253.html

10:35 2008-11-12
待做：
1, 王龙伟同学王吉龙：弘彧大厦。运通110, 628, 438, 355.
2, 顶帖；
3, 投简历；
4, 中星微面试总结。
5, 回家找讲andriod的那期程序员。

11:10 2008-11-12
企业信用信息查询系统：
http://qyxy.baic.gov.cn/qyxy.aspx

11:18 2008-11-12
求职进展，续，中星微面试总结
除了HR王小姐，技术有四个人面试我，
其中两个人是做nucleus的，两个是做嵌入式Linux的。我对嵌入式Linux的职位更感兴趣的。
第三个人，是做嵌入式Linux移植的，他似乎对我有些兴趣，要了一份我的简历，还问了我预期工资。

2:07 2008-11-13
待做，保存：
1, http://www.ibm.com/developerworks/cn/linux/embed/embdev/
嵌入式设备上的 Linux 系统开发
2, http://blog.chinaunix.net/u2/69674/showart_1212590.html
老手经验谈：Linux驱动程序开发学习步骤

11:26 2008-11-13
待做：
1, 渣打：
近期会不会有利息优惠。
50000两年是2527, 总利息是10648. 三年是1856, 利息是16816. 如果提前一年半还款大约节省3400元利息。
渣打吴杰建议我贷三年，以我目前的收入，两年的可能不容易批到50000，可能会降额度。

13:54 2008-11-13
Linux内核学习，代码阅读，jiffies.h(include\linux)
1, 防止jiffies越界的宏定义：
用于比较时间先后，例如time_after表示时间a在时间b之后。
利用了无符号和有符号数的转换：如果jiffies溢出，就是从一个很大的无符号数b变为很小的无符号数a，如果对b和a都转为有符号数，则b是负数，a是正数。这时"(long)(b) - (long)(a)"肯定是负数。所以a在b之后。
但现在不明白的是，如果b是最大的long，但a是比最大的long大的unsigned long，这时"(long)(b) - (long)(a)"是正数。
/*
 *	These inlines deal with timer wrapping correctly. You are 
 *	strongly encouraged to use them
 *	1. Because people otherwise forget
 *	2. Because if the timer wrap changes in future you won't have to
 *	   alter your driver code.
 *
 * time_after(a,b) returns true if the time a is after time b.
 *
 * Do this with "<0" and ">=0" to only test the sign of the result. A
 * good compiler would generate better code (and a really good compiler
 * wouldn't care). Gcc is currently neither.
 */
#define time_after(a,b)		\
	(typecheck(unsigned long, a) && \
	 typecheck(unsigned long, b) && \
	 ((long)(b) - (long)(a) < 0))
#define time_before(a,b)	time_after(b,a)

#define time_after_eq(a,b)	\
	(typecheck(unsigned long, a) && \
	 typecheck(unsigned long, b) && \
	 ((long)(a) - (long)(b) >= 0))
#define time_before_eq(a,b)	time_after_eq(b,a)

typecheck(include\linux\kernel): 
/*
 * Check at compile time that something is of a particular type.
 * Always evaluates to 1 so you may use it easily in comparisons.
 */
#define typecheck(type,x) \
({	type __dummy; \
	typeof(x) __dummy2; \
	(void)(&__dummy == &__dummy2); \
	1; \
})

14:50 2008-11-14
求职进展，续，中星微面试
张总问的问题基本都不是我擅长的。当然我也都答了，也没有明显有问题的。
感觉没有加分也没有减分。

13:18 2008-11-15
保龄球
1, 工体100，30元/局
热线电话:010-65521457 13311295691杨经理
2, 
http://www.nnddoo.com/236/index.html

15:12 2008-11-15
求职进展，风河&群硕面试总结
风河，xiong经理当时问我如果有一个6位日期，如何取出前四位，当时可能也是有段时间没有写脚本了，所以不会，今天很快就找到了方法，其实就是利用"()"的分组功能：
[root@localhost log]# echo `date +%M%S%m`;date +%M%S%m | sed
's/\([0-9]\{4\}\)\([0-9]\{2\}\)/\1/'
113511
1135
sed语句的含有是查找是4位数字组成的组和后面都是数字的串，把这个串替换为4位数字。()起分组作用，\([0-9]\{4\}\)\([0-9]*\)中有两个分组，第一组是4位数字，第二组是2位数字。后面的\1表示引用第一个分组。
bamvor: 感觉自己很久没有灵光一闪的感觉。而且面试中基本没有超水平发挥的时候，是否说明还是不够投入呢？

00:06 2008-11-17
待做，需要购买的东西：
电烙铁，焊锡，焊锡膏，吸锡带。
openjtag: 中发新市场地下一层精品间B1029号，130元。
暂缓：usb转并口，串口。

00:19 2008-11-17
待做：
加入这个群roup48163@xiaoi.com ，北航博士店的msn群。



17:17 2008-11-17
结婚纪念日叫法，两个版本
版本一：
Paper wedding 纸婚、布婚（结婚一周年) 
Calico wedding 棉布婚（结婚两周年) 
Straw wedding 稻草婚（结婚两周年) 
Cotton wedding 棉婚（结婚两周年) 
Muslin wedding 羊皮婚（结婚三周年) 
Leather wedding 皮革婚（结婚三周年) 
Silk wedding 丝婚（结婚四周年) 
Wood wedding 木婚（结婚五周年) 
Iron wedding 铁婚（结婚六周年) 
Copper wedding 铜婚（结婚七周年) 
Woolen wedding 毛婚（结婚七周年) 
Electric appliance wedding 电器婚（结婚八周年) 
Pottery wedding 陶器婚（结婚九周年) 
Tin wedding 锡婚（结婚十周年) 
Steel wedding 钢婚（结婚十一周年) 
Linen wedding 麻纱婚（结婚十二周年) 
Lace wedding 花边婚（结婚十三周年) 
Ivory wedding 象牙婚（结婚十四周年) 
Crystal wedding 水晶婚（结婚十五周年) 
china wedding 搪瓷婚(结婚二十周年) 
Silver wedding 银婚（结婚二十五周年）第一大典 
Pearl wedding 珍珠婚（结婚三十周年) 
Coral wedding 珊瑚婚（结婚三十五周年) 
Jade wedding 碧玉婚（结婚三十五周年) 
Ruby wedding 红宝石婚（结婚四十周年) 
Sapphire wedding 蓝宝石婚（结婚四十五周年) 
Golden wedding 金婚（结婚五十周年）第二大典 
Emerale wedding 翠玉婚（结婚五十五周年) 
Diamond wedding 钻石婚（结婚六十--七十五周年)

版本二：1年一棉婚；2年一皮婚；3年一麦婚；4年一蜡婚；5年一木婚；6年一铜婚；7年一羊毛婚；8年一虞美人婚39年一陶婚；10年一锡婚；11年一珊瑚婚；12年一丝婚；13年一铃兰婚；14年一铅婚；15年一水晶婚；16年一蓝宝石婚；17年一玫瑰婚；18年一绿松石婚；19年一印花婚；20年一瓷婚；21年一乳白石婚；22年一青铜婚；23年一绿玉婚；24年一萨丁婚；25年一银婚；26年一玉婚；27年一桃花心木婚；28年一镍婚；29年一绒婚；30年一珍珠婚；31年一羊皮婚；32年一紫铜婚；33年一斑岩婚；34年一琥珀婚；36年一梅斯林婚；37年一纸婚；38年一水银婚；39年一绉纱婚；40年一祖母绿婚；41年一铁婚；42年一珠质婚；43年一法兰绒婚；44年一黄玉婚；45年一朱红婚；46年一薰衣草婚;47年一开斯米婚；48年一紫晶婚；49年一雪松婚；50年一金婚；60年一钻石婚；70年一白金婚；75年一白石婚；80年一橡树婚。 

17:32 2008-11-17
纪念日，结婚纪念日，生日
1, 结婚纪念日
1), 大狗小狗
计划明年10.4礼物是大狗亲手做的多功能台表，包括彩色led模拟时钟，照片显示（如果能用电子纸最好，要考虑成本），音频播放，包括播放2008婚礼的月亮代表我的心，齐秦的月亮代表我的心和另外一首曲子。
主要要解决的问题是防震。
2), 张爸妈：
4.12。29周年纪念日。考虑送给爸妈珍珠和银饰结合的礼物，寓意爸妈从银婚即将到达珍珠婚。
2, 生日：四个爸妈生日，芸芸生日。

17:53 2008-11-17
求职进展
自：http://www.newsmth.net/bbstcon.php?board=Career_Upgrade&gid=5631
与此人联系：lishuangwinwin@hotmail.com
同主题阅读：北京外资招聘更多职位 [上一主题] [下一主题]【分页： 1 】

[本篇全文] [本篇作者：hire] [进入讨论区] [返回顶部]1发信人: hire (airman971), 信区: Career_Upgrade
标  题: 北京外资招聘更多职位
发信站: 水木社区 (Sun Nov 16 13:58:03 2008), 站内


猎头招聘以下职位，有兴趣请加我的MSN  lishuangwinwin@hotmail.com。
要求现居住地是北京。不符合请不要联系。

美国嵌入式公司职位
LINUX部门
1.    LINUX系统测试。
2.    功能测试
3.    开发测试工具集
4.    开放嵌入式发行版Userspace 开发
5.    Linux embeded engineer 
6.    BSP 开发 
7.    Networking engineer 要懂Carrier grade linux and open SAF  
与INTEL合作
MID（mobile internet deviece）作商业solution ,要懂ATOM  

手机项目组部门（与GOOGLE合作）
MOBILE PHONE TEAM：平台集成/电话协议栈集成/多媒体/BSP开发 
技术MANAGER 要求手机相关经验，LINUX精通。

TD公司职位
基站物理层软件工程师
基站物理层软件白盒测试工程师
基站L2软件工程师
基站呼叫处理软件工程师
RF Engineer
HW Mechanical Design Engineer
基站印刷电路板工程师
Hardware Test Engineering
FPGA Engineer

MS－MTC正式员工招聘职位
1.高级软件开发工程师，C＋＋/WINDOWS
2.软件测试，
3.软件开发LEADER，
4.PM


关键点公关公司 07年公关排名位居第二
职位要求十大公关公司
公关副总裁
媒介副总裁
品牌总监
客户总监

15:05 2008-11-18
求职进展，中星微
今天和中星微人力资源王小姐沟通，王小姐说公司认为我比较合适，在商量我的待遇，本周应该有结果。

11:22 2008-11-19
求职进展，投简历，飞塔
飞塔信息科技（北京）有限公司
公司行业：计算机软件 公司性质：外资(欧美) 公司规模：50-150人  
Linux Driver Developer (Hardware team)  
电子邮箱： hr@fortinet.com.cn  
发布日期： 2008-11-19 工作地点： 北京市 招聘人数： 2 工作年限： 三年以上 
外语要求： 英语 熟练 学    历： 本科         
职位描述：
Job description:
1. Responsible for new product BIOS/Firmware design 
2. Acquire firmware dev tools and build mini Linux system from scratch for the prototype debugging
3. Participate the debugging of key components 
4. Release firmware for delivery to mfr and assist technical issues solving 
Qualification:
1. At minimum, BS in Computer Sciences, Electrical Engineering or related field.
2. At least 3-year experience on Linux development with GNU tool-chain. Strong ability to build mini Linux system from scratch on various kinds of hardware platforms.
3. 3+ years of Assembly or C programming experience, familiar with embedded Linux device driver developping.
4. Skills of common scripting languages, such as Shell, Python, Ruby, Perl or TCL/TK.
5. 2+ years of firmware engineering experience is prefered.
6. Solid understanding of X86 archtecture, peripheral devices and device control systems. Experiences on ARM or PPC platform are prefered.
7. Experience with formal software development processes.
岗位职责： 
1．根据新产品开发需求进行系统分析，BIOS/Firmware设计，以及相应功能BIOS/Firmware的开发。 
2．协助样机的调试，由源代码为样机构建微型Linux系统。
3．解决在关键部件调试、测试中遇到的困难。 
4．解决在产品生产，运营中遇到的BIOS/Firmware技术问题。任职资格： 
1．计算机或电子工程专业本科或以上学历。 
2．至少3年以上Linux使用和开发经验，熟练使用GNU tool-chain，能够熟练针对各种硬件环境配置Linux内核，并由源代码构建Linux系统。
3．至少3年以上汇编语言或C语言开发经验。熟悉嵌入式Linux环境下的驱动开发。
4．掌握常见脚本语言Shell/Python/Perl/Ruby/TCL至少一种。
5．具有2年以上BIOS/Firmware/Boot Loader开发经验更佳。 
6．熟悉X86体系结构，熟练掌握Intel/VIA/AMD芯片组特性。熟悉ARM或PPC平台尤佳。
7．熟悉软件开发流程，熟练使用SVN或CVS版本控制工具。

13:06 2008-11-19
求职进展，投简历，阿德利亚科技
http://www.azaleanet.com.cn
工作职责 
1. 无线Mesh路由器网络层设计、优化和实现 
2. 系统调试和测试
职位需求：
1. 通信、计算机、网络、电子工程等相关专业，硕士及硕士以上学历
2. 精通Linux内部结构(ARM Linux结构优先)；
3. 精通linux下的C/C++语言,2年以上实际的嵌入式Linux内核和驱动开发经验；
4. 熟悉网络编程，网络层和内核API,熟悉TCP/IP 协议栈;
5. 熟悉802.11 MAC层协议者有限考虑。
6. 熟练使用英语，良好的口语与书面交流能力；
7. 良好的沟通能力与协作精神，良好的自信心与独立工作的能力；高度的主动性和责任感。
联系方式：
E-mail：career@azaleanet.com.cn

13:49 2008-11-19
计算机使用技巧，ppt，加入模板，李慧娟
目的：在自己制作的ppt中使用其它ppt中的“幻灯片设计”模板。
1, 打开自己制作的ppt，以下简称为myselfppt；
2, 单击“格式”菜单->“幻灯片设计”，会在powerpoint右侧显示幻灯片设计界面；
3, 单击“幻灯片设计”最下面的“浏览”，弹出“应用设计模板”对话框。在“应用设计模板”对话框中选择要使用模板所属的ppt（以下简称templateppt），单击应用。这时myselfppt中所有页面都会替换为刚才应用templateppt的模板，选择“编辑”菜单->“撤销设计模板”。
4, 经过步骤3, 幻灯片设计模板中已经有了刚才应用的templateppt模板。选择要求修改模板的幻灯片页面，右键单击要使用的模板，弹出的菜单中选择“应用于选定幻灯片”，即可使用于此步骤中选中的幻灯片页面。

15:31 2008-11-20
北京住房公积金网，公积金政策，贷款计算器
http://www.bjgjj.gov.cn/

16:00 2008-11-20
待做，更新moto和微软的简历
1, http://www.motorola.com.cn/careers_new/job/Resume_Center/Update_My_Resume.asp?jid=&type=1

13:47 2008-11-21
正则表达式的活学活用
查找Makefile某个目标："/target_name\s*:"。"\s*"表示0-任意个空白。

14:14 2008-11-21
手写输入法：
1, cellwriter，基础unicode，支持任何语言。
http://risujin.org/cellwriter
2, HanziLookup，中文：
http://www.kiang.org/jordan/software/hanzilookup/
3, 汉王芯片HW006，中文：
http://www.hw99.com/tech/pen-2.htm
4, chinput中似乎也有手写输入法，暂时没有找到。
400-810-8816
注，以上部分资料来源：
http://linux.chinaunix.net/bbs/viewthread.php?tid=916597
http://www.qtcn.org/bbs/read.php?tid=9397

15:51 2008-11-21
(11:52 2008-11-27)
(14:42 2008-11-27)
(10:25 2008-11-28)
(10:29 2009-2-4)
Linux学习, 移植, 代码阅读, time/timer详细分析, "vimicro_Linux移植文档"8-1/2
八, Linux time, timer详细分析
1, 相关文件：
1), linux\kernel\timer.c, 定时器相关
2), linux\kernel\hrtimer.c, 基于timer.c高精度内核定时器, 用于itimers, POSIX timers, nanosleep和precise in-kernel timing, 未分析.
3), linux\kernel\timekeeping.c: 计时相关函数.

2, 函数关系和功能简述
1), 初始化, 注册
start_kernel()
    ->tick_init():注册系统tick事件的顶层通知函数. dep:CONFIG_GENERIC_CLOCKEVENTS
        ->clockevents_register_notifier(): 注册"tick_notifier" 到"clockevents_chain". "tick_notifier.notifier_call"是"tick_notify"
    ->setup_arch(): "system_timer"指针赋值.
    ->init_timers(): 初始化系统定时器
        ->timer_cpu_notify(): 初始化是系统定时器链表
        ->open_softirq(): 注册其软中断回调函数"run_timer_softirq()". 
            ->run_timer_softirq(): 定时器软中断的回调函数
                ->__run_timers(): 处理待处理的定时器事件
    ->time_init()
        ->system_timer->init()(pxa_timer_init())
            ->setup_irq(): 注册中断处理函数"pxa_ost0_interrupt()"
            ->clocksource_register(): 时钟源注册, 
            ->clockevents_register_device(): 注册clock event设备
                ->clockevents_do_notify(CLOCK_EVT_NOTIFY_ADD, dev): 这里的dev是"ckevt_pxa_osmr0"
                    ...->nb->notifier_call(nb, val, v), 根据nb, val和v, 调用"tick_notify()"
    ->kernel_init()
        ->...
            ->do_initcalls()
                "device_initcall"
                    ->timer_init_sysfs(): 注册timer到sysfs

(1), init_timers()分析:
 * 初始化系统定时器: 初始化是系统定时器链表, 注册其软中断处理函数
void __init init_timers(void)
{
	/** V_ZJ
	 * action==CPU_UP_PREPARE时,调用"init_timers_cpu"初始化base->tv1.vec--
	 * base->tv5.vec五个定时器链表.
	 */
	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
				(void *)(long)smp_processor_id());
	//V_ZJ: at91xx和s3c24xx未使用, 跳过
	init_timer_stats();

	BUG_ON(err == NOTIFY_BAD);
	//V_ZJ: 与cpu hotplug有关，跳过. cpu hotplug参"14:22 2008-11-27"
	register_cpu_notifier(&timers_nb);
	/** V_ZJ
	 * 注册定时器的软中断处理程序"run_timer_softirq".
	 */
	open_softirq(TIMER_SOFTIRQ, run_timer_softirq, NULL);
}

(2), tick_notify()分析, 函数调用关系:
tick_notify(): 设置"event_handler()"
    ->reason是"CLOCK_EVT_NOTIFY_ADD", 调用"tick_check_new_device()"
        ->tick_setup_device()
            ->tick_setup_periodic()
                ->tick_set_periodic_handler()
                    ->"dev->event_handler = tick_handle_periodic;": 供下面的"pxa_ost0_interrupt()"调用.

未定义"CONFIG_GENERIC_CLOCKEVENTS_BROADCAST": "tick_set_periodic_handler"直接设置"dev->event_handler = tick_handle_periodic".
定义"CONFIG_GENERIC_CLOCKEVENTS_BROADCAST": arm只有arch\arm\mach-realview\core.c的"realview_timer_init"涉及到. x86定义了"CONFIG_GENERIC_CLOCKEVENTS_BROADCAST".

(3), timer_init_sysfs()(arch\arm\kernel\time.c)分析:
 * 注册timer class到sysfs. 把system_timer->dev注册到timer class中. 根据
 * "timer_sysclass"的定义, timer class的suspend/resume是wrapper函数, 会直接调用
 * system_timer的suspend/resume函数.
 * "CONFIG_NO_IDLE_HZ"未定义, 暂不分析.

2), 系统时钟定时器中断处理
(1), 未定义"CONFIG_GENERIC_CLOCKEVENTS" 和 "CONFIG_GENERIC_TIME",以s3c24xx为例):
timer_tick()(arch\arm\kernel\time.c)
    ->do_timer(): 更新jiffies_64和系统时间xtime. 此时持有顺序锁(seqlock)"xtime_lock". 顺序锁也是一种写优先级高于读优先级的读/写自旋锁.
	    ->更新jiffies_64
        ->update_times()
            ->update_wall_time(): 更新系统当前xtime
                ->change_clocksource(): 选择更好的时钟源. dep: CONFIG_GENERIC_TIME
    ->update_process_times(): 为进程增加一个tick的时间; 处理系统定时器事件.
        ->account_process_tick(): 更新进程时间
        ->run_local_timers(): 处理系统定时器事件.
            ->raise_softirq(TIMER_SOFTIRQ): 通过软中断机制调用run_timer_softirq
                ->run_timer_softirq()
                    ->hrtimer_run_queues()
                    ->__run_timers()，处理到期的定时器事件，
                        ->cascade()，把tvx+1内容移到tv1-tvx链表族中。
        ->scheduler_tick(): 减少进程时间片, 如果时间片用尽设置"need_resched"

(2), 定义"CONFIG_GENERIC_CLOCKEVENTS" 和 "CONFIG_GENERIC_TIME", 以pxa为例):
xxx_timer_interrupt()(pxa_ost0_interrupt())
    ->event_handler()(tick_handle_periodic())
        ->tick_periodic()
            ->do_timer(): 见上面流程
            ->update_process_times(): 见上面流程
        ->clockevents_program_event()
            ->ktime_get()
                ->ktime_get_ts()
                    持有xtime_lock时
                        ->getnstimeofday(), 详见'getnstimeofday()"分析
            ->set_next_event()

(3), update_wall_time()
 * 更新系统当前时间xtime
 * 1, 更新时首先需要获得上次更新后的新增时间(offset), 计算方法:
 * 如果定义了"CONFIG_GENERIC_TIME", 由"clocksource_read()-cycle_last"得到;
 * 若未定义, 直接把"clock->cycle_interval"赋给offset, 未定义
 * "CONFIG_GENERIC_TIME"时"clock->cycle_interval"只在"timekeeping_init()"计算.
 * 2, 如果定义了"CONFIG_GENERIC_TIME", 调用"change_clocksource()"选择更好的时钟
 * 源.

(4), run_timer_softirq()(kernel\timer.c)分析:
/*
 * This function runs timers and the timer-tq in bottom half context.
 */
static void run_timer_softirq(struct softirq_action *h)
{
	//得到前面通过DEFINE_PER_CPU定义的per_cpu__tvec_bases
	tvec_base_t *base = __get_cpu_var(tvec_bases);
	//有关高精度定时器，稍后分析
	hrtimer_run_queues();
	//如果当前时间等于base->timer_jiffies或在base->timer_jiffies之后，说明有定时器事件需要处理
	//调用__run_timers处理这些待处理的定时器事件。
	if (time_after_eq(jiffies, base->timer_jiffies))
		__run_timers(base);
}

4), 内核定时器的使用:
加入定时器和修改定时器时间实际通过"internal_add_timer()"实现. 
"internal_add_timer()"会把定时器时间加入到base->tv1 -- base->tv5五个链表中的某个链表中.
add_timer()
    ->__mod_timer()
        ->internal_add_timer()

mod_timer()
    ->__mod_timer()
        ->internal_add_timer()

18:03 2008-11-24
人脸识别算法，开源，Linux
http://malic.sourceforge.net/
Malic is an opensource face recognition software which uses gabor wavelet. 
2, http://www.malib.net/index.html
'MAlib' is an open source C library for ... Media Analysis, Motion Analizing, Movie Architecture, and Media Authoring.
3, http://sourceforge.net/forum/forum.php?forum_id=881541
http://opencv.willowgarage.com/wiki/
OpenCV (Open Source Computer Vision) is a library of programming functions mainly aimed at real time computer vision. 

18:07 2008-11-24
摄像头资料
1, OLYMPIA_MB_V10 p8
ov3640
2, utu-linux-f-v41 p5
3, ov9650
北京科信威电子有限公司 [北京]
联系人:许小姐
电话:010-62532259
北方科讯电子技术有限公司
联系人:张晓倩
电话:010-82637260 

14:06 2008-11-25
照片，一个在纽约生活的人18年每天一张的照片，待做，看
http://onlytheblogknowsbrooklyn.typepad.com/only_the_blog_knows_brook/jamie_livingston/index.html
http://photooftheday.hughcrawford.com/

15:22 2008-11-25
嵌入式，arm，s3c2440开发板，扬创开发板学习计划，待做：
1, 参考开发板文档，实验开发板所有功能。1天；
2, openjtag调试testcode和u-boot, Linux；
3, 有时间情况下试试最新的qt extended在开发板运行。还有minigui1.6在板子上运行。
有时间尝试在PC机编译，并移植到s3c2440板子。
“bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\消费电子产品\display显示器件和GUI软件\GUI\QT\源码\qt-extended-opensource-src-4.4.2.tar.gz”
4, 是先在扬创板子上做ovxxx芯片驱动，还是先学别的？好像摄像头驱动更接近一些。

15:39 2008-11-25
关注一下qt extended
1, 推荐配置：64Mram, 64Mflash，gcc4.1以上，Linux2.6以上
2, 是诺基亚收购qt后的版本，qt extended就是原来的qtopia。详见"Qtopia 再度更名為Qt Extended=+Qt名称变更历史.txt"的说明。
3, 详细介绍参考"Trolltech and Qtopia rev'd and renamed=++.pdf"。
4, 下载了qt-extended4.4.2完整代码，包括qtopiacore4.4.3。

16:09 2008-11-25
嵌入式，调试，ARM
最低成本的ARM调试解决方案——有关于Wiggler、H-Jtag、OpenOCD、GDB、Insight
自：http://xianzilu.spaces.live.com/blog/cns!4201FDC93932DDAF!485.entry
Wiggler是世界上最泛滥的一种调试工具，它非常简单，只需要一片74HC244，一个9013，几个电阻就可以。
注：9013是NPN三极管，9012是PNP的。
bamvor: 博客上写的是25岁，唉，差距很大啊。
另有一篇关于SDRAM布线的文章，很不错：http://xianzilu.spaces.live.com/blog/cns!4201FDC93932DDAF!434.entry
博主的联系方式：
xianzilu@hotmail.com，我不常在线，给我邮件吧cosine@126.com。

17:06 2008-11-25
简历阅读次数：
1, zhaopin: 80, 2
2, 51job, 151
3, chinaHR, 62

18:09 2008-11-25
待做：申请爱立信职位：https://ericsson.taleo.net/careersection/2/jobdetail.ftl?lang=en&job=00000930

10:00 2008-11-26
待做：
看定时器，记账；
找dos工具，调用ghost恢复芸芸电脑。

11:27 2008-11-26
嵌入式Linux，兼职
看到易登网，http://www.edeng.cn

13:21 2008-11-26
中星微：
0, 请您于2008年12月15日上午9：20到本公司报到并开始工作。请在报到之日携带如下个人证件和资料：个人简历、身份证(外地户口，请一并携带北京市暂住证、工作居住证)、学历及学位证书、体检证明、离职证明及免冠彩色1寸近照4张。
1, 上下班时间：9:00-18:00，1小时弹性时间。
2, 体检证明：正规医院的血常规和乙肝五项；
3, 工作满一年才有年假。
4, 试用期后，每12个月有15天年假。

11:34 2008-11-27
期待方便易用的电子书产品，博客
如果有个便携，支持格式多，使用方便的电子书（阅读+编辑/注释)，价格适中，我就不用整天搬很多代码和书上下班了。
问题是，是买个电子书，还是买NDS，PSP，还是MID呢？选择似乎很多，有空了解一下市场。
总结自己的需求：
1, 电子书阅读，编辑，注释。必备功能。要求支持pdf, html, txt, doc等格式，支持自动换行，消除白边等。
2, 音频视频播放器：看学习视频或电视剧，电影。要求支持各种mpeg格式，各种rm格式。
3, 最好有wifi上网和手机功能（cdma，gsm均可），这样可以实时查询一些资料。或者可以和我的手机连接，通过我的手机上网。
4, 屏幕不能太小，最好是5寸以上，至少640*480分辨率。
5, 价格1000元以内，一次充电满足一天上下班需要。
呵呵，要求比较多，不知有没有合适的产品，有空可以看看。要不自己做一个算了:)
或者是像NDS这种，自己往里面刷uClinux，可能也可以满足需要。

11:52 2008-11-27
Linux学习，移植，代码阅读，定时器（timer），统计功能分析，待做，分析相关函数
相关函数：init_timer_stats()，
文档：Documentation\hrtimer\timer_stats.txt。
开启方法：内核配置中：Kernel hacking->CONFIG_TIMER_STATS，olympia板子未开启此选项。
记录：事件次数，初始化定时器的进程pid，名称，调用定时器初始化函数的函数，定时器回调函数。
用户空间使用方法：/proc/timer_stats
激活采样：echo 1 >/proc/timer_stats
停止采样：echo 0 >/proc/timer_stats
读取：cat /proc/timer_stats
Timerstats sample period: 3.888770 s 
12,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick) 
15,     1 swapper          hcd_submit_urb (rh_timer_func)
 4,   959 kedac            schedule_timeout (process_timeout
 1,     0 swapper          page_writeback_init (wb_timer_fn
 28,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick
 22,  2948 IRQ 4            tty_flip_buffer_push (delayed_work_timer_fn
 3,  3100 bash             schedule_timeout (process_timeout
 1,     1 swapper          queue_delayed_work_on (delayed_work_timer_fn
 1,     1 swapper          queue_delayed_work_on (delayed_work_timer_fn
 1,     1 swapper          neigh_table_init_no_netlink (neigh_periodic_timer
 1,  2292 ip               __netdev_watchdog_up (dev_watchdog
 1,    23 events/1         do_cache_clean (delayed_work_timer_fn
 90 total events, 30.0 events/sec

12:03 2008-11-27
正在表达式学习，editplus，分组，换行
进行下面的替换：查找：\)\s*( [0-9]*)；替换：\n\1
注意editplus中\(\)表示括号，()表示分组。
Timerstats sample period: 3.888770 s 12,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick) 15,     1 swapper          hcd_submit_urb (rh_timer_func) 4,   959 kedac            schedule_timeout (process_timeout) 1,     0 swapper          page_writeback_init (wb_timer_fn) 28,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick) 22,  2948 IRQ 4            tty_flip_buffer_push (delayed_work_timer_fn) 3,  3100 bash             schedule_timeout (process_timeout) 1,     1 swapper          queue_delayed_work_on (delayed_work_timer_fn) 1,     1 swapper          queue_delayed_work_on (delayed_work_timer_fn) 1,     1 swapper          neigh_table_init_no_netlink (neigh_periodic_timer) 1,  2292 ip               __netdev_watchdog_up (dev_watchdog) 1,    23 events/1         do_cache_clean (delayed_work_timer_fn) 90 total events, 30.0 events/sec
结果见：“11:52 2008-11-27”。

14:22 2008-11-27
Linux学习，cpu-hotplug
文档：Documentation\cpu-hotplug.txt。
关于cpu热插拔，只有i386, ppc64, ia64/x86_64, s390支持。像笔记本中支持双核和超线程技术的CPU是不支持hotplug的：
A more novel use of CPU-hotplug support is its use today in suspend resume support for SMP. Dual-core and HT support makes even a laptop run SMP kernels which didn't support these methods. SMP support for suspend/resume is a work in progress.
这个功能以后再研究，目前这个阶段先专注于Linux内核中的通用部分。

14:35 2008-11-27
Linux学习，移植，代码阅读，软中断(softirq)分析，待做，以定时器为例补充完成，并分析相关代码
1, 使用软中断，参Linux内核设计与实现，中P79
1), 分配索引；
定时器软中断(TIMER_SOFTIRQ)序号是1，优先级仅次于HI_SOFTIRQ。
include\linux\interrupt.h:
/* PLEASE, avoid to allocate new softirqs, if you need not _really_ high
   frequency threaded job scheduling. For almost all the purposes
   tasklets are more than enough. F.e. all serial device BHs et
   al. should be converted to tasklets, not to softirqs.
 */

enum
{
	HI_SOFTIRQ=0,
	TIMER_SOFTIRQ,
	NET_TX_SOFTIRQ,
	NET_RX_SOFTIRQ,
	BLOCK_SOFTIRQ,
	TASKLET_SOFTIRQ,
	SCHED_SOFTIRQ,
#ifdef CONFIG_HIGH_RES_TIMERS
	HRTIMER_SOFTIRQ,
#endif
};
2), 注册处理程序：
init_timers()->open_softirq(TIMER_SOFTIRQ, run_timer_softirq, NULL);
3), 触发软中断：

14:36 2008-11-27
待做：
1, 定时器中与移植有关的部分；(完成)
2, 最近阶段看软中断，tasklet代码，下半部完成后看同步。

14:53 2008-11-27
Linux学习，移植，代码阅读，percpu，待做，补充，尤其是SMP情况
目前只分析单CPU情况，以定时器代码为例：
include\asm-generic\percpu.h:
#define DEFINE_PER_CPU(type, name) \
    __typeof__(type) per_cpu__##name

#define per_cpu(var, cpu)			(*((void)(cpu), &per_cpu__##var))
#define __get_cpu_var(var)			per_cpu__##var
#define __raw_get_cpu_var(var)			per_cpu__##var

kernel\timer.c:
tvec_base_t boot_tvec_bases;
EXPORT_SYMBOL(boot_tvec_bases);
//定义一个tvec_base_t类型的指针变量per_cpu__tvec_bases，初始值是&boot_tvec_bases。
static DEFINE_PER_CPU(tvec_base_t *, tvec_bases) = &boot_tvec_bases;
//得到前面定义的per_cpu__tvec_bases变量。
run_timer_softirq(): tvec_base_t *base = __get_cpu_var(tvec_bases);

17:25 2008-11-27
(13:49 2008-12-30)
嵌入式，电子书，pdf阅读，材料购买，液晶屏lcd
买屏还是考虑在北京买能看到屏是否有问题
1, 北京瑞派数码科技(中关村实体店)
北京市海淀区中关村太平洋电脑城9层916室，各种手机，PDA用液晶屏，100-200元。
http://store.taobao.com/shop/view_shop-27bfc17143d7610efcfaa7dbf8d266db.htm
2, 
http://auction1.taobao.com/auction/item_detail-0db2-50c480cd818156aacca9b9fae01b97ed.jhtml
夏普屏LQ71Y03 7.1，800 X 480，感觉很划算。
3,  夏普lcd资料：
http://forum.eetchina.com/FORUM_POST_10003_1100034495_0.HTM
我是夏普的,需要有关资料可和我联系!
联系方式:010-644667543 彭辉
E_mail:peng_h7@n.sharp-world.com
4, 三星7寸宽屏LTP700WV-F01，800x480
1), 扬创科技，1100不带触摸屏，好处是有了代码和高压模块。省时间和100元。
2), 网店，上海，680元，从成色和价格看像是新的：
http://auction1.taobao.com/auction/item_detail-0db2-c66f060daef09e391e149165a22dcd48.jhtml?pm1=2
淘宝上也有200-300的，二手屏，由于看不到，不敢买。
3), 中发网：
http://s.zfa.cn/niclp/lierlist?q=LTP700WV-F01&page=1&offset=25&slier=1
北京立功致远科技有限公司：82626833，北京海淀知春路113号银网中心712室，中发电子市场3123柜台
北京恒光视达电子科技中心：62620599，北京市海淀区知春路118号知春电子城2层C020
北京恒江实业电子：82618858/82620588，北京市海淀区中关村大街中发电子新市场2331柜台
5, IPS液晶。
IPS（In-Plane Switching，平面转换）技术是日立公司于2001推出的液晶面板技术，俗称“Super TFT”。代表厂商：日立，LG-飞利浦、瀚宇彩晶、IDTech。
今天去日立官网查，查到了7寸屏TX18D16VM1CAA，也是800x480的，在taobao多个店铺有买，对两家感兴趣。
待做：比较提供的lcd接口，触摸屏接口是否便于连接2440。买前确认有无详细datasheet。何时能收货。目前考虑寄到公司，收到后立刻验证是否能用。
1), 目前最感兴趣的是
http://store.taobao.com/shop/view_shop-08d3facb4db4d09b447a4897db99ef68.htm
这里是TX18D11VM1CAA,感觉是16的前一代，目前日立网站上已经是18了。
因为能提供液晶，vga，触摸屏等全部，且店铺提供大量液晶屏和配件对以后也有帮助。
 日立7寸TX18D11VM1CAA投影液晶屏,DIY投影,经典,年底特价！
http://auction1.taobao.com/auction/item_detail-0db1-78b21bc59702754b5ac2cb17e491d221.jhtml
7寸四线电阻式触摸屏，
http://auction1.taobao.com/auction/item_detail-0db1-0c6aab9f70fb4f6e3d15560c301697b2.jhtml
日立7寸屏TX18D11VM1CAA专用VGA+S-VEDIO+AV驱动板套件，226：
http://auction1.taobao.com/auction/item_detail-0db1-e90537002b4347eb765816b27408c3a4.jhtml

2), 另一家
工控车载电脑配件
http://shop36526755.taobao.com/?pageNum=2&queryType=all&catId=null&categoryName=null&searchWord=null&order=null&browseType=table#pagebar
日立TX18D16VM1CAA 7寸屏 6件套：7寸屏+单VGA驱动板+触摸屏+屏线+高压板+按键板跟全套线。456。比上面的便宜100多元。
http://auction1.taobao.com/auction/item_detail-0db1-d7dbc79b445ded0a70d43737f960ed40.jhtml

去中发，待做：
1), 需要买7寸宽屏触摸屏；
2), 带板子接口尺寸和引脚编号，问有没有转接板。
3), 去其他家买液晶插座。如果需要自己做板子，把电池部分板子一起做出来。
4), 看电池。最好是买现成的电池；
5), 顺便看看外壳：7寸电子设备的外壳。
