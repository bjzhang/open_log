.LOG
14:32 2012-11-01
GTD
0, -18:20

1, today
1), 15:06-16:37 update my libxl lock patch. see"11:31 2012-10-29"
2), -18:16 try to add domainInterfaceStats in libxl api. see"16:38 2012-11-01"

16:38 2012-11-01
virtualization, libvirt, xenlight, add libxl api, cont1, domainInterfaceStats
1, modify and compile code success. and test fail: start vm fail.
2, after recompile, the former error does not exist. 
but there is not vif in xenlight(it is list as vif in xend with the same xml file).
linux-vm4:/etc/xen/vm # virsh domiflist 6
Interface  Type       Source     Model       MAC
-------------------------------------------------------
-          bridge     br0        -           00:16:3e:01:88:54
3, (15:33 2012-11-02)
linuxDomainInterfaceStats read the data from host "/proc/net/dev", i could found the vif device while using xenlight, but there is no packget counts. why? xenlight does not use vif? 

8:02 2012-11-02
company, virtualization, suse, xen, regular meeting: US / China Virtualization Sync, meeting
1, xen and kvm future. 
2, BoYang
macvtype. 
3, Lin Ma
1), Jim, sle11 sp3 will use libvirt 1.0.0

17:07 2012-11-02
software skill, SCM, git, external diff
http://technotales.wordpress.com/2009/05/17/git-diff-with-vimdiff/
1, .git/config
[diff]
    external = git_diff_wrapper

2, bamvor@linux-bjrd:~> cat bin/git_diff_wrapper
#!/bin/bash

gvimdiff --nofork $2 $5

"--nofork" could block the gvim. it will not create lots of gvim while git diff.

17:43 2012-11-02
GTD
1, today
1), US/China Sync meeing. see"8:02 2012-11-02"
2), summary: 当初遇到migration fail, 我如果想到追到xenlight library里面, 也许问题早就解决了. 

10:03 2012-11-05
arm, armv8, Cortex-A50, Cortex-A53, Cortex-A57
摘要: 延续大小核技术, 第一批芯片2013年出货(?), 内核空间64bit同时用户空间32bit
http://www.eet-china.com/ART_8800677493_617693_NT_7a9b2e89.HTM
20nm A50系列产品2013年生产，FinFET产品2013年流片，由台积电(TSMC)提供早期实现帮助。
海思是个非常好的例证！从最初在机顶盒方面的合作，到现在的网络系统、数据中心产品，正是以海思为代表的合作伙伴多样化的产品需求，推动了ARM的产品研发。有时候，我们能够听到客户更多的抱怨反而是研发进度过慢而不是过快。
ARM处理器部门负责Program Management的总监John Goodacre日前撰文称，正是AArch32和AArch64这两种处理器执行状态的融合，使得ARMv8成为倍受业界关注的架构。他解释称，从以往来看，当处理器架构要支持64位处理时，通常在以下两种演进方式中二选其一：创造一个全新架构，摒弃所有高效传统模式；或在现有32位架构的基础上添加64位处理功能，导致复杂性提高而且低效。而ARMv8的优势在于既可支持性能出众的传统模式，又采用全新64位设计，可以最大程度地提高两种状态的功效，同时还为软件提供渐进式路标图，从而按市场要求的步调采用新功能。
例如，在很多网络和企业市场，用户运行的应用要求具有2GB或3GB以上的RAM，这些市场将会直接采用特定架构的AArch64 状态。在某些合作伙伴的具体实施中，没有需要在处理器的特定模式下工作的传统软件，因此他们可以决定放弃架构对AArch32 状态的支持，而只提供64位的支持。
操作系统“内存不足”很可能是移动设备在64位支持方面遇到的第一个问题。John Goodacre表示，ARMv8 架构采用了简易合理的方法，允许操作系统在AArch64的64位虚拟地址模式下运行，而用户应用仍可在AArch32状态下运行。这使解决方案能够做到两全其美：既可运行无限数量的完全性能32位用户应用，同时又能使操作系统在ARMv8设备上的AArch64位模式下高效运行。

10:16 2012-11-05
community, linaro, arm Server
1, 
http://www.linaro.org/news/release/industry-leaders-collaborate-to-accelerate-software-ecosystem-for-arm-servers-and-join-linaro/en/
Santa Clara, US - 1 Nov 2012
AMD, AppliedMicro, Calxeda, Canonical, Cavium, Facebook, HP, Marvell and Red Hat join existing Linaro members ARM, HiSilicon, Samsung and ST-Ericsson to form new group focused on accelerating Linux development for ARM servers 
Linaro Enterprise Group (LEG) will build on Linaro’s experience of bringing competing companies together to work on common solutions and enable OEMs, commercial Linux providers and System on a Chip (SoC) vendors to collaborate in a neutral environment on the development and optimization of the core software needed by the rapidly emerging market for low-power hyperscale servers. 
2, Bamvor
众多公司加入ARM Server阵营
现在这么多公司都加入到LEG做服务器开发, 大家都看好arm server的前景.
IC company: AMD, AppliedMicro, ARM, Calxeda, Cavium, HiSilicon, Marvell, Samsung and ST-Ericsson.  
Linux Distrubution: Canonical, Red Hat. 
Server: HP
Other: Facebook
现在芯片公司还差TI, Qualcomm. Linux distribution公司还差suse. 

10:37 2012-11-05
GTD
0, 9:40-11:44 13:51-18:18

1, today
1), 40' armv8 and arm server, see"10:03 2012-11-05", "10:16 2012-11-05". 
\TODO: write a blog for this. 
2), 10' 14:25-17:00 add api in libvirt libxl driver. see"11:17 2012-11-05"
3), 20' work report. "17:36 2012-11-05"

11:17 2012-11-05
virtualization, libvirt, xenlight, add libxl api, cont2, domainBlockStats
1, do some investigation for domainBlockStats in last weekend. the qdisk is created by qemu through xenstore. So, if i could find how to get statics from qemu(if it is possible). i could implement the domainBlockStats api. It looks better than domainInterfaceStats, because vif statics in host "/proc/net/dev" is always zero while using xenlight. 
2, qemu-dm
1), command line(get after xen vm): 
qemu-dm -d 1 -domain-name sles11_hvm_10 -vnc 127.0.0.1:0 -serial pty -videoram 8 -boot c -acpi -vcpus 4 -vcpu_avail 0xf -net none -M xenfv
2), list block statics in qemu monitor: 
info blockstats
3), 虽然找到了统计信息在什么地方, 但是如果想从qemu monitor拿到这个数据并且返回给xenlight. 似乎要做很多事情. 
(1), 如果要通过qemu monitor得到信息的话, 目前xenlight里面没有这个功能, 需要新增. 为了一个block statics有必要么? 同时xen 4.3里面的PVH mode就不会使用qemu了. 这个修改也就没用了(所以xen upstream)不一定会收. 
(2), 如果不通过qemu monitor, 需要看看xenstore里面有没有其他方式.
似乎是xenbus? 
3, 
(gdb) break blk_event 
Breakpoint 1 at 0x479eb0: file /usr/src/debug/xen-4.1.2-testing/tools/ioemu-dir/hw/xen_disk.c, line 778.
(gdb) cont
Continuing.

Breakpoint 1, blk_event (xendev=0xadd280)
    at /usr/src/debug/xen-4.1.2-testing/tools/ioemu-dir/hw/xen_disk.c:778
778         struct XenBlkDev *blkdev = container_of(xendev, struct XenBlkDev, xendev);
(gdb) p xendev
$1 = (struct XenDevice *) 0xadd280
(gdb) p *xendev
$2 = {type = 0x4f855e "qdisk", dom = 1, dev = 768,
  name = "qdisk-768", '\000' <repeats 54 times>, debug = 0,
  be_state = XenbusStateConnected, fe_state = XenbusStateConnected,
  online = 1,
  be = "/local/domain/0/backend/qdisk/1/768", '\000' <repeats 988 times>,
  fe = 0xadae70 "/local/domain/1/device/vbd/768",
  protocol = 0xb096a0 "x86_64-abi", remote_port = 8, local_port = 69,
  evtchndev = 0xadd7e0, gnttabdev = 0xaddca0, ops = 0x72d820, next = {
    tqe_next = 0x0, tqe_prev = 0xadc4a0}}
4, it seems that both domainBlockStats and domainInterfaceStats is not eary to implement. So, find another api for this week!!!
But jiaju suggect me first improve lock patch. 
5, 
domainGetMaxVcpus
domainBlockStats
domainInterfaceStats
domainBlockPeek
nodeGetCellsFreeMemory
nodeDeviceDettach
nodeDeviceReAttach
nodeDeviceReset
domainOpenConsole
nodeSuspendForDuration
nodeGetMemoryParameters
nodeSetMemoryParameters
1), BlockPeek: 
(1), validate "path"
(2), open "path", lseek and saferead. 

17:36 2012-11-05
work report - week 44
1, [devel-server] work report - week 44
work for libvirt libxl driver: 
1), send lock patch version 1 and version2 to libvirt upstream after upstream response. 
2), continue to try to add domainBlockStats for libxl driver. 
I found that xenlight use qemu as disk backend while disk type is qdisk for both pv and hvm guest. I could get block statics from qemu through monitor command, but it seems that there is no such machanism in xenlight for this. while in the xen 4.3, a new vm type PVH type will be used which will not use the qemu daemon in xenlight. So, maybe it is not worth to add block statics in current xenlight drivers? 

16:16 2012-11-06
GTD
0, 16:00-18:50 20:35

1, today
1), Chunyan her api status. about BlockPeek: from her work report, her finish all the api except for interface and block stats. 
2), 1h read migration(domain suspend) in xen upstream. see"16:52 2012-11-06"
3), 20' Jiaju talk to me, about my performance.
4), 20:35- search one api which i could finish this week. 

16:52 2012-11-06
virtualization, libvirt, xen, libxl, read migration(domain suspend) in xen upstream
1, 现在的关键就是到底xenlight 4.2里面migration能不能打断，如果能打断，我现在就能干活了。如果不能，还得找其他事情。
简单看了看，原来migration里面的核心代码"xc_domain_save"放到了tools/libxl/libxl_save_helper.c
2, 从下面的分析看，目前suspend(to disk or to remote socket)都是建立的一个子进程做xc_domain_save的工作。但是没有看到任何异步打断的机制，看起来只是为了便于上层调用，允许同时调下来多个命令？如果是这样的话，qemu的monitor lock似乎xenlight也需要。
1), \TODO: discuss with Jim and Chunyan for xenlight event lock(similar to qemu monitor lock), 在适当的时候.
2), 具体分析

libxl__domain_suspend -> set dss->shs.callbacks: suspend, postcopy, checkpoint
                         set toolstack_save as libxl__toolstack_save
                         libxl__xc_domain_save
                         domain_suspend_done
libxl__xc_domain_save -> run_helper
                         libxl__xc_domain_save_done

libxl__toolstack_save: get phy status?

run_helper -> fork
              exec suspend in child
              libxl__ev_fd_register: register event for monitoring suspend 
                                     process? 

xc_domain_save -> suspend_and_state -> suspend
suspend is set by libxl__domain_suspend as remus or common suspend. 

12:52 2012-11-07
GTD
0, 10:00 20:03-22:30

1, today
1), 15:03 search one api which i could finish this week. see"15:16 2012-11-07"
2), try to improve attach-disk, detach-disk in libxl driver, see"18:17 2012-11-07"

13:01 2012-11-07
virtualization, libvirt, 1.0.0 release; localization
1, 1.0.0 release notes
https://www.redhat.com/archives/libvir-list/2012-November/msg00118.html
2, localization
https://www.transifex.com/projects/p/libvirt/

14:07 2012-11-07
arm, board, allwinner A10, cubie board
rumor said that cubie board guys come from VIA. 

14:59 2012-11-07
software skill, mount, network, nfs; rpc, rpcbind
1, mount fail because the rpcbind not started
linux-iwgo:/home/suse # mount.nfs 147.2.207.77:/home/bamvor/sda3/home sda3/home/ -v
mount.nfs: timeout set for Wed Nov  7 15:00:44 2012
mount.nfs: trying text-based options 'vers=4,addr=147.2.207.77,clientaddr=147.2.207.74'
mount.nfs: mount(2): No such file or directory
Starting rpc.statd ... portmapper not running                        failed
mount.nfs: rpc.statd is not running but is required for remote locking.
mount.nfs: Either use '-o nolock' to keep locks local, or start statd.
mount.nfs: an incorrect mount option was specified
2, check and start rpcbind
linux-iwgo:/home/suse # zypper se rpc
Loading repository data...
Reading installed packages...

S | Name                    | Summary                                  | Type
--+-------------------------+------------------------------------------+--------
  | geronimo-jaxrpc-1_1-api | Geronimo J2EE server J2EE specifications | package
  | libgfrpc0               | GlusterFS Remote Procedure Call library  | package
  | librpcsecgss-devel      | Library Implementing GSSAPI Security f-> | package
  | librpcsecgss3           | Library Implementing GSSAPI Security f-> | package
  | libtirpc-devel          | Transport Independent RPC Library        | package
i | libtirpc1               | Transport Independent RPC Library        | package
  | libtirpc1-32bit         | Transport Independent RPC Library        | package
  | nagios-plugins-rpc      | Check RPC service                        | package
  | perl-JSON-RPC           | Perl implementation of JSON-RPC 1.1 pr-> | package
i | perl-PlRPC              | Perl Extension for Writing PlRPC Servers | package
  | perl-RPC-XML            | A set of classes for core data, messag-> | package
  | php5-pear-Horde_Rpc     | PEAR: Horde RPC API                      | package
  | php5-xmlrpc             | PHP5 Extension Module                    | package
i | rpcbind                 | Transport independent RPC portmapper     | package
linux-iwgo:/home/suse # rcrpcbind status
redirecting to systemctl
rpcbind.service - RPC Bind
          Loaded: loaded (/lib/systemd/system/rpcbind.service; disabled)
          Active: inactive (dead)
          CGroup: name=systemd:/system/rpcbind.service

linux-iwgo:/home/suse # rcrpcbind restart
redirecting to systemctl
linux-iwgo:/home/suse # rcrpcbind status
redirecting to systemctl
rpcbind.service - RPC Bind
          Loaded: loaded (/lib/systemd/system/rpcbind.service; disabled)
          Active: active (running) since Wed, 07 Nov 2012 14:59:16 +0800; 1s ago
        Main PID: 21209 (rpcbind)
          CGroup: name=systemd:/system/rpcbind.service
                  └ 21209 /sbin/rpcbind -w -f

Nov 07 14:59:16 linux-iwgo rpcbind[21209]: Cannot open '/var/lib/rpcbind/rpc...)
Nov 07 14:59:16 linux-iwgo rpcbind[21209]: Cannot open '/var/lib/rpcbind/por...)
linux-iwgo:/home/suse # mount.nfs 147.2.207.77:/home/bamvor/sda3/home sda3/home/ -v
mount.nfs: timeout set for Wed Nov  7 15:01:21 2012
mount.nfs: trying text-based options 'vers=4,addr=147.2.207.77,clientaddr=147.2.207.74'
mount.nfs: mount(2): No such file or directory
Starting rpc.statd ...                                               done
mount.nfs: trying text-based options 'addr=147.2.207.77'
mount.nfs: prog 100003, trying vers=3, prot=6
mount.nfs: trying 147.2.207.77 prog 100003 vers 3 prot TCP port 2049
mount.nfs: prog 100005, trying vers=3, prot=17
mount.nfs: trying 147.2.207.77 prog 100005 vers 3 prot UDP port 33276
3, nfs mount successful
linux-iwgo:/home/suse # ls sda3/home/
novell

15:16 2012-11-07
domainMemoryPeek: not support in xenlight

18:17 2012-11-07
virtualization, libvirt, xenlight, attach-disk, detach-disk
0, git branch libxl_attach_detach_disk
1, 
linux-vm4:/etc/xen/vm # virsh attach-disk sles11_hvm_10 /dev/sdb1 sda
Disk attached successfully

linux-vm4:/etc/xen/vm # xm
linux-vm4:/etc/xen/vm # virsh detach-disk sles11_hvm_10 sda
error: Failed to detach disk
error: End of file while reading data: Input/output error
error: Failed to reconnect to the hypervisor

2, xm support scsi-attach, scsi-detach, scsi-list

3, 原来的libxl是否支持ide，或者任何image或设备或lvm？
xen默认就是用俄ide硬盘，所以至少ide要支持吧. 如果SCSI的热插拔没法做的话.

4, attach-disk
1), command successful, but will valid after reboot. 
2), compare xenstore: the state is different. 
(1), hda
((1)) frontend
linux-vm4:/etc/xen/vm # xenstore-ls /local/domain/2/device/vbd/768
backend = "/local/domain/0/backend/qdisk/2/768"
backend-id = "0"
state = "4"
virtual-device = "768"
device-type = "disk"
ring-ref = "8"
event-channel = "8"
protocol = "x86_64-abi"
((2)), backend
linux-vm4:/etc/xen/vm # xenstore-ls /local/domain/0/backend/qdisk/2        
768 = ""                                                                   
 frontend = "/local/domain/2/device/vbd/768"                               
 params = "aio:/var/lib/xen/images_2/sles11_hvm_10/disk0.raw"              
 frontend-id = "2"                                                         
 online = "1"                                                              
 removable = "1"                                                           
 bootable = "1"                                                            
 state = "4"
 dev = "hda"
 type = "tap"
 mode = "w"
 feature-barrier = "1"
 info = "0"
 sector-size = "512"
 sectors = "8388608"
 hotplug-status = "connected"
(2), sda
((1)), frontend
linux-vm4:/etc/xen/vm # xenstore-ls /local/domain/2/device/vbd/2048
backend = "/local/domain/133/backend/qdisk/2/2048"
backend-id = "133"
state = "3"
virtual-device = "2048"
device-type = "disk"
ring-ref = "896"
event-channel = "10"
protocol = "x86_64-abi"
((2)), backend
linux-vm4:/etc/xen/vm # xenstore-ls /local/domain/133/backend/qdisk/2
2048 = ""
 frontend = "/local/domain/2/device/vbd/2048"
 params = "aio:/dev/sdb"
 frontend-id = "2"
 online = "1"
 removable = "1"
 bootable = "1"
 state = "1"
 dev = "sda"
 type = "tap"
 mode = "w"
3), libxl_device_disk_add force set state as 1. what does "1" mean?
4), 其实xenlight本来也支持attach-disk, 效果和我加不加scsi是一样的, 只是虚拟机看到的设备类型不同. 

4, detach-disk fail(scsi and xen are same)
2012-11-07 12:02:29.089+0000: 26374: error : virNetSocketReadWire:1293 : End of file while reading data: Input/output error
看起来是因为xen不允许热插拔???
但是xend是支持scsi attach detach的, 如果我能把xend scsi干的活在xenlight上面实现, 就好了. 

\TODO: 明天看看能否解决这个问题, 如果能避免出这个问题, 这周也算有个交代.

10:24 2012-11-08
GTD
0, 10:24-18:40 20:37-22:11

1, today
1), 10:33-11:25 13:19- libxl lock: check Jim reply, see"10:24 2012-11-08"
2), reply to Jim both libvirt list and jim work email
3), Summary: 这周工作主要是"强迫"自己工作, 从目前情况看, 现在一天已经能工作4-5个小时. 如果从下周开始, 每周出了正常工作的40小时, 再多加上8小时. 5个月就相当于工作其他同时工作6个月. 只要从现在开始抓紧时间, 估计到春节时, 应该会有点起色.

10:24 2012-11-08
virtualization, libvirt, xen, patch, lock, cont1, upstream reply to v2
1, Jim_email_20121108_0654
Bamvor Jian Zhang wrote:
>>> +static int 
>>> +libxlDomainAbortJob(virDomainPtr dom) 
>>  
>> This function will always fail with the above logic.  ret is initialized 
>> to -1 and is never changed. 
>>  
>> Is it even possible to safely abort a libxl operation?  If not, this 
>> function should probably remain unimplemented.  Maybe it will be useful 
>> when the libxl driver supports migration. 
>>     
> return error because of the there is no cancelation opeartion in libvirt libxl
> driver with xen 4.1. according to xen4.2 release document, maybe the
> cancelation of long-running jobs is supported.

I finally got some time to take a closer look at Xen 4.2 libxl and
notice that the "long running" operations (create, save, dump, restore,
etc.) now support a 'libxl_asyncop_how *ao_how' parameter to control
their concurrency.  If ao_how->callback is NULL, a libxl_event is
generated when the operation completes.  We'll just need to handle these
events in the existing libxlEventHandler.  Some of the async operations
support reporting intermediate progress (e.g. for
libxlDomainGetJobInfo), but at this time none of them support
cancellation AFAICT.

With the new asynchronous support in Xen 4.2 libxl, IMO we should delay
this patchset until converting the driver to support 4.2.  I didn't
think this patch would be affected by Xen 4.1 vs 4.2 libxl, but it is
and I don't see any reason to add code that further complicates the
conversion.

BTW, Ondrej was working on a patch to convert the driver to 4.2.  Now
that I have some free time, I'll pick up some of this work too.

> but it is still useful for save, dump and migration(in future), because libvirt
> should block the user abort operation othervise xenlight might crash
>   

If it is left unimplemented, libvirt would block the operation anyhow,
failing with "not supported"

Regards,
Jim

2, test and try to reply
1), 之前我记得测试过如果没有AbortJob, 用户Ctrl+c时会直接打断异步job. 但是今天从代码看, 似乎不是这样, 确认一下. 
加不加abort只是出错信息有区别, 所以Abort还真的可以不加. 

3, reply
run_helper: save, migrate, restore.
restore could be a async job at this point.

10:40 2012-11-08
software, skill, text editor, vim, moving around, buffer
1, list all buffer
:files[!]
:buffers[!]
:ls[!]
		When the [!] is included the list will show unlisted buffers
		(the term "unlisted" is a bit confusing then...).
		Each buffer has a unique number.  That number will not change,
		so you can always go to a specific buffer with ":buffer N" or
		"N CTRL-^", where N is the buffer number.

2, jump
buffer N
N CTRL-^

15:59 2012-11-08
virtualization, libvirt, libxl; automation test, CI; work
1, Jim_email_"Work items for next week"_20121108_1405
Hi Bamvor and Chunyan,

Just a reminder about the libvirt tasks I want to discuss and work on
while in the Beijing office next week.

1. Bamvor's lock patchset for libxl driver.
   Thanks Bamvor for posting a v2 of your patches upstream.  After more
   review and testing today, it seems the patches are not completely
   independent of libxl versions, thus we should rework the patches after
   converting the driver to Xen 4.2 libxl.  I replied upstream with a
   similar comment.  Do you agree that we should convert the driver to
   Xen 4.2 libxl before merging the lock patches upstream?

2. Convert libxl driver to Xen 4.2 libxl.
   This will be our primary task.  It is essential to support Xen 4.2
   libxl since it is now the primary toolstack in Xen 4.2.  Upstream
   libvirt has agreed to drop libxl support for Xen 4.1, allowing us to
   convert the driver to Xen 4.2 libxl and ignore Xen 4.1 libxl.  Ondrej
   has started some work on the conversion and I will pick up his patches
   tomorrow and continue with the effort.  Feel free to take a look and
   become familiar with his initial work in

https://build.suse.de/package/show?package=libvirt&project=home%3Aoholecek%3Abranches%3ADevel%3AVirt%3ASLE-11-SP3

   The patches of interest are libxl_to_xen_42.patch and
   libxl_compat.patch.

3. Migration patch for Xen 4.2 libxl.
   No need to continue with the migration patch for Xen 4.1.  We need to
   make this patch work with the converted Xen 4.2 libxl driver.

4. Feature parity with legacy Xen driver.
   At a minimum, we will need to have the libxl driver support all
   functions currently implemented in the legacy Xen driver.

5. Support for PCI passthrough in legacy xen driver
   We will still be using the xm/xend toolstack in SLES11 SP3, but
   mandatory fate #313570 requests that libvirt support PCI passthrough
   for Xen as it does for KVM.  Unfortunately, this is a feature we'll
   have to implement twice for Xen; first in the legacy driver to satisfy
   fate#313570, second in the Xen 4.2-compatible libxl driver.

I know that both of you have already been working on some of these tasks
or are otherwise familiar with them, but please be prepared to start
digging in on Monday when I show up in the office.

Thanks and see you next week!
Jim

2, reply to Jim
agree. i continue reading xen4.2 code this week. i found that the code for save, migrate and restore changes a lots, the core function for these api is called by subprocess. at this point, restore is a async job. 
meanwhile, i checkout the Ondrej's branch which build fail. i want to try to fix compile error and read the event handling relative code then improve lock patch based on it. 

3, work for Lin Ma
1), Jim email 20121109_0438
I don't want to leave Ma Lin out, so here is another task that might
interest him

- Continuous Integration testing for libvirt and kvm
  Since we have limited QA resources, improving automated testing
  is essential.  I'd like to explore setting up a CI infrastructure for
  libvirt+kvm, similar to what the SUSE Cloud QA folks have done.
  Jenkins can be used to orchestrate CI by periodically pulling sources
  from git (or svn, hg, obs), building a tarball (if necessary), building
  a package from a tarball, deploy the package, run libvirt-tck test
  suite, run KVM autotest, send notifications on failures, ...

Ma Lin, can you look at setting up a Jenkins instance in the Beijing
office?  Do you guys have a server for running such local services, e.g.
like our xen100 in Provo?  AFAIK, all of the scripts, configuration,
etc. for the cloud CI testing can be found here

  https://github.com/SUSE-Cloud/automation

Info about SUSE Cloud QA:
 https://github.com/Shttps://github.com/SUSE/cloud/wiki/SUSE-Cloud-Test-Matrix-%26-Quality-AssuranceUSE/cloud/wiki/SUSE-Cloud-Test-Matrix-%26-Quality-Assurance

Info about SUSE Cloud automation:
  https://github.com/SUSE/cloud/wiki/Automation

Jim
2), bamvor: accoring to LinMa. CI mean continous integration. Jenkins is a framework support CI.

17:42 2012-11-08
build service, how to add package to in build service
1, "Marcus Schäfer<ms@suse.de>"_email_"Re: [opensuse-arm] ARM images fail"_20121108_1624
> Should "vgs" be installed elsewhere?
ah ok now I understand. the buildservice should install lvm2 as part of
the buildsystem. I think that can be achieved if you change your prjconf
   osc meta -e prjconf
and add something like
   requires lvm2
I'm not 100% shure but Adrian knows it definitly :)
CC'ed him
2, bamvor: Adrian Schroeter

17:52 2012-11-08
virtualization, xen, arm server
1, xen arm website
http://xen.org/products/xen_arm.html
2, Xen ARMv7 with Virtualization Extensions
http://wiki.xen.org/wiki/Xen_ARMv7_with_Virtualization_Extensions
FAQ: http://wiki.xen.org/wiki/Xen_ARMv7_with_Virtualization_Extensions/DevFAQ
1), ARM Fast Model
Either the v7-A ARM Envelope Model (AEM) or the Cortex A15/A7 models (single CPU only). 
2), Device Tree
A device tree in the flat device tree format (.dtb). The device tree source for the AEM is here: git://xenbits.xen.org/people/dvrabel/device-trees.git. 
3), Xen
While xen-unstable is frozen for the 4.2 release ARM patches are being collected in the arm-for-4.3 branch of this git tree. This tree is based upon Anthony Perards conversion to git. 
4), Linux kernel for dom0
3.5-rc7-arm-2 branch of git://xenbits.xen.org/people/sstabellini/linux-pvhvm.git
5), Cross compile
http://www.kernel.org/pub/tools/crosstool/files/bin/x86_64/4.6.0/x86_64-gcc-4.6.0-nolibc_arm-unknown-linux-gnueabi.tar.bz2
4, Xen ARM in Linux! 
http://blog.xen.org/index.php/2012/10/08/xen-arm-in-linux/
5, XenSummit Sessions: New PVH virtualisation mode for ARM Cortex A15/ARM Servers and x86
http://blog.xen.org/index.php/2012/09/21/xensummit-sessions-new-pvh-virtualisation-mode-for-arm-cortex-a15arm-servers-and-x86/
6,Xen hypervisor ported to ARM chips 
Twice, in fact, and KVM in the works, too 
http://www.theregister.co.uk/2011/11/30/xen_kvm_hypervisor_for_arm_chips/

18:24 2012-11-08
http://wiki.xen.org/wiki/Choice_of_Toolstacks
libxl Design Principles

    Implement mechanisms, not policies
    Stateless
    Hide xenstore, libxenctrl, and libxenguest from higher levels
    Be as simple as possible 

21:39 2012-11-08
virtualization, libvirt, xen, xenlight, libxl
发现自己今年真的是挺晕的, 之前发libvirt patch的人是Daniel De Graaf <dgdegra@redhat.com>, 之前不知道他是redhat的人.
那个是否如果照着人家的patch接着改, 估计怎么也改完了. 
这事儿我还误导jiaju了.

23:50 2012-11-8
(09:25 2012-11-12)
virtualization, libvirt, xen, compare different virtualization mode, PV, HVM, PVHVM, PVH
http://blog.xen.org/index.php/2012/10/23/the-paravirtualization-spectrum-part-1-the-ends-of-the-spectrum/
http://blog.xen.org/index.php/2012/10/31/the-paravirtualization-spectrum-part-2-from-poles-to-a-spectrum/
The pagetable protections protect both the guest kernel and Xen from userspace; the segmentation limits protect Xen from the guest kernel.

Unfortunately, at the time that Xen team was developing clever new uses for this little-used feature, AMD was designing their 64-bit extensions to the x86 architecture. Any unused processor feature makes hardware much more complicated to design, reason about, and verify. Since basically no operating systems use segmentation limits, AMD decided to get rid of them.

In 64-bit HVM mode, the problem doesn’t occur. The HVM extensions make it easy to have three different protection levels without needing to play clever tricks with little-used processor features. So making system calls in 64-bit HVM mode is just as fast as on real hardware. For this reason, a lot of people began running 64-bit Linux in fully virtualized mode.

But fully virtualized mode, even with PV drivers, has a number of things that are unnecessarily inefficient. One example is the interrupt controllers: fully virtualized mode provides the guest kernel with emulated interrupt controllers (APICs and IOAPICs). Each instruction that interacts with the APIC requires a trip up into Xen and a software instruction decode; and each interrupt delivered requires several of these emulations.

So Stefano Stabellini wrote some patches for the Linux kernel that allowed Linux, when it detects that it’s running in HVM mode under Xen, to switch from using the emulated interrupt controllers and timers to the paravirtualized interrupts and timers. This mode he called PVHVM mode, because although it runs in HVM mode, it uses the PV interfaces extensively.

(“PVHVM” mode should not be confused with “PV-on-HVM” mode, which is a term sometimes used in the past for “fully virtualized with PV drivers”.)

With the introduction of PVHVM mode, we can start to see paravirtualization not as binary on or off, but as a spectrum. In PVHVM mode, the disk and network are paravirtualized, as are interrupts and timers. But the guest still boots with an emulated motherboard, PCI bus, and so on. It also goes through a legacy boot, starting with a BIOS and then booting into 16-bit mode. Privileged instructions are virtualized using the HVM extensions, and pagetables are fully virtualized, using either shadow pagetables, or the hardware assisted paging (HAP) available on more recent AMD and Intel processors.

Almost fully PV: PVH mode

A lot of the choices Xen made when designing a PV interface were made before HVM extensions were available. Nearly all hardware now has HVM extensions available, and nearly all also include hardware-assisted pagetable virtualization. What if we could run a fully PV guest — one that had no emulated motherboard, BIOS, or anything like that — but used the HVM extensions to make the PV MMU unnecessary, as well as to speed up system calls in 64-bit mode?

This is exactly what Mukesh’s PVH mode is. It’s a fully PV kernel mode, running with paravirtualized disk and network, paravirtualized interrupts and timers, no emulated devices of any kind (and thus no qemu), no BIOS or legacy boot — but instead of requiring PV MMU, it uses the HVM hardware extensions to virtualize the pagetables, as well as system calls and other privileged operations.

Once PVH is well-established (perhaps five years or so after it’s introduced), we will probably consider removing non-PVH support from the Linux kernel, making maintenance of Xen support for Linux much simpler. 

What about KVM?

KVM supports both “legacy boot”, starting in 16-bit mode with a BIOS (or EFI) to load the kernel bootloader, and booting directly into a kernel passed on the qemu command-line. It also provides an emulated motherboard, PCI bus, and so on. It can provide both emulated disk and network cards; and thus it is capable of supporting guests running in fully virtualized mode.

KVM also provides virtio devices, which can be considered paravirtualized, as well as a PV clock, for operating systems that can be modified to support them. KVM’s typical method of paravirtualization is somewhat different than Xen’s. Virtio devices expose a normal device interface, with MMIO control paths and so on, and could in theory be implemented by real hardware. Xen’s PV interfaces are based on shared memory and lockless synchronization. The kinds of actions that need an MMIO context switch for virtio devices probably correspond pretty closely to actions that need hypercalls for Xen PV devices; but in Xen no instruction emulation needs to be done.

KVM does not have a paravirtualized interface for timers or interrupts; instead (if I understand correctly) it uses an emulated local APIC. Handling a full interrupt cycle for an emulated local APIC typically requires several MMIO accesses, each of which requires a context switch and an instruction emulation. The Xen PV interrupt interface is based on memory shared with the hypervisor, supplemented by hypercalls when necessary; so most operations can be done without context switches, and those that do require only a single context switch (and no instruction emulation). This was one of the major reasons for introducing PVHVM mode for Xen guests.

So KVM has paravirtualized devices and a paravirtualized clock, but not paravirtualized interrupts; placing KVM on the spectrum, it would be one step more paravirtualized than “FV with PV drivers”, but not as paravirtualized as PVHVM.

The paravirtualization spectrum

So to summarize: There are a number of things that can be either virtualized or paravirtualized when creating a VM; these include:

    Disk and network devices
    Interrupts and timers
    Emulated platform: motherboard, device buses, BIOS, legacy boot
    Privileged instructions and pagetables (memory access)

picture: work/documents/virtualization/xen

10:39 2012-11-09
GTD
0, 10:20-18:07

1, today
1), 30' 14:36-18:07 work in compile libvirt with xen4.2 support. see"14:36 2012-11-09"
1), 1h lunch and learning. gstreamer by lance. see"12:01 2012-11-09"
2), 1h discuss with Tacey Ren <renjiaying2009@gmail.com> about mobile and opensuse arm. 

12:01 2012-11-09
lunch and learning; multimedia, gstreamer; lance
1, player : totem
converter: arista
edtior: pitivi

2, foundation
element
pad: src, sink
bin: a bin is a container for  a collection of element.
pipeline

3, event and queries
send and receive event through bus.

4, state: NULL, READY, PAUSED,  PALYEING.

5, Gobject, GstMiniObject: light weight Gobect. both came from gtype

6, playbin2 including file src, demux, decode. also ffmpeg

14:36 2012-11-09
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support
1, install  
Problem: nothing provides librados.so.2()(64bit) needed by libvirt-1.0.0-9.1.x86_64
1), search librados.so on http://rpm.pbone.net, it should be in the ceph package. 
2), search ceph on build.opensuse.org, got: 
http://download.opensuse.org/repositories/filesystems/SLE_11_SP2/

2, create vm with xend 4.2 in virsh successful, create vm with xl 4.2 successful. create vm with libxl in virsh fail. 
1), libvirtd.log
Caught abort signal dumping internal log buffer:


    ====== start of log =====

 0x8960c0
2012-11-09 08:24:57.660+00004836: debug : virObjectUnref:137 : OBJECT_DISPOSE: obj=0x8960c0
2012-11-09 08:24:57.660+00004836: debug : virEventPollRemoveTimeout:288 : EVENT_POLL_REMOVE_TIMEOUT: timer=1
2012-11-09 08:24:57.660+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:24:57.660+00004836: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f3740001090
2012-11-09 08:24:57.660+00004836: debug : virObjectUnref:137 : OBJECT_DISPOSE: obj=0x7f3740001090
2012-11-09 08:24:57.660+00004836: debug : virNetSocketDispose:997 : sock=0x7f3740001090 fd=21
2012-11-09 08:24:57.660+00004836: debug : virEventPollRemoveHandle:175 : EVENT_POLL_REMOVE_HANDLE: watch=8
2012-11-09 08:24:57.660+00004836: debug : virFileClose:72 : Closed fd 21
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:24:57.660+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:24:57.660+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:24:57.660+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=6 timeout=-1
2012-11-09 08:25:20.450+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 1
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 6
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=3 events=1
2012-11-09 08:25:20.450+00004836: debug : virNetSocketNew:147 : localAddr=0x7fff1844ecc0 remoteAddr=0x7fff1844ec30 fd=21 errfd=-1 pid=0
2012-11-09 08:25:20.450+00004836: debug : virObjectNew:110 : OBJECT_NEW: obj=0x7f37400008b0 classname=virNetSocket
2012-11-09 08:25:20.450+00004836: debug : virNetSocketNew:204 : RPC_SOCKET_NEW: sock=0x7f37400008b0 fd=21 errfd=-1 pid=0 localAddr=127.0.0.1;0, remoteAddr=127.0.0.1;0
2012-11-09 08:25:20.450+00004836: debug : virNetServerClientNew:405 : sock=0x7f37400008b0 auth=2 tls=(nil)
2012-11-09 08:25:20.450+00004836: debug : virObjectNew:110 : OBJECT_NEW: obj=0x7f37400010b0 classname=virNetServerClient
2012-11-09 08:25:20.450+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400008b0
2012-11-09 08:25:20.450+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.450+00004836: debug : virEventPollAddTimeout:243 : EVENT_POLL_ADD_TIMEOUT: timer=3 frequency=-1 cb=0x7f3755aa2110 opaque=0x7f37400010b0 ff=(nil)
2012-11-09 08:25:20.450+00004836: debug : virNetMessageNew:45 : msg=0x7f3740001a00 tracked=1
2012-11-09 08:25:20.450+00004836: debug : virNetServerClientNewInternal:383 : RPC_SERVER_CLIENT_NEW: client=0x7f37400010b0 sock=0x7f37400008b0
2012-11-09 08:25:20.450+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001a00 tx=(nil)
2012-11-09 08:25:20.450+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.450+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.450+00004836: debug : virNetServerClientRegisterEvent:200 : Registering client event callback 1
2012-11-09 08:25:20.450+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400008b0
2012-11-09 08:25:20.450+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.450+00004836: debug : virEventPollAddHandle:136 : EVENT_POLL_ADD_HANDLE: watch=9 fd=21 events=1 cb=0x7f3755aa9610 opaque=0x7f37400008b0 ff=0x7f3755aa9a00
2012-11-09 08:25:20.450+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.450+00004836: debug : virKeepAliveNew:212 : client=0x7f37400010b0, interval=5, count=5
2012-11-09 08:25:20.450+00004836: debug : virObjectNew:110 : OBJECT_NEW: obj=0x7f3740000e80 classname=virKeepAlive
2012-11-09 08:25:20.450+00004836: debug : virKeepAliveNew:236 : RPC_KEEPALIVE_NEW: ka=0x7f3740000e80 client=0x7f37400010b0
2012-11-09 08:25:20.450+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.450+00004836: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400010b0
2012-11-09 08:25:20.450+00004836: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400008b0
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.450+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.450+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.450+00004836: debug : virEventPollCleanupTimeouts:514 : EVENT_POLL_PURGE_TIMEOUT: timer=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=-1
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=1
2012-11-09 08:25:20.451+00004836: debug : virNetMessageDecodeLength:152 : Got length, now need 28 total (24 more)
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001a00 tx=(nil)
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientDispatchRead:1007 : RPC_SERVER_CLIENT_MSG_RX: client=0x7f37400010b0 len=28 prog=536903814 vers=1 proc=66 type=0 status=0 serial=0
2012-11-09 08:25:20.451+00004836: debug : virKeepAliveCheckMessage:384 : ka=0x7f3740000e80, client=0x7f37400010b0, msg=0x7f3740001a00
2012-11-09 08:25:20.451+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.451+00004836: debug : virNetServerDispatchNewMessage:219 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740001a00
2012-11-09 08:25:20.451+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7e1130
2012-11-09 08:25:20.451+00004836: debug : virNetMessageNew:45 : msg=0x7f37400012d0 tracked=1
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004839: debug : virNetServerHandleJob:190 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740001a00 prog=0x7e1130
2012-11-09 08:25:20.451+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.451+00004839: debug : virNetServerProgramDispatch:284 : prog=536903814 ver=1 type=0 status=0 serial=0 proc=66
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004839: debug : remoteDispatchAuthListHelper:18 : server=0x7d5d40 client=0x7f37400010b0 msg=0x7f3740001a00 rerr=0x7f374d8cebc0 args=0x7f3740001d10 ret=0x7f3740001ca0
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004839: info : remoteDispatchAuthList:2397 : Bypass polkit auth for privileged client pid:4900,uid:0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.451+00004839: debug : virNetMessageEncodePayload:358 : Encode length as 36
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.451+00004839: debug : virNetServerClientSendMessageLocked:1251 : msg=0x7f3740001a00 proc=66 len=36 offset=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.451+00004839: debug : virNetServerClientSendMessageLocked:1259 : RPC_SERVER_CLIENT_MSG_TX_QUEUE: client=0x7f37400010b0 len=36 prog=536903814 vers=1 proc=66 type=1 status=0 serial=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:25:20.451+00004839: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=0x7f3740001a00
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:25:20.451+00004839: debug : virNetServerClientCalculateHandleMode:184 : mode=3
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=-1
2012-11-09 08:25:20.451+00004839: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=3
2012-11-09 08:25:20.451+00004839: debug : virEventPollInterruptLocked:701 : Interrupting
2012-11-09 08:25:20.451+00004839: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7e1130
2012-11-09 08:25:20.451+00004839: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400010b0
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=1 events=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=5 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=-1
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.451+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=2
2012-11-09 08:25:20.451+00004836: debug : virNetMessageFree:73 : msg=0x7f3740001a00 nfds=0 cb=(nil)
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.451+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.451+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.451+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:25:20.451+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:25:20.451+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=-1
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virNetMessageDecodeLength:152 : Got length, now need 32 total (28 more)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientDispatchRead:1007 : RPC_SERVER_CLIENT_MSG_RX: client=0x7f37400010b0 len=32 prog=536903814 vers=1 proc=60 type=0 status=0 serial=1
2012-11-09 08:25:20.452+00004836: debug : virKeepAliveCheckMessage:384 : ka=0x7f3740000e80, client=0x7f37400010b0, msg=0x7f37400012d0
2012-11-09 08:25:20.452+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.452+00004836: debug : virNetServerDispatchNewMessage:219 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f37400012d0
2012-11-09 08:25:20.452+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7e1130
2012-11-09 08:25:20.452+00004836: debug : virNetMessageNew:45 : msg=0x7f3740000da0 tracked=1
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740000da0 tx=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004845: debug : virNetServerHandleJob:190 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f37400012d0 prog=0x7e1130
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.452+00004845: debug : virNetServerProgramDispatch:284 : prog=536903814 ver=1 type=0 status=0 serial=1 proc=60
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004845: debug : remoteDispatchSupportsFeatureHelper:13372 : server=0x7d5d40 client=0x7f37400010b0 msg=0x7f37400012d0 rerr=0x7f374a8c8bc0 args=0x7f37400014d0 ret=0x7f3740001b30
2012-11-09 08:25:20.452+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 1
2012-11-09 08:25:20.452+00004845: debug : virKeepAliveStart:289 : RPC_KEEPALIVE_START: ka=0x7f3740000e80 client=0x7f37400010b0 interval=0 count=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 1 timers
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 0 due in -1 ms
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=-1
2012-11-09 08:25:20.452+00004845: debug : virEventPollInterruptLocked:701 : Interrupting
2012-11-09 08:25:20.452+00004845: debug : virEventPollAddTimeout:243 : EVENT_POLL_ADD_TIMEOUT: timer=4 frequency=5000 cb=0x7f3755aa6220 opaque=0x7f3740000e80 ff=0x422f40
2012-11-09 08:25:20.452+00004845: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f3740000e80
2012-11-09 08:25:20.452+00004845: debug : virNetMessageEncodePayload:358 : Encode length as 32
2012-11-09 08:25:20.452+00004845: debug : virNetServerClientSendMessageLocked:1251 : msg=0x7f37400012d0 proc=60 len=32 offset=0
2012-11-09 08:25:20.452+00004845: debug : virNetServerClientSendMessageLocked:1259 : RPC_SERVER_CLIENT_MSG_TX_QUEUE: client=0x7f37400010b0 len=32 prog=536903814 vers=1 proc=60 type=1 status=0 serial=1
2012-11-09 08:25:20.452+00004845: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740000da0 tx=0x7f37400012d0
2012-11-09 08:25:20.452+00004845: debug : virNetServerClientCalculateHandleMode:184 : mode=3
2012-11-09 08:25:20.452+00004845: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=3
2012-11-09 08:25:20.452+00004845: debug : virEventPollInterruptLocked:701 : Interrupting
2012-11-09 08:25:20.452+00004845: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7e1130
2012-11-09 08:25:20.452+00004845: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400010b0
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=1 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=5 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525452
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525452 due in 5000 ms
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:625 : Poll got 2 event(s)
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=1 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=2
2012-11-09 08:25:20.452+00004836: debug : virNetMessageFree:73 : msg=0x7f37400012d0 nfds=0 cb=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740000da0 tx=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525452
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525452 due in 5000 ms
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.452+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virNetMessageDecodeLength:152 : Got length, now need 40 total (36 more)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740000da0 tx=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientDispatchRead:1007 : RPC_SERVER_CLIENT_MSG_RX: client=0x7f37400010b0 len=40 prog=536903814 vers=1 proc=1 type=0 status=0 serial=2
2012-11-09 08:25:20.452+00004836: debug : virKeepAliveCheckMessage:384 : ka=0x7f3740000e80, client=0x7f37400010b0, msg=0x7f3740000da0
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateTimeout:254 : EVENT_POLL_UPDATE_TIMEOUT: timer=4 frequency=5000
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.452+00004836: debug : virNetServerDispatchNewMessage:219 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740000da0
2012-11-09 08:25:20.452+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7e1130
2012-11-09 08:25:20.452+00004836: debug : virNetMessageNew:45 : msg=0x7f3740001b50 tracked=1
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001b50 tx=(nil)
2012-11-09 08:25:20.452+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.452+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.452+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525452
2012-11-09 08:25:20.452+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525452 due in 5000 ms
2012-11-09 08:25:20.452+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.452+00004841: debug : virNetServerHandleJob:190 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740000da0 prog=0x7e1130
2012-11-09 08:25:20.452+00004841: debug : virNetServerProgramDispatch:284 : prog=536903814 ver=1 type=0 status=0 serial=2 proc=1
2012-11-09 08:25:20.452+00004841: debug : remoteDispatchOpenHelper:11149 : server=0x7d5d40 client=0x7f37400010b0 msg=0x7f3740000da0 rerr=0x7f374c8ccbc0 args=0x7f3740001b30 ret=0x7f3740001770
2012-11-09 08:25:20.452+00004841: debug : remoteDispatchOpen:732 : priv=0x7f3740001bc0 conn=(nil)
2012-11-09 08:25:20.452+00004841: debug : virConnectOpen:1342 : name=
2012-11-09 08:25:20.452+00004841: debug : virObjectNew:110 : OBJECT_NEW: obj=0x7f37400018e0 classname=virConnect
2012-11-09 08:25:20.452+00004841: debug : virConnectGetConfigFile:964 : Loading config file '/etc/libvirt/libvirt.conf'
2012-11-09 08:25:20.452+00004841: debug : virConfReadFile:767 : filename=/etc/libvirt/libvirt.conf
2012-11-09 08:25:20.452+00004841: debug : virFileClose:72 : Closed fd 30
2012-11-09 08:25:20.452+00004841: debug : do_open:1142 : no name, allowing driver auto-select
2012-11-09 08:25:20.452+00004841: debug : do_open:1185 : trying driver 0 (Test) ...
2012-11-09 08:25:20.452+00004841: debug : do_open:1191 : driver 0 Test returned DECLINED
2012-11-09 08:25:20.452+00004841: debug : do_open:1185 : trying driver 1 (remote) ...
2012-11-09 08:25:20.452+00004841: debug : do_open:1191 : driver 1 remote returned DECLINED
2012-11-09 08:25:20.452+00004841: debug : do_open:1185 : trying driver 2 (Xen) ...
2012-11-09 08:25:20.452+00004841: debug : virCommandRunAsync:2200 : About to run /usr/sbin/xend status
2012-11-09 08:25:20.453+00004841: debug : virFileClose:72 : Closed fd 30
2012-11-09 08:25:20.453+00004841: debug : virFileClose:72 : Closed fd 32
2012-11-09 08:25:20.453+00004841: debug : virFileClose:72 : Closed fd 34
2012-11-09 08:25:20.453+00004841: debug : virCommandRunAsync:2218 : Command result 0, with PID 4902
2012-11-09 08:25:20.578+00004841: debug : virCommandRun:2016 : Result exit status 3, stdout: '' stderr: ''
2012-11-09 08:25:20.578+00004841: debug : virFileClose:72 : Closed fd 31
2012-11-09 08:25:20.578+00004841: debug : virFileClose:72 : Closed fd 33
2012-11-09 08:25:20.578+00004841: debug : do_open:1191 : driver 2 Xen returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1185 : trying driver 3 (xenlight) ...
2012-11-09 08:25:20.578+00004841: debug : do_open:1191 : driver 3 xenlight returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1213 : network driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1213 : network driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1213 : network driver 2 Network returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1228 : interface driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1228 : interface driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1228 : interface driver 2 udev returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1244 : storage driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1244 : storage driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1244 : storage driver 2 storage returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1260 : node driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1260 : node driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1260 : node driver 2 udevDeviceMonitor returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1276 : secret driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1276 : secret driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1276 : secret driver 2 secret returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : do_open:1292 : nwfilter driver 0 Test returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1292 : nwfilter driver 1 remote returned DECLINED
2012-11-09 08:25:20.578+00004841: debug : do_open:1292 : nwfilter driver 2 nwfilter returned SUCCESS
2012-11-09 08:25:20.578+00004841: debug : virNetMessageEncodePayload:358 : Encode length as 28
2012-11-09 08:25:20.578+00004841: debug : virNetServerClientSendMessageLocked:1251 : msg=0x7f3740000da0 proc=1 len=28 offset=0
2012-11-09 08:25:20.578+00004841: debug : virNetServerClientSendMessageLocked:1259 : RPC_SERVER_CLIENT_MSG_TX_QUEUE: client=0x7f37400010b0 len=28 prog=536903814 vers=1 proc=1 type=1 status=0 serial=2
2012-11-09 08:25:20.578+00004841: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001b50 tx=0x7f3740000da0
2012-11-09 08:25:20.578+00004841: debug : virNetServerClientCalculateHandleMode:184 : mode=3
2012-11-09 08:25:20.578+00004841: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=3
2012-11-09 08:25:20.578+00004841: debug : virEventPollInterruptLocked:701 : Interrupting
2012-11-09 08:25:20.578+00004841: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7e1130
2012-11-09 08:25:20.578+00004841: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400010b0
2012-11-09 08:25:20.578+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=1 events=1
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.578+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=5 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525452
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525452 due in 4874 ms
2012-11-09 08:25:20.578+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=4874
2012-11-09 08:25:20.578+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.578+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=2
2012-11-09 08:25:20.578+00004836: debug : virNetMessageFree:73 : msg=0x7f3740000da0 nfds=0 cb=(nil)
2012-11-09 08:25:20.578+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001b50 tx=(nil)
2012-11-09 08:25:20.578+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.578+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.578+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.578+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.578+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525452
2012-11-09 08:25:20.578+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525452 due in 4874 ms
2012-11-09 08:25:20.578+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=4874
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=1
2012-11-09 08:25:20.579+00004836: debug : virNetMessageDecodeLength:152 : Got length, now need 28 total (24 more)
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001b50 tx=(nil)
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientDispatchRead:1007 : RPC_SERVER_CLIENT_MSG_RX: client=0x7f37400010b0 len=28 prog=536903814 vers=1 proc=110 type=0 status=0 serial=3
2012-11-09 08:25:20.579+00004836: debug : virKeepAliveCheckMessage:384 : ka=0x7f3740000e80, client=0x7f37400010b0, msg=0x7f3740001b50
2012-11-09 08:25:20.579+00004836: debug : virEventPollUpdateTimeout:254 : EVENT_POLL_UPDATE_TIMEOUT: timer=4 frequency=5000
2012-11-09 08:25:20.579+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.579+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.579+00004836: debug : virNetServerDispatchNewMessage:219 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740001b50
2012-11-09 08:25:20.579+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7e1130
2012-11-09 08:25:20.579+00004836: debug : virNetMessageNew:45 : msg=0x7f37400012d0 tracked=1
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525579
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525579 due in 5000 ms
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.579+00004842: debug : virNetServerHandleJob:190 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f3740001b50 prog=0x7e1130
2012-11-09 08:25:20.579+00004842: debug : virNetServerProgramDispatch:284 : prog=536903814 ver=1 type=0 status=0 serial=3 proc=110
2012-11-09 08:25:20.579+00004842: debug : remoteDispatchGetURIHelper:7297 : server=0x7d5d40 client=0x7f37400010b0 msg=0x7f3740001b50 rerr=0x7f374c0cbbc0 args=0x7f3740001280 ret=0x7f3740001d00
2012-11-09 08:25:20.579+00004842: debug : virConnectGetURI:1711 : conn=0x7f37400018e0
2012-11-09 08:25:20.579+00004842: debug : virNetMessageEncodePayload:358 : Encode length as 40
2012-11-09 08:25:20.579+00004842: debug : virNetServerClientSendMessageLocked:1251 : msg=0x7f3740001b50 proc=110 len=40 offset=0
2012-11-09 08:25:20.579+00004842: debug : virNetServerClientSendMessageLocked:1259 : RPC_SERVER_CLIENT_MSG_TX_QUEUE: client=0x7f37400010b0 len=40 prog=536903814 vers=1 proc=110 type=1 status=0 serial=3
2012-11-09 08:25:20.579+00004842: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=0x7f3740001b50
2012-11-09 08:25:20.579+00004842: debug : virNetServerClientCalculateHandleMode:184 : mode=3
2012-11-09 08:25:20.579+00004842: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=3
2012-11-09 08:25:20.579+00004842: debug : virEventPollInterruptLocked:701 : Interrupting
2012-11-09 08:25:20.579+00004842: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7e1130
2012-11-09 08:25:20.579+00004842: debug : virObjectUnref:135 : OBJECT_UNREF: obj=0x7f37400010b0
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=1 events=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=5 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525579
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525579 due in 5000 ms
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.579+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=2
2012-11-09 08:25:20.579+00004836: debug : virNetMessageFree:73 : msg=0x7f3740001b50 nfds=0 cb=(nil)
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.579+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.579+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.579+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525579
2012-11-09 08:25:20.579+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525579 due in 5000 ms
2012-11-09 08:25:20.579+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.580+00004836: debug : virEventPollRunOnce:625 : Poll got 1 event(s)
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchTimeouts:410 : Dispatch 2
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:455 : Dispatch 7
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=0 w=1
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=1 w=2
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=2 w=3
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=3 w=4
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=5 w=6
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=6 w=7
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:469 : i=7 w=9
2012-11-09 08:25:20.580+00004836: debug : virEventPollDispatchHandles:483 : EVENT_POLL_DISPATCH_HANDLE: watch=9 events=1
2012-11-09 08:25:20.580+00004836: debug : virNetMessageDecodeLength:152 : Got length, now need 1148 total (1144 more)
2012-11-09 08:25:20.580+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f37400012d0 tx=(nil)
2012-11-09 08:25:20.580+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.580+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.580+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.580+00004836: debug : virNetServerClientDispatchRead:1007 : RPC_SERVER_CLIENT_MSG_RX: client=0x7f37400010b0 len=1148 prog=536903814 vers=1 proc=10 type=0 status=0 serial=4
2012-11-09 08:25:20.580+00004836: debug : virKeepAliveCheckMessage:384 : ka=0x7f3740000e80, client=0x7f37400010b0, msg=0x7f37400012d0
2012-11-09 08:25:20.580+00004836: debug : virEventPollUpdateTimeout:254 : EVENT_POLL_UPDATE_TIMEOUT: timer=4 frequency=5000
2012-11-09 08:25:20.580+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.580+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7f37400010b0
2012-11-09 08:25:20.580+00004836: debug : virNetServerDispatchNewMessage:219 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f37400012d0
2012-11-09 08:25:20.580+00004836: debug : virObjectRef:168 : OBJECT_REF: obj=0x7e1130
2012-11-09 08:25:20.580+00004836: debug : virNetMessageNew:45 : msg=0x7f3740001ae0 tracked=1
2012-11-09 08:25:20.580+00004836: debug : virNetServerClientCalculateHandleMode:153 : tls=(nil) hs=-1, rx=0x7f3740001ae0 tx=(nil)
2012-11-09 08:25:20.580+00004838: debug : virNetServerHandleJob:190 : server=0x7d5d40 client=0x7f37400010b0 message=0x7f37400012d0 prog=0x7e1130
2012-11-09 08:25:20.580+00004836: debug : virNetServerClientCalculateHandleMode:184 : mode=1
2012-11-09 08:25:20.580+00004838: debug : virNetServerProgramDispatch:284 : prog=536903814 ver=1 type=0 status=0 serial=4 proc=10
2012-11-09 08:25:20.580+00004836: debug : virEventPollUpdateHandle:146 : EVENT_POLL_UPDATE_HANDLE: watch=9 events=1
2012-11-09 08:25:20.580+00004836: debug : virEventPollInterruptLocked:697 : Skip interrupt, 1 1443907648
2012-11-09 08:25:20.580+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.580+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.580+00004836: debug : virEventRunDefaultImpl:244 : running default event implementation
2012-11-09 08:25:20.580+00004838: debug : remoteDispatchDomainCreateXMLHelper:1151 : server=0x7d5d40 client=0x7f37400010b0 msg=0x7f37400012d0 rerr=0x7f374e0cfbc0 args=0x7f3740000e60 ret=0x7f3740001610
2012-11-09 08:25:20.580+00004836: debug : virEventPollCleanupTimeouts:501 : Cleanup 2
2012-11-09 08:25:20.580+00004836: debug : virEventPollCleanupHandles:549 : Cleanup 8
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=0 w=1, f=7 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=1 w=2, f=9 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=2 w=3, f=12 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=3 w=4, f=13 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=4 w=5, f=6 e=0 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=5 w=6, f=6 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=6 w=7, f=15 e=1 d=0
2012-11-09 08:25:20.580+00004838: debug : virDomainCreateXML:1948 : conn=0x7f37400018e0, xmlDesc=<domain type='xen'>
  <name>sles11_hvm_10</name>
  <description>None</description>
  <uuid>a3e56d96-c285-90af-4bf8-136fe551292f</uuid>
  <memory>524288</memory>
  <currentMemory>524288</currentMemory>
  <vcpu>4</vcpu>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>
  <clock sync='utc'/>
  <keymap>en-us</keymap>
  <os>
    <type>hvm</type>
    <loader>/usr/lib/xen/boot/hvmloader</loader>
    <boot dev='hd'/>
  </os>
  <features>
    <apic/>
    <acpi/>
    <pae/>
  </features>
  <devices>
    <emulator>/usr/lib/xen/bin/qemu-dm</emulator>
      <disk type='file' device='disk'>
      <driver name='file'/>
      <source file='/var/lib/xen/images_2/sles11_hvm_10/disk0.raw'/>
      <target dev='hda'/>
    </disk>
      <interface type='bridge' model='para'>
        <source bridge='br0'/>
        <mac address='00:16:3e:62:c1:34'/>
        <script path='/etc/xen/scripts/vif-bridge'/>
      </interface>
    <graphics type='vnc'/>
    <console type='pty'>
      <source path='/dev/pts/1'/>
      <target port='0'/>
    </console>
  </devices>
</domain>
, flags=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollMakePollFDs:378 : Prepare n=7 w=9, f=21 e=1 d=0
2012-11-09 08:25:20.580+00004836: debug : virEventPollCalculateTimeout:320 : Calculate expiry of 2 timers
2012-11-09 08:25:20.580+00004836: debug : virEventPollCalculateTimeout:326 : Got a timeout scheduled for 1352449525580
2012-11-09 08:25:20.580+00004836: debug : virEventPollCalculateTimeout:346 : Timeout at 1352449525580 due in 5000 ms
2012-11-09 08:25:20.580+00004836: debug : virEventPollRunOnce:614 : EVENT_POLL_RUN: nhandles=7 timeout=5000
2012-11-09 08:25:20.581+00004838: debug : virFileClose:72 : Closed fd 30


     ====== end of log =====

2), libxl.log
libxl: debug: libxl_create.c:1173:do_domain_create: ao 0x7f374000a950: create: how=(nil) callback=(nil) poller=0x7f3740002bb0
libxl: debug: libxl_device.c:229:libxl__device_disk_set_backend: Disk vdev=hda spec.backend=tap
libxl: debug: libxl_create.c:677:initiate_domain_create: running bootloader
libxl: debug: libxl_bootloader.c:321:libxl__bootloader_run: not a PV domain, skipping bootloader
libxl: debug: libxl_event.c:561:libxl__ev_xswatch_deregister: watch w=0x7f3740003180: deregister unregistered
libxl: debug: libxl_numa.c:435:libxl__get_numa_candidate: New best NUMA placement candidate found: nr_nodes=1, nr_cpus=4, nr_vcpus=8, free_memkb=977
libxl: detail: libxl_dom.c:192:numa_place_domain: NUMA placement candidate with 1 nodes, 4 cpus and 977 KB free selected
xc: detail: elf_parse_binary: phdr: paddr=0x100000 memsz=0x9c1a4
xc: detail: elf_parse_binary: memory: 0x100000 -> 0x19c1a4
xc: info: VIRTUAL MEMORY ARRANGEMENT:
  Loader:        0000000000100000->000000000019c1a4
  TOTAL:         0000000000000000->000000001f800000
  ENTRY ADDRESS: 0000000000100000
xc: info: PHYSICAL MEMORY ALLOCATION:
  4KB PAGES: 0x0000000000000200
  2MB PAGES: 0x00000000000000fb
  1GB PAGES: 0x0000000000000000
xc: detail: elf_load_binary: phdr 0 at 0x0x7f3756066000 -> 0x0x7f37560f901c

3), gdb log
(1), Detaching after fork from child process 5875.
[Switching to Thread 0x7fb3ad994700 (LWP 5776)]
libxlVmStart
libxl_domain_config_init
libxlBuildDomainConfig
libxl_domain_need_memory
libxl_get_free_memory
libxl_domain_create_new
libxl_domain_need_memory

Program received signal SIGABRT, Aborted.
0x00007fb3b1185b55 in raise () from /lib64/libc.so.6
(2), where
#0  0x00007fb3b1185b55 in raise () from /lib64/libc.so.6
#1  0x00007fb3b1187131 in abort () from /lib64/libc.so.6
#2  0x00007fb3b117ea10 in __assert_fail () from /lib64/libc.so.6
#3  0x00007fb3b5ff318d in libxl__build_hvm ()
   from /usr/lib64/libxenlight.so.2.0
#4  0x00007fb3b5fe895a in libxl__domain_build ()
   from /usr/lib64/libxenlight.so.2.0
#5  0x00007fb3b5fe8bda in domcreate_bootloader_done ()
   from /usr/lib64/libxenlight.so.2.0
#6  0x00007fb3b6006154 in bootloader_local_detached_cb ()
   from /usr/lib64/libxenlight.so.2.0
#7  0x00007fb3b5fde284 in local_device_detach_cb ()
   from /usr/lib64/libxenlight.so.2.0
#8  0x00007fb3b5fe00f5 in libxl__device_disk_local_initiate_detach ()
   from /usr/lib64/libxenlight.so.2.0
#9  0x00007fb3b6006300 in bootloader_callback ()
   from /usr/lib64/libxenlight.so.2.0
#10 0x00007fb3b6007689 in libxl__bootloader_run ()
   from /usr/lib64/libxenlight.so.2.0
#11 0x00007fb3b5fe9818 in do_domain_create ()
   from /usr/lib64/libxenlight.so.2.0
#12 0x00007fb3b5fe9854 in libxl_domain_create_new ()
   from /usr/lib64/libxenlight.so.2.0
#13 0x00000000004f6735 in libxlVmStart (driver=0x7fb3a400c320,
    vm=0x7fb3a403cc90, start_paused=false, restore_fd=-1)
    at libxl/libxl_driver.c:737
(3), gdb detailed message
Detaching after fork from child process 7569.
[Switching to Thread 0x7fbdd192c700 (LWP 7481)]
libxlVmStart
libxl_domain_config_init
libxlBuildDomainConfig
libxl_domain_need_memory
libxl_get_free_memory
libxl_domain_create_new
libxl_domain_need_memory
xc_hvm_build_target_mem
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd892671c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8926734 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd892674c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8926764 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd892677c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8926794 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd89267ac in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_map_foreign_range
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd892681c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_map_foreign_range
xc_map_foreign_range
xc_get_hvm_param
xc_get_hvm_param
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8f88fa9 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8f88fc8 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0
xc_set_hvm_param
#0  0x00007fbdd8b3aef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007fbdd8f88fe7 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0

Program received signal SIGABRT, Aborted.
0x00007fbdd411bb55 in raise () from /lib64/libc.so.6
(4), from above log, i can see that it fail at 
 xc_set_hvm_param(handle, domid, HVM_PARAM_HPET_ENABLED,
                     libxl_defbool_val(info->u.hvm.hpet));

(5), test pv also abort
[Switching to Thread 0x7fdc3fa4e700 (LWP 7982)]                                 
libxlVmStart                                                                    
libxl_domain_config_init                                                        
libxlBuildDomainConfig                                                          

Program received signal SIGSEGV, Segmentation fault.
0x00007fdc4228a812 in __strlen_sse2 () from /lib64/libc.so.6
(gdb) where
#0  0x00007fdc4228a812 in __strlen_sse2 () from /lib64/libc.so.6
#1  0x00007fdc4228a516 in strdup () from /lib64/libc.so.6       
#2  0x00000000004ff869 in libxlMakeDomBuildInfo (d_config=<optimized out>, 
    def=<optimized out>) at libxl/libxl_conf.c:496                         
#3  libxlBuildDomainConfig (driver=0x879ea0, def=0x8aea40,                 
    d_config=0x7fdc3fa4d6d0) at libxl/libxl_conf.c:979                     
#4  0x00000000004f6352 in libxlVmStart (driver=0x879ea0, vm=0x8a19b0,      
    start_paused=false, restore_fd=-1) at libxl/libxl_driver.c:724
is that mean it is a Vmware vm bug? 

09:44 2012-11-12
GTD
0, 9:20-18:52 19:37-21:22

1, today
1), finish reading PVH mode. see"23:50 2012-11-8"
2), work report. see"09:50 2012-11-12"
3), debug libxl xen 4.2 with Jim. see"12:12 2012-11-12"

09:50 2012-11-12
work report - week 45
1, [devel-server] work report - week 45
1), work on libvirt libxl driver xen 4.2
(1), branch from Ondrej and make it compile pass.
(2), virsh create fail while xl successful. i will continue to debug it. 
2), discuss with Jim about my libxl lock in libvirt. I will improve this patch after xen 4.2 work libvirt. 
3), read doc about xen 4.3 features and new virtualization mode(PVH: PV guest on HVM container) in xen 4.3. 

12:12 2012-11-12
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont1
1, full log while "virsh create" fail.
[Switching to Thread 0x7f2cd7b45700 (LWP 2149)]
libxlVmStart
libxl_domain_config_init
libxlBuildDomainConfig
libxl_domain_need_memory
libxl_get_free_memory
libxl_domain_create_new
libxl_domain_need_memory
xc_hvm_build_target_mem
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_map_foreign_range
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f71c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f734 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f74c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f764 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f77c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f794 in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f7ac in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_map_foreign_range
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdeb3f81c in setup_guest () from /usr/lib64/libxenguest.so.4.2
xc_map_foreign_range
xc_map_foreign_range
xc_get_hvm_param
xc_get_hvm_param
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdf1a1fa9 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdf1a1fc8 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0
xc_set_hvm_param
#0  0x00007f2cded53ef4 in xc_set_hvm_param () from /usr/lib64/libxenctrl.so.4.2
#1  0x00007f2cdf1a1fe7 in libxl__build_hvm () from /usr/lib64/libxenlight.so.2.0

Program received signal SIGABRT, Aborted.
0x00007f2cda334b55 in raise () from /lib64/libc.so.6
(gdb) where
#0  0x00007f2cda334b55 in raise () from /lib64/libc.so.6
#1  0x00007f2cda336131 in abort () from /lib64/libc.so.6
#2  0x00007f2cda32da10 in __assert_fail () from /lib64/libc.so.6
#3  0x00007f2cdf1a218d in libxl__build_hvm ()
   from /usr/lib64/libxenlight.so.2.0
#4  0x00007f2cdf19795a in libxl__domain_build ()
   from /usr/lib64/libxenlight.so.2.0
#5  0x00007f2cdf197bda in domcreate_bootloader_done ()
   from /usr/lib64/libxenlight.so.2.0
#6  0x00007f2cdf1b5154 in bootloader_local_detached_cb ()
   from /usr/lib64/libxenlight.so.2.0
#7  0x00007f2cdf18d284 in local_device_detach_cb ()
   from /usr/lib64/libxenlight.so.2.0
#8  0x00007f2cdf18f0f5 in libxl__device_disk_local_initiate_detach ()
   from /usr/lib64/libxenlight.so.2.0
#9  0x00007f2cdf1b5300 in bootloader_callback ()
   from /usr/lib64/libxenlight.so.2.0
#10 0x00007f2cdf1b6689 in libxl__bootloader_run ()
   from /usr/lib64/libxenlight.so.2.0
#11 0x00007f2cdf198818 in do_domain_create ()
   from /usr/lib64/libxenlight.so.2.0
#12 0x00007f2cdf198854 in libxl_domain_create_new ()
   from /usr/lib64/libxenlight.so.2.0
#13 0x00000000004f6735 in libxlVmStart (driver=0x800c00, vm=0x89b1c0,
    start_paused=false, restore_fd=-1) at libxl/libxl_driver.c:737
#14 0x00000000004fb982 in libxlDomainCreateXML (conn=0x8bba10,
    xml=<optimized out>, flags=0) at libxl/libxl_driver.c:1261
#15 0x00007f2cdf4c014f in virDomainCreateXML (conn=0x8bba10,
    xmlDesc=0x7f2ccc002040 "<domain type='xen'>\n  <name>sles11_hvm_10</name>\n  <description>None</description>\n  <uuid>a3e56d96-c285-90af-4bf8-136fe551292f</uuid>\n  <memory>524288</memory>\n  <currentMemory>524288</currentMemory>"...,
    flags=0) at libvirt.c:1965
#16 0x0000000000447352 in remoteDispatchDomainCreateXML (ret=<optimized out>,
    args=<optimized out>, rerr=<optimized out>, msg=<optimized out>,
    client=<optimized out>, server=<optimized out>) at remote_dispatch.h:1172
2, after add breakpoint in ioctl, it seems that fail is after ioctl. 
add libc debug info and debug source. I finally fount that the abort signal is sent after the last xc_set_hvm_param.
i still not know why it fails.

3, debug together with Jim. I see that Jim got timeout and assertion fail while virsh create pv vm. which is different from my test result. 
So, i re-test it on linux-vm4 from Jim laptop. and I got timeout and assertion fail after virsh create successful, fail at virsh list. 
1), here is my test on linux-vm4, 1st 
[Switching to Thread 0x7f44b5784700 (LWP 5738)]
libxlVmStart
libxl_domain_config_init
libxlBuildDomainConfig
libxl_domain_need_memory
libxl_get_free_memory
libxl_domain_create_new
Detaching after fork from child process 5848.
[New Thread 0x7f44be802700 (LWP 5849)]
Detaching after fork from child process 5850.
libxl_domain_need_memory
Detaching after fork from child process 5854.
Detaching after fork from child process 5874.
Detaching after fork from child process 5879.
Detaching after fork from child process 5929.
Detaching after fork from child process 5942.
[Thread 0x7f44be802700 (LWP 5849) exited]

Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7f44be7ba840 (LWP 5734)]
0x00007f44b8f75b55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
64        return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
(gdb) where
#0  0x00007f44b8f75b55 in *__GI_raise (sig=<optimized out>)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x00007f44b8f77131 in *__GI_abort () at abort.c:92
#2  0x00007f44b8f6ea10 in *__GI___assert_fail (assertion=0x7f44bddfeb63 "!r",
    file=0x7f44bddfeb52 "libxl_internal.h", line=2652,
    function=0x7f44bde07380 "libxl__ctx_lock") at assert.c:81
#3  0x00007f44bddf3f9c in libxl_osevent_occurred_timeout ()
   from /usr/lib64/libxenlight.so.2.0
#4  0x00007f44be067b6a in virEventPollDispatchTimeouts ()
    at util/event_poll.c:435
#5  virEventPollRunOnce () at util/event_poll.c:628
#6  0x00007f44be066ba6 in virEventRunDefaultImpl () at util/event.c:247
#7  0x00007f44be153d4d in virNetServerRun (srv=0x7d5d40)
    at rpc/virnetserver.c:1004
#8  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>)
    at libvirtd.c:1354
2), 2nd.
Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7f5fbb16e840 (LWP 6026)]
0x00007f5fb5929b55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
64        return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
(gdb) where
#0  0x00007f5fb5929b55 in *__GI_raise (sig=<optimized out>)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x00007f5fb592b131 in *__GI_abort () at abort.c:92
#2  0x00007f5fb5922a10 in *__GI___assert_fail (
    assertion=0x7f5fba7bac25 "fd == ev->fd",
    file=0x7f5fba7baa21 "libxl_event.c", line=1020,
    function=0x7f5fba7bb5b0 "libxl_osevent_occurred_fd") at assert.c:81
#3  0x00007f5fba7a8133 in libxl_osevent_occurred_fd ()
   from /usr/lib64/libxenlight.so.2.0
#4  0x00007f5fbaa1bda6 in virEventPollDispatchHandles (fds=<optimized out>,
    nfds=<optimized out>) at util/event_poll.c:485
#5  virEventPollRunOnce () at util/event_poll.c:631
#6  0x00007f5fbaa1aba6 in virEventRunDefaultImpl () at util/event.c:247
#7  0x00007f5fbab07d4d in virNetServerRun (srv=0x7d5d40)
    at rpc/virnetserver.c:1004
#8  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>)
    at libvirtd.c:1354

3), (19:52 2012-11-12)
re-test on physical machine, got the same fault after virsh create is successful. i do not do anything, and libvirt deamon is fail. So, it must be the timeout fail at the first time??
Program received signal SIGSEGV, Segmentation fault.
0x0000000000000000 in ?? ()
(gdb) where
#0  0x0000000000000000 in ?? ()
#1  0x00007f01a9c38f47 in libxl_osevent_occurred_timeout ()
   from /usr/lib64/libxenlight.so.2.0
#2  0x00007f01a9eacb6a in virEventPollDispatchTimeouts ()
    at util/event_poll.c:435
#3  virEventPollRunOnce () at util/event_poll.c:628
#4  0x00007f01a9eabba6 in virEventRunDefaultImpl () at util/event.c:247
#5  0x00007f01a9f98d4d in virNetServerRun (srv=0x7d5d50)
    at rpc/virnetserver.c:1004
#6  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>)
    at libvirtd.c:1354

(1), trace libxl_osevent_occurred_timeout
(2), enable print in libxl_event.c
#define DEBUG 1
print log will be written to libxl.log while using libvirt"

4), read libxl_event.c/h code.

19:45 2012-11-12
suse, build service, osc build fail
# osc build SLE_11_SP2 x86_64
Building libvirt.spec for SLE_11_SP2/x86_64
Getting buildinfo from server and store to /home/bamvor/sda3/home/novell/work/source/virtualization/libvirt/build_service/home:bjzhang:branches:home:oholecek:branches:Devel:Virt:SLE-11-SP3/libvirt/.osc/_buildinfo-SLE_11_SP2-x86_64.xml
Getting buildconfig from server and store to /home/bamvor/sda3/home/novell/work/source/virtualization/libvirt/build_service/home:bjzhang:branches:home:oholecek:branches:Devel:Virt:SLE-11-SP3/libvirt/.osc/_buildconfig-SLE_11_SP2-x86_64
Updating cache of required packages
0.0% cache miss. 215/215 dependencies cached.

Verifying integrity of cached packages
using keys from SUSE
warning: rpmts_HdrFromFdno: Header V3 DSA signature: NOKEY, key ID 8a7c64f9
/var/tmp/osbuild-packagecache/Devel:Virt:SLE-11-SP3/SLE_11_SP2/x86_64/xen-devel-4.2.0_03-5.1.x86_64.rpm : public key not available
/var/tmp/osbuild-packagecache/Devel:Virt:SLE-11-SP3/SLE_11_SP2/x86_64/xen-libs-4.2.0_03-5.1.x86_64.rpm : public key not available

20:04 2012-11-12
software skill, SCM, git, revert, remove adding file from git(not commit)
1, original status
bamvor@linux-bjrd:log> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   novell/hypervisor_and_tools/libvirt/gdbinit/20121109_libxl_create/.gdbinit
#       new file:   novell/hypervisor_and_tools/libvirt/gdbinit/20121109_libxl_create/gdb.txt
#       new file:   novell/hypervisor_and_tools/migrate/201211/1102_v4/0000-cover-letter.patch
#       new file:   novell/hypervisor_and_tools/migrate/201211/1102_v4/0001-Introduce-a-lock-for-libxl-long-running-api.patch
#       new file:   novell/hypervisor_and_tools/migrate/201211/1102_v4/0002-Add-lock-for-libxl-api.patch
#       new file:   novell/hypervisor_and_tools/migrate/201211/1102_v4/log_20121108_11_make
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       1.txt
#       libxl_qemu_compare__bamvor_20120326.txt
#       patch
#       temp.txt
#       temp1524.txt
2, remove the file under 201211/1102_v4
bamvor@linux-bjrd:log> git reset HEAD novell/hypervisor_and_tools/migrate/201211/1102_v4/*
3, result:
bamvor@linux-bjrd:log> git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#       new file:   novell/hypervisor_and_tools/libvirt/gdbinit/20121109_libxl_create/.gdbinit
#       new file:   novell/hypervisor_and_tools/libvirt/gdbinit/20121109_libxl_create/gdb.txt
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#       1.txt
#       libxl_qemu_compare__bamvor_20120326.txt
#       novell/hypervisor_and_tools/migrate/201211/
#       patch
#       temp.txt
#       temp1524.txt

09:37 2012-11-13
GTD
0, 9:25 19:48-22:50

1, today
1), build service commands. see"09:50 2012-11-13"
2), 11:23- 14:38- 19:49- debug libxl xen 4.2 with Jim. see"11:23 2012-11-13".
3), libxl xen 4.2 patch, bug list, see"20:41 2012-11-13"

09:50 2012-11-13
(20:09 2012-11-13)
build service, obs/ibs, local build, chroot
1, local build
1), clean build, will delete all files in /var/tmp/build-root/
osc build --clean
2), continue to build. maybe compile fail last time. or adding new patch since last build.
osc build --no-init
2, local build log
osc lbl
3, change to build root
ref: http://en.opensuse.org/openSUSE:Build_Service_Tutorial
osc chroot openSUSE_12.1 x86_64
build directory: /usr/src/packages/BUILD/
build result: /usr/src/packages/RPMS/

11:23 2012-11-13
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont2
1, about event fd. 
it will fail when assertion fd==ev->fd fail. but after several times test, it maybe fail even if my gdb log said that fd==ev->fd. it abnormal i guess. So, i reboot computer. 
2, after reboot computer. timeout assertion appear again. 
try to print who register the timer, i guess it is fail because the libxl library internal. 

3, read create code in both libvirt and xl cmd.
1), libxlCreateDomEvents->libxl_event_register_callbacks
libxl_event_register_callbacks is called only in the libxl driver, why?.
2), libxl_evenable_disk_eject is not called by libxl driver. 
3), about ao
ao is used by external event handling system. while libxl_event_wait is used by libxl itself. 
4), try to debug about infinite, the comment: 
    int infinite; /* not registered in list or with app if infinite */
So, maybe the error is lead by the unregistered item? 

4, event fd
Breakpoint 8, virEventPollAddHandle (fd=21, events=1, cb=0x7fced54cb610 <virNetSocketEventHandle>, opaque=0x7fcec00010b0, ff=0x7fced54cba00 <virNetSocketEventFree>) at util/event_poll.c:106
106                               virFreeCallback ff) {
Detaching after fork from child process 5556.
Detaching after fork from child process 5557.
[Switching to Thread 0x7fcecdaf1700 (LWP 5489)]

Breakpoint 8, virEventPollAddHandle (fd=37, events=5, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88ba30, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
[New Thread 0x7fced5b6e700 (LWP 5558)]

Breakpoint 8, virEventPollAddHandle (fd=42, events=5, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88bac0, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
[Switching to Thread 0x7fced5b21840 (LWP 5487)]
libxl_osevent_occurred_fd: fd<37>, ev->fd<37>
(gdb) cont
Continuing.
[Switching to Thread 0x7fcecdaf1700 (LWP 5489)]

Breakpoint 8, virEventPollAddHandle (fd=38, events=6, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88bb70, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {

Breakpoint 8, virEventPollAddHandle (fd=38, events=5, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88bb30, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {

Breakpoint 8, virEventPollAddHandle (fd=42, events=6, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88bbe0, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
Detaching after fork from child process 5559.
[Switching to Thread 0x7fced5b21840 (LWP 5487)]
libxl_osevent_occurred_fd: fd<38>, ev->fd<38>
(gdb) cont
Continuing.
libxl_osevent_occurred_fd: fd<42>, ev->fd<42>
(gdb) cont
Continuing.
[Switching to Thread 0x7fcecdaf1700 (LWP 5489)]

Breakpoint 8, virEventPollAddHandle (fd=42, events=6, cb=0x4f7bc0 <cb_fd_event>, opaque=0x883b30, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
[Switching to Thread 0x7fced5b21840 (LWP 5487)]
libxl_osevent_occurred_fd: fd<38>, ev->fd<38>
(gdb) cont
Continuing.
[Switching to Thread 0x7fcecdaf1700 (LWP 5489)]

Breakpoint 8, virEventPollAddHandle (fd=42, events=6, cb=0x4f7bc0 <cb_fd_event>, opaque=0x883b30, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
[Switching to Thread 0x7fced5b21840 (LWP 5487)]
libxl_osevent_occurred_fd: fd<42>, ev->fd<42>
(gdb) cont
Continuing.
[Switching to Thread 0x7fcecdaf1700 (LWP 5489)]

Breakpoint 8, virEventPollAddHandle (fd=42, events=6, cb=0x4f7bc0 <cb_fd_event>, opaque=0x88a840, ff=0x4f5cc0 <free_fdinfo>) at util/event_poll.c:106
106                               virFreeCallback ff) {
Detaching after fork from child process 5562.
libxl__ev_time_register_rel: ev_time=0x88c320 register ms=10000
time_register_finite
libxl__ev_time_register_rel: ev_time=0x88c358 register ms=10000
time_register_finite
Detaching after fork from child process 5568.

Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7fced5b21840 (LWP 5487)]
0x00007fced02e0b55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
64        return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
(gdb) where
#0  0x00007fced02e0b55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x00007fced02e2131 in *__GI_abort () at abort.c:92
#2  0x00007fced02d9a10 in *__GI___assert_fail (assertion=0x7fced5172229 "fd == ev->fd", file=0x7fced5171fa1 "libxl_event.c", line=1020,
    function=0x7fced5172cf0 "libxl_osevent_occurred_fd") at assert.c:81
#3  0x00007fced515fd33 in libxl_osevent_occurred_fd (ctx=<optimized out>, for_libxl=0x882ec8, fd=42, events=<optimized out>, revents=4) at libxl_event.c:1020
#4  0x00007fced53d3da6 in virEventPollDispatchHandles (fds=<optimized out>, nfds=<optimized out>) at util/event_poll.c:485
#5  virEventPollRunOnce () at util/event_poll.c:631
#6  0x00007fced53d2ba6 in virEventRunDefaultImpl () at util/event.c:247
#7  0x00007fced54bfd4d in virNetServerRun (srv=0x7d5d50) at rpc/virnetserver.c:1004
#8  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>) at libvirtd.c:1354
1), the fd is really -1 in abort frame
(gdb) where
#0  0x00007f86829a7b55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x00007f86829a9131 in *__GI_abort () at abort.c:92
#2  0x00007f86829a0a10 in *__GI___assert_fail (assertion=0x7f8687839229 "fd == ev->fd", file=0x7f8687838fa1 "libxl_event.c", line=1020,
    function=0x7f8687839cf0 "libxl_osevent_occurred_fd") at assert.c:81
#3  0x00007f8687826d33 in libxl_osevent_occurred_fd (ctx=<optimized out>, for_libxl=0x7df588, fd=38, events=<optimized out>, revents=4) at libxl_event.c:1020
#4  0x00007f8687a9ada6 in virEventPollDispatchHandles (fds=<optimized out>, nfds=<optimized out>) at util/event_poll.c:485
#5  virEventPollRunOnce () at util/event_poll.c:631
#6  0x00007f8687a99ba6 in virEventRunDefaultImpl () at util/event.c:247
#7  0x00007f8687b86d4d in virNetServerRun (srv=0x7d5d50) at rpc/virnetserver.c:1004
#8  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>) at libvirtd.c:1354
(gdb) frame 3
#3  0x00007f8687826d33 in libxl_osevent_occurred_fd (ctx=<optimized out>, for_libxl=0x7df588, fd=38, events=<optimized out>, revents=4) at libxl_event.c:1020
1020        assert(fd == ev->fd);
(gdb) p fd
$1 = 38
(gdb) p *(libxl__ev_fd*)for_libxl
$2 = {fd = -1, events = 4, func = 0x7f868781f170 <datacopier_writable>, entry = {le_next = 0x7df560, le_prev = 0x7df620}, for_app_reg = 0x7e1f10}
(gdb)

2), it looks like the function is failed after it is callled. because the next and prev is same. 
Detaching after fork from child process 6611.
[Switching to Thread 0x7fa5589cb840 (LWP 6533)]
libxl_osevent_occurred_fd: fd<38>, ev->fd<38>
$2 = {fd = 38, events = 4, func = 0x7fa558002170 <datacopier_writable>, entry = {le_next = 0x7fa544003270, le_prev = 0x7fa544003330}, for_app_reg = 0x7fa544005620}

Program received signal SIGABRT, Aborted.
0x00007fa55318ab55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
64        return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
(gdb) where
#0  0x00007fa55318ab55 in *__GI_raise (sig=<optimized out>) at ../nptl/sysdeps/unix/sysv/linux/raise.c:64
#1  0x00007fa55318c131 in *__GI_abort () at abort.c:92
#2  0x00007fa553183a10 in *__GI___assert_fail (assertion=0x7fa55801c229 "fd == ev->fd", file=0x7fa55801bfa1 "libxl_event.c", line=1020,
    function=0x7fa55801ccf0 "libxl_osevent_occurred_fd") at assert.c:81
#3  0x00007fa558009d33 in libxl_osevent_occurred_fd (ctx=<optimized out>, for_libxl=0x7fa544003298, fd=38, events=<optimized out>, revents=4) at libxl_event.c:1020
#4  0x00007fa55827dda6 in virEventPollDispatchHandles (fds=<optimized out>, nfds=<optimized out>) at util/event_poll.c:485
#5  virEventPollRunOnce () at util/event_poll.c:631
#6  0x00007fa55827cba6 in virEventRunDefaultImpl () at util/event.c:247
#7  0x00007fa558369d4d in virNetServerRun (srv=0x7d5d50) at rpc/virnetserver.c:1004
#8  0x00000000004293b4 in main (argc=<optimized out>, argv=<optimized out>) at libvirtd.c:1354
(gdb) frame 4
#4  0x00007fa55827dda6 in virEventPollDispatchHandles (fds=<optimized out>, nfds=<optimized out>) at util/event_poll.c:485
485                 (cb)(watch, fds[n].fd, hEvents, opaque);
(gdb) frame 3
#3  0x00007fa558009d33 in libxl_osevent_occurred_fd (ctx=<optimized out>, for_libxl=0x7fa544003298, fd=38, events=<optimized out>, revents=4) at libxl_event.c:1020
1020        assert(fd == ev->fd);
(gdb) p fd
$3 = 38
(gdb) p *(libxl__ev_fd*)for_libxl
$4 = {fd = -1, events = 4, func = 0x7fa558002170 <datacopier_writable>, entry = {le_next = 0x7fa544003270, le_prev = 0x7fa544003330}, for_app_reg = 0x7fa544005620}
(gdb)
3), libxl__ev_time timeout get the similar things. just once. 

5, read the fd handling relative code in order to know why fd is -1.
1), the only function set fd as -1 is libxl__ev_fd_deregister.
2), the comments, maybe useful?
datacopier_check_state()
...
    /* nothing buffered, but still reading */
    libxl__ev_fd_deregister();
3), from gdb debug, i can see that libxl_osevent_occurred_fd is called after fd deregistered. why?
the question is while fd deregister, does the read/write really done?
if so, it should be deregister issue. if not, it mean some flag is set wrong. 
it is ok if i force ignore this abort sig while access done, otherwise, libvirt or libxl will fail after i ignore this abort sig.
after i ignore this, virsh create successful 6 times. the first twice test with gdb, the other test without gdb. 

4), work around timeout with the same way. 
(1), 
void libxl_osevent_occurred_timeout(libxl_ctx *ctx, void *for_libxl)
{
    libxl__ev_time *ev = for_libxl;

    EGC_INIT(ctx);
    CTX_LOCK;
    DBG("infinite=%d", ev->infinite);
    assert(!CTX->osevent_in_hook);

    if ( 1 == ev->infinite  ) ev->infinite = 0;
    assert(!ev->infinite);
    LIBXL_TAILQ_REMOVE(&CTX->etimes, ev, entry);
    if ( ev->func ) 
        ev->func(egc, ev, &ev->abs);

    CTX_UNLOCK;
    EGC_FREE;
}

(2), it is not work. try another way
void libxl_osevent_occurred_timeout(libxl_ctx *ctx, void *for_libxl)
{
    libxl__ev_time *ev = for_libxl;

    EGC_INIT(ctx);
    CTX_LOCK;
    DBG("infinite=%d", ev->infinite);
    assert(!CTX->osevent_in_hook);

    if ( ev->infinite && !ev->func ) goto out;
    assert(!ev->infinite);
    LIBXL_TAILQ_REMOVE(&CTX->etimes, ev, entry);
    ev->func(egc, ev, &ev->abs);

out:
    CTX_UNLOCK;
    EGC_FREE;
}
(3), it seems work. it will take more than 20 seconds alive. but it will fail atthe second test. 

6, next
i need to check each abort or fault. 调用它的函数是否是应该调用的，如果是应该调用的，为什么xl里面正常，但是libvirt里面有问题? 难道又是socket问题?

19:50 2012-11-13
software skill, suse, sles11 sp2, start x11 fail, no screen found
1, remove "acpi=off" from kernel command line. it will be ok. 
thanks to Joey Zheng. 

20:03 2012-11-13
suse, sle11 sp3, stage, milestone, alpha 1 deadline
"Stefan Behlert <behlert@suse.de>"_email_"[devel] REMINDER: SLE 11 SP3 Alpha 1 deadline"_20121113_1552
Hi,

this is a reminder for the upcoming SLE 11 SP3 Alpha 1 deadline. The deadline is

for base/core packages or packages with a huge dependency list:
        Friday 16th, 15:00 CET

for leaf packages:
	Monday 19th, 17:00 CET


o Milestone: Make sure that Autobuild setup is in place and working
o Internal snapshot only, not released outside of SUSE/Novell


Currently pre-Alpha image building looks good, so we encourage everyone to
submit his/her packages early to verify that no build failure occurs.

If you have a new package that has not been on a SP2 media but should be on the
SP3 media send an email with the package name (and a reference to
FATE/Bugzilla!) to the ReleaseManager of the affected product(s):

  SLES   - Thorsten Kukuk <kukuk@suse.com>
  SLED   - Stefan Behlert <behlert@suse.com>
  SLE HA - Anja Stock <ast@suse.com>
  SDK    - Matthias Frühauf <mfrueh@suse.com>


Be also so kind to mark the feature as done in FATE after you have submitted
your work.

	thanks,
	  Your Enterprise Release Team

20:41 2012-11-13
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont3, bug list
1, hvm create fail
2, pv fail after create successful
3, pv fail after vm poweroff. 

10:23 2012-11-14
GTD
0, 9:40 12:58-14:52-18:20

1, today
1), 40' Talk with Jim. Jim introduce virtualization features in sle11 sp3. 
2), 10:44-11:40 14:54-18:20 debug libxl xen 4.2 patch. see"10:44 2012-11-14". 
3), 12:58-14:52 nap

10:44 2012-11-14
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont4
1, read the code in xenlight library and libvirt. 
libvirt will assgin different event hanles even if user register with the same fd. is that same as xenlight? 
2, libvirtd event loop
main -> virNetServerRun -> virEventRunDefaultImpl -> virEventPollDispatchHandles 
virNetServerRun will quit while loop until srv->quit true. 
"rclibvirtd restart" call /etc/init.d/libvirtd which send SIGTERM to libvirtd. such signal will be handled by daemonShutdownHandler which will srv->quilt as 1.
3, when i test with Jim. seems that fd issue show up less than i test on my seat.
4, Jim found that libxl remove the wrong timer which is not registered by libxl. the timer id is zero or negative. here is the full patch: 
> hg log -p -r 26155
changeset:   26155:babb84d9a82e
user:        Jim Fehlig <jfehlig@suse.com>
date:        Thu Nov 15 10:25:25 2012 +0000
summary:     libxl: Fix passing of application data to timeout_deregister hook

diff -r b9b4456e12d1 -r babb84d9a82e tools/libxl/libxl_event.c
--- a/tools/libxl/libxl_event.c Thu Nov 15 09:54:38 2012 +0000
+++ b/tools/libxl/libxl_event.c Thu Nov 15 10:25:25 2012 +0000
@@ -184,7 +184,7 @@ static int time_register_finite(libxl__g
 static void time_deregister(libxl__gc *gc, libxl__ev_time *ev)
 {
     if (!ev->infinite) {
-        OSEVENT_HOOK_VOID(timeout_deregister, &ev->for_app_reg);
+        OSEVENT_HOOK_VOID(timeout_deregister, ev->for_app_reg);
         LIBXL_TAILQ_REMOVE(&CTX->etimes, ev, entry);
     }
 }

5, fd is called after fd deregister, unless it is called before the cleanup function. but it is only works while the dispatch function do not notice that the fd handler is marked as delete. 

10:12 2012-11-15
GTD
0, 10:00-12:30 14:20-18:40

1, today
1), 10:19- debug libxl xen 4.2 patch. see"10:18 2012-11-15". 
2), 20' join the kernel debug discuss with Bin Li, FAN yadan, ZHAO guangliang.

10:18 2012-11-15
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont5
1, finally, i got the fix. it fix all bugs list in "20:41 2012-11-13". 
1), patch
--- xen-4.2.0-testing.origin/tools/libxl/libxl_event.c	2012-11-15 10:31:20.000000000 +0800
+++ xen-4.2.0-testing/tools/libxl/libxl_event.c	2012-11-15 10:30:16.000000000 +0800
@@ -1017,11 +1017,15 @@ void libxl_osevent_occurred_fd(libxl_ctx
     CTX_LOCK;
     assert(!CTX->osevent_in_hook);
 
+    if (!libxl__ev_fd_isregistered(ev)) {
+        DBG("ev_fd=%p deregister unregistered",ev);
+        goto out;
+    }
     assert(fd == ev->fd);
     revents &= ev->events;
     if (revents)
         ev->func(egc, ev, fd, ev->events, revents);
-
+out:
     CTX_UNLOCK;
     EGC_FREE;
 }
2), test script
/home/bamvor/log/novell/hypervisor_and_tools/libvirt/xen4.2_support/loop_test.sh

2, repeat totally 842times
2012-11-15 03:01:03.903+0000: 4309: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel

full log: 

2012-11-15 03:00:53.748+0000: 4312: info : libvirt version: 1.0.0
2012-11-15 03:00:53.748+0000: 4312: error : virCommandWait:2287 : internal error Child process (/usr/sbin/iptables --table mangle --delete POSTROUTING --out-interface virbr0 --protocol udp --destination-port 68 --jump CHECKSUM --checksum-fill) unexpected exit status 2: iptables v1.4.6: unknown option `--checksum-fill'
Try `iptables -h' or 'iptables --help' for more information.

2012-11-15 03:00:53.765+0000: 4312: error : virCommandWait:2287 : internal error Child process (/usr/sbin/iptables --table mangle --insert POSTROUTING --out-interface virbr0 --protocol udp --destination-port 68 --jump CHECKSUM --checksum-fill) unexpected exit status 2: iptables v1.4.6: unknown option `--checksum-fill'
Try `iptables -h' or 'iptables --help' for more information.

2012-11-15 03:00:53.765+0000: 4312: warning : networkAddGeneralIptablesRules:1632 : Could not add rule to fixup DHCP response checksums on network 'default'.
2012-11-15 03:00:53.765+0000: 4312: warning : networkAddGeneralIptablesRules:1633 : May need to update iptables package & kernel to support CHECKSUM rule.
2012-11-15 03:00:54.141+0000: 4312: warning : virSecurityManagerNew:148 : Configured security driver "none" disables default policy to create confined guests
2012-11-15 03:00:54.142+0000: 4312: error : virNodeParseNode:290 : internal error CPU socket topology has changed
2012-11-15 03:00:54.142+0000: 4312: warning : qemuCapsInit:847 : Failed to get host CPU
2012-11-15 03:01:03.903+0000: 4309: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel
2012-11-15 03:01:05.121+0000: 4304: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel
...
2012-11-15 04:02:45.318+0000: 4307: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel
2012-11-15 04:02:47.517+0000: 4304: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel
2012-11-15 04:03:04.903+0000: 4304: error : libxlVmStart:747 : internal error libxenlight failed to create new domain 'sles11_sp2_pv'

9:03 2012-11-16
company, virtualization, suse, xen, regular meeting: US / China Virtualization Sync, meeting
1, bruce:
iscsi. kernel backport?
qemu 1.3
2, Bo yang
1), macvtype
2), bug: not virtualization work.
3, Lin ma
1), kvm, libvirt auto test.
CI on ibs sp3. how to trigger after ibs build successful.
4, Chunyan liu
1), add new api in libxl.
2), fate: send patch to upstream for review.
3), pci pass through. talk with Jim.
5, bamvor
1), libvirt libxl xen4.2. found one bug in xenlight library and prepare to write patch to xen community.
2), dicuss with jim about lock patch.
6, jim
prepare libvirt package for sp3 alpha 1.

11:10 2012-11-16
GTD
0, 8:50-22:30

1, today
1), 9:00-9:40 US/China Sync meeing. see"8:03 2012-11-16".
2), talk with Jim. see"11:13 2012-11-16"
3), lunch and learning, Jim, openstack. see"12:07 2012-11-16"
4), write patch for xenlight library. see"14:55 2012-11-16"
5), test xen on kvm. see"22:03 2012-11-16"


11:13 2012-11-16
virtualization, Jim, talk
1, why choose libvirt 1.0.2 and qemu 1.3?
balancing between patch and update risk. the maintainer need to check each commit between the sp2 and sp3 version and ensure backport important bugfix from newer than sp3 packages.
If libvirt 1.0.2 release before 15, Jun(sle11 sp3 beta, which mean features freeze). 
2, if i have time, i could check the openstack request which need add managed save code in libvirt xen legacy driver. 
the managed save means that caller does not give save location for libvirt. libvirt should decided itself. than tell to the hypervisor which location should save. 
3, Jim want to talk with me through im serveral days once. 
He said sorry that he was so busy that he do not have time to communicate with me. 

12:07 2012-11-16
cloud, openstack, Jim
1, nova
support kvm, qemu, libxl, lxc through libvirt, support xenserver, hyper-v and other non open souce through seperate drivers. 
2, image metadata

14:55 2012-11-16
(10:02 2012-11-19)
virtualization, libvirt, xen, xenlight, libxl, xen4.2 support, cont6, write the patch for xen upstream
1, comment
fix race condition between libvirtd event handling and libxl fd deregister

the race condition may be encounted at the following senaro: 
(1), xenlight will remove fd handle just after the transfer is done according to
the buffer pointer. this action will first mark fd handle delete in libvirtd
then remove fd handler from list in libxl. the action mark as delete depend on
libvirt mutex(virMutexLock). 
(2), meanwhile in the libvirt event dispatch process libvirt will check the
delete flag in libvirt mutex, at this time, "(1)" may be blocked before mark
delete flag. then libvirt release its mutex temperary for callback running.
but this callback need xenlight lock(CTX_LCOK) which is got by xenlight fd
deregister functin. So, libvirtd will continue to run this callback after fd
register exit which means xenlight has been marked delete flag, removed this fd
handler and set ev->fd as -1. after libxl__ev_fd_deregister exit, it is time for
callback running. but unfortunately, this callback has been removed as I
mentioned above. 

reference the following graph: 
libvirt event dispatch                  xenlight transfer done
       |                              enter libxl__ev_fd_deregister
       |                                     CTX_LOCK
       |                                         |
       |                                         |
       |                              enter osevent_fd_deregister
       |                                         |
       |                              enter virEventRemoveHandle
       |                                waiting virMutexLock
check handler delete flag                        |
virMutexUnlock                                   |
       |                                    virMutexLock
enter libxl_osevent_occurred_fd                  |
waiting CTX_LOCK                          mark delete flag
       |                                   virMutexUnlock
       |                                         |
       |                                exit virEventRemoveHandle
       |                                exit osevent_fd_deregister
       |                                         |
       |                                remove fd handler from list
       |                                   set ev->fd as -1
       |                                     CTX_UNLOCK
   CTX_LOCK
assert(fd==ev->fd) //lead to crash
call back in libxl
   CTX_UNLOCK
exit libxl_osevent_occurred_fd

at the same time, i found the times of file handler register is less than the times of file handler deregister. is that right? seems that it will be better if the register and deregister is paired. 

--- xen-4.2.0-testing.origin/tools/libxl/libxl_event.c	2012-11-15 10:31:20.000000000 +0800
+++ xen-4.2.0-testing/tools/libxl/libxl_event.c	2012-11-15 10:30:16.000000000 +0800
@@ -1017,11 +1017,15 @@ void libxl_osevent_occurred_fd(libxl_ctx
     CTX_LOCK;
     assert(!CTX->osevent_in_hook);
 
+    if (!libxl__ev_fd_isregistered(ev)) {
+        DBG("ev_fd=%p deregister unregistered",ev);
+        goto out;
+    }
     assert(fd == ev->fd);
     revents &= ev->events;
     if (revents)
         ev->func(egc, ev, fd, ev->events, revents);
-
+out:
     CTX_UNLOCK;
     EGC_FREE;
 }

2, thinking:
1), Q: if transfer is done. why there still new event will be dispatched?
A: maybe this event is just a timeout poll event. 
2), try to improve it: check the libxl.log and pull timeout value. 
Sadly, it is POLLOUT not timeout: 
39:libxl_osevent_occurred_fd: fd<43>, ev->fd<-1>, revents<4>, ev->events<4>
55:libxl_osevent_occurred_fd: fd<43>, ev->fd<-1>, revents<4>, ev->events<4>
63:libxl_osevent_occurred_fd: fd<43>, ev->fd<-1>, revents<4>, ev->events<4>
92:libxl_osevent_occurred_fd: fd<38>, ev->fd<-1>, revents<4>, ev->events<4>
96:libxl_osevent_occurred_fd: fd<43>, ev->fd<-1>, revents<4>, ev->events<4>
3), So, what does libvirt want to write after xenlight library think it transfer is over? \TODO

3, rest meterial
meanwhile in the libvirt event dispatch process libvirt will check the delete flag in libvirt mutex, then release its mutex temperary for callback running. maybe this callback will call the function registered in the xenlight library list which I mentioned above. 
the race condition between "(1)" and "(2)" will be encountered at the following condition: the delete flag is marked after libvirtd delete flag check. at this time, libvirtd will be blocked by xenlight library lock(CTX_LOCK) after invoking callback function. So, xenlight library will remove fd handler event from list. after fd handler removing is done, xenlight library will release CTX_LOCK. At this time, libvirtd finally got the CTX_LOCK then execute the assertion and actual callback function which has been removed by the xenlight library. 

4, send as patch
ref: "11:24 2012-04-28"

21:51 2012-11-16
software skill, linux, storage, build disk image, mount disk image; dd; kpartx
linux-iwgo:dd if=/dev/zero of=disk0.raw bs=1024k count=0 seek=2048
linux-iwgo:/var/lib/kvm/images/disk1 # fdisk disk0.raw
Welcome to fdisk (util-linux 2.21.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x25f16ceb.

Command (m for help): p

Disk disk0.raw: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders, total 4194304 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x25f16ceb

    Device Boot      Start         End      Blocks   Id  System

Command (m for help): c
DOS Compatibility flag is set (DEPRECATED!)

Command (m for help): c
DOS Compatibility flag is not set

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-4194303, default 2048):
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-4194303, default 4194303):
Using default value 4194303
Partition 1 of type Linux and of size 2 GiB is set

Command (m for help): p

Disk disk0.raw: 2147 MB, 2147483648 bytes
255 heads, 63 sectors/track, 261 cylinders, total 4194304 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x25f16ceb

    Device Boot      Start         End      Blocks   Id  System
disk0.raw1            2048     4194303     2096128   83  Linux

Command (m for help): w
The partition table has been altered!

Syncing disks.
linux-iwgo:/var/lib/kvm/images/disk1 # kpartx -av disk0.raw
add map loop1p1 (253:0): 0 4192256 linear /dev/loop1 2048
linux-iwgo:/var/lib/kvm/images/disk1 # mount /dev/mapper/loop0p1 disk
mount: unknown filesystem type '(null)'
linux-iwgo:/var/lib/kvm/images/disk1 # mke2fs /dev/mapper/loop0p1
mke2fs 1.42.4 (12-June-2012)
Discarding device blocks: done
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
131072 inodes, 524032 blocks
26201 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=536870912
16 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912

Allocating group tables: done
Writing inode tables: done
Writing superblocks and filesystem accounting information: done

linux-iwgo:/var/lib/kvm/images/disk1 # mount /dev/mapper/loop0p1 disk
linux-iwgo:/var/lib/kvm/images/disk1 # df -h
Filesystem           Size  Used Avail Use% Mounted on
rootfs                18G  9.1G  8.0G  54% /
devtmpfs             1.5G   92K  1.5G   1% /dev
tmpfs                1.5G  380K  1.5G   1% /dev/shm
tmpfs                1.5G  848K  1.5G   1% /run
/dev/sda2             18G  9.1G  8.0G  54% /
tmpfs                1.5G     0  1.5G   0% /sys/fs/cgroup
tmpfs                1.5G  848K  1.5G   1% /var/run
tmpfs                1.5G  848K  1.5G   1% /var/lock
tmpfs                1.5G     0  1.5G   0% /media
/dev/mapper/loop0p1  2.0G   24K  1.9G   1% /var/lib/kvm/images/disk1/disk
linux-iwgo:/var/lib/kvm/images/disk1 # mke2fs /dev/mapper/loop0p1 ^C

22:03 2012-11-16
virtualization, kvm, xen, xen on kvm
1, nested kvm
1), reference
Nested Virtualization with KVM Intel
http://kashyapc.wordpress.com/2012/01/14/nested-virtualization-with-kvm-intel/
Nested kvm guests
http://s3hh.wordpress.com/2012/01/19/nested-kvm-guests/
KVM-ON-KVM：Nested Virtualization
http://www.liangsuilong.info/?p=851
2), qemu-kvm configuration
using host-model for enable vmx
host-model
http://libvirt.org/formatdomain.html#elementsCPUTuning
The host-model mode is essentially a shortcut to copying host CPU definition from capabilities XML into domain XML. Since the CPU definition is copied just before starting a domain, exactly the same XML can be used on different hosts while still providing the best guest CPU each host supports. Neither match attribute nor any feature elements can be used in this mode. Specifying CPU model is not supported either, but model's fallback attribute may still be used. Libvirt does not model every aspect of each CPU so the guest CPU will not match the host CPU exactly. On the other hand, the ABI provided to the guest is reproducible. During migration, complete CPU model definition is transferred to the destination host so the migrated guest will see exactly the same CPU model even if the destination host contains more capable CPUs for the running instance of the guest; but shutting down and restarting the guest may present different hardware to the guest according to the capabilities of the new host.

linux-iwgo:/etc/kvm/vm # diff -urp sles11.xml.origin sles11.xml
--- sles11.xml.origin   2012-11-16 22:05:12.778853822 +0800
+++ sles11.xml  2012-11-16 21:39:08.726723088 +0800
@@ -3,6 +3,8 @@
   <uuid>1c53d314-c929-3f33-81c7-50d9be804c89</uuid>
   <memory>524288</memory>
   <currentMemory>524288</currentMemory>
+  <cpu mode='host-model'>
+  </cpu>
   <vcpu>2</vcpu>
   <os>
     <type arch='x86_64' machine='pc'>hvm</type>

22:23 2012-11-17
gsoc
run opensuse on android through chroot.
it is useful for suse users. lots of command could be used in Android device without headache Android application.

09:57 2012-11-19
GTD
0, 9:40-11:44 17:45

1, today
1), 10:03-11:14 write patch for xenlight library. see"14:55 2012-11-16"
2), 11:24-11:44 12:50-13:38 work report. see"11:24 2012-11-19"
3), check the feature request from Jim. see"13:21 2012-11-19". 
4), work on libvirt manage save for xen legacy. see"13:37 2012-11-19"
5), 20' talk with Jiaju. about the work in last week. 
6), 30' discuss with GuanJun about arm Cortex-A15 server. 

2, next
2), work on libvirt upstream for manage save of xen legacy. ref"13:37 2012-11-19"
1), gsoc: "22:23 2012-11-17"
2), check the error from "10:18 2012-11-15"2
2012-11-15 04:02:45.318+0000: 4307: error : virNodeGetSecurityModel:9567 : this function is not supported by the connection driver: virNodeGetSecurityModel
3), ask jim to invite me to xen irc. 
4), fix bug: https://bugzilla.novell.com/show_bug.cgi?id=789275
seems came from bridge-utils
5), try to fix osc build fail. see"19:45 2012-11-12".

3, next next
1), notes about Huawei from eet-china.
2), read bug:https://bugzilla.novell.com/show_bug.cgi?id=781425 

2, next
1), try to improve attach-disk, detach-disk in libxl driver, see"18:17 2012-11-07"4
2), test attach-disk command. see"10:41 2012-10-30"2
3), maybe libxl and qemu could communicate with qemu through xenstore?

libxl_dm.c: 
        /* Find uuid and the write the vnc password to xenstore for qemu. */
        t = xs_transaction_start(ctx->xsh);
        vm_path = libxl__xs_read(&gc,t,libxl__sprintf(&gc, "%s/vm", p->dom_path));
        if (vm_path) {
            /* Now write the vncpassword into it. */
            pass_stuff = libxl__calloc(&gc, 3, sizeof(char *));
            pass_stuff[0] = "vncpasswd";
            pass_stuff[1] = info->vncpasswd;
            libxl__xs_writev(&gc,t,vm_path,pass_stuff);

3, for Jim
1), xenlight event lock in libvirt. see"16:52 2012-11-06"2-1). 

4, next month
1), opensuse on MK802
(1), generate the 512MB version with opensuse12.2 RC2 which enable yast fist run. 
(2), try opensuse based on ubuntu kernel in order to solve the error from miniand. 
2), try armv8 emulator and read armv8 kernel code.  

11:24 2012-11-19
work report - week 46
1, [devel-server] work report - week 46
1), work on libvirt xen4.2 support with Jim.
afte debuging, i find a race conditon in xenlight library which lead to PV guest create fail in my test. after fix this bug with the other Jim's fix, vm create, reboot, shutdown is ok during 117 times test(Once test means vm create, reboot, shutdown and vm is alive after create or reboot). 
Jim think it is a reasonable fix but complex to understanding. So, he will help me review my patch which i had sent today. 
2), talk with Jim. Jim introduce the features and status of virtuazalition in sle11 sp3. it is great for me to know more in virtualization special in libvirt. 
3), lunch and learning about Openstack and SUSE Cloud from Jim.

13:21 2012-11-19
virtualization, libvirt, xen, xend, support management save, bugzilla
https://bugzilla.novell.com/show_bug.cgi?id=782311
1, Tilman Beitter 2012-09-26 14:18:51 UTC
Created an attachment (id=507203) [details]
log snippet from compute.log

User-Agent:       Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:15.0) Gecko/20100101
Firefox/15.0.1

With Xen as HV it is not possible to create snapshots of Cloud Guests.
The snapshot get's status "queued" within the Openstack Dashboard and is
then stuck there.

Checking Nova's compute.log I found this error:

"libvirtError: this function is not supported by the connection driver:
virDomainManagedSave" (full log attached)

I testet the whole environment with the same configurations and options,
but with KVM as HV, and both things work.

Reproducible: Always

Steps to Reproduce:
1. setup SUSE Cloud with Xen as HV (nova proposal)
2. launch any instance
3. take a snapshot of any instance
4. check status of the snapshot
5. check nova Log on compute node
Actual Results:  
snapshots get queued and nova compute.log reports errors.

Expected Results:  
snapshot should be done.

2, Jim
IMO, it would be better to see if we can implement the domainManagedSave,
domainHasManagedSaveImage, and domainManagedSaveRemove functions in the legacy
libvirt xen driver instead of introducing xen-specific hacks in the nova
libvirt driver.

Adding Chunyan and Bamvor as one of them may be able to help with this work.

13:37 2012-11-19
virtualization, libvirt, xen, xend, support management save, bugzilla, cont1
1, read libxl code
domainManagedSave, domainHasManagedSaveImage, and domainManagedSaveRemove.
1), libxlDomainManagedSavePath called by libxlVmStart, libxlDomainUndefineFlags
2), domainManagedSaveLoad: call libxlDomainMangedSavePath and virFileExists. 
3), domainHasManagedSaveImage: return vm->hasManagedSave
4), domainManagedSaveLoad: ?
5), domainManagedSaveRemove: libxlDomainMangedSavePath and unlink.
6), alloc and set saveDir in libxlStartUp. and free it in libxlShutDown. 
7), restore managed save in libxlVmCreate
8). define LIBXL_SAVE_DIR
2, it looks like it is not difficult to implement. try to finish code today. 
3, add code in xen/xen_driver.c
1), no xen driver lock? 
2), do i need to set vm->hasManagedSave during domainManagedSave? qemu does, but libxl does not. 
3), there is not Startup and ShutDown State function in xen. 
check xm_internal.c and xen_inotify.c, it seems that should add into xm_internal.c
check xenXMConfigCacheRefresh, xenXMOpen, xenXMLDomainDefineXML
after reading some code, i decided to add these in initialize and cleanup function in xen state_driver. hope it work. 

22:33 2012-11-19
GTD
1, work plan
1), work on xen arm HVM. 
(1), learn build service and kiwi, build allwinner A10 image.
(2), read xen arm code. running xen arm on arm cortex-a15 simulator.
(3), port xen to allwinner cortex-a7.
