10:16 2009-7-1
Linux, fedora11下载地址
http://mirrors.kernel.org/fedora/releases/11/Fedora/i386/iso/

13:18 2009-7-1
目前最晚一次下班是2009年4月14日 03:30. 

16:36 2009-7-1
VC0816, SV, COB176, COB封装成品率, <TODO>关注进展</TODO>
1, Chen Ying邮件"答复: 关于fail的816 COB板"20090630_0957, 没有发给我. 
Hi！Fengbeizhan，
别忘了测试一下所有的20块COB板：）多谢！工厂在催我们反馈成品率。COB板分下面三类：
1）正常生产的：一共有16块，好像已经有3块有问题了
2）调机的那两块（请在板上标识一下）
3）8mil wire的那两块（请在板上标识一下）
下周三下班前请把这20块COB板都用一下，把无法正常使用的返给zouweiran，我们将在下周四或下周五安排FA进行分析，研究是否是COB bonding的问题。

另外8mil bonding 的两块COB帮助try一下SDRAM的速度，看是否和正常板子有区别。这个有时间的时候，帮助安排一下就行。不需要一定周三前。当然早更欢迎。

2, FengBeiZhan邮件"答复: 关于fail的816 COB板"20090701_1618
除去以前坏了的，目前我们手里一共有18块；测试结果有5块有问题；具体如下：
1) 调机：共3块，坏2块；
2) 8mil：共2块，坏1块；
3) normal：共13块，坏2块；
另：8mil的速度比较差，且速度不稳定，在cpu 300多时容易出现错误；
所有坏了的板子，已经移交给zouweiran；

bamvor, 注: 
1, 后来确认是0.8mil不是8mil(1mil = 0.0254cm), 其它bonding线似乎是大于300u(0.3mm)的. 
2, beizhan最后几个cpu板的频率是用我的autoswitch命令测试的. 

17:00 2009-7-1
VC0816, VC0830, 开发环境, 编译选项, -m, <TODO>文档, 总结</TODO>
816, 830项目中eclipse中build参数中"-m"后面的模块必须用","分隔, 用空格"-m=m1 m2", 不会报错, 但是m2不会编译

17:16 2009-7-1
Android, kernel, 文档
之前一直没怎么看android, 今天进一步看了看, 而且找到了android内核配置文件. 
我硬盘上Android根目录: O:\bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\消费电子产品\手机设计\手机方案_Android等\Android
1, 运行emulator及kernel启动log:
PATH="$PATH:$HOME/android/out/host/linux-x86/bin"
ANDROID_PRODUCT_OUT=$HOME/android/out/target/product/generic
export ANDROID_PRODUCT_OUT
cd $HOME/android/out/target/product/generic
emulator  -show-kernel
其中"-show-kernel"表示打出kernel启动log. 可以用"-image system.img  -data userdata.img -ramdisk ramdisk.img"指定映像. 我感觉emulator自动使用了"prebuilt\android-arm\kernel\kernel-qemu"作为Linux kernel映像. 因为使用"emulator  -show-kernel -kernel ..\..\..\..\prebuilt\android-arm\kernel\kernel-qemu"的内核启动信息相同. 
从log可以看出内核是使用gcc4.2.1编译的2.6.25内核.

2, 工具链:
android目录: prebuilt\linux-x86\toolchain, 里面有arm 4.2.1和4.3.1 需要知道android编译2.6.29内核用的是哪个. "如何构建Android 1.5 Linux内核映像"的作者使用4.2.1编译的android 2.6.27. 

3, 内核
emulator启动后用"$adb pull /proc/config.gz ~/"得到当前内核的配置文件. 可以看到里面选择是MACH是goldfish. 内核配置文件: "Android\android_kernel_2.6.25_config"
abd是个调试工具. 用"adb shell"可以进入shell. 

4, log如下: 
Uncompressing Linux.................................................................................... done, booting the kernel.
Linux version 2.6.25-00350-g40fff9a (android-build@apa27.mtv.corp.google.com) (gcc version 4.2.1) #1 Wed Jul 23 18:10:44 PDT 2008
CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=00003137
Machine: Goldfish
Memory policy: ECC disabled, Data cache writeback
CPU0: D VIVT write-through cache
CPU0: I cache: 4096 bytes, associativity 4, 32 byte lines, 32 sets
CPU0: D cache: 65536 bytes, associativity 4, 32 byte lines, 512 sets
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 24384
Kernel command line: qemu=1 console=ttyS0 android.checkjni=1 android.qemud=ttyS1 android.ndns=1
Unknown boot option `android.checkjni=1': ignoring
Unknown boot option `android.qemud=ttyS1': ignoring
Unknown boot option `android.ndns=1': ignoring
PID hash table entries: 512 (order: 9, 2048 bytes)
Console: colour dummy device 80x30
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Memory: 96MB = 96MB total
Memory: 94268KB available (2380K code, 445K data, 100K init)
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
net_namespace: 152 bytes
android_power_init
android_power_init done
NET: Registered protocol family 16
NET: Registered protocol family 2
IP route cache hash table entries: 1024 (order: 0, 4096 bytes)
TCP established hash table entries: 4096 (order: 3, 32768 bytes)
TCP bind hash table entries: 4096 (order: 2, 16384 bytes)
TCP: Hash tables configured (established 4096 bind 4096)
TCP reno registered
checking if image is initramfs... it is
Freeing initrd memory: 141K
goldfish_new_pdev goldfish_interrupt_controller at ff000000 irq -1
goldfish_new_pdev goldfish_device_bus at ff001000 irq 1
goldfish_new_pdev goldfish_timer at ff003000 irq 3
goldfish_new_pdev goldfish_rtc at ff010000 irq 10
goldfish_new_pdev goldfish_tty at ff002000 irq 4
goldfish_new_pdev goldfish_tty at ff011000 irq 11
goldfish_new_pdev smc91x at ff012000 irq 12
goldfish_new_pdev goldfish_fb at ff013000 irq 13
goldfish_new_pdev goldfish_audio at ff004000 irq 14
goldfish_new_pdev goldfish_memlog at ff006000 irq -1
goldfish_new_pdev goldfish-battery at ff014000 irq 15
goldfish_new_pdev goldfish_events at ff015000 irq 16
goldfish_new_pdev goldfish_nand at ff016000 irq -1
goldfish_new_pdev goldfish-switch at ff017000 irq 17
goldfish_new_pdev goldfish-switch at ff018000 irq 18
goldfish_pdev_worker registered goldfish-switch
goldfish_pdev_worker registered goldfish-switch
goldfish_pdev_worker registered goldfish_nand
goldfish_pdev_worker registered goldfish_events
goldfish_pdev_worker registered goldfish-battery
goldfish_pdev_worker registered goldfish_memlog
goldfish_audio_probe
goldfish_pdev_worker registered goldfish_audio
goldfish_pdev_worker registered goldfish_fb
goldfish_pdev_worker registered smc91x
goldfish_pdev_worker registered goldfish_tty
goldfish_pdev_worker registered goldfish_tty
goldfish_pdev_worker registered goldfish_rtc
goldfish_pdev_worker registered goldfish_timer
goldfish_pdev_worker registered goldfish_device_bus
goldfish_pdev_worker registered goldfish_interrupt_controller
ashmem: initialized
Installing knfsd (copyright (C) 1996 okir@monad.swb.de).
yaffs Jul 23 2008 18:10:35 Installing. 
io scheduler noop registered
io scheduler anticipatory registered (default)
io scheduler deadline registered
io scheduler cfq registered
allocating frame buffer 320 * 480, got ffc10000
Console: switching to colour frame buffer device 40x30
console [ttyS0] enabled
brd: module loaded
loop: module loaded
nbd: registered device at major 43
smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <nico@cam.org>
No IRQF_TRIGGER set_type function for IRQ 12 (goldfish)
eth0: SMC91C11xFD (rev 1) at c6800000 IRQ 12 [nowait]
eth0: Ethernet addr: 52:54:00:12:34:56
goldfish nand dev0: size 4000000, page 2048, extra 64, erase 131072
goldfish nand dev1: size 4000000, page 2048, extra 64, erase 131072
goldfish nand dev2: size 4000000, page 2048, extra 64, erase 131072
mice: PS/2 mouse device common for all mice
*** events probe ***
events_probe() addr=0xc6804000 irq=16
events_probe() keymap=qwerty2
input: qwerty2 as /class/input/input0
goldfish_rtc goldfish_rtc: rtc core: registered goldfish_rtc as rtc0
logger: created 64K log 'log_main'
logger: created 64K log 'log_events'
logger: created 64K log 'log_radio'
IPv4 over IPv4 tunneling driver
GRE over IPv4 tunneling driver
TCP cubic registered
NET: Registered protocol family 1
NET: Registered protocol family 17
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
802.1Q VLAN Support v1.8 Ben Greear <greearb@candelatech.com>
All bugs added by David S. Miller <davem@redhat.com>
VFP support v0.3: implementor 41 architecture 1 part 10 variant 9 rev 0
goldfish_rtc goldfish_rtc: setting system clock to 2009-04-13 04:33:08 UTC (1239597188)
Freeing init memory: 100K
init: cannot open '/initlogo.rle'
yaffs: dev is 32505856 name is "mtdblock0"
yaffs: passed flags ""
yaffs: Attempting MTD mount on 31.0, "mtdblock0"
yaffs: dev is 32505857 name is "mtdblock1"
yaffs: passed flags ""
yaffs: Attempting MTD mount on 31.1, "mtdblock1"
yaffs: dev is 32505858 name is "mtdblock2"
yaffs: passed flags ""
yaffs: Attempting MTD mount on 31.2, "mtdblock2"
sh: can't access tty; job control turned off
# init: cannot find '/system/bin/playmp3', disabling 'bootsound'
eth0: link up
warning: `rild' uses 32-bit capabilities (legacy support in use)

注: log是200901下载的android代码编译出的, 
位置"zhangjian_Android编译运行\android_bootlog.txt";

参考:
1, (已下载), 如何构建Android 1.5 Linux内核映像.
http://www.williamhua.com/2009/04/30/how-to-build-android-15-kernel-image/#more-142
2, Android源代码编译一次成功，非常幸运=+.txt 

20:05 2009-7-1
VC0830, Linux移植, 讨论, <TODO>更新</TODO>
摘自"s3c2440 Linux移植分析_V0.2.doc"
zhangjian邮件"答复: 新一带的平台开发启动"20090701_2007
结合之前大家讨论, 我更新了Linux内核移植文档并上传至36服务器(Share\Linux\doc\s3c2440 Linux移植分析_V0.2.doc),  主要更新了如下内容: 

1), hostPC: 移植需要PC是Linux环境, 没有网络情况下ubuntu安装库非常不方便, 考虑用fedora 11(已下载, zhangjian用fedora 10编译过2009/1的android, 比较顺利)做Linux服务器, 便于大家在工位和实验室编译, 修改内核/驱动.
服务器有如下功能: xmanager远程登录, 编译arm Linux内核, svn服务器(用于Linux内核开发, android开发等), 调试(还没考虑好)

2), toolchain: 最新的Linux2.6内核适合使用gcc4. Android prebuild包中有4.2.1和4.3.1两个编译器, 需要确认编译android 2.6.29是哪个编译器. 将来如果需要可以用"crosstool"工具编译我们所需版本的工具链;

4), 内核（kernel）
内核移植初期需要支持uart, timer, clock,中断这四个模块, 内核启动完成后(预计需要2个人月), 一方面建立文件系统, 一方面开始其它模块driver开发.
(1), 内核版本
综合如何几方面因素选定内核版本: 内核变动情况, 是否支持Android, 内核代码是否清晰易读, 内核相关资料.
u       内核变动情况: Linux2.6.25有较大变动, 2.6.25之后的内核变动相对较小.
u       是否支持Android: android支持的内核有2.6.25, 2.6.27, 2.6.29.
u       内核代码是否清晰易读: Liaozhicheng看过2.6.28代码后认为, 内核代码比原来清楚很多, 目录划分更为合理.
u       内核相关资料: 2.6内核较多资料是2.6早期资料, 与现在差异较大, 2.6.25及其之后的内核资料多寡差异不大.
综合考虑, 认为2.6.29内核最适合当前学习和移植, 同时用这个版本的内核支持android较为容易. 
注: 之前Zhangjian分析过Linux2.6.25.20.内核的s3c2440移植, Liaozhicheng看过2.6.28内核启动代码. 
(2), 内核移植

如前所述主要是对clock, interrupt, timer, uart四部分的支持, 需要了解内核启动过程. 第四章Linux内核移植分析是对2.6.25.20内核中s3c2440做的分析. 

这部分中Linux interrupt结构清晰, 做填空题就可以. 

Uart也比较清楚, 后文分析也比较到位. 四部分中难度最小 

Timer: 涉及到不同的实现方式, 2440中实现方式不好, 考虑用linux通用方式;

Clock: 模块时钟管理, 不切频情况下主要是时钟注册和配置,. 目前830中clock管理使用了与Linux kernel类似的方式. 和将来power manager关系很紧密, 切频code可以从830中移植. 

计划下一步2个人用5-7个工作日分析完goldfish 移植分析, 同时了解内核启动过程. 结合前面2440分析, 定出移植计划. 再用10个工作日完成内核移植. 总共约需要17-20个工作日, 即两个人月. 

如果不能用jtag调试, 只能用kernel提供的串口low level print接口, 用print调试. 
(3), driver

内核启动后移植如下driver, 以lcd framebuffer driver工作量为1. 

模块 工作量 所需接口, 库 Notes
lcd(lcdc, lcdif, ipp等) 1 Framebuffer 
Storage: sd 1 Sd 有sd卡后, 做demo比较方便
Network 1.5 Usb garbage 有网络后, 使用NFS调试文件系统比较方便
audio 0.7 Alsa, alsa-lib Alsa库提供了audio操作函数, audio测试可以用脚本调用alsa命令实现
Sensor 0,7 V4l2 Video for Linux 2, 用于tuner和视频采集的接口,  
Cmmb 1.7 V4l2 V4l2只支持dvb, 对cmmb完全没有支持, 可能难度较大.
Video codec 2 Gstreamer Gstreamer是Linux中最常用的一种多媒体库. 需要了解android使用的何种库
Power manager ? ?, sysfs 电源管理在kernel中比较复杂, 考虑参考android的方式
Kpd 0.3 Input Input device抽象了所有输入设备
Tpi 0.4 Input 
Spi 0.6 Spi 

(4), 内核调试方法, 关键是内核启动过程中如何调试. 

(5), Android code

2009年1月15日的Android全部代码已放到性下面目录: \\10.0.2.36\sqmshare\Share\Linux\android\Android_git_200901015

2009年6月25日 Android代码位于: “Share\Linux\android\Android_git_20090625_0018”, 

Linux驱动的开发/移植在内核启动后开始。

Goldfish 2.6.29代码:

 “Share\Linux\android\ goldfish_common-b10edef14984cc56182d8014815a4e47518c2cdc.tar.gz

12:47 2009-7-2
36服务器似乎出问题了

12:47 2009-7-2
<TODO>caijin BGA282, sdramSamsung, 完全无法切频 </TODO>邮件20090702_1244
1, 用我自己176LQFP封装实验: 
确认了是SV板, BGA282 , sdramSamsung配置. 
切240_120会死, 336_168也会死. 
2, autoswitch: cpu->bus=12->168, step=4,
发现60MHz(不含)以下可以, 以上就直接没波形了, 感觉是没拿到参数, 也没有中止切频. 
3, 用rvdebug跟踪发现, 不是memory参数问题. 死在:
Clkrst_SwitchXclk的
if      ( XCLK_ID != curClockSwitchInfo->clksource_index ) {
这句话本身肯定没问题, curClockSwitchInfo指针和curClockSwitchInfo->clksource_index都对. 汇编是: 
>>> CLKRST_APP_SWITCH\#479         if      ( XCLK_ID != curClockSwitchInfo->clksource_index ) {
   00026F1C E59D3000  LDR      r3,[r13,#0]
   00026F20 E5933000  LDR      r3,[r3,#0]
   00026F24 E3530003  CMP      r3,#3
   00026F28 0A000004  BEQ      0x26f40                    <Clkrst_SwitchXclk+0x8C>
"LDR      r3,[r13,#0]"是从栈上读这个变量. 应该也没问题. 
4, 后来这里也没问题了. 在set sdr adj函数调用前或执行第一条语句时出错, 汇编代码完全错了. 
5, 查不出问题, 比较"20090616_1801_代码整理前最终"和最新CVS code差异. 
<TODO></TODO>

14:33 2004-7-2
VC0816, 
1, me需要支持27MHz, 24MHz-22MHz;
2, 现在autotest需要切频. 把pclk放在pll11. 
3, CVS:
zhangjian, clkrst: clkswitch; video: panel
支持设置pclk在pll1上, 这样保证panel和audio可以同时使用. 
4, CVS log:
Checking in clkrst/app/clkrst_app.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app.c,v  <--  clkrst_app.c
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/app/clkrst_app_module_clock.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_module_clock.c,v  <--  clkrst_app_module_clock.c
new revision: 1.9; previous revision: 1.8
done
Checking in clkrst/app/clkrst_app_public.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_public.h,v  <--  clkrst_app_public.h
new revision: 1.6; previous revision: 1.5
done
Checking in clkrst/app/clkrst_app_switch.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_switch.c,v  <--  clkrst_app_switch.c
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/app/clkrst_app_switch.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_switch.h,v  <--  clkrst_app_switch.h
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/driver/clkrst_drv.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.c,v  <--  clkrst_drv.c
new revision: 1.4; previous revision: 1.3
done
Checking in clkrst/driver/clkrst_drv.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.h,v  <--  clkrst_drv.h
new revision: 1.4; previous revision: 1.3
done
Checking in clkrst/driver/clkrst_drv_system_info.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv_system_info.h,v  <--  clkrst_drv_system_info.h
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/test/clkrst_test.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/test/clkrst_test.c,v  <--  clkrst_test.c
new revision: 1.6; previous revision: 1.5
done
Checking in video/panel/panel.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/video/panel/panel.c,v  <--  panel.c
new revision: 1.44; previous revision: 1.43
done

5, bug:
1), 只是软件修改了pclk parent, 没有修改func_mux_sel.
2), 修改后仍然不行. 发现是Clkrst_Parm_Init初始化时覆盖了, g_Clkrst_Parm.pclkFixAtPll2的配置. 
在Clkrst_TClk_Init()->Clkrst_TClk_InitModule()的
Clkrst_TClk_SetParent(pclkp,PLL1_ID);会设置Clkrst_Parm.pclkFixAtPll2为0, 并把pclk切到pll1.

6, 代码, 映像:
D:\work\VC0816\code\20090702\20090702_2056_fix_autotest_audio开始后TVClock不对.pakinfo.rar, image\2043_fix_autotest_audio开始后TVClock不对.pak
同时保存在: "D:\work\VC0816\阶段性代码和映像\20090702_Clkrst切频v0.3_audio和panel可以同时使用"目录. 

7, (11:45 2009-7-3)还是有问题.
udc不能用. 
找guangyue帮忙看, 接上gpio2: usb detect pin.就可以了. 

8, 文件问题解决,
1),  需要保证: pclk在pll1上(设置func_mux_sel[2]=0, 软件设置parent为pll1d2), udc跳线gpio2, pll1div2满足27M和12M的倍数, pll2给audio用. 
现在autotest中切频是在video autotest(autotest\video_auto.c: video_auto_api())中切的. 
2),  zhangjian, shuyu, clkrst, autotest,
fix autotest中panel和udc不能使用问题. 现在是panel, udc, audio三个可以同时使用. 
使用udc时, 需要跳上"gpio2"(usb detect pin).
3), CVS log
Checking in .cdtproject;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/.cdtproject,v  <--  .cdtproject
new revision: 1.46; previous revision: 1.45
done
Checking in autotest/nand_auto.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/autotest/nand_auto.c,v  <--  nand_auto.c
new revision: 1.5; previous revision: 1.4
done
Checking in autotest/video_auto.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/autotest/video_auto.c,v  <--  video_auto.c
new revision: 1.10; previous revision: 1.9
done
Checking in clkrst/app/clkrst_app_module_clock.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_module_clock.c,v  <--  clkrst_app_module_clock.c
new revision: 1.11; previous revision: 1.10
done

16:06 2009-7-2
安装FC11
1, 硬盘是IDE的. SCSI的找不到硬盘. 
2, vmware tools: vmware-config-tools.pl
3, 共享文件夹
<TODO>复制vmware手册</TODO>
按照vmware-tools后仍然不能使用共享文件夹, 尝试open-vm-tools(open wmware tools):
open-vm-tools-2009.06.18-172495.tar
Ubuntu 8.10+VMware6.0嵌入式环境搭建3-hgfs共享
http://www.ubuntuchina.com/viewthread.php?tid=6444
    
文档
1, 我这个vmware序列号过期了, 每次vmware启动, 虚拟机启动/重启时, 需要修改时间到2005年. 
2, 需要修改share folder, 默认在d:\work\Ldvm_share

17:01 2009-7-2
<TODO></TODO>
1, 816
setfreq有bug, 切频不到指令频率是需要返回0.
2, 816切频v0.3 release
3, 830切频死. 

11:13 2009-7-3
Linux移植计划, 编译android
1, hardware/msm7k/libaudio/AudioHardware.h :25
找不到hardware/AudioHardwareBase.h,
发现是移到了hardware_legacy中.
2, 修改后, 有pure virtual function没有实现的问题. 暂时放弃;
3, 编译200901下载的android:
提示PRODUCT_POLICY设置不正确. 
4, 看FC10下make详细信息. <TODO></TODO>

11:13 2009-7-3
VC0816, SV, 调试, kpd, jtag, kpd不能用jpeg调试, 用jtag前不能初始化kpd
816中kpd和jtag share, 所以需要jtag调试时不能使用(包括初始化)kpd. 同样, 如果使用jtag前初始化了kpd, 否则multiICE会找不到JTAG.

13:47 2009-7-3
Linux移植计划, 编译android, 续
1, 1), 在FC10下用arm-eabi-4.3.1编译goldfish2.6.29内核(goldfish_common-b10edef14984cc56182d8014815a4e47518c2cdc.tar), 内核配置文件使用200901android中提供的2.6.25内核的配置文件(config4goldfish2.6.25). 
目录: 36, Share\Linux\android.
2), 用4.2.1编译.

2, 换成2.6.27内核实验:
1), 下载goldfish 2.6.27
http://android.git.kernel.org/?p=kernel/common.git;a=shortlog;h=refs/heads/android-goldfish-2.6.27
2), 用zhangpu android 1.5r2的映像内核可以启动, 但是提示dbug无法启动. 
3), 用zhangjian 自己编译的映像android可以启动, 有时操作时会提示activate无响应, 感觉是虚拟机速度慢造成的, 应该不是内核问题. 

3, 编译标准内核Linux2.6.27.26通过.
一定得选择开发板, 否则在链接_tmp_vmlinux1时会报错: no machine record ... 

4, 邮件"答复: 新一带的平台开发启动"20090703_1840
内核和编译器选型进展:
1, android : zhangjian 20090115下载.
编译20090625的android报错, c++ 纯虚函数未定义. 放弃这个版本. 
TODO: 尝试android 1.5r2版本是否可用.
2, kernel goldfish 2.6.27, 在上面android中可以正常启动, 但有时操作android手机时会提示activate无响应, 感觉是虚拟机速度慢造成的, 应该不是内核问题.
用Goldfish2.6.29时, Linux kernel可以boot起来, 但是脚本有问题, android界面无法启动.
3, 工具链: android 提供的arm eabi 4.2.1, 使用这个工具链编译2.6.27.26通过. 
4,hostPC: Fedora core 10. FC11无法编译android 20090115
结论: 可以使用如下环境开发: 
Fedora Core 10 + android 20090115 + kernel2.6.27 + arm-linux-gcc: arm-eabi-4.2.1

18:08 2009-7-3
VC0830, SV, 优化, memcpy, <TODO>有空看代码</TODO>
LiDongLiang邮件"答复: memcopy"20090703_1807
Memcpy 的优化实现已经完成，参考了linux kernel中的代码
实现了ads和gcc两个版本
已经提交到D:\VC0830\VC0830\bootloader 目录下
memcpy_opt_ads.S  和 memcpy_opt.S
功能测试：
与libc 中的memcpy实现进行比较，无误
速度测试：
CB内存,   与libc 中的memcpy实现进行比较
测试命令位于 mem 模块中，”memcpy_opt_test”
1). 在src与dst地址都4字节对齐的情况下
Memcpy_opt:  75408 KB/s
Memcpy:   41152 KB/s 
2). 在src或者dst地址有一个不是4字节对齐的情况下
optimized speed(KB/s):  60670 
lib speed(KB/s):  9421
3). Memcpy 的数据量是否4 bytes对齐对速度基本没什么影响

bamvor note: 
1, 原来memory是否对齐对性能影响很大. Linux kernel中对于不对齐的处理:
先对齐dst, src是移植和load/store结合. 
2, dongliang测试环境: 上面数据是gcc 830 SV, 176LQFP+pcddrHynix, 480_240_120测试的. 未切频. ads下的memcpy是在arm7下测试的. 

20:27 2009-7-3
VC0816, SV, dragon, UINT64
1, 816的timer.h修改后, 没有改全. 仍然有unsigned long long的写法, 按830修改即可:
#ifndef UINT64
#ifdef WIN32
	#define UINT64	unsigned __u64
#else
	#define UINT64	unsigned long long
#endif // WIN32 end
#endif // UINT64 end
注: 忘了这里不include common_def.h的原因. 似乎是timer.h层次更低. 

2, 修改后仍然后错: 
dragon中编译死活不过, 意思就是提示UINT64没有定义. 和830比较也查不出问题.
后来查找哪些文件include了timer.h, 发现"hal_io.h", 在"(!defined(__GNUC__) && !defined(USE_ADS_MODE))"之前包含了timer.h, 也就是同时影响dragon和板子:
#ifdef TIMER
#include "../timer/timer.h"
#endif
	
#if (!defined(__GNUC__) && !defined(USE_ADS_MODE))
    //windows下操作接口
#else
    //板子的操作接口

830中不是这样用的. hal_io.h是很底层的抽象, 使得我们在板子上操作和在dragon下操作感觉一致, timer.h比这个层次高, 放在这里不合适. 如果将来一定要包含也需要像830一样在panda不能在dragon里面. 
修改后编译dragon通过, FPGA video编译通过, SV autotest编译通过. 

3, CVS: 
zhangjian, timer, dragon
fix dragon compile error.
删除了hal_io.h的:
#ifdef TIMER
#include "../timer/timer.h"
#endif
	
830中不是这样用的. hal_io.h是很底层的抽象, 使得我们在板子上操作和在dragon下操作感觉一致, timer.h比这个层次高, 放在这里不合适. 如果将来一定要包含也需要像830一样在panda不能在dragon里面. 
修改后编译dragon通过, FPGA video编译通过, SV autotest编译通过. 

4, CVS log:
Checking in include/hal_io.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/include/hal_io.h,v  <--  hal_io.h
new revision: 1.7; previous revision: 1.6
done
Checking in timer/timer.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/timer/timer.c,v  <--  timer.c
new revision: 1.5; previous revision: 1.4
done
Checking in timer/timer.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/timer/timer.h,v  <--  timer.h
new revision: 1.4; previous revision: 1.3
done

5, 代码:
D:\work\VC0816\code\20090703\20090703_2237_Clkrst代码完成.rar

21:31 2009-7-3
VC0816, SV, clkrst, clkswitch切频完成
zhangjian至816qa邮件"816切频代码完成"20090703_2144
Hi, all
816切频代码完成, 提供如下功能: 
1, 模块时钟管理
1), panel和audio可以同时使用, 保证autotest, me使用. 
2), 除了audio在pll2, 包括cpu,bus, pclk等其余模块都在pll1. 模块设置频率的命令是setfreq, API是Clkrst_TClk_SetFreq()(clkrst\app\clkrst_app_module_cloc.c). Clkrst_TClk_SetFreq()的使用方法参见panel_open()(video\panel\panel_open.c).
3), 管理如下clock: xclk, pll1, pll2, cpu, bus, iclk, jclk, snr_clk, per_clk, phy_udc, nfc, sdio, pclk, uart0, timer_clk, 使用svclkinfo查看. 

2, cpu,bus切频
命令: clksv, 使用方法与830相同
切频API: Clkrst_Switch(), 具体说明见clkrst\notes.txt

3, 自动切频测试命令: autoswitch
1), 不超频情况下(pll<=672, cpu<=360, bus<=168) 
cpu min freq(MHz): (Int)/[12] cpu最低频率
cpu max freq(MHz): (Int)/[168] cpu最高频率
cpu freq step(MHz): (Int)/[4] cpu频率step
cpu bus ratio(1,2,3,4): (Int)/[1] cpu:bus比例, 2表示2:1
times: (Int)/[5] 自动切频共测试几次
itIndex(0,1,2,... ): (Int)/[2] 迭代器编号, 不超频情况下选择0,1,2均可, 推荐2, 完成cpu最低频率->cpu最高频率->cpu最低频率的测试过程. 
pesudoSwitch: (Int)/[0] 用于测试. 取默认值0即可. 
destination clock source(0: pll1; 3: xclk): (Int)/[0] 切频目的clock source, 取默认值pll1. 
dmaTimes: (Int)/[10] 切频后做几次dma
delay(us): (Int)/[0] 切频后是否delay

2), 超频情况下(pll<=900, cpu<=400, bus<=200) 
建议pll,bus,bus超过或接近(pll<=672, cpu<=360, bus<=168)时使用.
只有"itIndex(0,1,2,... ): (Int)/[2]"必须选择3, 表示修改pll,cpu,bus范围到(pll<=900, cpu<=400, bus<=200), 其余用法相同. 

4, 代码已上传CVS, SV, FPGA, dragon均编译通过. 

注: 所有与SV clock有关代码都用CLOCK_TCLOCK宏区分. 其它模块使用TClock结构体或除clkrst.c以外的函数, 也需要用宏CLOCK_TCLOCK. panel, uart, i2c, timer中相关部分已经修改. 

9:58 2009-7-6
VC0816, SV, clkrst, clkswitch, LQFP144
1), cpu=bus=24->168, step=24, dma=10, pass
2), cpu=240->336, step=12, cpu:bus=2:1, dma=10, pass
3), cpu=300->400, step=10, cpu:bus=3:1, dma=100, fail @ 390:130, 切频死.
4), cpu=360->390, step=5, cpu:bus=3:1, dma=1000, fail @ 390:130, 切频死.
最高770:385:128.3. 
5), 直接切频到385:128.3, dma=5000, pass.
6), 结论:
Cpu最高到385(770_385_128.3), dma 5000 pass; bus168稳定. bus188(752_188_188)dma 1000 pass.

15:28 2009-7-6
VC0830, SV, storage, sdio, build command中-m多次加入同一个模块引起的bug
今天dashan编译vdec_sv时, build command里面定义了两个sdio模块, 编译时提示sdio中函数重定义.  经检查, 确定原因是eclipse build command中-m有两个sdio造成的:
sdio被多次定义, 意味着mods.mk多次include sdio目录的subdir.mk, 这样subdir.mk中的C_OBJECTS包含了两份sdio*.o, 最后在链接时, 两份sdio*.o导致link认为函数重定义. 

具体细节: 
build.pl会把build cmd中"-m=xx,xxx"的目录include进来, 生成build\mods.mk, 类似:
#This Makefile generated by Vimicro VC0830 Auto Builder, DO NOT MODIFY!
include ./timer/subdir.mk
include ./sdio/subdir.mk
include ./fat/subdir.mk
include ./interrupt/subdir.mk
include ./clkrst/subdir.mk
include ./dmac/subdir.mk
include ./cache/subdir.mk
include ./sdio/subdir.mk
include ./aasp/subdir.mk
include ./bootloader/subdir.mk
include ./memory/subdir.mk
include ./uart/subdir.mk
include ./pdma/subdir.mk
include ./padc/subdir.mk

这样在"$(EXECUTABLE)"规则中的"C_OBJECTS", 就会有多余的sdio*.o:
arm-elf-g++ -lstdc++ -Wl,-Map ./build/ld.map -T./ld_script//dram32M_4bank_dynamic.lds -nostartfiles -nodefaultlibs -nostdlib -L./lib/ -LC:\ESDE/gcc/lib/gcc/arm-elf/4.1.1 -L./build -L./build/bootloader -O0 -o ./build/VC0830.elf   ./build/timer/timer.o  ./build/timer/timer_test.o  ./build/SDIO/sdio_test.o  ./build/SDIO/src/sdioapp.o  ./build/SDIO/src/sdiobase.o  ./build/SDIO/src/sdiodrv.o  ./build/SDIO/src/sdioprt.o  ./build/fat/volume.o  ./build/fat/util_sfn.o  ./build/fat/util_lfn.o  ./build/fat/util.o  ./build/fat/port.o  ./build/fat/media_drv.o  ./build/fat/file.o  ./build/fat/fat_test.o  ./build/fat/fat.o  ./build/fat/drv.o  ./build/fat/dir_lfn.o  ./build/fat/dir.o  ./build/fat/fat_cmd.o  ./build/interrupt/interrupt_test.o  ./build/interrupt/interrupt_drv.o  ./build/interrupt/interrupt.o  ./build/clkrst/test/clkrst_test.o  ./build/clkrst/app/clkrst.o  ./build/clkrst/app/clkrst_app_module_clock.o  ./build/clkrst/app/clkrst_app_operation_point.o  ./build/clkrst/app/clkrst_app_switch.o  ./build/clkrst/app/clkrst_app.o  ./build/clkrst/memory/mem_config.o  ./build/clkrst/memory/mem_sdram_samsung.o  ./build/clkrst/memory/mem_sdram_vimicro_BGA181.o  ./build/clkrst/memory/mem_pcddr_hynix.o  ./build/clkrst/memory/mem_mddr_micron.o  ./build/clkrst/driver/clkrst_drv_system_info.o  ./build/clkrst/driver/clkrst_drv_divider.o  ./build/clkrst/driver/clkrst_drv.o  ./build/clkrst/basefunc/clkrst_basefunc.o  ./build/dmac/dmac.o  ./build/dmac/dmac_test.o  ./build/cache/arm926ejs_mmu.o  ./build/cache/arm926ejs_cache.o  ./build/cache/arm926ejs_cache_test.o  ./build/SDIO/sdio_test.o  ./build/SDIO/src/sdioapp.o  ./build/SDIO/src/sdiobase.o  ./build/SDIO/src/sdiodrv.o  ./build/SDIO/src/sdioprt.o  ./build/aasp/AASP_cmd_help.o  ./build/aasp/AASP_cmd_version.o  ./build/aasp/AASP_Shell.o  ./build/aasp/aasp.o  ./build/bootloader/dev_uart.o  ./build/bootloader/newlibport.o  ./build/bootloader/vc0830_main.o  ./build/bootloader/bootscript.o  ./build/memory/mem_test.o  ./build/memory/mem.o  ./build/memory/buf_test.o  ./build/memory/buf.o  ./build/memory/sys_mem/ncnb_memory.o  ./build/memory/sys_mem/nucleus_mem.o  ./build/uart/uart_test.o  ./build/uart/uart.o  ./build/uart/uart_drv.o  ./build/uart/uart_api.o  ./build/uart/uart_basefunc.o  ./build/pdma/pdma.o  ./build/padc/padc.o  ./build/padc/padc_test.o    

注:
1, "$(EXECUTABLE)"规则是: 
# for elf
$(EXECUTABLE): $(OBJECTS) 
#@echo $(EDE)     
	$(CC) $(ASFLAGS) -c bootloader/vc0830init.S -o build/bootloader/vc0830init.o
	$(LD) $(LDFLAGS) $(OLevel) -o $(EXECUTABLE)  $(OBJECTS)       $(LIBS)

2, C_OBJECTS是每个模块目录下定义的. 
C_OBJECTS				+=		$(C_OBJS)

这样就造成了上面的编译错误. 直接原因是我们的perl脚本没有检查模块是否多次包含(我认为这属于没有检查依赖关系, 现在很多编译错误是由于没有依赖关系造成的). 
另外这也和我们Makefile组织结构有关: 模块的subdir.mk是include到顶层Makefile后一起编译的, 这样用感觉很别扭. 

15:41 2009-7-6
VC0816, SV, 资源分配表
FengBeiZhan邮件"816资源分配表"20090702_1728
Hi，all
如下是816资源表，请大家保管好自己手里的资源，现在所有的人都配备了cob，144 2套封装；我们重点测试的也是cob，144；
如果资源编号有问题，请及时找我更改；
母板 cpu_176（cob） cpu_144 cpu_176 owner 电源 sdram notes
test
80090624032 80090625040 80090701013 　 fuyali 默认已配 默认已配
80090629052 80090629058 80090701018 　 wangke 默认已配 默认已配 
80090701006 80090629057 80090701011 　 zhanglu 默认已配 默认已配
80090629055　 80090701007 　 luopengyu 默认已配 默认已配 　 
80090629046 80090630070 　　 luopengyu 默认已配 默认已配
80090624031 80090701002 80090701012　 fengyaya 默认已配 默认已配 调机
software 
80090624036 80090624037 80090701010 socket(1) zhangjian 默认已配 默认已配
80090623024 80090625039 80090701015 　 lvboxue 默认已配 默认已配 　
80090629051 80090629056 80090701009 　 zhangpu 默认已配 默认已配
80090624035 80090624038 80090701016 　 zhuliying 默认已配 默认已配 
80090629050 80090624034 80090701014 　 shuyu 默认已配 默认已配
80090629048 80090623026 80090701008 　 zhoudashan 默认已配 默认已配 
80090629047 80090630068 80090701017 　 fengbeizhan 默认已配 默认已配

16:11 2009-7-6
1, 配好samba, 共享文件夹. 
2, 按照android sdk, 编译内核, 在另外一个硬盘上编译android 20090115 code.
3, 虚拟机文档. 
4, 今天要开始看代码了. 先了解一下goldfish文件. 

16:45 2009-7-6
1, 用open-vmware-tools mount hgfs后, 文件也被识别是目录. 
2, 参考"http://hi.baidu.com/tangxijin/blog/item/cfeb2e73600918198701b08e.html"实验. 

17:40 2009-7-6
Linux移植, 新一代的平台开发启动, 续
1, Fedora10, android 200901(android 1.5r2 sdk), kernel 2.6.27, arm gcc4.2.1(android prebuild)
2, 周四: 装Linux, 跑android, 编译kernel. 

17:40 2009-7-6
Linux移植, 新一代的平台开发启动, 周四会议
1, 个人感觉第一次装Linux, 配系统有些复杂, 如果大家需要也可以提供安装好的系统映像. 
2, 虚拟机安装. 
(1), 内存: 虚拟机自己的内存最好是物理内存, 不是虚拟内存.  建议等于实际物理内存的1/2-1/4. zhangjian是512M.
(2), 硬盘
硬盘选择IDE方式, 否则FC10找不到硬盘. 硬盘选择prealloc方式可以提高性能. FC10系统大约需要5G, 加上交换分区512M, 以及将来内核编译, android sdk空间, 建议硬盘大小为8G. 如果是FAT32一定得选择切分硬盘映像为2G一个文件. 
(3), 网络: NAT. 
内存大小, 网络连接, Vmware安装后且虚拟机未启动时可以修改. 硬盘大小不能修改, 可以增加新硬盘, 如果将来增加希望编译android sdk, 可以新增一个大于6G的硬盘. 

3, 安装Fedora 10
1), 分区: Fedora自动分区. 
2), 软件包安装:
开发部分下完全安装. 

4, Linux使用
1), 安装软件: configure, make, make install
autoconf....
2), 常用命令: 
Linux基本操作推荐<鸟哥的Linux私房菜--基础学习篇>, 最新是第二版. 
操作时简单说明命令作用. Linux命名: 2个字符表示一个单词: mke2fs, 
(1), man, 显示手册, 包括但不限于函数, 命令, 头文件.
man sudo #显示sudo命令帮助.
(2), sudo, 为其它用户开放指定root权限.
(3), grep, 简单文本查找工具, 支持基本的正则表达式.
(4), 查找文件:
a, find: find -name filename    #在当前目录下查找filename文件.
b, locate: locate filename #前提是数据库存在, 数据库用updatedb更新. 
b, whereis: 查找bin文件. 
(5), vi/vim. 文本编辑工具, 将来830上面只有这个编辑器.
附件"Linux开发中的常用命令=+.txt"也有些常用命令.

5, 配置samba和共享文件夹. 

6, 编译android, 运行. 

7, 编译goldfish kernel:
1), 指定config;
2), export ARCH CROSS_COMPILE
3), make

8, (11:40 2009-7-7)其它工具
1), 提取注释工具:doxygen, graphviz
2), svn服务器. 

21:29 2009-7-6
Linux移植, 续, 阅读代码goldfish2.6.27, cmdline
1, UPDATE0706. 已经更新. 将来更新文档. 
2, cmdline:
1), 首先的setup_arch()里面处理__early_begin到__early_end之间的, 比如initrd.
2), setup_command_line会把处理后的cmdline保存到saved_command_line和static_command_line, 前者是文件系统中会使用. 后者是parse_args处理. 
3), 另外, Linux会在调用parse_args()前由parse_early_param处理__setup_start到__setup_end之间的cmdline. 
4), <TODO></TODO>
(1), 为什么分三次parse cmdline? 
(2), 三部分都是哪些参数. 
3, devicemaps_init()
之前映射的IO寄存器, 这里会被remove, 所以: 
This means you can't use any function or debugging 
method which may touch any device, otherwise the kernel _will_ crash.
remove实际是:
	for (addr = VMALLOC_END; addr; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));
如果我们这里不从VMALLOC_END开始清, 自己留出一部分VMALLOC_END..addr_start用于映射设备. 
	for (addr = addr_start; addr; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));

10:03 2009-7-7
VC0816, SV, clkrst, clkswitch
频率测试等待Shuyu autotest完成后测试.

10:23 2009-7-7
Linux移植计划, 代码阅读, 查找Linux下的注释提取工具, doxygen
1, 下载:http://www.stack.nl/~dimitri/doxygen/download.html#latestsrc
中文文档: http://www.fmddlmyy.cn/text21.html
2, 安装dot.
3, <TODO>实验提取Linux kernel注释, 建立函数调用关系</TODO>
4, 参考资料:
http://www.ibm.com/developerworks/cn/aix/library/au-learningdoxygen/index.html
http://www.fmddlmyy.cn/text21.html
http://www.cnblogs.com/duguguiyu/archive/2008/06/29/1231852.html
http://www.vckbase.com/document/viewdoc/?id=1287
http://www.image2003.com/image2003bbs/dispbbs.asp?boardID=17&ID=2463&page=3
http://www.diybl.com/course/3_program/c++/cppsl/200866/122890.html

14:56 2009-7-7
VC0816, SV, nand, 电容问题, <TODO>关注进展</TODO>
1, VC0816 LQFP144封装下nand与sd, lcd share时, 在有映像情况下会报all backup image fail.
注: VC0830 LQFP176当时也有类似情况, 当时LingMing用示波器看, 发现有sd后nand波形变差. 后来是降频解决的. 
和830问题原因相同, 只是这次lcd和sd对nand都有影响, zhicheng用示波器看波形, 发现是电容效应. 
<TODO>思考, 项目总结</TODO>: 为什么会有这个问题呢?  如果是share引起的, 当时是否考虑到此影响呢? 如果考虑到, 为什么IC没有提示呢? 如果没有考虑到, 那就是设计缺陷了. 虽然公司产品是强调成本的, 但我理解应当是在有流程, 技术保证的情况下, 有保证的降低成本. 如果由于这个影响了系统性能, 恐怕就更值得反思了.

2, 第二次是测试遇到的: 
1), Fuyali邮件"答复: 816切频代码完成"20090707_1441, 1431
高于100M的，现在测试有一片，nand都fail，不能识别出u盘(另外还试了一片，nf是ok的)；336_168有时切不过去

Nand fail的是这样一个问题：
1. 与片子无关，不存在片子差异，刚才试了好几片。
2. 程序起来后，不作切频的动作，也就是默认情况下，autonand是ok的
3. 可是一旦切频后，比如切频到240_120，nand就fail了
4. 疑问：默认情况下难道不是240_120吗？是不是要check一下程序？

2), 暂时解决: 
zhangjian邮件"答复: 816切频代码完成"20090707_1453
刚才和fuyali一起看了看.
原因是切频后默认切nand到30MHz, nand太高引起的, 估计和816  144 bootloader问题一样是由于电容造成的nand信号变差造成的.
Fuyali暂时切频后用setfreq修改nand频率到12Mhz.
请zhicheng给出nand能稳定工作的频率范围

17:18 2009-7-7
Linux开发, 源代码分析/阅读, 函数调用关系, 工具, 试验, 续, 另一篇综述文档
<TODO>从zhangpu msn加入</TODO>

10:35 2009-7-8
VC0816, SV, LQFP144, clkrst, clkswitch, jpeg, snr, <TODO></TODO>
映像:D:\work\VC0816\code\20090707\shuyu autotest LQFP144切频有问题映像\autotest.pak
0, LQFP144切频不稳定, 问题描述:
1), 切频不稳定, shuyu和fuyali板子切336_168死. 
2), jpeg解码错误. 
3), sensor 2010切频后(240_120), video, open死. 如果切频前open, 切频后sensor可用. 
1, 我的板子, 编译autotest_sv, 直接切到336_168死, 用autoswitch(240->336, dma100, tep=12(下同))pass.
2, shuyu板子, shuyu自己的映像, 
1), shuyuCPU(80090701014), 直接切到336_168死, 用autoswitch(240->336, dma100) fail@324_162, 
2), 换成我的CPU板(80090701010), 
(1), 直接切到336_168fail(引起aasp重启), 
(2), 用autoswitch(240->336, dma100) fail@336_168.
(3), 用autoswitch(240->336, dma1000), pass, autovideo, pass.
3), 再换成shuyucpu板, 
(1), 重复2)-(3).  fail@312_156
(2), 用autoswitch(300->336, dma2000), fail@324_162
测量bus clock, 正确. 
(3), 感觉这也就是最高频率了. 实验bus.
切频后实验(672_168_168, dma 1000)x2, pass.
(3), 更换为我的电源板就没问题. 
4), 分析板子差异:
(1), 测试电压:
zhangjian core: 1.196, shuyu core: 1.190, 
怀疑是电压问题;
(2), 晶振, 晶体无影响. 
5), 做压力切频测试:
1), LQFP144, 加我的电源板: 240->336->240, step=4, cpu:bus=2, dma=0, 接示波器两次都fail@86,@15x. 不接示波器一次成功, 一次fail@145.
2), LQFP176, 
(1), autoswitch: cpu=336->336->336, cpu=168, dma=0, time=20, pass.
(2), autovideo, pass
(3), 240->336->240, step=4, cpu:bus=2, dma=0, fail@136: 296_148.
连续296_148切频200次, fail@97

注: autoswitch(240->336, dma1000)具体选择如下:
clkrst  SD:/>autoswitch
All Operation Point Iterator Group is:
CLKRST: 0 name: min_to_max:
CLKRST: help: min_to_max
CLKRST: 1 name: max_to_min:
CLKRST: help: max_to_min
CLKRST: 2 name: minMaxMin:
CLKRST: help: Iterate from min to max, then from max to min
CLKRST: 3 name: overClockItorGrp:
CLKRST: help: over clock test: pll(900), cpu(400), bus (200) overclock
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
cpu min freq(MHz): (Int)/[12]240
cpu max freq(MHz): (Int)/[168]336
cpu freq step(MHz): (Int)/[4]12
cpu bus ratio(1,2,3,4): (Int)/[1]2
times: (Int)/[5]1
itIndex(0,1,2,... ): (Int)/[2]0
pesudoSwitch: (Int)/[0]
[CLKRST_MODULE]MESSAGE:do_clkswitchAutoSwtich arg input succeed!

Select the clock switch path:
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
destination clock source(0: pll1; 3: xclk): (Int)/[0]
[CLKRST_MODULE]MESSAGE:arguments_dstCpuBusSrc input succeed!

[CLKRST_MODULE]->do_clkswitchAutoSwtich()
dmaTimes: (Int)/[10]1000
[CLKRST_MODULE]MESSAGE:arguments_dmac input succeed!

[CLKRST_MODULE]->do_clkswitchAutoSwtich()
delay(us): (Int)/[0]

6), 总结, 邮件:
(1), ZhangJian至"'Feng Bei Zhan'; 'Zou Wei Ran'; 'Dong Xin'; 'Wally GX Li'; 'Ai Guo'; 'Lv Pin'; 'Lin Chuan'", 抄送"'Chen Ying'; 'Lv Hai Fang'", "复: 下午2点半，我们再张建座位那里讨论一下切频的事情"20090708_1318
//////////////邮件开始/////////////////
刚才做了些连续切频实验, 补充如下信息: 
1, 下文1.90, 1.95是指core=1.190和core=1.196. 
2, 即使用1.196的电源板, 切频也不是完全稳定. 
如果cpu从240->336->240Mhz, step=4MHz, cpu:bus=2:1, 这样连续做切频,  有3次(3/4)会在切频80至150次时出错. 
3, 用COD176封装实验, 前提: 切频到336_168, autovideo测试pass, 连续切频会死在296_148,  在这个频点多次切频切到97次会死. 
4, 对齐830sv, 这种连续切频没有问题. 
5, 所以我感觉core电压差异只是加重了不稳定. 可能不是根本原因. 
会不会是切频流程有问题, 或者830 LQFP176一样是IR drop问题. 
//////////////邮件结束/////////////////
(2), 标题, 接收人一致 
补充, 初步实验, 软件可以在切回pll1前多delay的绕过这个问题. 
考虑到830中181封装出现的情况: 加入多余pll stable时间切频才稳定. 
816中也做同样实验, 切频后多delay 16 000个for 循环(cpu=12MHz, 大约1ms), 即使用1.190电源板切频稳定很多. 不论COB176还是LQFP144切频到336_168都可以过autovideo.
问题是目前pll stable cnt=0x3fff, 对于bus=12MHz来说这个delay大约是1.3ms. 远大于300us. 
不应该再需要多余的delay了.

如果软件流程没有问题说明是IC的bug. 

16:03 2009-7-8
VC0816, SV, LQFP144, clkrst, clkswitch, jpeg, snr, sensor, 续, 做如下实验
1, pll ckd不变情况下, 在xclk<->pll_ckd之间多次切频(500次, 下同)
core=1.200, memory=3.30, vdd28on=2.80
pll不重新配置, 为什么会死在trigger switch中呢? 

16:33 2009-7-8
VC0816, SV, clkrst, jpeg
jpeg通过setfreq配置频率80MHz后, 进入jpeg模块后频率会改变为40MHz. 查找CLOCKRST_CKD_JCLK_CONFIG发现在jpeg_test中do_jpeg有配置CLOCKRST_CKD_JCLK_CONFIG和ckd enable. 与zhuliying确认这是__FPGA__用的, 加入宏区分. (如果寄存器名CLOCKRST_CKD_JCLK_CONFIG没找到, 还得找寄存器地址0x60000050)

21:22 2009-7-8
Linux开发, 源代码分析/阅读, 函数调用关系, 工具, doxygen
1, 解决源文件编码和输出编码不一致的问题
doxygen使用libiconv工具(Linux命令"iconv")转换编码.
DOXYFILE_ENCODING是初始编码, 目前是UTF-8
INPUT_ENCODING是源文件编码, GB2312
2, 针对C语言优化(还不知道具体有什么用)
OPTIMIZE_OUTPUT_FOR_C = YES
3, 生成todo list
\todo
4, 疑问: 如何使没有注释的函数不显示?
5, 今天是一边整理doxygen配置文件, 一边合并了前天读的代码. 明天要开始正式读代码了. 
6, (11:27 2009-7-9)doxygen windows下工具的VC工程无法打开, 有没有有空看看呢? 

10:10 2009-7-9
VC0816, SV, <TODO>任务</TODO>
1, 给zouweiran pll测试映像;<DONE>
2, 实验加压. 
3, 修改nand 最高频率为26.7MHz.
1), CVS: 
zhangjian, clkrst, clkswitch, moduleclock
(1), 修改nandflash(nfc)最高频率为26.7MHz;
(2), 加入pll reconfigure 参数, 默认是无论pl有无变化都需要reconfigure. 不reconfigure目前有问题, 不应使用.
4, 邮件
我在36上建立SV映像目录:\\10.0.2.36\sqmshare\Projects\Mobile BU\vc0816\SV, 保存release出的映像.
目录命名: MonthData_ImageName_Owner2User, 如果没有User可以不填. e.g. "20090709_pll测试_ZhangJian2ZouWeiRan", 目录包括映像(.pak), pakinfo, elf(用于rvdebug调试), bin文件(重新打包).
映像(pak)文件命名: Time_Package_Memory_Target_Notes. "1016_LQFP144_autotest_注释了启动脚本中auotest部分.pak". 816memory参数没有差异, 可以不写, 映像启动后, 可以用settype查看默认封装, 板子, memory配置. 
5, 支持24MHz外部晶振:
ZouWeiRan需要测量如下bus: 168, 152, 136, 120, 80, 60, 12

11:00 2009-7-9
VC0816, SV, LQFP144, clkrst, clkswitch, jpeg, snr, sensor, 续, 做如下实验
1, delay测试, core=1.200, memory=3.30, vdd28on=2.80
1), delay us cnt=1000, cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500, fail@437: 584_292_146.
2), delay us cnt=5000, cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500, fail@172: 656_328_164
2, delay测试, delay us cnt=1000, core=1.3v.
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=5000, fail@120: 632_316_158
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500, fail@206: 520 260 130
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=5 pass. 共250次.
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500 fail@362: 568_284_142
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@34: 640_160_80
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@101: 496_248_124
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@214: 496_248_124
发现在低频更容易死. 会不会与低频采用高频参数有关? 

14:48 2009-7-9
VC0816, SV, clkrst, clkswitch, <TODO>关注</TODO>
1, Fuyali邮件"答复: 自动测试的问题总结"20090709_1437
出现software interrupt的规律：
240_120，跑autovideo测试->324_162，跑autovideo测试->336_168，跑autovideo测试->60_60，跑lliautotest 1000次->80_80，跑lliautotest 1000次，这时就会出现software interrupt了。
还有一个问题，刚才发现autonand有nf init success，但是系统提示“无法识别的设备”而无法弹出u盘的情况，再找找看有没有规律。
另外，240_120在autovideo test下，自动抓的240x320的yuv420图片发暗，在这个频率下手动抓就是正常的。其他频率下自动抓也是正常。见附件。
不过，这个问题也不是很重要了。
2, 参见函数"restore_clk_m_gating_status()(clkrst\app\clkrst_app_switch.c)"
1), CVS zhangjian, clkrst, clkswitch
fix udc切频bug: 如果先切频到不是12Mhz整除的pll, 再切回12Mhz整除的pll, 仍然不能使用. 原因是前一步操作gate了udc,phy, 后来并没有放开. 
解决: 切频时如果模块不能使用并不gate. 
2), CVS log
Checking in app/clkrst_app_switch.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_switch.c,v  <--  clkrst_app_switch.c
new revision: 1.4; previous revision: 1.3
done
Checking in driver/clkrst_drv.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.c,v  <--  clkrst_drv.c
new revision: 1.7; previous revision: 1.6
done
Checking in driver/clkrst_drv.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.h,v  <--  clkrst_drv.h
new revision: 1.6; previous revision: 1.5
done
Checking in test/clkrst_test.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/test/clkrst_test.c,v  <--  clkrst_test.c
new revision: 1.8; previous revision: 1.7
done

22:51 2009-7-9
Linux移植, <TODO>request_standard_resources</TODO>

13:55 2009-7-10
Linux移植, 代码阅读, <TODO>timespec和timeval的差异</TODO>
与winCE5.0比较.
include\linux\time.h: 
struct timespec {
	time_t	tv_sec;		/* seconds */
	long	tv_nsec;	/* nanoseconds */
};
#endif

struct timeval {
	time_t		tv_sec;		/* seconds */
	suseconds_t	tv_usec;	/* microseconds */
};

14:24 2009-7-10
VC0816, SV, clkrst, 用启动脚本测试切频, 需要加入wdt复位
1, wdt:
1), 设置
void wdogisr(void)
{
	iprintf("Mask wdog in second irq level, but don't clear second srcpend.\n!!");

	//do nothing
	HAL_WRITE_REG32(TIMER_SETMASK,0x4);
}
Timer_DoWdog(targetvalue, (aasp_ISR_t *)wdogisr, 1);
2), 喂狗:
void Timer_WdogCurrentValueSet(unsigned int value);
unsigned int Timer_WdogCurrentValueGet(void);
3), cpu=bus=12MHz下dma 100 需要90s. 60MHz下需要16s, 168MHz下需要6s.
60_30下需要20s. 为了简化: 判断如果cpu, bus有一个小于60MHz, wdt加90s. 否则加20s. 

2, /// 测试失败, 暂时不能使用. 
//#define CLKRST_PATCH_TEST

17:31 2009-7-10
24Mhz
1, 切到480_60_60切死. 只死过一次. 
2, 164有类似问题, 且同一板子无法复现
24_656_164_164, pll_ckd=0x00180148. dma 1000 pass
24_328_164_164, pll_ckd=0x001800a4. dma 1000 pass
3, zouweiran cpu板启动, dma后, 很快死. 换成我的板子没问题. 换到我的底板也不行. 
4, 邮件"答复: 下午2点半，我们再张建座位那里讨论一下切频的事情"20090710_1816
1, 使用24MHz晶振情况下pll稳定性很差.
Zouweiran LQFP144 cpu板不切频情况下, dma操作会死在10次之内. 
我的LQFPcpu板在480_60_60和656_164_164 第一次运行时dma会报大量错误. 但是如果先切到其它频率, 再切回这些频率, 没有问题. 

2, 加压测试(core=1.3), 稳定性没有改善. 无法解释为什么当时1.196v电源板好于1.190v电源板.
bus只是没有在很低的频率死过, 在143以上也只有158死过一次. 说明bus频率高低稳定性没有线性关系. 

具体情况如下: 
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=5000, fail@120: 632_316_158
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500, fail@206: 520 260 130
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=5 pass. 共250次.
cpu=240->336->240, step=4, cpu:bus=2:1, dma=0, times=500 fail@362: 568_284_142
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@34: 640_160_80
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@101: 496_248_124
cpu=24->336->24, step=4, cpu:bus=2:1, dma=0, times=500 fail@214: 496_248_124

5, 对于切频的事情感觉很郁闷, 针对dongxin邮件回复如下邮件, 已经尽量调整说话方式了, 要人有人有意见也... 本来也不擅长表达.
邮件"Re: 下午2点半，我们再张建座位那里讨论一下切频的事情"20090710_1938
1, 把第一次和后面几次的相关寄存器打印出来比较一下。
把zouweiran 的LQFP144 cpu板的寄存器也打印出来比较一下。
请具体指明是哪些寄存器.  另外830中如果切频后立刻读取寄存器很容易死, 希望IC能给出具体流程, (切频和读寄存器之间有无delay, 需要多大delay等), 
2, 稍后会实验nop(switch前后各50个nop), 
这个实验的结果怎样？
切频问题较多, 尚未实验: 
1), 昨天测试报出切频错误,  调试中. 
2), 为zouweiran实验24Mhz晶振切频代码, 

补充一些我的想法
1, 疑问: 如果切频切死, wdt还能否正常工作? 
从我今天实验看, 切频切死后wdt无法正常工作,  加上切频问题较多, debug非常耗时间, 希望能给出有针对性的批量测试方案.  手工测试进展很慢. 

2, 从我下面加压测试(core=1.3)可以看出切频死没有明显的规律, 有没有可能IC多做一些分析?  比如tt, ff, ss corner 仿真
从PLL divider不能超过672MHz这个设计缺陷我猜测我们没有做PLL模拟和数字部分的联合corner仿真. 有没有可能IC经过仿真得到更准确的切频流程(包括写寄存器的顺序, 需不需要加nop, 加多少个nop等), 这样软件验证才更有目的性.
比如PLL模拟和数字部分的联合corner仿真, 切频逻辑的corner仿真, cpu,bus divider配置等等. 

3, 830中一直感觉芯片现在较低频率工作, 逐步边工作边切频, 比直接切频到较高频率稳定(以下简称”预热”问题).  816中也有类似现象. 
这个问题感觉很困扰: 如果认为切死就fail,  实际830, 816大量切频相关测试无法正常进行,  如果承认”预热”合理, 软件切频这部分又没有经过IC确认的流程. 

17:49 2009-7-10
<TODO></TODO>
1, 对0指针操作造成的异常被覆盖引起的问题. 
2, <TODO>机台测试, powerkeep没有的原因是ATE给的不够(pmu50ms之后才动作)</TODO>

22:47 2009-7-11
Linux移植, android, 多媒体框架, gstreamer, packetVideo OpenCore
文章"7个Linux手机平台比较 （4）：多媒体架构的异同"
自: http://blog.csdn.net/cuijpus/archive/2008/06/19/2567250.aspx
位置: "bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\消费电子产品\手机设计\手机方案_Android等"
提到了Linux手机方案中使用的三种多媒体框架: gstreamer, packetVideo OpenCORE, RealNetworks Helix DNA Client.
其中5.5/7使用gstreamer, 1/7(Android)使用packetVideo OpenCORE, 0.5/7使用Helix. Qtopia支持1,3两个, 按各0.5计算. 
可以看出gstreamer使用最广, 由于本身是开源项目, 而且项目活跃, 不用担心将来不能用的问题. packetVideo OpenCORE是packetVideo方案的开源版本, 本身是c++的, 可能更适合c调用. 

1, android中OpenCore分支
http://android.git.kernel.org/?p=platform/external/opencore.git;a=summary
2, android使用的开源项目, 参"google的Android利用了很多的开源项目", http://android.tgbus.com/Android/tutorial/200901/174359.shtml.
3, Android的多媒体框架OpenCore介绍, http://tech.it168.com/a2009/0331/270/000000270422_3.shtml.
android的codecs_v2目录的子目录omx实现了一个khronos OpenMAX的功能。OpenMAX是一个多媒体应用程序的框架标准，由NVIDIA公司和Khronos在2006年推出。OpenMAX IL 1.0（集成层）技术规格定义了媒体组件接口，以便在嵌入式器件的流媒体框架中快速集成加速式编解码器。
OpenMAX的设计实现可以让具有硬件编辑码功能的平台提供统一的接口和框架，在OpenMAX中可以直接使用硬件加速的进行编解码乃至输出的功能，对外保持统一的接口。但是在此处的OpenMAX则是一个纯软件的实现。

23:10 2009-7-11
Linux移植, 文档化工具, doxygen, <TODO>参考GNOME POWER Manager编写文档</TODO>
1, Doxygen + Graphviz + Htmlhelp, 成为文档好手
自: http://blog.csdn.net/cuijpus/archive/2008/05/22/2471014.aspx
文中提到GNOME POWER Manager(http://www.gnome.org/projects/gnome-power-manager/)使用doxygen生成的文档很好, 可以参考. 

1:26 2009-7-13
软件技巧, vmware6.5(?), sn, 序列号
我用的是第一组. 
9V8A1-5H34C-80J4U-4P8NQ(0710)
T30HW-GHEFG-02H6U-4MXZ7
W30KE-MP20J-A85DG-4WWQ3
YKNF5-DYZ40-A25DY-4PDX7
ALEKR-UHHFD-YA4DV-4Y8N3
EV8Y1-RHKAL-4AHDG-4MDN2 

12:50 2009-7-13
<TODO></TODO>
1, 整理上午会议记录, 实验, 4.
1), 发实验四的结论.
2), 发Fuyali报的bug.
2, 看830切频有无遗留问题. 整理buglist
1), 对于"预热"没有明确的结论(是切频问题, 还是bus问题, 如何才能稳定), 担心产品部使用会出问题. 当时Wangke测试的时候是跑vdec->切频->跑vdec->切频... , 实际产品中感觉没法这么做. 
3, 回wally邮件. 重申672MHz设计缺陷和core 仿真看法. 
1), 回复前查看816, 830最新的mas和databook pll频率范围. 

14:14 2009-7-13
VC0830, SV,clkrst, clkswitch, <TODO>切频测试</TODO>
<TODO>cpu step</TODO>
LQFP176, sdram, 不加压, xclk<->pll1, pll1<->pll2(480_120_120)
12->168, 1:1 
12->290, 2:1
12->290, 3:1
dma=10.

15:48 2009-7-13
VC0830, VC0816, 总结, rvdebug, jtag
如果希望使用映像初始化memory, rvdebug中仅仅load image, 需要保证映像不会初始化与jtag share的pin, 否则jtag和板子无法正常连接. 

15:52 2009-7-13
VC0816, SV, clkrst, clkswitch bug
1, zouweiran的板子很不稳定. 
2, 我的板子, 测量电压. 
240->336->240, step=4Mhz, dma=0, times=500, switch前后都delay 1s.
1), delay=1s, fail@46: 512_256_128
2), delay=10ms, fail@37: 560_280_140
3), delay=100ms, fail@3: 496_248_124
4), 不使用Clkrst_Drv_TriggerSwitch, 恢复为Clkrst_SetNormal2Bypass, Clkrst_SetBypass2Normal.
@todo 估计是函数进入退出引起的, 这个问题要发信讨论. 
code(包括elf,bin): D:\work\VC0816\code\20090713\20090713_1638_切频前后delay1s_与20090713_1552_4)工作日志对应.rar
delay=1s
(1), fail@184: 608_304_152, 死的时候并没有stop, 只是无法停止, 停止rvdebug时提示: Attempt to force processor to enter debug state failed - execution.
(2), fail@15: 592_296_148, 死亡状态同上. 
(3), fail@181: 632_316_158, 死亡状态同上. 
5), 代码不变, 测试范围改为12->336->12. 
(1), fail@961: 640_320_160, 死亡状态同上. 
(2), fail@472: 368_92_46, 死亡状态同上. 
(3), fail@:109 464_232_116, 死亡状态同上. 
今天所有log: log_20090713144957.txt

3, 发邮件:
加delay后没有明显效果. 具体情况如下:
1), 测试频率范围cpu=240->336->240, cpu:bus=2:1, step=4Mhz, trigger switch前后都delay 1s. 
(1), fail@184: 608_304_152(表示死在第184次切频, 此时pll=608, cpu=304, bus=152), 死的时候并没有stop, 只是无法停止, 停止rvdebug时提示: Attempt to force processor to enter debug state failed - execution.
(2), fail@15: 592_296_148, 死亡状态同上. 
(3), fail@181: 632_316_158, 死亡状态同上. 
2), 测试范围改为12->336->12. 
(1), fail@961: 640_320_160, 死亡状态同上. 
(2), fail@472: 368_92_46, 死亡状态同上. 
(3), fail@:109 464_232_116, 死亡状态同上. 
3), 可以看出和之前情况差不多, 看不到明显改善. 离每个频点都切频500次pass这个标准距离还很远. 
4), 如果切频时trigger switch用单独函数, 切频更不稳定. 明天优先做trigger前后加50
个nop的实验.
5), 附上上周测试同事Fuyali报的bug:
240_120，跑autovideo测试->324_162，跑autovideo测试->336_168，跑autovideo测试->60_60，跑lliautotest 1000次->80_80，跑lliautotest 1000次，这时会出现software interrupt

20:17 2009-7-13
(18:45 2010-6-13)
Linux移植, 软件技巧, 配置FC10, vmware tools(共享文件夹)等, vmhgfs
1, 安装open vmware tools:
cd open_vmware_tools/dep/Fedora10
rpm -ivh *
如果提示有些包已经安装, 用rm删除后再次"rpm -ivh *"
cd ../..
tar zxf open-vm-tools-2009.06.18-172495.tar.gz
./configure && make && make install 
注: configure和make最好使用普通用户, 否则没法启动时自动挂载. 如果没有权限可以修改目录owner(例如改为dec所有):
su
chmod dec:dec * -R
make install必须是root用户. 
#vmware软件中打开共享文件夹后: 
mount -t vmhgfs .host:/ /mnt/hgfs

2, 为了每次启动不用挂载修改/etc/profile, 把下面两句放在最后. 实际应该放在更合适的地方, 为了省事, 暂时放这里. 
mount -t vmhgfs .host:/ /mnt/hgfs

12:56 2009-7-14
<TODO>实验在电压允许范围内, pll稳定性差异</TODO>
<TODO>拿dongliang笔记本, 改ppt, 并上传</TODO>
<TODO>lvpin, 邮件: 确认fuyali是否是必现错误; 是否请shuyu解释? </TODO>

13:27 2009-7-14
VC0816, SV, clkrst, clkswitch bug, 续
1, 实验不reconfigure是否有改善
1), trigger switch后死, 后来发现是切到xclk时, 把pll关了. 修改Clkrst_SwitchXclk()代码, 如果不需要reconfigure pll, 就不关pll, 并且不能bypass pll. 
2), not reconf pll1
(1), cpu=240, bus=120, time=277, pass
(2), cpu=336, bus=168, time=500, pass
(3), cpu=316, bus=158, time=500, fail@377: 632_316_158
说明不配置pll时, 稳定性好很多, 但是仍然会死. 
3), cpu=12->336->12, dma=0, itor=2, times=500, pll切频时不power donw, 切频前后加入nop, doing.
(1), fail@97: 560_280_140
(2), cache off: 520_260_130
4), ChenYing"816 切频问题讨论会议"20090713_1203
模拟组提醒：如果不pll power down就切频，分频的寄存器的配置顺序要注意算一下，任何时候任何dividor修改后出来的都不能超过PLL的SPEC.否则可能会锁不住。
5), Lvpin认为应该先做pll是否reconf实验, 把pll择出来. 
6), 根据"4)"修改了代码, pll1,2的maindiv和indiv一起写入. <TODO>这点加入clkrst notes</TODO>
dma=0, itor=2, times=500, pll切频时不power donw, 切频前后加入nop, 如果切频前后pll相同不重新reconfigure pll.
(1), cpu=12->336->12 fail@239: 616_308_154
(2), 336_168, time=1000, pass
(3), 316_158, times=500, pass
(4), 60->168->60, 1:1, times=500, itor=2, fail@396: 608_76_76
(5), 296_148, times=500, pass.
(6), 120->336->120, 2:1, times=500, itor=2, fail@13: 344_172_86
难道是pll小于480导致的? 只在480-672之间测试: 
(7), 240->336->240, 2:1, times=500, itor=2, fail@220: 632_316_158
(8), (10:08 2009-7-15)保守一点, 实验memory在120--132之间切频
240->264->240, 2:1, times=500, itor=2, fail@38: 520_260_130, 260_130这个频点切了6次, 第七次死的. 
(9), 260_130, times=1000, pass, 
(10), 240->260, step=20, time=1000, fail@66: 520_260_130
(11), 240->264, step=24, time=1000, pass, 共切频2000次. 
(12), (16:02 2009-7-15)新增, 补充实验, 是否是24MHz倍数时相对稳定呢? 
(13), 240->336, step=24, time=500, fail@132: 528_264_132
(14), 240->336, step=24, time=500, pass
"16:02 2009-7-15"end
(15) (19:43 2009-7-15)
case1: bus从120->168, cpu:bus=2:1, step=4, fail@65 592_296_148
case2：bus从120->168, cpu:bus=2:1, step=24, fail@42 528_264_132
case3：bus从120->168, cpu:bus=2:1, step=24, fail@190 480_240_120
"19:44 2009-7-15"end

分析:
(1), 不reconfigure pll情况下, 切频没有死. 
(2), 与之前测试316_158切频测试相比, 目前的代码加入了nop, 之前是切到377次死. 另外在reconfigure pll情况下, case7是死在316_158, 说明reconfigure pll 会影响切频稳定性 
(3), 344_172_86死可能是低于pll 480-672的范围, 之前有类似情况   以后会避免超过pll480-672的范围.  
(4), 最后一个case: 240_120<->264_132互切case没有死. 这是目前唯一一个reconfigure pll切频没死的case.

补充:
(1), 316_158: case6)-(2)与case2)-(3)相比, 切频前后增加了nop, 说明切频前后增加nop是有效果的. 
(2), 注意到切死的case pll都不是12MHz的倍数. 难道和没有gate udc有关? 应该不是, 因为但是632_316_158这个频点, 单独切频没问题(case3)), 240->336连续切就死了(case7)), 不过fuyali的case pll都是12MHz倍数. 

7), 注意到
AASP时间, 打算以后用这个时间, 所以AASP必须重新编译. 
MSG(("Vimicro AASP V0.1 - built %s, %s\n",__TIME__,__DATE__));

8), 切到xclk时pll power down
今天讨论时dongxin猜测: 可能zhaogang仿真时是按配置div时pll power down仿真的. 
除了pll power down, 其余相同. 
(1), 240_120, times=500, pass.
(2), 240->336, step=12, times=250, itor=2, fail@2162: 504_252_126, 成功切频216次
(3), (23:38 2009-7-15)做2)的对比实验, 除了不power down, 其余相同: 
240->336, step=12, times=250, itor=2, fail@1697: 600_300_150, 成功切频169次. 和power down没什么区别. 
(4), (9:27 2009-7-16)power down
240->336, step=24, times=250, itor=2, pass
(5), 做4)的对比实验, 除了不power down, 其余相同: 
240->336, step=24, times=250, itor=2, pass

9), 测试不重新reconfigure pll, 但是改变cpu, bus divider. 有无问题. 
(1), (16:28 2009-7-15)代码修改编译完成, 尚未测试. 

15:02 2009-7-14
VC0830, SV, clkrst, memory, buglist, <TODO>整理</TODO>
1, Sdrc mode rdpath control
2, 300us 不够
3, 672：设计缺陷。480-900更好用。
4, 对于相同bus divider，pll1, pll2 ddr配置不同。
5, 低频到高频切频容易切死，预热后稳定。

21:08 2009-7-14
Linux移植, 续, 阅读代码goldfish2.6.27, 工具doxygen使用经验, <TODO>总结</TODO>
"early_trap_init"函数无法形成文档的原因: 
doxygen提示: 
/usr/src/embedded/android/kernel/goldfish/arch/arm/kernel/traps.c:726: Warning: documented function `void __init early_trap_init' was not declared or defined.
原因是函数中使用了"\var", 删除后"early_trap_init()"文档正确. 

21:30 2009-7-14
(16:46 2009-7-15)
Linux移植, 续, 阅读代码goldfish2.6.27, 续
1, 总体分析
1), 除了uart, clock, timer/tick, interrupt以外还需要看的: 
machine_desc, 如何映射IO, 寄存器列表, 
2), 直接从vmlinux开始调试, 还是从zImage开始? 初期如果不能直接看代码, 可以用命令复制vmlinux到memory. 然后开始运行. <TODO>找zhicheng, dongliang讨论, aasp能不能不开mmu? 如果从aasp开始做简单的bootloader比较好</TODO>
3), 相关函数列表, porting我们的test code时需要修改的底层调用.
(1), 除法
arch\arm\include\asm\div64.h:
uint32_t do_div(uint64_t *n, uint32_t base)
(2), 寄存器读写函数
arch\arm\include\asm\io.h: 
__raw_writex(__raw_writeb,w,l), __raw_readx(__raw_readl,b,w)

2, machine_desc分析

3, sysfs注册
1), smdk2440中core_initcall调用s3c2440_core_init()注册sysfs class s3c2440_sysclass.
在arch_initcall中, 依次调用s3c2440_irq_init, s3c2440_clk_init, s3c2440_pm_drvinit, s3c2440_dma_init注册struct sysdev_driver. s3c2440中的clk, irq分别都注册了两次, 注册两次的目的都是为了分层完成. 后者还在一次注册中注册了resume和suspend函数. 

4, Clock(转至"11:41 2009-7-18")
goldfish中由于没有实际硬件所以没有clock配置. 
计划参考pxa, at9261, s3c2440的移植. 
1), at91和s3c2440都是在map_io中初始化clocok.
2), pxa: littleton是在postcore_initcall(pxa3xx_init)初始化. 
map_io中只是get_clk_frequency_khz.
3), (22:53 2009-7-16)
pxa clk结构体没有parent, 将来如果需要切频肯定不方便, 但是pxa clk 接口函数实现的很清楚. 见arch\arm\mach-pxa\clock.c
"22:53 2009-7-16"end
4), (13:33 2009-7-17)
从clock接口实现方法, clk结构体, clock初始化流程等方面比较. 
clock接口说明在include\linux\clk.h已经有详细说明, 

5, uart

6, timer/tick

7, irq

8, 将来要做的工作
1), pm: pm函数暂时都不实现. 

9, 发信
函数注释可以参考: include\linux\clk.h
函数内部注释和列表可以参考: setup_arch()(arch\arm\kernel\setup.c)
结构体注释可以参考: include\asm\plat-s3c24xx\clock.h
doxygen在线文档: http://www.stack.nl/~dimitri/doxygen/manual.html

16:40 2009-7-15
Linux移植, 资料, kernel api文档
http://www.kernel-api.org/(项目已经暂停运行)
http://www.kernel-api.org/docs/online/2.6.17/

17:53 2009-7-15
VC0830, SV, vdec, 工具, demux
Caijin邮件"h264demux"20090715_1544
usage: 
h264_demux.exe -i test.mkv -y test.yuv -ss 00:00:20 -t 00:00:30
表示从test.mkv中提取h264码流，起始点为20s，截取30s码流
输出stream.h264为h264 byte stream
支持avi/mp4/mov/mkv等媒体格式

在截取码流时作了如下处理，
1.    保留所有的sps/pps nal unit
2.    在时间起始点之后，跳过部分帧，直到第一个IDR slice才开始dump
3.    所有非sps/pps/vcl nalu全部被直接扔掉了，从830 h264 driver来看，是没有问题的。 [有
问题可以反馈]

10:12 2009-7-16
VC0830, SV, clkrst, clkswitch, 切频测试
core=1.15, memory=3.11, 底板6050, cpu9073, memory9069, 电源板#102
1, 与CVS code merge, 调试
在Clkrst_SwitchXclk加入了"ClkrstBase_REALTIME_CTRL(1)"
之前caijin报的切频问题就是写入0x600000d0时, 没有把[28](REALTIME_CTRL)置1, 造成寄存器在切频前就更新. 
<TODO>这样说的话岂不是816也有这个问题? 只是因为memory参数没有变, 所以看不到</TODO>
2, 现在切频code一样, memory参数一样, 打包文件也一样. 
3, 830中如果加大延时可以多切几次, 但是原来代码没这个问题. 
4, 再次回去比较code, 交换现在code和0617code, 发现新code放到0617切频死, 旧code放到新code中没问题. 说明新code中哪里流程有问题. 

18:55 2009-7-16
VC0816, SV, clkrst, clkswitch, 切频会议
1, 切频会议记录:
1), Stable必须是16。
切频时看cke是否降，自动(self refresh)cke会降。如果是自动stable配512没问题。
如果是手动：切频前refresh，切频后再refresh。
(16:39 2009-7-17)
LinChuan邮件"答复: 898 stacked memory", Aiguo20090717_1543转发.
我检查了代码和波形
816在切频时采用的是sdram进入self refresh方式，本来应该对时间不敏感
但是在波形中发现，在刚发clock switch时，如果有其他命令一起发，会导致self refresh自动退出，所以，还是需要将delay时间设为20，由于DLL没有使用，这个时间是安全的
Bamvor: 和linchuan确认, 配置stable为0x10即可. 
"16:39 2009-7-17"
2), 切频时关闭cache
3), Pll power down
4), 确认pll reconfig，reset顺序
Reset放到reconfigure之后。
5), 816中830的CLOCLRST_PHY_MUX_SEL放到了sdrc的rd_path寄存器
6), 切频时不加nop
7), Sdrc timing是否是按168配置的。

2, 实验
1), pll1的reconfigure和reset顺序调整为先reconfigure后reset.
结论: 这样不行, 会造成pll无法正确配置. 
2), 60MHz以上, 以下都用Clkrst_SetSdrcStableTgt(0x10); 

3, 结论, 计划(zhangjian邮件)
1), stable 改为16后, 不加nop, 不delay, 不reconfigure pll时不会死. 
2), pll先reconfigure后reset无法正常工作
3), 今天开始先排除830新code切频问题, 排除代码问题. 再看816切频.

19:10 2009-7-16
1, cacheoff, pll powerdown, pll not reconfigure, no nop, no delay.
240_120, 500, pass

11:12 2009-7-17
VC0830, SV, clkrst, clkswithc, 修sdramSamsung切频问题
1, pll_sdrc_adj没有正确配置;
240_120切没问题. 到240->336, step=4, 死在264_132. 共切频了6次. 
错误不再是rvdebug停不下来, 而是0x0c异常. 
2, 切频到第9次, 272_136_136, 出现0x04异常. 
跟踪发现肯定是切频到pll后死, 查具体位置:
1), 在Clkrst_SwitchPll和"Clkrst_Msg("End Switch clk\n");"之间死. 
2), 后来确认是"Clkrst_Msg("End Switch clk\n");"后面死. 
为了避免是USB频率不正常造成的问题, 拔掉usb线, 而且打开restore_clk_m_gating_status中gate不能使用模块的代码. 
3), 这次是在"Clkrst_Msg("End Switch clk\n");"之前死. 下一次仍是. 可能上面是数错了. 
4), 没有进展, 
但是死在132MHz概率很大. 

11:34 2009-7-17
VC0830, SV, clkrst, clkswitch, EVB pcddr
1, 
ZhouDaShan邮件"830 EVB 板切频程序"20090717_1116
Zhangjian 
830evb 板的扫描参数在 830_sv_memscan 里面 ，
pcDdr16_evb.c pcDdr_evb_pll2.c
pll2 的参数为CPU:BUS=120M:120M                
切频保证能切到144M 即可

2, pcDdr16_evb.c中more_120参数适用于240_120, 288_144. 
pcDdr_evb_pll2.c适用于480_120_120.

3, 目标: Shuyu autotest跑过. 似乎一跑就死了, 但是切频没问题, 具体实验如下:
<TODO>这部分实验结果连同dashan邮件都要放到代码中</TODO>
1), cpu=240->288->240, step=4Mhz, cpu:bus=2:1, dma=0, times=500, 也就是每个频点切1000次. 
2), 288_144, vdec dongjingpiaoyi 720p, 无屏幕(没有找到屏幕:( ). (21:58 2009-7-17)mmc卡 mount 不上, 放弃.  
3), cpu=240->288, step=4Mhz, cpu:bus=2:1, dma=1000, times=1, pass
4), cpu=240->288->240, step=48MHz, cpu:bus=2:1, dma=5000, times=5, pass. 

4, CVS
zhangjian, clkrst, clkswitch
1, 加入EVB切频参数, 
1), cpu=240->288->240, step=4Mhz, cpu:bus=2:1, dma=0, times=500, 也就是每个频点切1000次.  pass
2), cpu=240->288, step=4Mhz, cpu:bus=2:1, dma=1000, times=1, pass
2, 加入添加memory文档(见clkrst\memory\mem_config.h), 完善了部分注释.
3, 根据816经验调整了部分代码

5, CVS log
Checking in clkrst/app/clkrst_app.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/app/clkrst_app.c,v  <--  clkrst_app.c
new revision: 1.37; previous revision: 1.36
done
Checking in clkrst/app/clkrst_app.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/app/clkrst_app.h,v  <--  clkrst_app.h
new revision: 1.16; previous revision: 1.15
done
Checking in clkrst/app/clkrst_app_module_clock.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/app/clkrst_app_module_clock.c,v  <--  clkrst_app_module_clock.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/app/clkrst_app_module_clock.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/app/clkrst_app_module_clock.h,v  <--  clkrst_app_module_clock.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/app/clkrst_app_switch.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/app/clkrst_app_switch.c,v  <--  clkrst_app_switch.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/basefunc/clkrst_basefunc.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/basefunc/clkrst_basefunc.h,v  <--  clkrst_basefunc.h
new revision: 1.16; previous revision: 1.15
done
Checking in clkrst/driver/clkrst_drv.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/driver/clkrst_drv.c,v  <--  clkrst_drv.c
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/driver/clkrst_drv.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/driver/clkrst_drv.h,v  <--  clkrst_drv.h
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/driver/clkrst_drv_system_info.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/driver/clkrst_drv_system_info.c,v  <--  clkrst_drv_system_info.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/driver/clkrst_drv_system_info.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/driver/clkrst_drv_system_info.h,v  <--  clkrst_drv_system_info.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/memory/mem_config.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_config.c,v  <--  mem_config.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/memory/mem_config.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_config.h,v  <--  mem_config.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/memory/mem_pcddr_hynix.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_pcddr_hynix.c,v  <--  mem_pcddr_hynix.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/memory/mem_pcddr_hynix.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_pcddr_hynix.h,v  <--  mem_pcddr_hynix.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/memory/mem_sdram_samsung.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_sdram_samsung.c,v  <--  mem_sdram_samsung.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/notes.txt;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/notes.txt,v  <--  notes.txt
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/test/clkrst_test.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/test/clkrst_test.c,v  <--  clkrst_test.c
new revision: 1.28; previous revision: 1.27
done
Checking in marb/bsdrc.h;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/marb/bsdrc.h,v  <--  bsdrc.h
new revision: 1.3; previous revision: 1.2
done

dma 5000次完成后:
Checking in mem_pcddr_hynix.c;
/doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0830/VC0830/clkrst/memory/mem_pcddr_hynix.c,v  <--  mem_pcddr_hynix.c
new revision: 1.4; previous revision: 1.3
done

6, code, 映像和log
D:\work\VC0830\SV\code_image\20090717\timer_sv_EVB测试映像PcddrHynix切频到144

7, <TODO></TODO>
1), 为什么mmc卡不能用; 
2), 发信pcddr切频和sdram有何区别(auguo, fengbeizhan, lingming, zhoudashan, linchuan) 
3), 

13:32 2009-7-17
VC0830, VC0816, SV, clkrst, clkswitch, <TODO></TODO>
1, <TODO>11:12 2009-7-17 2</TODO>
2, 816切频中, 在如下情况下测试每隔4Mhz测试切频1000次: cache off, pll不reconfigure, pll power down, 切频前后无delay无nop.
3, 听说830高温测试情况不错. <TODO>了解具体情况</TODO>

16:28 2009-7-17
VC0830, SV, DFT, TPI使用XClk情况下配置, for LvBoXue
0x60000000[1]=1
0x60000058[0:15]=0x0
0x60000024[6:7]=3
0x60000030[12]=0

16:55 2009-7-17
<TODO></TODO>
1, "13:32 2009-7-17"
2, 今天一定要完成clock文档. 明天完成uart文档. 

17:01 2009-7-17
VC0830, SV, rvdebug, 测量bus clock, <TODO>830使用总结</TODO>
1, 如果上一次使用rvdebug时开了memory窗口, 显示的是sdram数据. 重启板子再开rvdebug时, 会导致rvdebug连上板子后, "死"在读memory数据中. 因为此时memory尚未配置. 
2, 测量bus clock的方法:
1), 根据SV板封装. LQFP176芯片上面6个插针中间两个(一个clk, 一个clk反); BGA282封装上面6个插针最左边两个(一个clk, 一个clk反); 这种方法的好处是可以固定示波器持续测量. 
2), memory插槽中间缺口左侧. 这个与底板和memory无关, 是很通用的办法. 

11:41 2009-7-18
Linux移植, 续, 阅读代码goldfish2.6.27, clock分析
goldfish中由于没有实际硬件所以没有clock配置. 
计划参考pxa, at9261, s3c2440的移植. 
1), at91和s3c2440都是在map_io中初始化clocok.
2), pxa: littleton是在postcore_initcall(pxa3xx_init)初始化. 
map_io中只是get_clk_frequency_khz.
3), (22:53 2009-7-16)
pxa clk结构体没有parent, 将来如果需要切频肯定不方便, 但是pxa clk 接口函数实现的很清楚. 见arch\arm\mach-pxa\clock.c
"22:53 2009-7-16"end
4), (13:33 2009-7-17)
从clock接口实现方法, clk结构体, clock初始化流程等方面比较. 
clock接口说明在include\linux\clk.h已经有详细说明, 
5), 其它
at91中postcore_initcall->debugfs_create_file()建立了"/sys/kernel/debug/at91_clk", 用户可以读出clock寄存器和模块clocok状态(on/off), 频率. 和830中svclkinfo作用类似.  见"arch/arm/mach-at91/clock.c"

<TODO>at91的基本分析完了, 下午看pxa的, 写出文档. uart可能完不了啊!!! </TODO>

15:50 2009-7-20
Linux移植, 续, 阅读代码goldfish2.6.27, doxygen
1, 修改提取函数的规则
EXTRACT_ALL            = NO
EXTRACT_PRIVATE        = YES
EXTRACT_STATIC         = YES
EXTRACT_LOCAL_CLASSES  = YES
EXTRACT_LOCAL_METHODS  = YES
EXTRACT_ANON_NSPACES   = NO
HIDE_UNDOC_MEMBERS     = YES
HIDE_UNDOC_CLASSES     = YES
这样, 没有加文档的函数, 不会显示在文档中. 文档干净不好. 但是一定要注意如果希望某个函数加入文档, 首先需要把这个文件加入文档. 

16:40 2009-7-20
VC0816, SV, clkrst, clkswitch, 切频API, pll1->xclk, xclk->pll1
1, 切频
#include "clkrst\drv\clkrst_drv_public.h"
#include "clkrst\app\clkrst_app_switch.h"
1), 切到xclk: 
Clkrst_Switch(&g_SystemInfo_XClk12, INVALID_CLKSOURCE_ID, 0);
2), 切到480_240_120: 
Clkrst_Switch(&g_SystemInfo_24_480_240_120_120, INVALID_CLKSOURCE_ID, 0);
2, gate
#include "clkrst\basefunc\clkrst_basefunc.h"
Clkrst_SysClkGate, Clkrst_SysClkUnGate, Clkrst_MClkGate, Clkrst_MClkUnGate

17:00 2009-7-20
VC0830, VC0816, SV, clkrst, clkswitch, 
1, 
1), 现在可以确定只有cpu:bus=2:1, 使用xclk切频才有问题. 改写autoswitch代码, 确定这个想法. 
(19:39 2009-7-20)先1:1后2:1对于改善低频切频有帮助. 但是对于改善cpu>260MHz的情况没有帮助, 切528_132_132过去后, 再切528_264_132有问题. <TODO>明天找lvpin讨论</TODO>
2), 但是, 原来代码没有问题, 可能是代码流程不同造成的? 
(19:46 2009-7-20)估计是修改代码后, 有些地方的delay变了. 今天观察了两次, rvdebug死的时候, memory读写没有问题, 说明就是切频相关问题. 
2, VC0816 SV实验:
cpu=12->168->12, step=4Mhz, cpu:bus=1:1, dma=0, times=500, fail@97: 608_76_76

9:56 2009-7-22
<TODO>请假单, 找dongliang, aiguo签字,给zhangmin</TODO>

14:08 2009-7-22
VC0816, SV, beizhan切频bug: 每次切频50次, 连续切频多次后出错, 再进行多次后出错并引起AASP重启, <TODO>dashan在查, 关注进展</TODO>

14:32 2009-7-22
切频
1, 830 sdram情况下pll sdrc adj设成了0, 造成memory在120MHz切频死. 
2, 830中目前基本肯定死在268_134频点或附近2MHz. 
1), 会不会是其它模块造成的? 
2), xclk切频相关延时? 

3, 继续实验. 
1), cpu=24->270->24, cpu:bus=2:1, dma=0, itor=2, times=5, 第一次切到268_134, uart乱码. log: "log_20090722111734"
2), cpu=120->270->120, cpu:bus=2:1, dma=0, itor=2, times=5, 第一次切到264_132, uart乱码. log: "log_20090722144041"
3), 直接切到264_132, 产生0x4异常: 未定义指令. 
4), 单步跟踪没有问题. 

19:06 2009-7-22
VC0830, SV, BGA282不插CPU板的AP跳线可能导致无法启动(现象: 串口无信息)

19:14 2009-7-22
软件技巧, sourceinsight, 复制文件路径, 快速打开注释中的文件, 增强的Open功能
1, 
从lingming那里学到了如何复制文件路径, 在"Project File List"中右键菜单中选择"Copy List"的"Copy Selected Item(s)":
"Clkrst_test.c (clkrst\test)	35802	2009-7-20", 为了去掉不需要的size和date, 可以在右键菜单的"Project Window Properties"的"Appearance Options"去掉"File Size"和"File Date", 这样就是:
Clkrst_test.c (clkrst\test), 
比较好用. 如果直接在上面"Appearance Options"中选择"File Directory", 切出来的信息是: 
Clkrst_test.c	clkrst\Test
感觉反而不好用. 

2, 利用"Jump To Definition"打开文件, 选中包含文件名或完成路径的文件名, 选择"Jump To Definition"(快捷键"Ctrl+=")即可打开这个文件, 如果有多个重名文件, SI会和处理多个函数名一样, 打开对话框供选择. 
注意, 要么是文件名, 要么是文件相对工程的完整路径(例如: drivers/mmc/host/pxamci.c). 写"host/pxamci.c"是不行的. 
所以说, 在注释中, 必要的时候写明文件系统相对工程的完整路径+文件名在sourceinsight中能直接打开该文件, 在doxygen中会建立到该文件的超链接. 

3, SourceInsight强大的open功能:
sourceinsight扩展了Open功能, 有工程情况下File->Open(快捷键Ctrl+o)有如下用法:
1), 输入文件名: 显示所有满足此文件名的文件. 按回车打开第一个文件. 
这里的文件名要么是单独文件名要么是包含相对工程的完整路径的文件名(例如: drivers/mmc/host/pxamci.c), 而且支持通配符*. 例如忘记了830寄存器文件名. 可以输入"*regdef*".
2), 文件显示方式有两种: 一是工程所有文件; 二是当前目录文件. 默认是前者. 
两种情况下会恢复默认显示: A, 从Project file browser等选项卡切换回; B, Open的下拉菜单中选择"All Project Files"(下拉列表第一项)

21:37 2009-7-22
VC0816, SV, 用830旧代码, 程序虽然编译通过, 但是在32MHz跑飞, 明天继续查. 

12:55 2009-7-23
VC0816, SV, clkrst, clkswitch
1, 两次都是死在第一次的316_158, 单步却没问题. 后来自动跑死在303: 496_124_62.
目前死的现象是没有clk. 
2, 
1), 280_140: pc=0xc338
3, 旧代码也不行, 不查了, 直接实验pll不变情况下切cpu, bus.
4, 固定pll测试和pll变化测试:
0), clkrst参数如下: 
clkrst  SD:/>setparam
[CLKRST_MODULE]->do_clk_set_param()
clkrst pll stable add cnt: (Int)/[1](n: 切频前后加入n x cpu_clk的while循环delay)
clkrst pclkFixAtPll2: (Int)/[0](0: 允许切pclk到pll1)
clkrst force reconf pll while clock switch: (Int)/[0](0: 只有pll改变时才recongiure pll)
clkrst add nop before and after pll while pll1 clock switch: (Int)/[0](0: 切频前后不加入nop, 目前此参数无效, 如果恢复需要使用*.S的切频函数)
clkrst power down pll1 while switch to xclk: (Int)/[1](1: 当切频到xclk时关闭pll, reconf pll=1时有效)
1), pll=480, times=500, pass
2), pll=648, times=500, pass
3), pll=672, times=500, pass
4), 324_162, dma 1000 pass
5), cpu=240->336->240, step=4, cpu:bus=2:1, itor=2, dma=0, times=500, fail@58: 544_272_136
6), cpu=120->168->120, step=4, cpu:bus=1:1, itor=2, dma=0, times=500, fail@60: 592_148_148

5, 提交测试, 
测试环境: VC0816, LQFP144, sdram Samsung 32M
测试pll=480, 648, 672下cpu, bus切频是否正常, 测试1000次(共切频7000次), 命令和参数如下(只有cpu min/max freq 随pll频率变动而变动, 其余参数固定): 
clkrst  :/>autoswitch
All Operation Point Iterator Group is:
CLKRST: 0 name: min_to_max:
CLKRST: help: min_to_max
CLKRST: 1 name: max_to_min:
CLKRST: help: max_to_min
CLKRST: 2 name: minMaxMin:
CLKRST: help: Iterate from min to max, then from max to min
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
cpu min freq(MHz): (Int)/[12] pll / 8 ( 例如pll=480时, cpu min freq = 60 )
cpu max freq(MHz): (Int)/[168] pll / 2 ( 例如pll=480时, cpu min freq = 240 )
cpu freq step(MHz): (Int)/[4]1
cpu bus ratio(1,2,3,4): (Int)/[1]
times: (Int)/[5]1000
itIndex(0,1,2,... ): (Int)/[2]4(表示pll固定, cpu,bus切频)
pesudoSwitch: (Int)/[0]
[CLKRST_MODULE]MESSAGE:do_clkswitchAutoSwtich arg input succeed!
Select the clock switch path: 
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
destination clock source(0: pll1; 1: pll2, 3: xclk): (Int)/[0]
[CLKRST_MODULE]MESSAGE:arguments_dstCpuBusSrc input succeed!
[CLKRST_MODULE]->Clkrst_TestGetPll1MediumClkSrc()
clock switch method (1: pll1->pll2->pll1, 3: pll1->xclk->pll1): (Int)/[3]
[CLKRST_MODULE]MESSAGE:arguments_mediumCpuBusSrc input succeed!
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
dmaTimes: (Int)/[10]0
[CLKRST_MODULE]MESSAGE:arguments_dmac input succeed!
[CLKRST_MODULE]->do_clkswitchAutoSwtich()
delay(us): (Int)/[0]
[CLKRST_MODULE]MESSAGE:arguments_delay input succeed!

映像同时放在: "\\10.0.2.36\sqmshare\Projects\Mobile BU\vc0816\SV\20090723_816切频测试(pll固定)_Zhangjian2ZhangLu.rar"

6, zhangjian, clkrst, clkswitch
1), 切频代码调整;
2), 加入了固定pll切频的itor: 4

7, CVS
cvs commit: warning: unrecognized response `stty: standard input: Invalid argument' from cvs server
Checking in .cdtproject;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/.cdtproject,v  <--  .cdtproject
new revision: 1.54; previous revision: 1.53
done
Checking in config.gcc.mk;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/config.gcc.mk,v  <--  config.gcc.mk
new revision: 1.5; previous revision: 1.4
done
Checking in bootloader/bootscript.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/bootloader/bootscript.c,v  <--  bootscript.c
new revision: 1.6; previous revision: 1.5
done
Checking in bootloader/main.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/bootloader/main.c,v  <--  main.c
new revision: 1.31; previous revision: 1.30
done
Checking in clkrst/app/clkrst.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst.c,v  <--  clkrst.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/app/clkrst_app.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app.c,v  <--  clkrst_app.c
new revision: 1.4; previous revision: 1.3
done
Checking in clkrst/app/clkrst_app_module_clock.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_module_clock.c,v  <--  clkrst_app_module_clock.c
new revision: 1.14; previous revision: 1.13
done
Checking in clkrst/app/clkrst_app_operation_point.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_operation_point.c,v  <--  clkrst_app_operation_point.c
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/app/clkrst_app_operation_point.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_operation_point.h,v  <--  clkrst_app_operation_point.h
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/app/clkrst_app_switch.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_switch.c,v  <--  clkrst_app_switch.c
new revision: 1.5; previous revision: 1.4
done
Checking in clkrst/app/clkrst_app_switch.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/app/clkrst_app_switch.h,v  <--  clkrst_app_switch.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/basefunc/clkrst_basefunc.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/basefunc/clkrst_basefunc.h,v  <--  clkrst_basefunc.h
new revision: 1.5; previous revision: 1.4
done
Checking in clkrst/clkrst.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/clkrst.h,v  <--  clkrst.h
new revision: 1.4; previous revision: 1.3
done
Checking in clkrst/notes.txt;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/notes.txt,v  <--  notes.txt
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/subdir.mk;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/subdir.mk,v  <--  subdir.mk
new revision: 1.4; previous revision: 1.3
done
Checking in clkrst/driver/clkrst_drv.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.c,v  <--  clkrst_drv.c
new revision: 1.8; previous revision: 1.7
done
Checking in clkrst/driver/clkrst_drv.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv.h,v  <--  clkrst_drv.h
new revision: 1.7; previous revision: 1.6
done
Checking in clkrst/driver/clkrst_drv_divider.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv_divider.h,v  <--  clkrst_drv_divider.h
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/driver/clkrst_drv_system_info.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv_system_info.c,v  <--  clkrst_drv_system_info.c
new revision: 1.3; previous revision: 1.2
done
Checking in clkrst/driver/clkrst_drv_system_info.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv_system_info.h,v  <--  clkrst_drv_system_info.h
new revision: 1.5; previous revision: 1.4
done
Checking in clkrst/driver/clkrst_drv_type.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/driver/clkrst_drv_type.h,v  <--  clkrst_drv_type.h
new revision: 1.2; previous revision: 1.1
done
Checking in clkrst/test/clkrst_test.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/test/clkrst_test.c,v  <--  clkrst_test.c
new revision: 1.9; previous revision: 1.8
done
Checking in include/sys.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/include/sys.h,v  <--  sys.h
new revision: 1.23; previous revision: 1.22
done
Checking in padc/padcbase.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/padc/padcbase.h,v  <--  padcbase.h
new revision: 1.7; previous revision: 1.6
done
Checking in timer/timer.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/timer/timer.c,v  <--  timer.c
new revision: 1.6; previous revision: 1.5
done
Checking in timer/timer.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/timer/timer.h,v  <--  timer.h
new revision: 1.5; previous revision: 1.4
done
Checking in uart/uart_base.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/uart/uart_base.c,v  <--  uart_base.c
new revision: 1.10; previous revision: 1.9
done

8, memory目录未提交:
Checking in mem_config.c;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/memory/mem_config.c,v  <--  mem_config.c
new revision: 1.3; previous revision: 1.2
done
Checking in mem_config.h;
/public/methodology/ic-arch-verif/fpga_verif/VERIFY/VC0816/Panda/clkrst/memory/mem_config.h,v  <--  mem_config.h
new revision: 1.2; previous revision: 1.1
done

14:33 2009-7-23
VC0830, VC0816, SV, clkrst, clkswitch, <TODO></TODO>
816 pll不变切频完成后, 
0, 确定2:1切频是否一定死. (是, 1:1同样)
1, 确认830新旧code差异, 给aiguo发邮件. <DONE>
2, 今天要解决udc问题. 
3, zouweiran24Mhz测试估计得下周了. 

17:19 2009-7-23
信号发生器上, shift表示加入一定直流电平. 

18:05 2009-7-23
VC0816, SV, clkrst, dma, per, timer, <TODO>总结, 经验</TODO>
1, beizhan调试OS时uart配置不对(per配成了0x11), 了解原因: 似乎是osapp中修改的:
1), OSInit.S修改, 目的是使用timer.
INT_Timer_Initialize:
    STMDB   sp!,{a1-a4}                 /* Save on temporary IRQ stack */
    //set timer clk is 24m
    LDR		a1, =CLOCKRST_CKD_PER_CONFIG
    LDR		a2, =0x11
    STR		a2, [a1,#0]
    // delay for clk set    
2), 汇编里面可能没法用__SV__宏, 所以暂时不改了. 直接在main.c中再把per修改为0x44. 
\todo 这个地方得注意, 将来如果出问题可能得查. 

2, 之前DMA问题是变量溢出: dma内部有个counter, beizhan 循环时造成这个变量溢出. 把变量清零就好了. 

19:42 2009-7-23
VC0830, SV, clkrst, clkswitch
1, 测试1:1, 1:2, 1:3切频
1), cpu=12->168->12, step=4Mhz, cpu:bus=1:1, dma=0, itor=2, times=500,

20:36 2009-7-23
VC0830, SV, clkrst, clkswitch
zhuliying的sdram, zhangpu其余.
cpu=24->280->->24, itor=2, time=5, dma=0
core=1.180(我的板子1.163), memory=3.27(我的板子3.17)
5012+4011(CPU):
1, D:\work\VC0830\SV\code_image\20090723\830切频代码比较\new
fail@64: 276_138(两次)
2, D:\work\VC0830\SV\code_image\20090723\830切频代码比较\old
fail@65: 280_140, 但是276_138时已经不稳定了. 
cpu=240->288, step=4, cpu:bus=2:1, dma=100, 276_138之后乱码. 

3, 对换: 
5012+9073(CPU): 新旧code都pass: cpu=240->290->240, times=5, 
6050+4011(CPU): 
旧old: cpu=240->290->240, times=5, pass. 
新code: cpu=240->270->240, times=5, pass. 

21:46 2009-7-23
目前2块板子(LQFP144, sdramSamsung, 32M)固定在480, 648, 672三个pll频率下cpu,bus切频pass, 具体如下:
一个pll对应7个cpu,bus组合, 按cpu divider从大到小, bus divider从小到大顺序切频. 共做1000组. 
明天会继续做多个cpu板实验. 

10:18 2009-7-24
VC0816, SV, udc, udc优盘"设备无法识别", __packed, RVCT3.0
1, 20090709_0000code没问题. 
2, 换成新clkrst也没问题.
3, 换成新udc有问题, 比较差异:
1), D:\VC0816\Panda\udc\mass\udc_mass_cfg.h, driver\udc_config.h, driver\udc_frm.h, 都是"__packed"差异: 
1.3: 
__packed typedef struct  _USB_MASS_CFG_DESC {
	USB_CFG_DESC			CfgDesc;					/* config structure */
	USB_IF_DESC				IfDesc;						/* interface structure */
	USB_EP_DESC				EpDesc[USB_MASS_EP_NUM];		/* endpoint structure */
} USB_MASS_CFG_DESC, *PUSB_MASS_CFG_DESC;

1.2:
typedef struct  _USB_MASS_CFG_DESC {
	USB_CFG_DESC			CfgDesc;					/* config structure */
	USB_IF_DESC				IfDesc;						/* interface structure */
	USB_EP_DESC				EpDesc[USB_MASS_EP_NUM];		/* endpoint structure */
}__packed USB_MASS_CFG_DESC, *PUSB_MASS_CFG_DESC;

映像: "CVS20090709_ClkrstUdcCVSnew_UdcMassCfg_H修改为07090000code", 即改为1.2的形式. 

4, <TODO>Liaozhicheng在查, 关注进展</TODO>
当初zhicheng是因为rvct3.0编译不过才修改的. 

16:09 2009-7-24
VC0816, SV, clkrst, clkswitch, DongXin邮件"Fw: 816切频测试"回复
A: 就816目前观察而言: 
[1] Q: 你量切频死的时候的clock，能不能确定死在切频前还是切频后？
A: 死在切回pll1后,未见其它情况. 
[2] Q: 如果低频率下也能切死，那怀疑与sdram的hold timing不够有关，所以把程序放到sram中的切频程序一定要做
A: 并没有明确切频死的频率范围, 在较低频率死时pll小于480MHz, 估计是pll没有lock住造成的. 除此之外基本在120MHz以上死. 
[3] Q: 能不能确定在切频死后watchdog还能不能起作用，前提是你要确定watchdog的配置是对的。
A: 不能起作用, 正常切频时可以, 切频死了watchdog不起作用. 

17:03 2009-7-24
CPU: 80090313046

17:57 2009-7-24
VC0816, SV, clkrst, clkswitch, <TODO>实验切频是wdt能否使用</TODO>

11:00 2009-7-25
816: 1, 等张露测试结果;
2, wdt实验(早晨去了先做)
3, 24m晶振可能是pll2溢出造成的.

830
1, 完成周五测试, 176,282最高频率.

发信.

11:25 2009-7-27
VC0830, VC0830, SV, clkrst, clkswitch
今天实验的log从: "log_20090727140115"开始. 
1, 816: 
1), 等张露测试结果;
2), wdt实验
(1), wdt复位后有时会停在"Load""All backup img fail"或"Go, 发现这个地方一般会打出wdt中断中那句话"Mask wdog in second irq level, but don't clear second srcpend.\n!!".
wdt isr中去掉这句话后没发现会死. 
具体死在如下几个频点(pll cpu bus): 624 312 156, 632 316 158, 664 332 166, 448 224 112.
(2), wdt复位时没有重读strap pin. 
(3), 发现有一次wdt没有正常复位的情况. <TODO>发信</TODO>
(4), (10:08 2009-7-28)wdt可能也需要大量测试:
(1), 找IC看配置, reset count如何调整? 需要大量测试, 排除板子问题. 
(2), 修改配置后也无法保证每次都复位成功, 那只能是wdt复位后不mask自己, 在main.c中再关闭wdt. 
"10:08 2009-7-28"end
3), 24m晶振可能是pll2溢出造成的.
4), cpu是12的倍数时不会死:
(1), 直接gate usb的sys_gt和m_gt, 会死. 实验了一次
(2), cpu是12M的倍数时, 每个频点切50次没有死. 
(3), cpu=12->336->12, step=12, cpu:bus=2:1, 480<pll<672, fail@11075: 648_324_162, 此频点成功切频了396x2=792次.

6), sram切频空间太小, 所以用SPI. 找liaozhicheng. 见"16:22 2009-7-27"

2, 830
1), 完成周五测试, 176,282最高频率.

15:38 2009-7-27
VC0830, SV, clkrst, clkswitch, EVB(LQFP176_pcddrHynix), pll 576_144_144参数. 
1, ZhouDaShan邮件"evb 板参数根据新算法重新确定"20090727_1520
Zhangjian :
Linchuan 又提了新的参数算法，我根据新的算法重新确定了一组参数加到830切频程序中，以前发给你的数值先屏蔽掉，需要用最新的参数来验证我们板子的频率.
这个改动不是很大,除了下面的参数，其它不动
Sdradj   adj0  adj1  adj2  adj3
0Xe98e  0xb8  0x94  0x00 0x00  

2, 映像: 20090727_1643_温度测试288_144_Zhangjian2zhoudashan_LinChuan新扫描算法
以后用"D:\VC0830\vc0830_bootloader\DfuPack\K9HCG08U1M\bootloader_pcddr16_176_evbBoard"打包. 

16:22 2009-7-27
VC0816, SPI, SPI烧写eeprom和spi boot
1, 烧写eeprom
1), reset:
Find device At25f1024
2), erase 0 1 
3), dmawrite 0 imageAddress imageSize

2, spi boot是strap pin[0]

18:18 2009-7-27
VC0816, bootloader switch
尽量不修改原有bootloader和clkrst代码
1, 在common_def.h定义"INT32"
2, Makefile.arm:
1), 不编译clkrst_test
3, system.h
#define __SV__

#ifdef __SV__

#define CLKRST_TCLOCK
#define _SV144_
#define SYSTEM_MEM SDRAM_SAMSUNG

#endif // #ifdef __SV__

4, 处理clkrst, 还加入了
1), padc, marb目录, 只使用了头文件
2), 从uart_base.c/h加入以下四个函数到uart.c/h
Uart_base_calculate_baudrate
Uart_base_get_baud_reg
Uart_base_set_baudrate_with_divider
Uart_base_get_baudrate_from_divreg

10:56 2009-7-28
VC0830, VC0816, clkrst, clkswitch, <TODO>切频事宜</TODO>
aiguo希望这周完成, 我自己希望明天完成. 
1, VC0830优先:
1), EVB测试楼下提供好的频点. 低->高->低, 1000次. 
2), SV测试cpu=24->264, bus=12->132的1:1, 2:1. 1000次.
2, VC0816:
SPI boot

12:52 2009-7-28
merge 816 bootloader 到 830
1, 已经分析到clkrst_app_operation_point.c. 
2, <TODO></TODO>: 
1), 加入get/set parm. <DONE>
2), systemInfo->flag要注意修改: 看所有pll状态. PLL_CKD_RIGHT
3), <TODO>do_clkswitchAutoSwtich</TODO>

13:53 2009-7-28
VC0830
memory: sdram samsung 80090511027, CPU: LQFP176: 80090313046, 
底板: 80090316050(#8板).

22:29 2009-7-28
VC0830, SV, media, me, me同步提示
0: 音频视频同步(说明原来不同步, 现在同步了)
1: 轻微不同步, 软件丢B帧;
2: 严重不同步, 丢B, P帧, 也就是说只能等到I帧出现再解码了. 画面会有明显停顿. 

17:12 2009-7-29
./build/clkrst/test/clkrst_test.o: In function `do_clkswitchAutoSwtich':
clkrst/test/clkrst_test.c:744: undefined reference to `Clkrst_App_InvalidCoreClkSrc'
后来发现是clkrst_app.c中"#ifdef CLKRST_TCLOCK"放在了clkrst_app.h前面, 这样"CLKRST_TCLOCK"就没定义了. 

18:14 2009-7-29
VC0830, SV, clkrst, clkswitch, EVB(LQFP176+hynixPcddr)
1, cpu=144->288->144, step=4, cpu:bus=2:1, times=500,pass
2, cpu=144->288->144, step=4, cpu:bus=2:1, times=100000, 时间关系只切到19239, pass. log: log_20090729174403
3, (11:21 2009-7-30)
cpu=144->288->144, step=4, cpu:bus=2:1, times=10000, 时间关系只切到6534, pass. log: log_20090730094535
4, 映像和log目录: D:\work\VC0830\SV\code_image\20090729\1752_timer_sv_EVB(LQFP176_hynixPcddr

18:57 2009-7-29
<TODO>816用lingming 830 spi memscan尝试</TODO>

23:07 2009-7-29
工作总结, 今天工作, VC0830 clkswitch, Linux移植
1, 816代码修改merge到830, 测试cpu:bus=2:1通过. 晚上在跑10 0000次, 明天早晨实验1:1. 
2, Linux调试工具(Linux2.6.27), KFT对27没有支持, ftrace支持, kgdb支持. 实验ftrace但是加入ftrace后内核在解压缩后无反应. 查android emulator如何调试. 

9:46 2009-7-30
VC0830, SV, clkrst, clkswitch, 楼下EVB问题
映像: D:\work\VC0830\SV\code_image\20090730\1655_timer_sv_随机切频测试
1, 288_144->48_48死, 288_144切到72_72再切到48_48.
2, 加入了随机切频, 为了排除pll问题, 设定pll最小值为480. 
cpu=72->288, step=12, itor=5, times=1000, dma=0, pass
log: log_20090730144152
3, 刚才和youhai讨论, 估计是pll低于480造成的. 
4, 做好实验, 同样的code:
cpu=12->264, itor=5, times=1000, dma=0, pass. 
log: log_20090730175143, 最后一个autoswitch.
如果过了就踏踏实实做816 spi切频了. 
5, 移植Clkrst_SwitchPll12Pll1到vc0830_sv_memscan_use_spi_eeprom工程中, 首先实验通过830 spi和sdram, 然后修改为816. 

21:24 2009-7-30
VC0830, SV, EVB参数, 见youhai 20090730 2208 邮件

10:12 2009-7-31
(11:59 2009-8-1)
VC0830, SV, clkrst, clkswitch, 切频工具
用户外部配置若干组memory参数和切频方式, 启动后自动开始切频测试
1, 总的数据结构, 默认使用UINT32. 
0), 打包信息偏移: 0x200000(2Mbyte)
1), 系统参数:
(1), memory类型, (2), uart number(扩展, 目前用户不可见)
(3), pll,cpu,bus,vdec最大最小(这个是否由软件计算呢)
2), 切频方式: 正反随机, 次数, 目的clocksource(xclk, pll1, pll2), cpu,bus比例.
3), 切频参数: 频点, memory. 最多100个. 
第一个参数应当是medium switch的参数, 例如pcddr中pll1切频中中介的pll2上的参数. 
4), Clkrst_MemInfo_Get()
需要增加使用用户参数这个功能, 相关函数都需要修改. 
5), getSdrcRefresh!!!
如果sdrc_refresh提供, 就不调用这个函数. !!这个原来思路不同, 要认真check!!
6), tag_TOpItorGroupParm
(1), min, max, step归为一类, 单位改为Hz. !!!

2, 主要是review一下是否严谨:
1), memory参数, dll开关和延时是否加入? 
2), clkrst param是否加入? 
3), 其它参数. 

3, 修改代码:
1), Clkrst_MemParm_GetSdrcAdj()
如果用户提供了sdram的pll_sdrc_adj, 使用用户参数. 否则使用默认参数. 
已经修改了原型. adjpp改为parmp.
2), tag_TFreq
里面的min, max是否含, 原来是不含min, 含max. 文档已经改为都含. 确认. 
3), Clkrst_MemParm_DefaultGet
如果系统定义切频目的clock source, 不需要自己建立attr, 因为切频code认为给出的memory参数正确, 并直接使用TMemoryParm进行切频. 
4), Clkrst_MemParm_GetRefresh()
从SDRC_CFG(0x60011000)读出row, sdrc_refresh= 64000 / row * bus_freq(MHz)
<TODO>这得看lingming最后怎么确定了</TODO>
5), TOpItorGroupParm
type是新增的, 需要根据用户数组按顺序或随机切频, code需要修改. 
<TODO>: 暂缓.
6), Clkrst_Switch
用户批量切频时频点与memory参数一一对应, 利用Clkrst_SwitchPll12Pll1Base实验切频.调用Clkrst_TClk_Update计算per, uart divider, 不再调用Clkrst_SwitchMakeInfo.

4, CVS:
zhangjian, clkrst, clkswitch, 加入用户批量切频测试功能
1), 加入对应结构体. 

5, 与aiguo讨论后修改结构体
主要是加入默认值, 用户数据避免使用指针. 
CVS:
zhangjian, clkrst, clkswitch, 加入用户批量切频测试功能
1), 加入对应结构体. ver 0.2

6, (18:56 2009-7-31)目前基本雏形已经完成, 剩下是填细节, 上面提到的函数都需要修改. 此外Clkrst_SwitchPll12Pll1Base的update module divider也需要修改. 另外uart和per的寄存器还没有计算. 

7, (11:45 2009-8-1)<TODO>修改代码后首先保证原有切频代码可用</TODO>
1), 是否需要加入memory type呢? 查看代码后确认批量切频不需要配置memory类型. 
2), 编译时主要错误是struct和struct指针之间赋值问题. 

8, (19:41 2009-8-1)批量切频基本完成, 目前串口divider有点问题. 另外完成dma后uart没有打出频点. 

12:49 2009-7-31
<TODO>关注</TODO>:
1, http://lyris.mentor-info.com/t/17737/12100089/12516/3595/
mentor的android: 似乎是android, nucleus双核. 

14:43 2009-7-31
VC0830, SV, clkrst, clkswitch, <TODO></TODO>
pcddr低于60MHz不一定保证能用, 需要确认是否能用, 外部dll(即pcddr芯片内部的dll)是开还是关? 

19:00 2009-7-31
VC0830, VC0882, <TODO></TODO>
1,vm operation struct作用. 27中如何支持. <DONE>见"23:56 2009-7-31"
2,明天先完成并编译代码. 建立一个用于调试的结构体进行调试.
3,如果lingming参数完成, 用上面程序测试.
4,加入随机切频, 希望与opitor复用代码.

23:36 2009-7-31
VC0882, 多媒体, 图形加速, mali
1, 瑞芯微电子已经授权获得了ARM Mali-55 图形处理单元、ARM926EJ-S 处理器以及ARM Cortex-M3微控制器等三项ARM技术，帮助OEM 厂商提高图形质量，并且能够在不影响电池寿命的前提下在便携式设备上运行复杂的应用程序。
自: http://www.enet.com.cn/article/2009/0730/A20090730513117.shtml, 瑞芯微电子与Telechips获得ARM Mali图形处理单元. 已保存. 

23:56 2009-7-31
VC0882, 多媒体, 图形加速, mali, virtual memory, vm_operations_struct
1, vm_operations_struct定义在linux/mm.h, 是virtual memory的操作函数. 
2.6.24.7和2.6.27.29都有这个结构体, 略有调整

2, Linux2.6.24.7

/*
 * These are the virtual MM functions - opening of an area, closing and
 * unmapping it (needed to keep files on disk up-to-date etc), pointer
 * to the functions called when a no-page or a wp-page exception occurs. 
 */
struct vm_operations_struct {
	void (*open)(struct vm_area_struct * area);
	void (*close)(struct vm_area_struct * area);
	int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
	struct page *(*nopage)(struct vm_area_struct *area,
			unsigned long address, int *type);
	unsigned long (*nopfn)(struct vm_area_struct *area,
			unsigned long address);

	/* notification that a previously read-only page is about to become
	 * writable, if an error is returned it will cause a SIGBUS */
	int (*page_mkwrite)(struct vm_area_struct *vma, struct page *page);
#ifdef CONFIG_NUMA
	int (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);
	struct mempolicy *(*get_policy)(struct vm_area_struct *vma,
					unsigned long addr);
	int (*migrate)(struct vm_area_struct *vma, const nodemask_t *from,
		const nodemask_t *to, unsigned long flags);
#endif
};

3, Linux2.6.27.29

/*
 * These are the virtual MM functions - opening of an area, closing and
 * unmapping it (needed to keep files on disk up-to-date etc), pointer
 * to the functions called when a no-page or a wp-page exception occurs. 
 */
struct vm_operations_struct {
	void (*open)(struct vm_area_struct * area);
	void (*close)(struct vm_area_struct * area);
	int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);

	/* notification that a previously read-only page is about to become
	 * writable, if an error is returned it will cause a SIGBUS */
	int (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);

	/* called by access_process_vm when get_user_pages() fails, typically
	 * for use by special VMAs that can switch between memory and hardware
	 */
	int (*access)(struct vm_area_struct *vma, unsigned long addr,
		      void *buf, int len, int write);
#ifdef CONFIG_NUMA
	/*
	 * set_policy() op must add a reference to any non-NULL @new mempolicy
	 * to hold the policy upon return.  Caller should pass NULL @new to
	 * remove a policy and fall back to surrounding context--i.e. do not
	 * install a MPOL_DEFAULT policy, nor the task or system default
	 * mempolicy.
	 */
	int (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);

	/*
	 * get_policy() op must add reference [mpol_get()] to any policy at
	 * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure
	 * in mm/mempolicy.c will do this automatically.
	 * get_policy() must NOT add a ref if the policy at (vma,addr) is not
	 * marked as MPOL_SHARED. vma policies are protected by the mmap_sem.
	 * If no [shared/vma] mempolicy exists at the addr, get_policy() op
	 * must return NULL--i.e., do not "fallback" to task or system default
	 * policy.
	 */
	struct mempolicy *(*get_policy)(struct vm_area_struct *vma,
					unsigned long addr);
	int (*migrate)(struct vm_area_struct *vma, const nodemask_t *from,
		const nodemask_t *to, unsigned long flags);
#endif
};

4, 调整内容:
1), page_mkwrite 的第二个参数从page改为vmf.
原有24代码的page可以从"vmf->page"得到. 
2), 增加了access函数. 

5, <DONE>参考"11:34 2009-8-4"
1), 27, 24代码vm_operations_struct: 27少了nopage和nopfn, 这两个函数在27中都用fault代替.
2), 找一个vm_operations_struct的典型用法分析. 
