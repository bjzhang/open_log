
10:20 2010-2-1
VC0882, 最小环境, arm cortex-a8, SOC: omap3530, 移植aasp到OMAP3530, 续, 完善aasp, 去掉semihost, 续"12:40 2010-1-30"
0, 代码完成, 上传CVS. 总结: aasp除了热键功能外基本完成, 此次改进见"1".
代码映像: "D:\work\VC0882\code\milestonemini_aasp_aasp除了用户热键其余基本ok"
1, 加入aasp子命令模式: 
1), fgetssubT居然也是单独实现的. 而且依赖与修改后的fgetc行为. 这个问题我认为很严重: 我们要么使用库(库下面只有桩脚函数), 要么不使用库(像我们的f_open虽然不方便, 但没有可移植性问题). 
2), 命令行模式下退格有问题. 
2, 修正命令补齐问题: 
1), 把原有fgetc和Uart_Read4Aasp在aasp.c中实现, 并改名为getc4aasp和Read4Aasp. 可以正确补齐help命令. 补齐dhry会死. 
2), 现在又可以了. clean后再实验. 输入help, vimicro, dhry, dhry_global都可以. 发现输入"dhry_global 0 1就死了"
3), 后来去掉-Otime就没事了. 肯定还是代码有问题. 暂时不差. 
2, 注: dhry测试中由于没有实现timer, 所以最后不会给出测试结果. 

3, 去掉semihost:
1), 打开init.s的"IMPORT __use_no_semihosting", 提示: 
armlink : error L6915:  Library reports error: __use_no_semihosting was requested, but _sys_open was referenced
2), 与_sys_open有关的记录. 
Loading member sys_io.o from c_5.l. definition:  __stderr_name
              definition:  __stdin_name
              definition:  __stdout_name
              definition:  _sys_open
              definition:  _sys_close
              definition:  _sys_write
              definition:  _sys_read
              definition:  _sys_istty
              definition:  _sys_seek
              definition:  _sys_ensure
              definition:  _sys_flen
              reference :  __I$use$semihosting
              reference :  strlen
Loading member fopen.o from c_5.l. definition:  freopen
              definition:  fopen
              reference :  __aeabi_memclr4
              reference :  __stdin
              reference :  _fclose_internal
              reference :  _fseek
              reference :  _sys_open
              reference :  malloc
Loading member fopen_locked.o from c_5.l. definition:  _freopen$locked
              definition:  _fopen$locked
              reference :  __aeabi_memclr4
              reference :  __stdin
              reference :  _fclose_internal
              reference :  _fseek
              reference :  _mutex_initialize
              reference :  _stream_list_lock
              reference :  _sys_open
              reference :  freopen
              reference :  malloc
              weak ref  :  _mutex_acquire
              weak ref  :  _mutex_release
没什么线索. 只好单步跟踪.
3), 单步跟踪发现是"_main"->__rt_entry_presh_1->__rt_lib_init->_initio->freopen->_sys_open
4), 看_sys_open相关库的移植.
(1), fputc要考虑大小端问题. 
Be aware of endianness with fputc(). fputc() takes an int parameter, but contains only a character. Whether the character is in the top or the bottom byte of the integer variable depends on the endianness. The following code sample avoids problems with endianness:
extern void sendchar(char *ch);
int fputc(int ch, FILE *f)
{
/* example: write a character to an LCD */
char tempch = ch; // temp char avoids endianness issue
sendchar(&tempch);
return ch;
}
(2), 2.11.2 Target-dependent input and output functions use semihosting. If any function is redefined, all stream-support functions must be redefined.
(3), 没看出太多端倪, 
最后是参考"VC0882/adslib/In_custom.c"修改retarget.c, 注释了
//FILE __stdout;
//FILE __stdin;
//FILE __stderr;
并加入了In_custom.c的_sys_xxx定义. 这个地方其实不是很明白. \todo 还需要理清思路. 
原来retarget.c的注释说
** These must be defined to avoid linking in stdio.o from the
** C Library
struct __FILE { int handle;   /* Add whatever you need here */};
//FILE __stdout;
//FILE __stdin;

4, 目前未解的地方:
1), cortex-a8 cache mmu最基本代码还不理解: 开cache, 映射并开启mmu. 
2), 

13:00 2010-2-1
时间管理
0, 9:37-23:03

1, 计划
1), VC0882最小环境, 移植aasp到OMAP3530.
2), 发VC0882最小环境上周总结邮件. 见"13:01 2010-2-1"
3), 新增计划(19:38 2010-2-1)
(1), 加VC0882 nucleus下面的中断. 
(2), 发邮件: kernel选型, kgdb, ftrace. <DONE>
(3), 简单看下vavante Linux driver版本. 
"19:38 2010-2-1"end

2, 执行
1), VC0882最小环境, 移植aasp到OMAP3530. 见"10:20 2010-2-1"
(其中1h支持arm debug).

3, 次日计划: 
1), 填加班记录. 

13:01 2010-2-1
VC0882, 最小环境, 上周工作总结, 移植aasp到OMAP3530, arm debug
1, aasp: 目前实现功能和问题. 架构调整. 
2, armdebug: 仿真没有通过. 给IC同事发了CSAT和RVI文档. 会加上RTCK和ROM.
开始需要一个比较大的sram(256kbyte). 

22:33 2010-2-1
VC1600, VC0882, arm debug, JTAG; RVI, rvds4.0安装
关于VC0882机器
Hi, all
598实验室进门右手中间那台机器(test6)已经为882项目安装了RVDS4.0, 此机器的RVDS3.0暂时不能用. 请大家用其他机器. 
hi, dongliang 
test11那台机器的license怎么设置都不行(rvds4.0和rvds3.0都不行). 没办法只能用test6这个机器了(安装很顺利..). 
不知道是因为test6机器比较干净.

22:43 2010-2-1
VC0882, gpu, 2d/3d, vivante, 编译
vivante: rvds3.0 codewarrior. 编译2d时提示no linker command. 后来clean一下就可以了. 编译3d时还是同样问题, vavante工程师发现是utilities.h的'#include "Regs\AQ.h"'字母大小写 错了. 
注: 3D资料: "\\10.0.2.36\sqmshare\Document\Gpu"

10:19 2010-2-2
时间管理
0, 9:43

1, 计划
0), 整理本周工作计划. <DONE>
1), VC0882<转移>:
(1), VC0882最小环境, 移植aasp到OMAP3530. 初步完成, 总结. 
(2), 发前段时间arm最小环境总结提纲, 本周如果有时间向大家汇报. 见Aiguo邮件"答复: VC0882 kernel选型和debug方式调查"20100202_0939
(3), 加VC0882 nucleus下面的中断. 周四之前需要给大家使用. 
(4), 在VC0882/panda_os下面加入irq, uart, sdio寄存器. 本周完成. 见AiGuo邮件"882 reglist"20100201_1950
2), GPU driver: 简单看下vavante Linux driver版本. <转移>
3), 编译并实验beagleboard eclair. <转移>
4), 杂: <转移>
(1), 填加班记录. 

4, 总结: 下午去调vivante东西花了大量时间. 当初拿来arm11板子时如果用过烧FPGA这个就会快一些. 当初本来想做的, 为什么没做就不清楚了. 

10:28 2010-2-2
VC0882, 最小环境, FPGA, arm debug, cortex-a8, RVI连接VC0882, 续, HuangWei询问Arm cortex-a8 coresight debug问题
Support-cores [Support-cores@arm.com]邮件"Re: two issues on coresight (446204)"20100202_0739
> I have two questions on cortex-a8.
> 
> 1. cortex-a8 and DAP can both access debug apb bus. But from ARM 
> document,
> cortex-a8 access debug
> apb with address bit 31 low but dap access it with address bit 31 
> high. Does this mean that two address regions, one resides in lower 2G 
> and one in higher 2G, should be allocated for debug apb bus ?
No. You simply allocate enough memory map for the address space of the debug APB in your system memory map. You have a APB interface connected to your bus matrix (like PL301/NIC-301). You decode your APB at the appropriate system address. Let's say you need 128K bytes for your Debug APB. You connect the APB from your system bus to the APB-Mux in the DAP. Now either your system address space or your debugger can get to this 128K (17 address bits) space. So all of the peripheral on the debug APB look at the 17 bits of address. They also look at bit
31 on the debug APB to determine if the master is the system CPU or the debugger.
> 
> 2. We implemented cortex-a8 and coresight in FPGA．Using CSAT as the 
> debug console, we found that alternative APB-AP and AHB-AP access to 
> debug apb will result in AHB-AP access failure. Is anything wrong with 
> this ? And realview debugger can't correctly connect to a8. Will 
> realview debugger use both APB-AP and AHB-AP to access debug apb?
You are allowed to use either system accesses or debug accesses to the debug APB. There are no limitations on mixing these accesses. There are no known errata related to this function.

10:36 2010-2-2
杂志, 嵌入式, 电子工程专辑, 用户名zhangjian@vimicro.com, 密码: 最简工号密码(7位)

11:12 2010-2-2
VC0882, 最小环境, FPGA, arm debug, aasp, 整理本周工作计划. 
1, VC0882最小环境, 移植aasp到OMAP3530. 初步完成, 总结. 
2, 发前段时间arm最小环境总结提纲, 本周如果有时间向大家汇报. 见Aiguo邮件"答复: VC0882 kernel选型和debug方式调查"20100202_0939
3, 加VC0882 nucleus下面的中断. 周四之前需要给大家使用. 
4, 在VC0882/panda_os下面加入irq, uart, sdio寄存器. 本周完成. 见AiGuo邮件"882 reglist"20100201_1950
5, 试验openocd, codehammer在VC0882上能不能使用. 这个估计得周五了. 

11:39 2010-2-2
VC0882, rtos, nucleus, nucleus中timer移植
参考nucleus internal(中文: Nucleus PLUS源码分析)定时组件(Timer Component)
1, 根据文档 tmt.xxx是timer移植文件. 查看工程可以找到Nu_Tmt.s(VC0882/panda_os/nucleus/port), 这个里面有各种timer底层函数. 可能只是我们没有实现. 另外"Panda_Init.s (appsentry\init_src\asm)"里面的调用timer中断的部分(TMT_Timer_Interrupt)可能被注释了.
2, 根据文档和代码"Timer"应该是timer counter基址, 但是没找到谁给它赋值.

13:48 2010-2-2
1, 注意cortex-a8和cpu-axi是同步的. 
HuangWei邮件"Vc0882 FPGA platform is ready now"20100202_1248
Vc0882 FPGA platform is ready to run test now. FPGA image version is rev0_01020122_02020121. 
Configuration of this version is as following:
1. CPU_ACLK:   32MHz 
2. PCLKIN;     25Mhz
3. ACLKIN:     22.58Mhz
4. XCLKIN:     24Mhz
5. X32KIN:     12Mhz
Note that A8 core clk is synchoronus to CPU_ACLK. Thus A8 core is running at 32Mhz.
Hi ZhangJian, 
you can start debug session on this version now. In addition, please setup another FPGA hardware platform for concurrent use by ICD and ICP. 
Hi MeiPing, 
Using CSAT as the debug console, alternative APB-AP and AHB-AP access to debug apb will result in AHB-AP access failure. And this failure is repeatable. So Could you continue emulating it and try to regenerate it in simulation? I will work with you on this. 
2, YangZuoXing邮件"答复: Vc0882 FPGA platform is ready now"20100202_1304
目前我们采用简版的ARM A8 (NO NEON, NO L2 CACHE), 在简化的条件下（32MHZ FOR ARM AND 32MHZ FOR ARM’S BUS），终于可以通过A8 的JTAG访问到882 的SRAM 和模块寄存器了！
感谢HUANGWEI, HAIFENG,JIHUA, ZHANGJIAN,MEIPING这一两个礼拜的努力！
虽然比原来的计划晚了一些，但我们还是要努力将失去的时间再赶回来。
HI, YANGLEI,
请仿一下FPGA版本的DDRC+PHY.
HI, DASHAN, YUNFEI AND WENJIE,
请准备在FPGA上调试MOBILE DDR.
HI, JIHUA and zhangjian,
请准备好三个平台，一个FOR ARM DEBUG, 一个FOR ZHANGJIAN, 一个FOR DDR DEBUG.
3, 实验和回信:
1), 简单测试了1MHz, 10Mhz, 20Mhz clock下arm寄存器和sram读写pass, 下面会实验最简单的程序能否运行. 
2), 实验中RVdebugger memory窗口中访问0x7ffc地址时会提示0x8000 precise data abort, 
记得830 sram超过边界会自动绕回. 一般这种超过memory边界的访问硬件如何处理呢? 
3), 用adaptive clock auto configure会出错. 

Hi, dr. yang
0), 能不能总结一下之前遇到的问题便于将来分析. 
1), memory只有32k, 没法跑我们已经准备好的测试程序. 因为axf文件默认从0x8000地址(32k)开始链接, 我们希望在sram和ddr跑的程序是一样的. 
2), 说明FPGA现有模块: 是否是全功能, 对软件的影响, 例如arm没有L2 cache. 我们软件最小环境至少需要uart, timer, irq等模块. 
3), 希望说明一下现有coresight结构. 另外现有版本仿真是否仿过path: jtag-dp -- apb-ap -- cortex-a8, jtag-dp -- ahb-ap -- sram. 这两条通路RVdebugger软件需要使用.
4, 思考: 去掉arm的L2 cache和NEON会不会有问题呢? 没有NEON会出现未定义指令. 查没有L2会怎么样. rvds4.0里面可以选择无NEON无L2. 

16:20 2010-2-2
VC0882, GPU, 2d/3d, vivante, vivante 2d test运行成功
1, 参考"16:16 2009-11-5"arm debug training. 
2, "C:\Program Files\ARM\Versatile\PB11MPCore_HBI0159\3.7\1\boardfiles"
1), filelist.txt有文件说明: 包括progcards_multiice, progcards_usb, progcards_rvi相关文件的说明. 
3, multiICE:
1), multi-ice\multi-ice_config_file_creator.xls, 里面Board选择PB11MPCore, 单击"Create multiICE configuration file"生成配置文件(*.cfg). 
2), 根据irlength_arm.txt文档把irlength加入"<\Program Files\ARM>\Multi-ICE\irlength.arm".
3), 打开multiice server, load刚才保存的configuration.
4), progcards_multi.exe
4, USB方式.
在"C:\Program Files\ARM\Versatile\PB11MPCore_HBI0159\3.7\1\boardfiles\usb_debug_driver"安装驱动. 
4, 最后发现是板子型号错了. 
板子型号: EB_HBI0140, 资料光盘(arm felix liu提供)"\\10.0.2.36\sqmshare\Document\ARM\VersatileFamilyCD_v3.7".
板子支持usb烧写FPGA, 驱动位于boardfiles\usb_debug_driver. 
使用progcards_usb.exe下载, 完整压缩包在"\\10.0.2.36\sqmshare\Document\Gpu\GC430\demo完整包"(包括编译结果和log).

10:05 2010-2-3
时间管理
0, 9:38

1, 计划<DONEor转移>
1), 上午完成VC0882装机. 发信. <DONE>
2), arm评估板FPGA烧写方法总结: 这个很重要. 下午training前要完成. <DONEby0204)
3), 下午training. <DONE>
4), 看昨天, 前天VC0882最小环境相关邮件. 
5), 晚上看irq并找dongliang讨论. VC0882最小环境其他计划见11:12 2010-2-2".
6), 杂: 编译并实验beagleboard eclair; 填加班记录(2月1日, 2月3日). 
7), 新: 
(1), irq写测试代码. reglist: irq, dmac. 
(2), 请dongliang讲了讲uart改动(nucleus下), 无OS下的代码以后看来使用会很少了. 
(3), clock提供接口函数. beizhan已经发了padc的. 这个我要抓紧.
(4), 更新VC0882 FPGA注意事项: config, reset等<DONEby0205)
8), beizhan会做一个sd卡boot, 可能需要我帮忙.
9), zhaoyuan会去移植Linux. 我的想法是做irq, uart,timer最小环境时就考虑好Linux需要的函数, 最小环境OK同时Linux kernelOK. 版本选择2.6.29标准内核.
10), sdio 寄存器读写. 

2, 执行
1), 上午+中午部分时间完成计划-1), 见"10:27 2010-2-3".
2), 下午training.
3), 19:41- . VC0882最小环境, 在FPGA上跑简单程序验证arm基本可用. 见"19:44 2010-2-3"

10:14 2010-2-3
VC0882, 最小环境, arm cortex-a8, coresight, debug, aasp, 列出VC0882最小环境相关内容的提纲("11:12 2010-2-2"2)
1, cortex-a8 overview, 原来总结过. 分core到board四个层次说明
2, debug: 结合arm文档和huangwei VC0882资料, 调试中问题说明. 三个cortex-a8调试器.
3, TI OMAP3530研究. bootloader,kernel, android.
4, Linux kernel: kgdb, ftrace. 
5, VC0882最小c环境: rvds4.0初始化流程变化. cache,mmu变化(HW, SW).

10:27 2010-2-3
(11:28 2010-3-5)
(20:39 2010-6-1)添加realviewICE, TRACE2驱动地址
VC0882, 最小环境, rvds4.0安装使用, RealViewICE使用说明, 已上传CVS, 与CVS同步
CVS位置: "D:\VC0882\document\arm\debug\RealViewICE使用说明.txt"
0, 注意事项
1), 使用两相电源线, 原配三相电源线是125V, 10A的.
2), arm推荐用LVDS那根高速jtag线(40pin): 
a long 40-way ribbon cable and a Low Voltage Differential Signaling (LVDS) 40-way to 20-way probe.

1, rvds4.0机器做了ghost
在"\\10.0.2.36\sqmshare\share\ghost"传了四个映像, "gx620_rvds4.0_ghost"是实验室test6机器的映像, 这个映像是新恢复的系统, 很干净. "gx755_full_sw_ghost"是zhangjian pc的映像(需要改ip). "gx520_rvds40_ghost", "4600_rvds40_ghost"分别是830sv实验室两个机器的映像. 
"gx755_full_sw_ghost"用于yuyang 760机器时, 开始鼠标键盘无法使用, 后来系统自动更新后可以使用(不清楚是否与系统自动有关).

2, rvds4.0安装: 
1), 软件和crack位于"\\10.0.2.36\sqmshare\Utilities\IDE\rvds4.0". crack详见crack\readme.txt. 
注意rvds4.0和以前版本无法共存, 安装rvds4.0后codeworrier和eclipse仍然可以使用, 但是armcc会使用4.0的armcc. 
如果希望使用旧版, 需要修改环境变量. 
例如使用rvdebugger3.0, 需要修改"RVDEBUG_INSTALL"为: 
C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium. 否则rvdebugger会在连接时报错.
注: 使用eclipse ads编译时要去掉"--apcs /adsabi", 这个参数rvds4.0已经不支持了. 
2), 如果是机器ghost恢复的直接修改网卡物理地址即可:
C:\Program Files\ARM\Licenses\rvds.dat中"0013729F936F"(hostID)替换为自己的网卡物理地址. 网卡物理地址可以用"ipconfig /all"查看. 
0013729F936是rvds.dat中hostID=后面的数字. 一共19处需要替换. 复制自己网卡物理时别忘了去掉中间的连接符”-“

3, RVI使用
1), RVI第一次连接时会安装驱动. 成功后在任务栏右下角有USB设备" RealView ICE Hardware on USB". 如果没有自动安装驱动, 可以去设备管理器中更新驱动, 系统自动找到驱动. 
2), 使用比原来的jlink和multiice多了auto configure步骤, 详细过程见"36: Document\Jtag_Debugger\RVI\rvi使用方法.doc"
(1), clock speed设为10MHz. auto configure时一定不要选”Use adaptive clock”, VC0882硬件设计有问题. RTCK接到了其它地方, 会造成rvi找不到a8. 
(2), 建议右键单击新加入的RVI configuration, 选择rename, 改名为”VC0882”, 已经在init_sciprt 脚本中加入连接cortex-a8的命令.
3), 命令行使用
\todo: 测试cortex-a8基本寄存器和memory能不能写成脚本. 
1), 设置寄存器
setreg @R9=0x1
2), memory填充, 从0x0到0x8000以32byte为单位填充0xaa55aa55: 
fill /32 S:0x0..+0x8000=0xaa55aa55

4, realviewICE和TRACE2插入PC后, 提示安装驱动. 一般选择自动搜索即可. 如果找不到, 可以手动指定目录"C:\Program Files\ARM\RVI\Drivers\usb_driver\1.3\39\win_32-pentium".

17:22 2010-2-3
VC0882, GPU, 2d/3d, vivante, arm evaluation board: EB_HBI0140, FPGA烧写方法, 运行vivante 2d demo; 支持shanghai VC0718 team PB-A8使用. 
1, 准备工作
1), 确定板子型号(EB_HBI0140): 从板子coretile, logictile下面可以看到HBI0140.
2), 解压"\\10.0.2.36\sqmshare\Document\Gpu\GC430\demo完整包\boardfiles.rar", 烧写FPGA需要的文件都在这里.
注: 板子原始资料可以安装"\\10.0.2.36\sqmshare\Document\ARM\VersatileFamilyCD_v3.7". "C:\Program Files\ARM\Versatile\EB_HBI0140\3.7\1\boardfiles"是板子FPGA烧写工具和配置脚本. 里面的Filelist.txt描述了各文件作用.

2, FPGA烧写
FPGA烧写支持USB, multiICE, RVI等方式, 我们使用USB方式.
1), 把"Config switch"(电源按键旁边)拨到ON, 给板子上电, 准备烧写FPGA. 这时板子的字符lcd不会显示字符. 
2), 安装USB驱动: "boardfiles\usb_debug_driver".
3), 烧写程序是progcards_usb.exe, 使用"tapid.arm"作为扫描链配置文件. 
4), 执行progcards_usb.exe
第一次输入1: "  1: Emulation Baseboard (HBI-0140) skip". 我们不烧写主FPGA, 直接跳过. 
第二次输入1: "  1: gc300_4_5_0_armv5 (DEFAULT) - LT-XC5VLX330 (HPI-0172A) try1 to flash"表示烧写logic tile FPGA为gc300_4_5_0_armv5. 
输入后会烧写flash(相当于我们写CF卡). 为了提高速度去掉了verify部分. 
这里使用了vivante给出的三个文件: gc300_4_5_0_armv5.brd, gc300_4_5_0_armv5.bit, via\ltxc5vlx330_172a_xc5vlx330_via_build0.bit.
brd是烧写配置文件, 我们也可以根据FPGA型号, 扫描链, 烧写文件名编写(参考progcards.pdf). gc300_4_5_0_armv5.bit是logic tile FPGA配置文件. 最后一个不知道是啥东西. 

3, 运行vivante 2D demoe:
1), FPGA config switch 拨到OFF. 字符LCD先显示test..., 最后显示软件硬件版本. 这表示FPGA配置完成, 板子可以用了. 
2), rvds4.0和RVI使用参见"D:\VC0882\document\arm\debug\rvi使用方法.txt". 只是RVI会找到4个arm11MP, 连接MP0即可. 
3), "Target->load image"加载映像, 运行. 2d demo使用semihost输出到rvds STDIO, 可以输入数字键选择test case.

4, (13:44 2010-6-2)复制自log文件
progcard, 烧写log:
ARM Development Card Logic Programmer
Version 2.70

Attempting to connect to OCD driver.

Found 8 TAP controllers

  TAP0 XC2V6000
  TAP1 XC2C128
  TAP2 XC2C128
  TAP3 ispClock5620
  TAP4 ispClock5620
  TAP5 XC2C384
  TAP6 ARM11MPCore_BS5
  TAP7 XC5VLX330

Several possible boards detected at TAP position 0:-
  0: Quit progcards
  1: Emulation Baseboard (HBI-0140) skip
  2: Emulation Baseboard Rev B or C or D or E Mux PLD build 2
  3: Emulation Baseboard Rev B or C or D or E Mux PLD build 3
  4: Emulation Baseboard Rev C Config PLD build 2
  5: Emulation Baseboard Rev D or E Config PLD build 3

Make a choice: 1

CT11MPCore (HBI-0146) skip detected at TAP position 3

Several possible boards detected at TAP position 7:-
  0: Quit progcards
  1: gc300_4_5_0_armv5 (DEFAULT) - LT-XC5VLX330 (HPI-0172A) try1 to flash
  2: Virtex 5 Logic Tile (HBI-0172B) skip

Make a choice: 1


Step 1: FPGA download of via\ltxc5vlx330_172a_xc5vlx330_via_build0.bit
  Progress: 100.00%, Throughput: 158.53k/s, Frame: 1245194

Step 2: Intel flash download of gc300_4_5_0_armv5.bit
  Progress: 4.63%, Throughput: 9.80k/s

...

5, log文件解释(zhangjian2YangGuolong邮件"答复: pb A8下载问题"20100602_1530 shanghai VC0718(?)). 邮件中删除了与vivante gccxxx有关的文字. 
Hi, yang guolong

Pb-a8通过usb config下载的详细文档见progcard的帮助. "progcards_xxx.pdf", logic tile范例有AN128(flash led), AN151(AXI device). 目录"C:\Program Files\ARM\Application_Notes\".
另外pb-A8使用有问题也可以直接给arm support发邮件. 

1), 我结合原来在arm EB_HBI0140(arm11)板子的log说明使用progcard烧写过程. 
EB_HBI0140板子的jtag扫描链有八个芯片. 我希望在第8个芯片(TAP7)烧写. 过程如下
1, 启动progcard后, progcard会扫描FPGA jtag扫描链, 找到扫描链上所有芯片, 会列出芯片名称, 例如下面这个log里面有八个芯片.
ARM Development Card Logic Programmer
Version 2.70

Attempting to connect to OCD driver.

Found 8 TAP controllers

  TAP0 XC2V6000
  TAP1 XC2C128
  TAP2 XC2C128
  TAP3 ispClock5620
  TAP4 ispClock5620
  TAP5 XC2C384
  TAP6 ARM11MPCore_BS5
  TAP7 XC5VLX330

扫描后, progcard会从tap0开始查找配置文件, 如果找到配置文件, 会列出全部配置文件, 供用户选择, 如果未找到会直接跳过, 这些配置文件一般包括skip和实际操作两种, 例如
Several possible boards detected at TAP position 0:-
  0: Quit progcards
  1: Emulation Baseboard (HBI-0140) skip
  2: Emulation Baseboard Rev B or C or D or E Mux PLD build 2
  3: Emulation Baseboard Rev B or C or D or E Mux PLD build 3
  4: Emulation Baseboard Rev C Config PLD build 2
  5: Emulation Baseboard Rev D or E Config PLD build 3
这次我写烧写tap7, 所以选择1 skip, 表示不操作这个tap, skip对应配置文件见("2)"):
可以看到文件中TAP0后面的” XC5VLX330”是与上面progcard找到的扫描链中TAP0的名称对应的. 选择1之后
Make a choice: 1

CT11MPCore (HBI-0146) skip detected at TAP position 3

最后会到达tap7, 找到配置文件如下, 1是我用于烧写的配置文件(见"3)"), 选择1会按配置文件进行烧写. 
Several possible boards detected at TAP position 7:-
  0: Quit progcards
  1: LT-XC5VLX330 (HPI-0172A) try1 to flash
  2: Virtex 5 Logic Tile (HBI-0172B) skip

Make a choice: 1


Step 1: FPGA download of via\ltxc5vlx330_172a_xc5vlx330_via_build0.bit
  Progress: 100.00%, Throughput: 158.53k/s, Frame: 1245194

Step 2: Intel flash download of xxx.bit
  Progress: 4.63%, Throughput: 9.80k/s

...
如此烧写完成. 

2), skip文件(for TAP0 XC5VLX330):
[General]
Name = Virtex 5 Logic Tile (HBI-0172B) skip
Priority = 1
Board = v5lt_skip

[ScanChain]
TAPs = 1
TAP0 = XC5VLX330

[Program]
SequenceLength = 0

3), 用于烧写的配置文件(for TAP7 XC5VLX330): 
[General]
Name = LT-XC5VLX330 (HPI-0172A) try1 to flash
Priority = 1
Board = gc600
# IncludeBoard = ltxc4vlx100_158a_bytestreamer

[ScanChain]
TAPs = 1
TAP0 = XC5VLX330

[Program]
;Verify can be removed for speed - change SequenceLength to 2 to exclude verify
SequenceLength = 2
Step1Method    = Virtex5
Step1TAP       = 0
Step1File      = via\ltxc5vlx330_172a_xc5vlx330_via_build0.bit
Step2Method    = IntelFlash
Step2TAP       = 0
Step2Address   = 0
Step2ByteFix   = 1
Step2File      = xxx.bit

6, yangguolong:
谢谢！我们这儿已经好了是JTAG的电源没有拔掉的原因。

17:23 2010-2-3
VC0882, c语言编程规范, VC0882附加要求
1, 编程规范见"VC0882/document/882软件编程基本规范.doc"
2, FengBeiZhan邮件"答复: 882项目要求"20100203_1719
1）goto语句：
在驱动层，不能使用goto语句；
在test层，每个api最多只能使用2个goto语句；
（已经更新到编程规范里了）
2）padc and clock 将在padc and clock 模块提供，使用者请直接调用这些模块的api使用，便于以后的更新维护；
3）在提交程序时，请保证vc and eclipse都能编译通过；然后再提交； 

19:44 2010-2-3
VC0882, 最小环境, FPGA, no c library, 在FPGA上跑简单程序验证arm基本可用. 
1, 分析
1), 这个事情其实分三步, 一个是没有c库的程序进入c环境. 二是做简单计算看是否正确. 三是操作gpio. 确定sram和寄存器访问可用. 三其实可以省略. 
2), 完成后发信: 1), 256kbyte sram什么时候可用, 很着急, 没法跑最小环境. 2), timer, uart, irq具体仿真情况. 

2, 看看rvds4.0实现无c库如何伤心啊
Reimplement __rt_raise(), because this error-handling function can be called from numerous places within the compiled code.
Not define main() to avoid linking in the library initialization code.
Write an assembly language veneer that establishes the register state required to run C. This veneer must branch to the entry function in your application.
Provide your own RW/ZI initialization code.
Ensure that your initialization veneer is executed by, for example, placing it in your reset handler.
Build your application using --fpu=none and link it normally. The linker uses the appropriate C library variant to find any required compiler helper functions.
Many library facilities require __user_libspace for static data. Even without the initialization code activated by having a main() function, __user_libspace is created automatically and uses 96 bytes in the ZI segment. See The __user_libspace static data area on page 2-6 for a description of the __user_libspace area.
感觉比较麻烦, 直接用VC0830_sv_memscan

3, 删除VC0830_sv_memscan中无用代码. 开始进入c后只是死循环. 后来发现是开了"-Os". 删除后实验. 进入c语言正常, i--计算正常. 

4, 上传CVS:
加入没有c lib的c环境, 从VC0830_sv_memscan复制. 用armbin编译, RVdebugger调试正常. 
代码和映像: "D:\work\VC0882\code\milestone\mini_c_env_nolib_无c_lib_c环境OK.rar"

5, FPGA不稳定, 见6.

6, 发信:
1), VC0882
今日进展
在32k sram上最简单的c环境建立完成, arm运行程序正常. 现在需要更大的sram(至少256kbyte)以便使用rvds c lib, 否则没法做进一步测试. 
另外最小环境的timer, uart, irq三个模块进展如何, 仿真是否通过, 仿真了哪些内容? 

今天使用中发现debug仍然不稳定: 
FPGA3号板在jtag clk是10MHz和5MHz时都出现过不正常, 只有断电(soft reset不行)后才能重新连接:
是FPGA加电后第一次正常, 运行完程序断开再连接提示: 
Error: 0x02410100: The run control operation could not be completed : .
此时a8没有停住, 也就没法访问a8寄存器和sram. 
这个问题后来在FPGA1号板和3号板都没法再复现. 

10:57 2010-2-4
VC0882, 最小环境, FPGA, 模块状态
1, KongYingQi"Re: 答复: Vc0882 FPGA platform is ready now"
intc、timer、uart情况如meiping所说，其中intc与timer验证比较充分，uart只跑了下基本case。timer在使用时有些限制，用的时候注意看mas。
2, zhangjian: uart保证8n1是测过的. DMA没有测.
timer: dual timer: 按减一表示target, 0表示全f: 查mas, mas描述如此, timer3-6与其它timer不同. 

11:17 2010-2-4
VC0882, 最小环境, rvds4.0, 与VC0598 rvds3.0(rvdebugger)和ESDE eclipse共存, 软件技巧, Windows批处理文件
软件技巧, windows, dos, bat(批处理)
0, 参
http://blog.csdn.net/qshzf/archive/2007/10/29/1853741.aspx

1, 注释: "rem"或"::"
与rem 不同的是, ::后的字符行在执行时不会回显, 无论是否用echo on打开命令行回显状态, 因为命令解释器不认为他是一个有效的命令行, 就此点来看, rem 在某些场合下将比 :: 更为适用; 另外, rem 可以用于 config.sys 文件中.

2, 如何选择不同程序?
1), 开始想用choice, 发现winXP下面居然没有choice. 这样就需要给大家发工具, 不太方便.
2), 用参数. 最终批处理文件见3.

3), rvdebugger3.0和eclipse位置
"C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium\bin\rvdebug.exe"
运行rvdebugger时如果提示brd文件(rvdebugger配置文件)需要merge, 点确认即可. 
C:\ESDE\eclipse\eclipse.exe

3, 邮件, VC0882与VC0598环境共存
CVS位置: "D:\VC0882\document\arm\debug\与VC0598环境共存"
VC0882的rvds4.0与VC0598的rvds3.0共存方法. 用如下方法可以保证rvdebugger3.0, rvdebugger4.0, ESDE eclipse和ARM Workbench IDE v4.0四个应用程序同时使用. 
1), 把附件中的"VC0598_env.bat删除中文"复制到在"C:\ESDE\runtime\bin"目录, 并改名为"VC0598_env.bat"(outlook不允许发可执行程序).
2), 修改快捷方式(参见图片说明.doc)
(1), RealView Debugger v3.0快捷方式->右键菜单"属性"->"快捷方式"选项卡->"目标"从
"C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium\bin\rvdebug.exe"
改为
VC0598_env.bat "C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium\bin\rvdebug.exe"
为了支持图标不变, 选择"更改图标"->"浏览", 目录填入"C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium\bin\rvdebug.exe", 选择原有图标即可. 
(2), eclipse方法相同. 只是把"C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium\bin\rvdebug.exe"替换为"C:\ESDE\eclipse\eclipse.exe"
3), 修改后rvds3.0/eclipse和原来用法相同. 如果希望在命令行下执行rvds3.0命令, 可以在桌面单独建立一个快捷方式, 在"请键入项目的位置"中填入"vc0598_env cmd", 确定即可. 以后双击这个就可以得到rvds3.0和ESDE eclipse的命令行环境. 
4), 注:
(1), 如此运行rvdebugger3.0和ESDE eclipse会有个cmd窗口, rvdebugger3.0和ESDE eclipse关闭后它会自动关闭.
(2), "VC0598_env.bat"放在任何一个Path路径下都可以. 
(3), 批处理文件代码和注释: 
::set our VC0830/VC0816/VC0598 eclipse compile and rvds3.0 environment
@PATH=C:\ESDE\runtime\bin;C:\ESDE\gcc\bin;C:\Program Files\ARM\RVCT\Programs\3.0\586\win_32-pentium;%PATH%
::set rvds3.0 environment
@SET RVDEBUG_INSTALL=C:\Program Files\ARM\RVD\Core\3.0.1\309\win_32-pentium
::del minGW path, replace "d:\software\MinGW\bin" with your own minGW path
SET PATH=%PATH:d:\software\MinGW\bin;=%
::run the program you passed
%1
(4), rvds2.2同理, 只是把rvds3.0的环境变量改为2.2的. 我机器上面没有2.2就不实验了. 
推荐大家用rvds3.0和4.0. 

14:46 2010-2-4
VC0882, memory分配和寄存器总表, d:\VC1600WCVS\doc\arch\vc0882\VC0882 memory and register mapping.xls

15:29 2010-2-4
时间管理
0, 9:34-21:34?

1, 计划<转移>
1), 如果256kbyte sram OK, 跑基本semihost测试程序. 看看uart是否跑通. 如果不通就加入semihost的aasp.
2), 今天要整理昨天计划. 昨天晚上和aiguo聊过后, 我的VC0882工作有些调整. 
3), 今天要把timer api和寄存器列表加入(因为sram估计出不来了, 先把小活做完, 以后还得集中精力看rvds4.0初始化流程).

2, 执行
1), VC0882最小环境, 见"10:57 2010-2-4". 被2)打断. 
\todo 看怎么在编译器中开关NEON, L2? : NEON可以选择, L2只能软件自动控制, 可以读cp15知道有没有L2. 见"15:39 2010-2-4"7-3)-(4)
2), VC0882 irq修改. 被3)打断. 
3), VC0882和VC0598环境共存问题. 见"11:17 2010-2-4", 这个搞了1h40'. 时间有点长了. 

3, 次日计划<转移>
明天先实验uart收发. 测试通过后整理VC0882工作. 然后看看把1-3)做完. 然后整理rvds4.0初始化流程. 整理后发出来, panda_os我一个人肯定不行. 

15:39 2010-2-4
VC0882, 最小环境, FPGA, irq, nucleus, armv7 architecture学习, 总结: VC0882介绍资料; Cache, memory system: PoC, PoU
1, VIM_INT_Driver.c里面的g_priorityHigh, g_priorityMid, g_priorityLow是nuclues的中断优先级. High和Low只是各自填了IRQ_CPU0_VECTOR, IRQ_CPU1_VECTOR. 将来要根据系统需要调整. \todo
2, dongliang把基本东西都加入了. 完善
3, 根据"VC1600_MAS_Interrupt_Controller_V0.93"5.4更新寄存器. 
4, INT_IRQ_Priority在882中无用, 注释, 将来没有就删除. 
5, 修改cache,mmu代码为cortex-a8. copy from TI uboot
6, 修改上传CVS:
1), 根据"VC1600_MAS_Interrupt_Controller_V0.93"5.4更新寄存器. 
2), 修改cache,mmu代码为cortex-a8. copy from TI uboot
3), 根据VC0882数量更新: panda_init.s的INT_IRQ_Vectors.
7, 为修改"main"做准备:
1), aasp shell: 
task_aasp_func()->cyg_user_start()->aasp_shell(). 其中task_aasp_func是nucleus task. \todo 到底怎么启动的. 需要看.
2), 原有"main"函数中硬件初始化部分: 
INC_Initialize()->Application_Initialize()->InitVC0598()
3), 需要理解nucleus如何管理memory. rvds4.0文档提到如果OS管理memory分配, 有些注意事项. 
8, 分析Cortex-a8 cache, mmu(tlb)代码--disable:
1), old panda os
;old code for arm926ej-s. reserve for 
; Disalbe MMU
MRC p15, 0, a1, c1, c0, 0
BIC a1, a1, #0
MCR p15, 0, a1, c1, c0, 0
; Invalidate TLB
; 这里面后面两句从arm926ej-s文档看也第一句作用一样, 为什么要重复呢? 
MOV a1, #0
MCR p15, 0, a1, c8, c7, 0
MCR p15, 0, a1, c8, c5, 0
MCR p15, 0, a1, c8, c6, 0
2), cortex-a8, ;copy from TI uboot-02.01.03.11/cpu/arm_cortexa8/start.S. copy start
;/*
; * Invalidate L1 I/D
; */
mov     r0, #0                  ;@ set up for MCR
;Invalidate TLB和原来一样. 
mcr     p15, 0, r0, c8, c7, 0   ;@ invalidate TLBs
;Invalidate all instruction caches to PoU. Also flushes branch target cache.
mcr     p15, 0, r0, c7, c5, 0   ;@ invalidate icache

;/*
; * disable MMU stuff and caches
; */
mrc     p15, 0, r0, c1, c0, 0
bic     r0, r0, #0x00002000     ;@ clear bits 13 (--V-)
bic     r0, r0, #0x00000007     ;@ clear bits 2:0 (-CAM)
orr     r0, r0, #0x00000002     ;@ set bit 1 (--A-) Align
orr     r0, r0, #0x00000800     ;@ set bit 12 (Z---) BTB
mcr     p15, 0, r0, c1, c0, 0
3), memory and cache
(1), PoC and PoU: \todo p1246前后也要看
The points to which a cache maintenance operation can be defined differ depending on whether the operation is by MVA or by set/way:
  For set/way operations, and for All (entire cache) operations, the point is defined to be to the next level of caching.
  For MVA operations, two conceptual points are defined:
Point of coherency (POC)
For a particular MVA, the POC is the point at which all agents that can access memory are guaranteed to see the same copy of a memory location. In many cases, this is effectively the main system memory, although the architecture does not prohibit the implementation of caches beyond the POC that have no effect on the coherence between memory system agents.
Point of unification (POU)
The PoU for a processor is the point by which the instruction and data caches and the translation table walks of that processor are guaranteed to see the same copy of a memory location. In many cases, the point of unification is the point in a uniprocessor memory system by which the instruction and data caches and the translation table walks have merged.
The PoU for an Inner Shareable shareability domain is the point by which the instruction and data caches and the translation table walks of all the processors in that Inner Shareable shareability domain are guaranteed to see the same copy of a memory location. Defining this point permits self-modifying code to ensure future instruction fetches are associated with the modified version of the code by using the standard correctness policy of:
1. clean data cache entry by address
2. invalidate instruction cache entry by address.
The PoU also enables a uniprocessor system which does not implement the
Multiprocessing Extensions to use the clean data cache entry operation to ensure that all writes to the translation tables are visible to the translation table walk hardware.
\todo clean和invalidate又搞混了. 下次接着看. 
(2), ARMv7-A, the A profile, requires the inclusion of a Virtual Memory System Architecture (VMSA),
(3), 原来要想保证一致性, 要么是不开cache, 要么是开了cache, 但是用命令保证cache coherency. ARMv7A中加入了Shareable domain:
The Outer Shareable attribute is introduced in ARMv7, and can be applied only to a Normal memory region in a VMSA implementation that has the Shareable attribute assigned. It creates three levels of shareability for a Normal memory region:
Non-shareable
A Normal memory region that does not have the Shareable attribute assigned.
Inner Shareable
A Normal memory region that has the Shareable attribute assigned, but not the Outer Shareable attribute.
Outer Shareable
A Normal memory region that has both the Shareable and the Outer Shareable attributes assigned.
这个没看懂, 以后继续看. ARM_ARM_7AR: p144-p145
(4), ARMv7最多支持7级cache, 每级cache的属性可以通过Cache Type Register和Cache Level ID Register得到. 
From ARMv7 the architecture defines support for multiple levels of cache, up to a maximum of seven levels. In ARMv6, only the Level 1 caches are architecturally defined,
A, c0, Cache Type Register (CTR)
CWG, bits [27:24]: Cache Writeback Granule(微粒). WriteBack时写到memory的最大容量=以2为底y的对数. y的单位是word. 最大值是b1001=9, 所以最大写回大小是2^9=512words=512*4=2kbytes
ERG, bits [27:24]: Exclusives Reservation Granule. 这个得看"Load-Exclusive and Store-Exclusive instructions"和"see Tagging and the size of the tagged memory block on page A3-20"
B, Cache Level ID Register: 可以读出7级cache每级cache的情况. 有无cache, 指令cache和数据cache分开还是合一. 

17:02 2010-2-4
VC0882, arm cortex-a8, Linux porting, android, readme4ZhaoYuan
1, Aiguo转发邮件"答复: CotexA8 资料"20100204_1648
你那里有CotexA8的开发版吗？？能不资料给我们共享一下吗？？
所有的Datesheet,软件。我们分析一下他的Kernel。以便我们最快的把Kernel
Porting到FGPA 上。
2, 回信
Hi, zhaoyuan
我们的cortex-a8开发板是北京瑞泰的TI OMAP3530: ICETEK_OMAP3530_LCDE. 
所有资料都放在"\\10.0.2.208\share\zhangjian\TI OMAP3530"目录. 
1, Datasheet: 
"芯片datasheet": TI OMAP3530, tps65920(PMIC+audio codec+otg PHY), tfp410(convert to DVI)
2, TI官方Linux资料: "TI资料\Linux", 包括两级boot, kernel, dvsdk(gpu, video codec)代码和文档. 
3, beagleboard资料: "BeagleBoard". 
beagleboard是开源的OMAP3530开发板. 社区很活跃(http://beagleboard.org/).
它的android移植有三个(rawboat, embinux, 0xlab). 我们自己编译rawboat donut运行成功(rawboat\git). embinux已经推出了eclair版本, "embinux_eclair.tar.gz"是我从git下载的最新eclair android. 
4, 北京瑞泰资料板子的原理图与beagleboard几乎相同, 可以直接beagleboard代码. 瑞泰资料我就不上传了. 
5, qemu: OMAP3530 qemu已经可以boot Linux kernel, 具体可以参见"http://code.google.com/p/qemu-omap3/"和"https://garage.maemo.org/scm/?group_id=877"
资料比较大网速很慢, 我只上传了1和2的bootloader和kernel. dvsdk没有上传. 其他资料需要直接硬盘拷吧. 

19:59 2010-2-4
VC0882, FPGA, 双FPGA, IC同事信息
GuoHaiFeng负责Cortex-a8 FPGA. FanZhiJun(7284)负责另一个FPGA. 
这个问一下yangzuoxing: FPGA code放什么地方, 更新放在什么地方(excel?). 谁负责release. 

9:33 2010-2-5
时间管理
0, 9:18-

1, 计划
1), 今天重点是AASP在VC0882 FPGA上运行: 先测试sram和uart收发, 无问题后移植aasp. 最后实验timer0和timer0 irq. 
2), 修改fputc避免大小端问题. 
3), 实验codehammer.
4), 看昨天, 前天VC0882最小环境相关邮件. 
5), 打算写一个VC0882最小环境调试log. 把有必要计入的内容都加入"VC0882最小环境调试log"关键字, 最后用脚本生成.
6), FPGA问题提到ISSUE track.

2, 执行
1), -9:42 杂, 邮件, 整理VC0882相关工作, 很多, 今天要整理. 见"9:41 2010-2-5"
2), 9:44-  VC0882最小环境, AASP在FPGA 256kbyte sram运行.
(11:32-12:50 午饭, 休息). 16:00 uartPollRxTxOK.
(19:24- 晚饭)

9:41 2010-2-5
VC0882, 最小环境, arm cortex-a8, debug coresight, 相关工作, \todo 整理, 安排.
今天要整理昨天计划. 昨天晚上和aiguo聊过后, 我的VC0882工作有些调整. VC0882最小环境其他计划见11:12 2010-2-2". 
考虑一下mini_c_env是否支持830. 要保证里面的每个build都是可用的. 
今天要把timer api和寄存器列表加入(因为sram估计出不来了, 先把小活做完, 以后还得集中精力看rvds4.0初始化流程).
然后整理rvds4.0初始化流程. 整理后发出来, panda_os我一个人肯定不行. 
clock提供接口函数. beizhan已经发了padc的. 这个我要抓紧.
irq写测试代码. reglist: irq, dmac. 
zhaoyuan会去移植Linux. 我的想法是做irq, uart,timer最小环境时就考虑好Linux需要的函数, 最小环境OK同时Linux kernelOK. 版本选择2.6.29标准内核. Linux运行需要memory OK, 希望ddr OK前可以完成Linux2.6.29移植. 
beizhan会做一个sd卡boot, 可能需要我帮忙.
最小环境完成后, 希望有一周时间整理, 沉淀. 然后sdio 寄存器读写. 
杂: 编译并实验beagleboard eclair; 填加班记录(2月1日, 2月3日,2月4日). 

9:44 2010-2-5
VC0882, 最小环境, FPGA, sram, uart, 在256kbyte sram上运行aasp
1, 计划: 先测试sram和uart收发, 无问题后移植aasp. 最后实验timer0和timer0 irq. 
今天要把代码并入panda目录. 
2, sram不行, 仍然只是32kbyte的. fanzhijun实验发现访问sram失败后， 访问bus也不行.
后来发现原来0x是rom(可写), sram在0x20000000, 也是32kbyte. 所以软件用sram时还需要可以修改链接地址. 代码要考虑到是否映射到0x0地址, 如果不是, 需要复制异常向量到0x0. 
1), (15:55 2010-2-5)已解决: 是marb限制.
(1), FanZhiJun邮件"答复: Vc0882 FPGA platform is ready now"20100205_1307
256KB的问题，刚问了zhangxuejian，sarb里根据maping表对地址做了上下限判决。
marb里面对于地址的限制，是依照vc0882 memory and register map.xls里面的定义进行设置的。
(2), ZhangXueJian邮件"答复: Vc0882 FPGA platform is ready now"20100205_1327
为了FPGA debug需要，目前把S5的地址范围修改为32’h20000000~2fffffff
`ifdef FPGA
    `define AXI_R1_NEA_S5 32'h2fffffff
`else
    `define AXI_R1_NEA_S5 32'h20007fff
`endif
(3), xuejian这样修改后, 软件看就和原来VC0830一样了: 超过0x20040000地址后, sram会绕回访问0x20000000地址. 
"15:55 2010-2-5"end
3, 实验uart
1), padc
uart mas guideline
Configure the UART line TXD as output port.
Configure the UART line RXD as input port.
Configure the UART line RTS to unused.
Configure the UART line CTS to "0" always.
Configure the UART line DSR to "0" always.
Configure the UART line DCD to "0" always.
Configure the UART line RI to "1" always.
Configure the UART line DTR to unused.

pad pin pinlist, uart0只有下面四个信号, 
UART0_SDO	1	UART0 Serial Data Output
GPIO_C2		
UART0_SDI	1	UART0 Serial Data Input
GPIO_C3		
2), uart, timer都是24Mhz, \todo 加入clock函数.
3), 发现没有接uart.. 真晕..
(1), FanZhiJun拿来了Uart转接板, 但我不知道插在什么地方. 查FPGA知道UART子板插在J7
.
(2), 发现rvdebugger和arm读到的寄存器有时不同. 
读UART0_LSR(0x60043020)输入字符后arm读到0x00001202, rvdebugger读到0x00001200. 
但是UART0_RDR(0x60043000)在rvdebugger和arm中时一致的. 
GuoHaiFeng: LSR的UART_RXRDY时读0x60043000数据后清UART_RXRD bit.
后来发现是因为rvdebugger先读了UART_RXRDY, 所以UART会清UART_RXRD bit. 所以这不是bug. \todo 加入到VC0882 FPGA 最小环境调试log. 

(3),memory错误
A, 不论访问0x0或0x20000000都提示: 
Error: Unable to write Program memory at S:0x00000000(sram时提示0x20000000)
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory while Setting Program Counter.
Warning: entry point is 0 - may be undefined.
Warning: Error V2801C (Vehicle): Failed to read the requested number of bytes to memory while Error Setting Entry Point.
B, 发信
发送: GeMeiPing; HuangWei; ZhangXueJian; FanZhiJun; JiaJiHua; VC0882_ICD; Zhangjian
抄送: YangZuoXing; WangXin; Aiguo; FengBeiZhan
标题: VC0882 FPGA新问题: memory有时无法写入. 现在FPGA不稳定很影响效率希望尽快解决

memory访问, FPGA三号板有50%可能会出现sram或rom无法写入的问题. 出问题后, rvdebugger找不到arm(在rvdebugger command line中显示"UNKNOWN"). 
如果关闭FPGA电源(有时需要断电一段时间), 再重新上电可能会恢复正常. 
感觉有点像是FPGA本身不稳定. 这个问题没有在一号板复现过. 

整理一下目前FPGA上问题:
1, 访问bus上非法地址后, 再访问合法地址也不能访问. 
2, memory写入不稳定(见上). 
3, FPGA有时连不上Cortex-a8, 见Zhangjian2010年2月3日邮件"答复: Vc0882 FPGA platform is ready now".
4, csat访问ap会fail, 见HuangWei2010年2月2日邮件"Vc0882 FPGA platform is ready now". 

现在FPGA不稳定很影响效率, 今天为了和GuoHaiFeng讨论UART, 就花时间试验哪个FPGA好用. 希望FPGA能尽快稳定. 

(4), 在没有建立FPGA CF code服务器之前临时用GuoHaiFeng"\\10.0.13.27\share\ace"目录. 

(5), GuoHaiFeng说IRQ映射不正确. timer中断暂时不能用. 

4, 整理上传代码. 
1), 感觉今天的工作有些效率, 或者今天比较集中精力没被打断? 
2), 先上传当前版本再整理:
uart basic poll OK, 先上传代码, 下一版本按格式整理
(1), boot\bootload.c中直接加入uart读写函数, 简单测试通过.
(2), 为了与panda_os一致, 加入"VIM_DRIVER_Regdef.h", 删除v830regdef.h.
3), 整理代码: 用cortex-a8编译, 链接地址改为0x20000000, uart代码移到uart目录. 
(1), \todo
A, 发信:
i, ICP: 发邮件时写明如何安装新工具链. 
ii, ICD: FPGA一号板也不稳定. FPGA这些问题感觉还是放issue上面比较好.
B, 更新CVS: 修改mcpu等编译参数为cortex-a8, vc0830bootloader.lds改名为vc0882bootloader.lds.
(2), "Sourcery G++ Lite"工具链使用见"20:11 2010-1-8". \todo 实验有无thumb2模式代码大小差异. 使用arm926ej-s和cortex-a8代码大小差异. 
(3), 编译通过后试验, 一号板连着几次(大于5
次）连接后停不下来. 换成三号板没有问题. \todo 用原来的CF code实验比较稳定性, 发信. 
(4), 运行后dataabort, 单步跟踪发现UART0_BASE设置不正确. UART0_BASE--UART3_BASE差值也不正确, 说明是随机值. 而且检查寄存器地址定义时正确的. 修改UART0_BASE后程序运行正常. 另外uart_base数组基址时0xe00. 联想原来VC0816量产切频遇到的问题, 猜测时超过了链接脚步区域. 查看果然如此, 原来的VC0830链接脚本中memory最大rom是0xe00.
\todo 只要uart_base链接到ro_data, 上面分析才成立. 
(5), 修改链接脚本后仍然不行. 从现在结果看uart_base时链接到data区域.
看反汇编文件, 没发现问题:
Disassembly of section .data:
20007000 <uart_base>:
20007000:	60043000 	andvs	r3, r4, r0
20007004:	60044000 	andvs	r4, r4, r0
20007008:	60045000 	andvs	r5, r4, r0
2000700c:	60046000 	andvs	r6, r4, r0
(6), 看汇编, 发现代码问题:
	/*! Relocate [copy] data from ROM to RAM*/
    ldr     r3,=__rom_data_end
    ldr     r4,=__ram_data_end
    ldr     r5,=__ram_data_start
    cmp     r3,r4
    beq     2f
    cmp     r4,r5 
    beq     2f
1:  ldr     r0,[r3,#-4]!     
    str     r0,[r4,#-4]!
    cmp     r4,r5
    bne     1b
(21:56 2010-2-5)不知为什么怎么也删不了这部分和clear bss代码. 手工跳过后运行正常.
后来为了绕过这个问题把uart_base改为const. 这样就放在了ro_data. 

5, 先上传代码. 下次解决这个问题. 
1), CVS log("22:11 2010-2-5")
VC0882: mini_env_no_c_lib. 在无c li测试通过代码基础上, 参考pands_os要求调整代码结构. 便于将来32k sram上实现一些功能. 
工具链是"\\10.0.2.36\sqmshare\share\Linux\toolchain&lib\arm-2009q3-68-arm-none-eabi.exe", 默认安装, 选择把工具加入到环境变量, 这个工具链与原来工具链名称不同, 不会有冲突. Makefile.arm已经按此修改. 
MakefileRvdebug.arm和vc0882bootloader.rvd.lds稍候修改. 
2), \todo 要解决的bug: 
(1), 解决"[copy] data from ROM to RAM"和"clear bss"删除有用数据的问题. 
(2), 修改MakefileRvdebug.arm和vc0882bootloader.rvd.lds. 

6, 发信: 
收件人: aiguo, fengbeizhan
题目: VC0882 FPGA最小环境今日进展: uart查询模式rx,tx正常, sram256kbyte已经可以使用
VC0882 FPGA最小环境今日进展
在"D:\VC0882\mini_env\mini_c_env_nolib"工程(用VC0598 eclipse+新工具链编译)下加入uart, 并参考pands_os要求调整代码结构. 便于将来使用. 
工具链是"\\10.0.2.36\sqmshare\share\Linux\toolchain&lib\arm-2009q3-68-arm-none-eabi.exe", 默认安装, 选择把工具加入到环境变量, 这个工具链与原来工具链名称不同, 不会有冲突. Makefile.arm已经按此修改. 
今天FPGA 256kbyte sram已经可以使用, 简单测试通过.
周日我会把aasp移植到VC0882. 并修正"mini_c_env_nolib"上的两个小问题.

12:50 2010-2-5
VC0882, 最小环境, FPGA, 今天总结, 邮件
发信: 
现在FPGA还缺的东西: CF code放到服务器, 版本变化excel.
还存在的问题: 见"9:44 2010-2-5"

13:35 2010-2-5
(11:02 2010-3-5)
(21:34 2010-3-5)
(19:55 2010-3-10)
(18:04 2010-3-13)
(20:27 2010-6-1)
(21:41 2010-7-1)
VC0882, 最小环境, FPGA注意事项, 与CVS保持同步
CVS: "D:\VC0882\document\fpga\VC0882_FPGA注意事项.txt"
FPGA注意事项

initial                                         zhangjian
添加rvds文档位置                    2010-6-1    zhangjian
add memory and register mapping     2010-7-1    zhangjian

0), 关于ddr电压:
(1), LvHaiFang邮件"答复: Vc0882 FPGA platform is ready now"20100202_1413
调试ddr的同事请注意，lpddr和ddr3的电压不一样，在上电之前请找我们确认一下转接板电压。
1.8v，1.5v
(2), Mike WX Chen"答复: fpga底板的电压问题"20100506_1035
板子右上角的跳线J22可以选择I/O电压是否是1.8V还是1.2V.
目前，我们只是将beihua使用的那个FPGA板由1.2V――改为1.5V，I/O电压还是可以选择成1.8V。建议插子板前，先测量对应插座的电压。如果不会，通知SV组吧。
其他FPGA板也需要将1.2V――改为1.5V，才能测试DDR3。

1), 电源, 复位, 晶振:
(0), 上电前确认晶振插好, 没有接触不良, 2FPGA时只有左下OSC5可以不插. 否则RVI可能找不到arm, 或出现其他问题.
右下角Xclk需要插48MHz晶振, 否则FPGA配置后D9常亮表示DDR phy clock有问题. 
(1), 电源是外正内负: 和原来FPGA一样, 与SV板不同, 千万别接错了. 
(2), FPGA电源在左上角, 上电后FPGA开始配置, F1_DONE和F2_DONE都亮表示FPGA配置完成, CF卡旁边按键是FPGA reconfig. 系统复位是s1(soft reset). LED灯: 右上三个是红灯
, 输入LED红绿皆可. 从5.2,5.3开始调, 一般最5.5, 输入电压太高也会fail, 有问题找fanzhijun. 
目前FPGA正常工作电流2A以上, 如果供电不足, 可能导致RVI扫描不到硬件, 或者扫描过程中fail, 或其他奇怪问题. 
(3), 现在都要求用新电源(30v20A0), 旧电源最大3A, 对FPGA稳定性有影响(如果用旧电源, 旧电源一路输出不能满足需要, 需要采用并联模式, 调整电源输出电压5.5v保证到FPGA
的电压是5v(保险丝到地的电)).
(4), FPGA config时电流会有明显变化, 例如在新电源上FPGA上电, config FPGA1 done, config FPGA2 done的电流分别是1.7A, 2.0A, 2.2A. 如果config时电压没有类似明显增
大, FPGA config可能有问题. 
F1_done, F2_done在板子中上. 
(5), FPGA config后, D9, D11会灭, 如果没有灭说明FPGA不在正常运行状态. 按Soft Reset(S1)时D9,D11亮, 松手D9,D11灭. 
D9在FPGA左下. D11在FPGA右上. 
(6), 复位: 4FPGA只能按上面板子复位. 不论2FPGA, 4FPGA按softreset复位时sram数据都不会丢失(static ram只要不断电不会变), 如果程序memory处理有问题(例如新分配的
memory没有memset 0)可能出错. 

2), FPGA文档和原理图"D:\VC1600WCVS\doc\FPGA":
(1), 双FPGA硬件手册: VC1600WCVS\doc\FPGA\882_fpga\fpga_scheme: DUAL_XC5VLX330_EVALUATION_BOARD_V2.00.pdf, Vimicro Dual-V5 Hardware Reference Manual_v1 
00.doc. VC882_FPGA_V1.5.doc.
(2), 时钟方案: vc0882_fpga_clkrst_scheme.vsd. 2010年3月20日 2FPGA更新时钟方案加入module divider(3月22日4FPGA更新)
(3), FPGA端口定义"D:\VC1600WCVS\doc\FPGA\882_fpga\fpga_scheme\vc0882_dual_fpga.xls"
(4), VC0882子板原理图"D:\VC1600WCVS\doc\FPGA\882-SUB-Boards\Schematic"
(5), memory和register地址映射, 见"VC0882 memory and register mapping.xls"(D:\VC1600WCVS\doc\arch\vc0882)

3), 其他
(1), 现有子板: jtag转接板J2. CF卡转接板J15. UART子板J7. sd接J8. 
(2), CF卡里面一定只有一份ace文件. 如果有两个ace文件, 会有问题.
(3), VC0882 CF code: \\10.0.2.36\sqmshare\Projects\Mobile BU\VC0882\fpga\cf
(4), 如果不插RVI, 需要JTAG转接板JP7[0]-JP8[0]跳线. 参LiDongLiang邮件"答复: EMI Norflash boot"20100315_2037
(5), Strap pin, Emi norflash boot: LCD_D[1]=1, LCD_D[0]=0

4), 模块注意事项:
(1), ddr: JP1[2,3]跳线(如果不跳线, ddr读出内容基本是重复一个pattern). 检查背面电阻焊接是否正确: 57,59,61.
(2), sd:
自DuanLiHua邮件"答复: mmc card调试需要改ucf及疑惑"20100316_1008
Q: ucf里，mmc card拉了一个reset，接到111 port上了，但是卡座上是没有这个reset pin的.
A: 这个reset的考虑确实是给mmc card用的，但是只有符合最新的mmc 4.4协议的card才支持这个功能，视情况使用吧~

5), 附录:
(1),  FPGA新时钟方案说明
Hi, all
根据FPGA新时钟方案我修改了代码, 以后FPGA都会使用这个时钟方案. 右下角Xclk需要插48MHz晶振. 请大家使用新时钟方案版本调试, 如果时钟方案修改后FPGA不稳定或有其他问
题请及时发信报Issue. 
修改见VIM_CLKRST_Init()(clkrst\VIM_CLKRST_Driver.c), 各个模块clock都已初始化为24MHz. 大家可以根据自己需要在clkrst模块加入clock配置函数. 
同时我在Arm workbench 4.0的每个编译规则中加入"-define=XCLK_48MHZ=1"表示这一修改. 如果大家使用都没有问题, 会去掉这个宏. 
注: 
1, 新时钟方案见
D:\VC1600WCVS\doc\FPGA\882_fpga\fpga_scheme\VC0882_REG_CLKRST_FPGA.V0.1.xls, vc0882_fpga_clkrst_scheme.vsd
2, 从3月20日下午三点开始的2FPGA cf code都是新时钟方案. 

Hi, caijin, zhuliying, zhangpu, yangmin
4FPGA新时钟方案版本见GuoHaiFeng邮件"New ACE For 4 FPGA"20100322_1745. 下次出4FPGA时会使用新时钟方案版本. 

2), umonitor:
从"D:\VC1600WCVS\doc\mas\VC0882\PAD\VC0882_REG_PADC_Vxxx.doc"查到um_ctrl是0x600510f0.
D:\VC1600WCVS\doc\arch\vc0882\VC0882 umonitor definition.xls说明如何通过配置umonitor寄存器选择不同module. 
umonitor的引脚在uart转接板. 

3), RealviewICE, rvds等工具使用说明见"D:\VC0882\document\arm\debug". rvds中英文文档见"D:\VC0882\document\arm\rvds".

17:08 2010-2-5
同事信息, 同学, 北京工业大学, 张淼
加盟中星微运营管理部任GA  Manager的张淼，直接向财务总监刘平汇报工作。张淼女士毕业于北京工业大学国际贸易专业，加盟中星微之前曾在KPMG、PWC、京都会计师事务所、中国银行任职；她的办公电话是：010-68948888-7337，email:zhangmiao@vimicro.com

20:40 2010-2-5
VC0882, 最小环境, FPGA, sram, uart, Issue Track, 
自"9:44 2010-2-5"
1, 把下面四个问题提到Issue Track上面
1), 访问bus上非法地址后, 再访问合法地址也不能访问. 
2), memory写入不稳定(见上). 
3), FPGA有时连不上Cortex-a8, 见Zhangjian2010年2月3日邮件"答复: Vc0882 FPGA platform is ready now".
4), csat访问ap会fail, 见HuangWei2010年2月2日邮件"Vc0882 FPGA platform is ready now". 

2, [882]0008112 rvdebugger访问bus上非法地址出错后, 无法再访问合法地址 
出现频率: 有时
严重性: 系统崩溃
优先权: 高
摘要: rvdebugger访问bus上非法地址出错后, 无法再访问合法地址
说明: 例如rvdebugger访问0x4000地址(VC0882只有32k rom), 会造成再访问0x0 rom, 0x2000000sram, 0x60000000寄存器都无法访问. rvdebugger显示红色叹号.
注: 从coresight文档看, rvdebugger应该是通过ahp-ap经过HMX访问AXI bus. 
指派给: HuangWei.
zhangjian: 想了半天, 本来想直接指给JiangBo或这负责memory的人, 后来想我只是看到rvdebugger不能访问, 没有实验arm能不能访问(测试环境还没有搭起来). 是哪里的问题还不好说, 只好先指给huangwei.

3, [882]0008113 rvdebugger写入memory失败 
出现频率: 有时
严重性: 系统崩溃
优先权: 紧急
摘要: rvdebugger写入memory失败
说明: rvdebugger连接FPGA后, 写入memory(rom/sram)会出错: 
Error: Unable to write Program memory at S:0x00000000(sram时提示0x20000000)
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory while Setting Program Counter.
Warning: entry point is 0 - may be undefined.
Warning: Error V2801C (Vehicle): Failed to read the requested number of bytes to memory while Error Setting Entry Point.

出错后, rvdebugger找不到arm(在rvdebugger command line中显示"UNKNOWN"). 

如果关闭FPGA电源(有时需要断电一段时间), 再重新上电可能会恢复正常. 
这个问题在1号和3号FPGA板子都出现过, 感觉是用一段FPGA后, 才会出现这个问题. 

指派给: huangwei

4, [882]0008114 rvdebugger有时连不上Cortex-a8
出现频率: 有时
严重性: 易用性不佳
优先权: 高
FPGA3号板在FPGA加电后第一次正常, 运行完程序断开再连接提示: 
Error: 0x02410100: The run control operation could not be completed : .
此时a8没有停住, 也就没法访问a8寄存器和sram. 
jtag clk是10MHz和5MHz时都出现过不正常, 只有断电(soft reset不行)后才能重新连接.
是
这个问题后来在FPGA1号板和3号板都没法再复现. 
指派给: huangwei
zhangjian: 自"19:44 2010-2-3"

5,  [882]0008115 csat访问dap-ap fail
出现频率: 有时
严重性: 易用性不佳
优先权: 高
摘要: csat访问dap fail
说明: 用arm csat(CoreSight Analysis Tool)访问DAP出错, 具体命令和log如下: 

%>rvs
RVIScan started...
.........
>> USB:171390200

RVIScan : Scan complete.
%>con usb

Attempting to connect to ...USB
Connected to:ARM RealView ICE
Base H/W: V1 Rev G-01
TurboTAP Rev: 1.86
LVDS Probe H/W: V50 Rev p-48
Firmware: 3.3.0, Build 948
%>chain dev=ARMJTAG-DP,UNKNOWN_4 clk=1000000
Jtag clock set to 1000000
ID:0 ARMJTAG-DP
ID:1 UNKNOWN_4
%>dvo 0
Open connection to device ID : 0xA5D0023B, version 0x00000006
Msg returned with RVMOpenConn: Coresight DAP template

RX ASYNC !*
CSDAP_ERR : TurboTAP Error Occurred.
CSTTAP DPACC.CSW write failed (nCont Stall on Read.. Exit[0x82] Exception[0x04].
). Dap power up failed - could not get DP status

*!
Failed to power up DAP debug on open.
%>dmr 0 0x13000000 4
RVMMemRead while reading memory from target failed: EMUERR_RWFAIL: general error
 on memory operation
%>
RX ASYNC !*
CSDAP_ERR : Operation invalid for this AP.
CSTTAP Enumerate AP failed (nCont Stall on Write.. Exit[0x81] Exception[0x04].).

AP_AxB_ReadMemBlock failed - DAP error.

*!
%>

12:09 2010-2-7
时间管理
0, 11:55-

1, 计划
1), VC0882事情很多, 整理最近计划和昨天邮件. 新增sd卡讨论: 明天上午, 今天必须看.
春节前nucleus要想跑起来比较勉强. panda跑起来肯定没问题. dashan可以先用mini_aasp2天. 春节前是否需要介绍我最近看的东西? 有同事回家了, 我可以春节前整理好.
明天例会时问一下到底谁调ddr. 去实验室的时候没见IC在调. 
参"9:41 2010-2-5".
加班记录(2月1日, 2月3日,2月4日,2月5日,2月7日). 
2), VC0882 aasp. 发信.
3), VC0882 FPGA issue <DONE>

2, 执行
1), 12:30-14:28 VC0882 FPGA arm debug issue, 见"12:34 2010-2-7"
(zhangjian: 本来想着很快能解决的. 还是用了两个小时, 今天时间很紧张了, 加油! :)).
2), 14:29- VC0882最小环境, 移植AASP到VC0882. 见"14:29 2010-2-7"

12:34 2010-2-7
VC0882, 最小环境, FPGA, arm debug, cortex-a8
1, 
Hi，zhangjian
关于第一个个问题，访问非法地址后不能访问合法地址的问题，你需要把DP的CRTL STAU寄存器的stickyerr位清一下才能开始下一此访问。具体可以参考IHI0031A_ARM_debug_interface_v5.pdf文档的6.1.2关于JTAG－DP寄存器描述。
我不知道rvdebugger有没有清除这个bit的操作，我仿真时使用JTAG向这个寄存器位写1就行了，你可以试试。
其它三个问题仿真上都没有重现。
gemp

2, 更新Issue Track描述后发信: 
参考GeMeiPing邮件"答复: VC0882 FPGA新问题: memory有时无法写入. 现在FPGA不稳定很影响效率希望尽快解决"20100206_1434, 进一步实验. 

今天进一步实验访问寄存器非法地址部分情况会造成无法继续访问合法地址或cortex-a8寄存器.
访问VC0882中非法寄存器地址(有模块没加入或reserved)不论能否继续访问合法地址, 都不会报出"Precise abort". 这样软件没法判断是否访问错误. 
访问memory非法后可以访问合法地址, 但是rvdebugger提示两次相同的"Precise abort", TI Cortex-a8(OMAP3530)提示一次. 感觉一次比较合理. 
具体参见Excel表格:
实验序号	访问地址	访问类型	SOC	访问错误提示	访问能否访问memory, memory-map reg, cortex-a8 reg			备注
1	0x40000	memory非法地址	VC0882	2次(注1)	可以	可以	可以	
2	0x0	memory非法地址	OMAP3530	1次(注1)	可以	可以	可以	
3	0x6000d000	memory-map reg  reserved 地址	VC0882	无	可以	可以	可以	clkrst
4	0x60042000	memory-map reg  module address	VC0882	无	不能	不能	不能(注2)	peri: spi2
5	0x6004e000	memory-map reg  reserved 地址	VC0882	无	不能	不能	不能(注2)	peri 
6	0x60060000	memory-map reg  reserved 地址	VC0882	无	不能	不能	不能(注2)	
7	0x49100000	memory-map reg  reserved 地址	OMAP3530	同2	可以	可以	可以	peri

注								
1, 访问VC0882memory非法地址时有两次错误提示:
Error: 0x021d0102: Error Memory access caused precise abort.
Debug Precise Abort Registers : DFSR = 0x00000008, DFAR = 0x000F0000 from target : Cortex-A8_0.
Error: 0x021d0102: Error Memory access caused precise abort.
Debug Precise Abort Registers : DFSR = 0x00000008, DFAR = 0x000F0000 from target : Cortex-A8_0.
对比TI Cortex-a8(OMAP3530), 只有一次错误提示.			
由于ZhangXueQian修改了FPGA上MARB sram地址约束, 现在0x2000000-0x2fffffff地址都是合法的, 所以原来sram非法地址访问造成的问题我没法复现								
2, 错误提示不同:								
实验4提示: 								
setreg @R0=0x00000111								
Error V2801C (Vehicle): 0x021d0102: Error Failed to write value to register = 'R0' from target : Cortex-A8_0.								
实验5,6提示: 
> setreg @R0=0x00001111
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory

另外OMAP3530并不是标准的Coresight debug架构, 不利于分析debug或trace中遇到的问题. 
如果能有一个PBa8板子. 比较cortex-a8, debug, trace问题会很方便. 
email arm不直接, 效率也低. 


今天3号板很不好用: 正常连接两次后, 断电再上电也不能再连接了, 断电5分钟再上电也不行. 
FPGA2号板没有串口子板. 

Hi, GeMeiPing: 
软件没法直接通过rvdebugger控制JTAG-DP(也不应该由软件直接控制). 其他0008113-0008115都不是必现错误, 仿真有可能发现不了. 

14:29 2010-2-7
VC0882, 最小环境, FPGA, aasp, 移植AASP到VC0882
1, 完成后发信:
还需要工作: aasp加入到panda中. panda按照panda_os要求改写. 便于将来使用(担心可能会随时回到mini_c_env_no_lib和panda), 按照arm要求改写aasp. 
改进建议: 库的接口函数不合理, 没必要重写_rt_entry(尽量按arm要求编写利于升级), subxxx与xxx合并. 
2, 修改链接脚本:
** Section #1 'ROM_EXEC' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 1068 bytes (alignment 4)
    Address: 0x80020000
** Section #2 'DHRY_CODE' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 43400 bytes (alignment 4)
    Address: 0x80030000
** Section #3 'DHRY_DATA' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 148 bytes (alignment 4)
    Address: 0x80040000
** Section #4 'DHRY_DATA' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 15556 bytes (alignment 4)
    Address: 0x80040228
** Section #5 'ARM_LIB_STACKHEAP' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 4194304 bytes
    Address: 0x80050000
** Section #6 'TTB' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 16384 bytes
    Address: 0x80460000
** Section #7 'NCNB' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 10485760 bytes
    Address: 0x80470000
** Section #8 'NCNB_1' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 0 bytes
    Address: 0x80e70000
** Section #9 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1464 bytes
** Section #10 '.debug_frame' (SHT_PROGBITS)
    Size   : 7076 bytes
** Section #11 '.debug_info' (SHT_PROGBITS)
    Size   : 32084 bytes
** Section #12 '.debug_line' (SHT_PROGBITS)
    Size   : 16268 bytes
** Section #13 '.debug_loc' (SHT_PROGBITS)
    Size   : 12760 bytes
** Section #14 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 34380 bytes
** Section #15 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 4663 bytes
** Section #16 '.symtab' (SHT_SYMTAB)
    Size   : 18176 bytes (alignment 4)

各section大小: 1068  43400  148  15556  4194304  16384  10485760  0  1464  7076  32084  16268  12760  34380  4663  18176  
除去ARM_LIB_STACKHEAP和NCNB, 一共203427bytes. 看来256kbyte ram也并不富裕. 
这里面debug信息是126871bytes(section9-16).
估计至少要从0x8000开始使用, 这样256kbyte还剩下=25k. NCNB肯定不会用象征性给1k. 堆栈分配24k. 如果空间还是不够, ttb可以少映射一些. 在sram中运行的code只映射0x0到0x6fffffff就可以. 可以省下9kbytes空间. 
看来需要512kbyte, 才能保证后面ddr调通前的使用? \todo email fanzhijun, 问问增加sram有没有什么不好的影响, 还是没事希望增加到512k或1M. 
3, (16:44 2010-2-7)代码修改完成, 编译, 开始用的omap3530的链接脚本, 编译通过, 换成vc0882的链接脚本编译报错:
armlink : error L6788:  Scatter-loading of execution region DHRY_CODE will cause the contents of execution region DHRY_CODE to be corrupted at run-time.
把DHRY_CODE起始地址从0x20008800改为0x20013000才行. \todo 查rvds4.0手册.
这样后面就没有地方存放调试信息了, 把起始地址从0x20008000, 改为0x20000000,
1), 访问cache和mmu都有问题. 注释. 
2), 还是有问题. 实验mini_c_env build1.
(1), 修改堆栈地址(stack bottom 0x20020000, heap base 0x20010000. 选择cortex-a8 no.neon编译(_fp_init会变成空函数).
3), 把mini_aasp build_vc0882也改为cortex-a8 no.neon
还是会停在:
__scatterload_copy:
   S:200000F8 E2522010  SUBS     r2,r2,#0x10
SUBS这句就执行不过去了.
4), (18:23 2010-2-7)看来还是要从build1到build4一个一个来. 这样便于分析. 

9:23 2010-2-8
项目, VC0882, 时间管理, 上周工作总结
1, 上周主要是aasp, FPGA两方面工作
另外需要更大的sram: \todo nucleus 需要多大memory?
上周计划: irq dongliang帮我做的, 我看了这部分代码
2, aasp进展: 
uart poll rx tx ok, cortex-a8 semihost 正确, non semihost 错误.
一步一步实验.去掉l2会不会有影响? arm core如何知道没有l2? ic还有没有其它变动? 估计需要两天时间.
min c env no lib也可以用于验证.
3, FPGA不稳定, 已经提交Issue.
4, 感觉还要改进时间管理.
5, \todo 细化整理. 改进时间管理. 

9:47 2010-2-8
VC0882, 最小环境, FPGA, AASP在VC0882上运行
1, 计划: 从build2到build4一步一步来. 实验cortex-a8 dhry.
2, build_2_omap3530:
N:8000AEEC EEE10A10  VMSR     FPSCR,r0

13:06 2010-2-8
VC0882, sync up meeting, sd讨论meeting minutes
1, sync up
1), 3月5日基本代码完成80%-90%.
2), zhangjian任务: 
(1), 本周完成panda_os 最小环境(aasp可用, timer可以不加, 不开mmu,cache). 
(2), nucleus运行需要1Mbyte sram, 给IC发信. 
(3), \todo 
A, 需要了解Nucleus memory分配. 
B, 明天晚上讨论Panda os最小环境. 今天发出提纲. 
(4), 自己增加: 有空把前段时间看的cortex-a8资料和心得提纲列出来. 

2, sd讨论meeting minutes:
整理见"D:\VC0882\document\sd\882sd.doc", duanlihua回信后贴到这里. 
蓝色是aiguo注释, 绿色是meeting minutes和与duanlianhua的讨论结果(原文附后).
除了注明close的, 都需要再讨论
sd新加入的功能：
1）	LLI，包括强制断掉续传的问题；
我记得这个是通过一组寄存器来实现，和damc的LLI有区别
如何测试? 首先肯定是简单构造case测试. 然后希望其他module使用sd时也能测到(考虑到nucleus对于memory碎片没什么支持, 这个有难度).
2）	boot，好多register的地方都出现了这个，
这个是干什么的？zhangjian知道吗？
	Support MMC boot operation
		Mmc卡有针对boot的工作模式, 是mmc 4.3协议新增的, 需要mmc卡支持.
	Support MMC bus testing procedure
MMC的测试方式, 发CMD19和协议要求的data pattern, card会传回协议要求的数据. 详见MMC spec"4.4.4 Bus Testing Procedure"
3）	block gap
指的是在multi-block传输中，相邻两个block之间的gap，sdio协议支持在这个gap里发interrupt，这个feature我们是支持的(见sdio spec "8.1.4 Interrupt Period at the Data Block Gap in 4-bit SD Mode (Optional)")
4）	4种cmd type，例如Normal，suspend，resume，abort
我们以前是支持Normal吗？后面的是为了功耗？
对于sd/mmc来说只有normal和abort, 对于sdio来说才支持四种指令. 疑问: abort后host/slave如何处理: 本次传输作废还是尽快结束并加上CRC?
abort是软件发的，如何处理由软件来决定，一般用于处理错误，另外接收到abort命令的card相当于被reset了，加crc没有意义
5）	auto cmd新增加了 auto cmd response
一般来说multi read/write会使用auto cmd. 其它场合也可以使用, 硬件没有限制. 
6）	dma boundary 的错误为什么会产生；
dma boundary不是错误，是指当前dma transfer已经meet软件配置的长度边界，需要软件更新dma起始地址和长度；另外访问slave越界错误或非法地址范围用dma_err表示
7）	mmc 4.4card 支持（我看到新加入了该card reset），以前我们是4.2 4.3
wake up  inset and remove 等的使用；
在sdio进入省电模式后，card insert和card remove都会触发wake up event，向pmu申请恢复模块时钟. Wakeup里面只是enable. 并不是status
8）	detect pin and data 3 pin的share使用；
reglist HOST_MODE [4] DET_PIN_SEL写明需要software配置, 但这个是协议规定好的, 作为detect还是data[3]感觉需要软件干预. 
协议确实提到这两种方式，如果没有dedicated detect pin，协议允许用DAT3 pin来代替，所以需要软件来配置. 
Zhangjian: 其实VC0830, VC0882默认都是有独立的detect pin, 所以软件默认不需要处理. 
9）	dma是byte对齐，且长度也是用byte表示的； close
这样就省掉了软件的判断和memory copy。
10）	internal 2-channel DMA，但是pin只有1组，要2个channel的dma有什么用
确实不是全双工，但是所有的host设计都保留了两个channel，至于意义我觉得可以在读和写之间做pipeline
11）	是否固定512 byte test? 
按协议来讲，SDHC(SD high capacity)还支持1k和2k byte，低容量卡可能只有512byte模式. 
看来至少要把SDHC的case覆盖全. 
12）	1bit, 4bit sdio卡的interrupt的软件处理相同.
DMA_CONTROL[0](DMA_EN)写明可以在DMA传输中打断. 打断后本次传输fail.

sd card其他改动的地方：
1）	irq进行了合并以及增加，例如block done and dma done 合并成trans complete了；
2）	state register用 src pending代替了
3）	以前有buf、fifo 2种mode，现在只有fifo mode了；当然，fifo有了各自的clear
以前这两种mode有什么区别？
	4）去掉了switch 请求功能；

Burst len也要测试；

另外，fifo也是用auto gate clock来控制是否出错的；
这次一定要测试高速模式: MMC: 52MHz clock, SD: 50MHz clock. 
Switch function这个功能是否需要完整测试?

3, 发信Wolf Duan [duanlianhua@vimicro.com], 及回信
0), 咱们有没有完整版本的mmc 4.4协议? 
[wolf:] 没有，咱只有4.3的
1), Mmc卡有针对boot的工作模式, 是mmc 4.4协议新增的, 这个feature是否不需要mmc卡支持?
[wolf:] boot是mmc4.3协议新增的，不是4.4，这个feature同时需要mmc卡的支持
2), Support MMC bus testing procedure. 这个是否指MMC spec"4.4.4 Bus Testing Procedure"这节提到的测试方法. 
[wolf:] 是的，不过我也不知道有什么用
3), block gap
reglist中多次提到block gap, 这个是不是指sdio或sd协议规定的block之前的gap, 用于sdio卡的interrupt. 同时"8.1.4 Interrupt Period at the Data Block Gap in 4-bit SD Mode (Optional)"这个feature我们支持吧? 
[wolf:] 指的是在multi-block传输中，相邻两个block之间的gap，sdio协议支持在这个gap里发interrupt，这个feature我们是支持的
4), 4种cmd type(Normal，suspend，resume，abort), 
对于sd/mmc来说是不是只有normal和abort(是否指stop command?), 对于sdio来说才支持四种指令? 
[wolf:] 没错，你理解的对
另外希望知道abort后host/slave如何处理: 本次传输作废还是尽快结束并加上CRC?
[wolf:] abort是软件发的，如何处理由软件来决定，一般用于处理错误，另外接收到abort命令的card相当于被reset了，加crc没有意义
5), 是否只有multi read/write才使用auto cmd? 
[wolf:] 不一定，灵活性我留了出来，multi read/write后接cmd12比较流行，其他的组合你们也可以考虑
6), dma boundary 的错误指什么? 访问slave时越界错误么? 
[wolf:] dma boundary不是错误，是指当前dma transfer已经meet软件配置的长度边界，需要软件更新dma起始地址和长度；另外访问slave越界错误或非法地址范围用dma_err表示
7), wake up, insert and remove等的作用.
[wolf:] 在sdio进入省电模式后，card insert和card remove都会触发wake up event，向pmu申请恢复模块时钟
8), detect pin and data 3 pin的share使用；
reglist HOST_MODE [4](DET_PIN_SEL)写明需要software配置, 但这个是协议规定好的, 为什么需要软件配置呢? 
[wolf:] 协议确实提到这两种方式，如果没有dedicated detect pin，协议允许用DAT3 pin来代替，所以需要软件来配置
9), sd/mmc不支持全双工, internal 2-channel DMA起什么作用? 
[wolf:] 确实不是全双工，但是所有的host设计都保留了两个channel，至于意义我觉得可以在读和写之间做pipeline
10), SDHC是否只支持512byte block? 
[wolf:] 按协议来讲，SDHC(SD high capacity)还支持1k和2k byte，低容量卡可能只有512byte模式
11), 1bit, 4bit sdio卡的interrupt的软件处理是否相同.
[wolf:] 应该是相同的
12), DMA_CONTROL[0](DMA_EN)写明可以在DMA传输中打断. 打断后如何处理? 本次传输作废还是尽快结束并加上CRC?
[wolf:] 这个也是由软件决定，什么场景我不确定，如果软件需要打断，本次传输肯定是废了~

15:00 2010-2-8
VC0882, 最小环境, FPGA, panda_os(nucleus), 移植AASP到VC0882
1, 发信: 
Hi, Dr, Yang

我们这边的测试环境需要运行nucleus os, 至少需要1Mbyte sram(之前项目最小环境需要922kbyte+一定数量堆栈空间). 如果方便最好提供2Mbyte sram, 我们效率会更高, 能尽快建立测试环境. 

Thanks
zhangjian
2, 整理FPGA最小环境(panda_os)问题和建议:
1), 现有进展:
omap3530下开mmu,cache的aasp调试通过. 
c环境下(无lib)uart查询模式收发测试通过. 
rvds4.0 lib+semihost模式工作正常. 
rvds4.0 lib+non-semihost无法进入c main函数, 原因不清楚. 
2), 建立基于nucleus的最小环境计划分为两步
(1), 建立完整rvds4.0 lib non-semihost环境. 
(2), 加入nucleus OS. 
我按上面两个步骤说明可能遇到的问题和改进建议. 讨论时按代码介绍rvds4.0初始化流程. 从汇编看$Super$main其实就是main函数.
3), 第一步: 
4), 第二步: 差异: nucleus自己管理memory, 堆栈指针和malloc,free库函数要disable.

3, 实验mini_aasp
1), init.s: 如果IF, ENDIF没有配对, 可能会提示Structure Overflow
2), 单步跟踪发现, 昨天居然链接脚本都没有改完. DHDY_CODE后面的区域都在0x30000000呢... 修改后原来SUBS那个可以过去. 但是串口仍然没有输出. 
3), 对比OMAP3530, 使用相同的memory方案, 只是起始地址改为0x80000000. 运行fail.
查原因. 
4), 发现build_omap3530也不行, 代码有问题? 
5), 实验自己保存的milestone: "mini_aasp_aasp4OMAP3530_除了用户热键其余基本ok". 是可以的. 看来后来代码改错了? 
6), 下午总结: 下午3个FPGA半小时内都不能用了. 后来用OMAP3530实验VC0882 memory分配方案和现有代码, 发现代码有问题. 晚上继续修改. 
7), 这次谨慎一点, 一步一步走.
(1), 顺便看下上次VC0882出错的:
MRC p15, 1, r0, c0, c0, 1   ; Read CLIDR	;OMAP3530_r0 = 0x0A000023
ANDS r3, r0, #&7000000	    ; OMAP3530_r3=0x02000000
MOV r3, r3, LSR #23         ; Total cache levels << 1
BEQ Finished

访问的是"c0, Cache Level ID Register", 对于Cortex-a8来说结果基本是固定的, 详见Cortex-a8 TRM p154-p155, 值得注意的是这里有个LoC和LoU, 前面的PoC, PoU还没明白, 这里有除了新东西...
The purpose of the Cache Level ID Register is to indicate the cache levels that are implemented. The register indicates the level of unification, LoU, and the level of coherency, LoC. For example, in the CortexA8 processor, the point where both data and instruction are unified is the Level 2 cache, therefore, the LoU is 3'b001. The point at which both data and instruction are coherent is the AMBA AXI interface, therefore, the LoC is 3'b010.

顺便列一下armv7中cp0-cp13的访问方式(ARM_ARM_7AR, p1213):
B1.7.2 Access controls on CP0 to CP13
Coprocessors CP0 to CP13 might be required for optional features of the ARMv7 implementation. In particular, CP10 and CP11 are used to support floating-point operations through the VFP and Advanced SIMD extensions to the architecture, see Advanced SIMD and floating-point support on page B1-64.
2), 现在这个代码就有问题, 原来哪个就没事. 
没办法, 只能把现有代码备份"D:\work\VC0882\code\mini_aasp_modify4VC0882_造成build_omap3530运行出现dataabort.rar". 先用原有代码. 
3), 从CVS更新, 输入"dhr<TAB>y_><TAB>g"后无反应. 停止时dataabort.
这个问题暂时没法查, 只能先用这个了. 
4), 去掉cache,mmu操作. 用一个最简的代码再往VC0882上面移植. 
5), 删除uart无用代码, 编译运行通过. 上传CVS.
6), 整理project配置. 把.cproject中fileinfo都删除, folderinfo只保留"/"(一个build配置一个). 
7), 加入CACHE_MMU_ENABLE, NEON宏后, 似乎没有进入aasp, 直接运行到:
  N:8003A174 EF123456  SVC      #0x123456
8), 运行build_omap3530_mini_mem, 会在_rt_memcpy中循环. 
感觉越走越窄. 

4, 从头来, 这次踏实一点, 直接用makefile管理, 也便于将来支持panda_os. 
这次要支持VC0882, OMAP3530, VC0882.
1), VC0830 build1运行成功. 
2), (22:53 2010-2-8)明天继续. 
总结: 开始走的不扎实造成现在返工, 以后一定要一步一步走稳了. 看明白, 而且可控的情况下再往下走. 之前一是rvds4.0管理工程的方法, 二是cortex-a8 cache,mmu代码, 这些都增加了复杂度. 

16:22 2010-2-8
时间管理
0, 9:10?-22:52

1, 计划
1), VC0882最小环境, 移植AASP到cortex-a8. 
2), 继续"9:23 2010-2-8"上周工作总结.
3), 实验"17:50 2010-2-8“VC0882, 最小环境, FPGA, Issue Track [VC0882]0008112

2, 执行
1), 上午VC0882 sync up, sd问题组内讨论. 
2), 中午-16:32 整理上午meeting minutes并与duanlianhua讨论. 中间还支持了FPGA bug的一点事情. 时间托的有点长了. 
3), 下午3个FPGA半小时内都不能用了. 后来用OMAP3530实验VC0882 memory分配方案和现有代码, 发现代码有问题. 晚上继续修改. 见"15:00 2010-2-8"

16:30 2010-2-8
VC0882, 项目计划, testchip, MPW时间表
MPW(multi project wafer)时间表, 见YangZuoXing转发邮件"转发: 会议通知：SW & 882"20100204_1206
Base on MPW tapeout time 14-Apr
所有FPGA模块初步测试完毕 31-Mar
ZhaoYuan Team Join 882 15-Mar Need 2 set FPGA boards
Yunlong Team Join 882 15-Mar Need 2 set FPGA boards
Need 2 set ICE for SW before 5-Mar

17:43 2010-2-8
VC0882, 最小环境, FPGA, debug, csat使用, Issue Track[882]0008115, 已添加注释: HuangWei的csat访问命令如下(使用dmr交替访问ap0, ap1会问题)
rviscan
con usb
chain dev=auto clk=10000000
dvo 0
dpe
dmr 0 0x20000000 4
dmr 1 0x60004ff0 4

17:50 2010-2-8
VC0882, 最小环境, FPGA, Issue Track [VC0882]0008112
1, ZhangXueQian邮件"答复: 现在主要是访问寄存器非法地址有问题"20100208_1609
通过APB Bridge的相关设置，可以通过中断的方式，通知CPU访问到了非法的地址。
The following are descriptions to indicate how to use timeout mechanism.
1.       Set internal counter target value – write target value to register, CNT_TGT
Counting time = (CNT_TGT+1)*APB_CLK
NOTE: counting time must be long enough to avoid confusing behavior of APB slave port. Otherwise, PREADY generated by slave may come after the one generated by timeout module. 
Set CNT_PERR to decide whether PSLVERR is high when timeout
2.       Enable counter – write 1 to CNT_ENABLE[0] 
3.       Counter keeps working until it reaches its target value, CNT_TGT and generates an interrupt to INTC.
4.       CPU gets the interrupt and check interrupt source– read CNT_SRCPND[0]. Interrupt pending if it is 1. Also, CPU is able to read CNT_ERRADDR to see which address is non-responding.
5.       Clear interrupt – write 1 to CNT_SRCPND[0]
6.       Go back to step 3 if counter is enable. To disable the counter – write 0 to CNT_ENABLE[0] , if the counter is not in use.
除了两种异常机制提醒访问有错误外，还会帮助slave完成pready的返回，以及记录出错的访问地址。出错的访问地址只能记录一组，如果有新的错误访问，将被覆盖。因此在访问到非法地址的时候，只要timeout机制打开，应该不会锁死。
具体使用方法参加apb bridge的mas

2, GeMeiPing邮件"答复: 现在主要是访问寄存器非法地址有问题"20100208_1725
Apb bridge timeout 机制默认是不开的，需要配置CNT_ENABLE(0x6004200)  CNT_TGT(0x6004004)两个寄存器，CNT_ENABLE为timeout enable，默认为0，应配为1，CNT_TGT默认值0xffffffff，应配一个比较小的值。
我试过两种情况
1、   timeout不使能，APB总线挂死，以后的访问出错。
2、   timeout使能，APB bridge在CNT_TGT cycle后拉起pready，总线不会挂死，以后的访问正常。

3, \todo 实验. 

9:13 2010-2-9
时间管理
0, 8:49

1, 计划
呵呵, 完全照搬昨天计划. 之前的计划也要看. 
1), VC0882最小环境, 移植AASP到VC0882. 
2), 继续"9:23 2010-2-8"上周工作总结.
3), 实验"17:50 2010-2-8“VC0882, 最小环境, FPGA, Issue Track [VC0882]0008112

2, 执行
1), -13:42 VC0882最小环境, 移植AASP到VC0882, 见"9:19 2010-2-9"
午饭(11:31-12:24)
2), 14:00-15:13 VC0882最小环境现有进展(见"15:00 2010-2-8"), 讨论和下一步工作(见"13:42 2010-2-9")
3), 15:50- 续1).
(晚饭: 19:01-)

3, 次日计划:
1), AASP移植到VC0882. 
2), 与GuoHaiFeng讨论uart发送查询模式. 

9:19 2010-2-9
VC0882, 最小环境, FPGA, 移植AASP到VC0882, 续
续"15:00 2010-2-8"
make位置见"11:19 2010-1-3"2-5)
1, build1, vc0830, 修改Makefile. 编译运行通过, 上传CVS:
copy from "C:\Program Files\ARM\RVDS\Examples\4.0\77\windows\emb_sw_dev", make target: build1_vc0830, build_clean pass. 
run build1\vc0830.axf in vc0830 sv board with more than 32Mbyte map to 0x0. 
2, build1_omap3530
1), 修改omap3530的connection配置: 
CONNECTION=\Advanced_Information\Default\ARM_config\Stack_Heap
The ARM tools automatically set the stack and heap based on the top of memory using semihosting. To change the setting, change the values in the right pane.
把"*Stack bottom"从<above heap>改为0x80800000. 
注: 如果是<above heap>, 似乎返回的是0x00800000.
2), 运行到_fp_init, 会出错, 不知道是不是因为omap3530 0x0地址没法写入vectors. 
去掉neon, armcc中cortex-a8有两种 no neon写法, 不清楚区别, 暂时用"--cpu=Cortex-A8.no_neon": 
 --cpu=Cortex-A8
 --cpu=Cortex-A8.no_neon
 --cpu=Cortex-A8NoNEON
3), 去掉后运行通过, 明显感觉omap3530的semihost比vc0830慢很多. 上传CVS:
add build1_omap3530 support, see build1\readme_omap3530 for further information
3, build1_vc0882, 修改堆栈地址为0x20040000后(256kbyte sram), 运行成功, 上传CVS
add build1_vc0882, reference build1\readme_vc0882.txt for further information

4, build2_vc0830
1), 编译运行通过, 上传CVS:
add build2_vc0830. using uart0 for input and output. semihost is also defined.
2), 修改, 上传CVS:
modify top Makefile for build configuration.
add build configuration: build2_VC0830, compile and run PASS

5, build2_OMAP3530, 很顺利, 上传CVS.

6, build3_VC0882, 先运行mini_c_env_nolib\build\bootloader.elf再运行(不断开rvdebugger, 不reset板子)build2\VC0882.axf, 上传CVS:
add build2_VC0882, need run "D:\VC0882\mini_env\mini_c_env_nolib\build\bootloader.elf" before. because there is no uart init in build2.

7, (15:56 2010-2-9)build3_VC0830, build3_OMAP3530. 
add build3_VC0830, build3_OMAP3530. We assume that there is 16Mbyte in VC0830/OMAP3530. 

8, build3_OMAP3530_M!M, build3_VC0882_M1M. 前者测试通过. 后者由于FPGA无法使用没有测试, 上传CVS:
add build3_OMAP3530_M!M, build3_VC0882_M1M. the former test passed. the other is not test yet.
M1M means only use 1Mbyte memory.

9, (18:59 2010-2-9)如果FPGA不能用, 晚上实验build4, omap3530 1M memory 方案. 并实验有无NEON两种情况. 

10, 晚上实验build3_VC0882_M1M, 用LSR[12]查询发送完成仍然会丢数, 原来记得用LSR[9]是没问题的(已发信给guohaifeng). 上传CVS:
add build3_VC0882_M1M compile and run PASS.
modify VC0882 uart sendchar code. poll bit 12 instead of bit9 in order to avoid losing character during transmision. it is better than before. but still miss some character sometimes

11:06 2010-2-9
VC0882, 最小环境, FPGA, debug, FPGA不稳定的临时解决方法: 换晶振, 查时钟方案
FanZhiJun邮件"答复: 需要增加sram大小"20100209_1102
今天1号板上来也不行，试了七八次，重启，重上电，都试过
最后把24Mhz晶振换成32mhz上电就能用了
如果多次反复连续不行，可以试试换个晶振

13:42 2010-2-9
VC0882, 最小环境, FPGA, 讨论和下一步工作
1, 讨论
1), 说明了我最近mini_env进展.
2), aasp问题讨论. 

2, 下一步工作
1), 修改AASP: 尽量少uart. 用标准库实现. 简化aasp.
2), 研究rvds4.0 no lib c环境. (稍候做)
3), debug.
4), 整理cortex-a8.
5), 稍候(年后): 
(1), nucleus: 是否用rvds4.0堆栈和malloc/free呢? 和dongliang讨论. 
(2), sd卡. 

17:53 2010-2-9
VC0882, 最小环境, FPGA, Issue Track[882]0008113, 添加注释
今天出现类似错误, 使用csat访问正常:
RVI链接VC0882后, load axf映像时提示
Error: Unable to write Program memory at S:0x20000000
Error V2801C (Vehicle): Failed to read the requested number of bytes to memory
Warning: The Cortex-A8 has had its world set to Secure.
后来Huangwei用csat访问0x20000000没有问题. 再用rvi连接正常. 而且可以看到刚才csat写入的数据. 
下次又出现这个问题, 发现csat也无法下载. 读APB-AP正常, 读写AHB-AP fail. 

18:22 2010-2-9
VC0882, 最小环境, FPGA, FPGA稳定性, Issue Track[882]0008114, 现在发现下面三方面对于RVI正确连接FPGA有帮助
好电源, 电源和RVI共地, RVI USB插在后面. 

18:27 2010-2-9
VC0882, 最小环境, FPGA, 下载CF code
winscp, hpcc: project\vc0882
我们没有excution权限, 无法进入. 

19:50 2010-2-9
绩效, 本月工作时间, 加班
本月加班时间, 1: 16(六),17(日),19,20,21,22,25,26,27,29,30(六); 2: 1,3,4,5,7(日),8,9
总加班时间不小于: 14*2.5 + 4*6 = 59. 后面三天, 估计会加班1-2天. 这样从加班时间不小于64小时. 

9:22 2010-2-10
VC0882, 最小环境, FPGA, debug, FPGA稳定性, Issue Track[882]0008114, 该邮件已上传IssueTrack, FanZhiJun初步找出一些规律: 好电源, 共地, USB接后面, 昨天FanZhiJun发现的先连接再接串口也有作用(见2)
1, FanZhiJun邮件"答复: FPGA稳定性测试映像"20100209_2306
HI Zhangjian
晚上测试用了你提供的测试映像，测试程序都用的“rev0_01020909_02020416.ace”，即1MB Sram；
平台1，
1，电源为20A电源 
2，PC为第二台（第二台显示器对应机器）
3，1号FPGA板（OSC3为32MHz）
4，1号ICE，
5，1号UART板
软件操作包括
1，   灌“mini_c_env_nolib_bootloader.elf”敲键盘有回应
2，   灌“VC0882.axf”，输入数字，程序跑起来
从21：23至21：43连续测试11次，包括上电，复位arm，重启软件，重新扫描，断开重连，等测试，每次软件测试都成功；
 
平台2，
1，电源为20A电源 
2，PC为第二台
3，3号FPGA板（OSC3为24MHz）
4，1号ICE，
5，1号UART板
 
失败两次
把OSC3晶振换成1号板的32MHz
切换成3号板，软件测试成功
 
平台3，
1，电源为20A电源 
2，PC为第四台（第四台显示器对应机器）
3，3号FPGA板（OSC3为32MHz）
4，1号ICE，
5，3号UART板
 
软件测试成功
 
总结一下可能的因素
1，   电源需用20A的，应该是必须的
2，   ICE的USB插在机箱后面
3，   ICE和电源共用一个接线板，可能的话，PC也共用这个接线板，共地更好。
 
我们明天再领5台20A的电源，在此基础上再看有没有问题。
 
另外，debugger软件的版本和USB驱动是统一的4.0吗？
把ICE5接到第二台PC上时，重新装了次驱动。

2, 昨天FanZhiJun发现先不接串口板, 再连接. 很容易连接. 连接后插上串口板可以正常使用. 

9:30 2010-2-10
时间管理
0, 9:09-

1, 计划
0), Dr.Yang说需要在装3台机器环境(也就是6套VC0882环境), 但是RVI一共5套, arm11要用一套. 就不够用了. 一会儿让FanZhiJun发信. 
1), VC0882最小环境, 移植AASP到VC0882, 今天要完成build4_VC0882, 开始移植AASP
2), VC0882 uart bug.<DONE: 没有复现>
3), 今天有时间的话把cache ID reg那个bug报上Issue. 
4), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

2, 执行
1), 11:05 VC0882 uart bug. 今天又发现没问题了. 可能与昨晚FPGA不稳定有关系? \todo 只能下次遇到再找GuoHaiFeng.
(30' 与youhai讨论VC0830 sdram切频流程)
2), 11:18- VC0882最小环境, build4_VC0830, OMAP3530, VC0882. 见"11:19 2010-2-10"
(12:00-13:48 午饭, 午休), (19:00-20:15 晚饭).

3, 次日.
1), build4_VC0882 fix bug. aasp porting
2), aiguo协调装机3台. 

9:41 2010-2-10
软件技巧, 正则表达式, editplus, 搜索, perl, logAssistant, 续
把@filelist做逆序, 这样log200x*.txt, log2010*.txt会按逆序排列, 可以更快搜索到最近的log信息. 将来再想提速就只能用buffer了. 
my @filelist = glob $filename;
#sort and reverse the filelist in order the search the last data work log.
#notes: i do not case that search logAllOther..., logEmbedded..., and other 
#small log files before log201002*.txt
@filelist = sort @filelist;
@filelist = reverse @filelist;

11:19 2010-2-10
VC0882, 最小环境, FPGA, arm cortex-a8, emb_sw_dev build4支持VC0830, OMAP3530, VC0882
1, build4_VC0830
dataabort. 查原来是怎么跑的. 
2, (14:03 2010-2-10)认真看
1), Root region:
Root region是执行地址与加载地址与相同的区域, 下列内容必须放在root region中:
__main.o, __scatter*.o, __dc.*o:
A root region is an execution region with an execution address that is the same as its load address. Each scatter-loading description file must have at least one root region. 
One restriction placed on scatter-loading is that the code and data responsible for creating execution regions cannot itself be copied to another location. As a result, the following sections must be included in a root region:
  __main.o and __scatter*.o containing the code that copies code and data
  __dc*.o that performs decompression
  Region$$Table section containing the addresses of the code and data to be copied or decompressed.
Because these sections are defined as read-only, they are grouped by the * (+RO)
wildcard syntax. As a result, if * (+RO) is specified in a non-root region, these sections must be explicitly declared in a root region using InRoot$$Sections.
See Assigning sections to a root region on page 5-24 in the Linker User Guide for more information.
2), 后来也不知怎么修改就过了.
3, build4_OMAP3530_M1M
1), \todo 千万别忘了我现在没有开Neon. 将来是要开的. 不知道开不开NEON对lib效率有没有影响. 
2), data abort. 单步跟踪和直接分析反汇编文件, 看看到底怎么执行的, 其实文档应该也有描述. \todo 还需要对照文档. 
发现我在链接脚本中错误的把RW, ZI运行地址从0x10000开始:
    DATA 0x80010000 
    {
        * (+RW,+ZI)
    }
在"__scatterload_copy"搬移RW段时肯定dataabort. 修改后pass.
注: OMAP3530异常向量表位于rom 0x14000(public rom本来是在0x40014000, 0x14000应该是映射过去的).
3), 继续分析代码, 主要内容都写在OMAP3530.S中了.
__user_libspace可能在移植OS时需要重写(DUI0349B_rvct_libraries_guide p25): 
The __user_libspace() function does not normally have to be redefined. However, if you are writing an operating system or a process switcher, you must reimplement this function. See Tailoring static data access on page 2-42 for more information. 
前面都是每条语句看的, 很慢. 说明自己汇编不熟悉, 库的初始化就比较复杂, 简单跳过. 
这里所有笔记都记录在"D:\VC0882\mini_env\mini_c_env_base\build4\analysis\OMAP3530.S"中.  上传CVS:
add build4_VC0830, build4_VC0882.
add include\omap3530: 前面build2,3的OMAP3530会编译不过去, 有这个文件就没问题了. 

3, build4_VC0882
乱码, uart初始化有问题. 用mini_c_env_no_lib bootloader.elf初始化后uart和dhry正常.
(9:45 2010-2-11)发现是LCR没有赋值(手工修改时需要保证修改前ENR==0, 修改后ENR=7, 否则修改无效). 赋值写成了逗号表达式. 看了看armcc文档, 没找到如何提示这个warning. gcc中就可以提示. 为了调试方便, 去掉了"-W"选项(不显示任何warning). 上传CVS:
add build4_VC0882_M1M configuraion. This is full function and non semihosting program. So, there is no need to run uart init program(like mini_c_env_no_lib\build\bootloader.elf) before it.

11:19 2010-2-10
VC0882, 寄存器属性, VMM_RAL, 寄存器测试方法, \todo 查VMM_RAL
1, WangFengHai邮件"关于882中寄存器的属性"20100210_1101
Hi, all：
因为882引入了VMM_RAL的寄存器测试方法，所以寄存器excel表中的属性跟以往不太相同，可能不太直观，导致有不少人对此感到困惑。
现在把属性说明贴在附件里，请相关的人抽出时间来看一下。
另外，这个说明已经上传到CVS服务器上，大家也可以去那里查看。路径是：
VC1600WCVS\doc\mas\pub_src\register_table_requirement\vc0882寄存器属性说明.doc

2, vc0882寄存器属性说明.doc
VC0882寄存器属性说明如下：
1. RW： 通过APB总线可对该寄存器进行读写。读出值即上次写入值。模块内部不允许对该寄存器进行任何修改。 
2. RO： 通过APB总线可读取该寄存器的内容。通过APB总线写该寄存器没有任何效果。模块内部不允许对该寄存器进行任何修改。 
3. WO： 通过APB总线可写该寄存器。通过APB总线读该寄存器，读取值永远为0，与该寄存器内的值无关. 
4. W1： write once。通过APB总线可读取寄存器的内容。每次reset之后，通过APB总线只可对该寄存器写一次。随后再写没有任何效果。只有再次reset以后，才可通过APB总线再次往该寄存器写入一个值。模块内部不允许对该寄存器进行任何修改。 
5. RU： 通过APB总线可读取寄存器的内容。通过APB总线写该寄存器没有任何效果。模块内部可以对该寄存器进行修改。 
6. RC： read clear。通过APB总线访问时，如果是写，没有任何效果。如果是读，第一次可读出寄存器的值。随后寄存器的值被清为0，再次读取时，读取值为0。模块内部可以对该寄存器进行修改。 
7. WC： 写1清0。通过APB总线可读取寄存器的内容。通过APB总线写该寄存器时，如对某位写0，则该位不变，如对某位写1，则该位变为0。模块内部可以对该寄存器进行修改。 
8. A1： 写1无效。通过APB总线可读取寄存器的内容。通过APB总线写该寄存器时，如对某位写0，则该位变为0，如对某位写1，则该位不变。模块内部可以对该寄存器进行修改。 
9. A0： 写0无效。通过APB总线可读取寄存器的内容。通过APB总线写该寄存器时，如对某位写0，则该位不变，如对某位写1，则该位变为1。模块内部可以对该寄存器进行修改。 
10. DC： don’t care。不属于以上9种情况的任何寄存器可归为此类。RAL环境不对此类寄存器进行测试，在模块级单独对此寄存器的功能进行测试。 

关于4类寄存器，文档上没有明确说模块内部是否可对该寄存器进行修改。不过就测试来说，修不修改也不会影响RAL的测试，反正读出来都是0.

另外，请注意以下两点：
1. RO和RU属性的不同。 对于RO寄存器，模块不允许改变它的值。而对于RU寄存器，模块才可改变它的值。这跟RO一般的理解不太相同。
2. 每个寄存器内部的所有field都具有相同的属性。目前公司的脚本要求必须是这样。

21:35 2010-2-10
(14:44 2010-7-27)
VC0882, arm cortex-a8, cortex-a8学习, 编译与调用Specifications: aapcs, elf, abi, relocation, \todo Cortex-a8学习资料整理
AAPCS: Procedure Call Standard for the ARM Architecture. 
1, 文档位置: "C:\Program Files\ARM\Documentation\Specifications\4.0\1\PDF", IHI0042A_aapcs.pdf
AAPCS与ABI比较, 见"5"
2, 看AAPCS文档时看到r12(IP)作用, 同时终于明白了"R_ARM_PC24"是啥.
1), 没看太懂, 大概是说可能BL跳转时linker会借用IP(r12):
5.3.1.1 Use of IP by the linker(p19)
Both the ARM- and Thumb-state BL instructions are unable to address the full 32-bit address space, so it may be necessary for the linker to insert a veneer between the calling routine and the called subroutine. Veneers may also be needed to support ARM-Thumb inter-working or dynamic linking. Any veneer inserted must preserve the contents of all registers except IP (r12) and the condition code flags; a conforming program must assume that a veneer that alters IP may be inserted at any branch instruction that is exposed to a relocation that supports inter-working or long branches.
Note R_ARM_CALL, R_ARM_JUMP24, R_ARM_PC24, R_ARM_THM_CALL, R_ARM_THM_JUMP24 and R_ARM_THM_JUMP19 are examples of the ELF relocation types with this property. See [AAELF] for full details.
2), AAELF("IHI0044A_aaelf.pdf")介绍了elf文件格式等. 
其中"4.6 Relocation"就是说明R_ARM_XXX这些. Relocation: 字面意思是重定位, 跳转指令肯定是算, ADD, SUB这些指令也涉及到. 
"15:10 2009-8-10"遇到错误中的R_ARM_PC24已经废弃由Use R_ARM_CALL or R_ARM_JUMP24代替. 结合build4_OMAP3530代码说明对R_ARM_CALL和R_ARM_ABS32的理解:
使用fromelf -r参数(e.g. fromelf --text -s -c -r --output init.s init.o)可以看到init.s里面两个跳转InitMMUentry和__main分别是R_ARM_ABS32和R_ARM_CALL类型: 
** Section #2 '.relINIT' (SHT_REL)
    Size   : 16 bytes (alignment 4)
    Symbol table #11 '.symtab'
    2 relocations applied to section #1 'INIT'

    #     Offset    Relocation Type               Wrt Symbol     Defined in
    ========================================================================

      0  0x00000024   28 R_ARM_CALL               13 InitMMUentry        Ref
      1  0x00000034    2 R_ARM_ABS32              12 __main              Ref
它们的跳转指令分别是BL和BX:
   0x00000024:    ebfffffe    ....    BL       InitMMUentry
   0x00000028:    e59fc004    ....    LDR      r12,[pc,#4] ; [__main = 0x34] = 0
   0x0000002c:    e12fff1c    ../.    BX       r12
$d
   0x00000030:    80018000    ....    DCD    2147581952
   0x00000034:    00000000    ....    DCD    0 ; __main

从AAELF p29可以看到R_ARM_CALL的确是用BL或BLX:
28 R_ARM_CALL Yes BL/BLX X & 0x03FFFFFE

呵呵, 感觉还是很糊涂, 暂时就理解到这个程度. 

3, AAPCS中5.5详细说明了参数传递, 没有细看. \todo.

4, 原来APCS中fp的使用没有找到, 可能在编译器手册中? 

5, 从"IHI0036A_bsabi.pdf"p6可以看出, ABI是
Application Binary Interface:
1. The specifications to which an executable must conform in order to execute in a specific execution environment. For example, the Linux ABI for the ARM Architecture.
2. A particular aspect of the specifications to which independently produced relocatable files must conform in order to be statically linkable and executable. For example, the C++ ABI for the ARM Architecture, the Run-time ABI for the ARM Architecture, the C Library ABI for the ARM Architecture.
简单说ABI是运行时要求(例如在Linux中运行的要求, 所以我们的kernel选择是EABI, 参见"18:10 2009-8-22"). APCS是是函数调用规范属于ABI.

9:44 2010-2-11
VC0882, ddr, 使用virtex5 io的delay等参数, 原来在VC0830中是逻辑做的延时, 对验证有没有什么影响? 

10:15 2010-2-11
时间管理
1, 计划
1), build4_VC0882 fix bug<DONE>. aasp porting<DONE>
2), 找aiguo协调装, Dr,Yang还需要2台环境. <DONE>
3), 今天有时间的话把cache ID reg那个bug报上Issue. 
4), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

2, 执行
1), 9:40-10:15 VC0882最小环境, build4_VC0882_M1M pass. 见"11:19 2010-2-10"3
2), 10:17-11:59 VC0882最小环境, aasp移植到VC0882. 见"10:17 2010-2-11".
3), 饭前1h+饭后11h, 装机见"11:56 2010-2-11".
4), 15:12- 续2). 

10:17 2010-2-11
VC0882, 最小环境, FPGA, aasp移植到VC0882
1, 先把aasp包干净, 再移植到mini_c_env_base中.
发现现有mini_aasp没法在OMAP3530上运行, 把现有代码备份到"D:\work\VC0882\code\mini_aasp_bak_OMAP3530和VC0882都无法运行.rar", 使用CVS上面的版本. 
2, 根据VC0882\panda_os\aasp调整代码. 暂时无法实现的用"PANDA_OS"区分. 修改后发现运行到脚本后无法输入命令, 停止时dataabort. 把刚才修改的size部分都改回去(仍用PANDA_OS)区分. 修改后运行已有命令OK. 
3, 上传CVS:
add build_AASP_OMAP3530_M1M. ref VC0882\panda_os\aasp. 
4, build_AASP_VC0882_M1M pass, 上传CVS:
add build_AASP_VC0882_M1M, modify "ifdef OMAP3530" to "ifdef AASP_FIX_BUG" in aasp\aasp.c.
AASP_FIX_BUG: fix previous aasp bugs.
AASP_FIX_USER_IO: modify aasp get/put char function. 
5, 加入dhry和dhry_global命令, 发现只能执行dhry_global, 输入dhry提示无此命令. 
另外单步调试时出现一次错误: 
Error V2801C (Vehicle): 0x021d0102: Error Failed to read value from register = 'DSCR' from target : Cortex-A8_0.
DSCR(CP14 c1 Debug Status and Control Register)保存cortex-a8内部debug unit的状态和控制信息, 详见Cortex-a8 TRM p451.
出错后, 直接关闭rvdebugger(没有选择断开, 感觉是rvdebugger自动断开的), 使用csat访问sram(0x20000000)和寄存器(0x60000000)正常. 

和Huangwei讨论, 应该是DAP-DP通过APB-AP访问的DSCR. 
这个问题是第一次出现, 原来用OMAP3530或其他板子也没有出现过, 担心VC0882 coresight内部有bug或不稳定影响将来使用. 

目前我们并没有办法通过csat访问cortex-a8内部debug寄存器, 这类问题没有经过测试, 出了问题也没法调试. 附上出现bug时使用的程序映像和完整代码. 

已经上报Issue Track: [882]0008148

5, 给aiguo fengbeizhan发信, 
Hi, aiguo, beizhan
今天VC0882 aasp可以运行, 输入help, vimicro, version都有正确结果, 这三个命令的命令补齐也正常. 
加入dhry和dhry_global两个命令后, 发现只能执行dhry_global, 输入dhry提示无此命令. 
还不清楚是aasp原有bug, 还是我调整aasp后引入的. 
程序位置: “D:\VC0882\mini_env\mini_c_env_base” build_AASP_VC0882_M1M.
另外单步调试时出现一次错误: 已经上报Issue Track: [882]0008148
zhangjian


11:56 2010-2-11
VC0882, 最小环境, 装机, rvds4.0需要重新配置
本来是计划写perl脚本重新crack: 把*.bak改名为*, 从ipconfig/all获得物理地址, 重新执行crack. 保留perl和exe两个版本. 
后来发现改物理地址就行:
1, 修改"C:\Program Files\ARM\Licenses\rvds.dat"中hostid为本机网卡物理地址(ipconfig /all).
2, 确保系统环境变量Path的C:\Program Files\ARM\RVCT\Programs\4.0\400\win_32-pentium;在C:\Program Files\ARM\RVCT\Programs\3.0\586\win_32-pentium;前面。
系统环境变量在"我的电脑"右键菜单"属性"->高级->环境变量->系统变量.

9:15 2010-2-12
VC0882, 最小系统, FPGA, FPGA不稳定, FanZhiJun邮件
1, FanZhiJun邮件"vc0882: fpga 平台"20100212_0016
Hi weiran，mike
现在FPGA平台不稳定，可能还有一些问题没有发现。
1）1，2，3号板上，加上UART子板（未接串口线），会导致ICE连接不上；因为拔掉UART板后马上连接成功，能证明是插了子板的影响。
连接成功之后再插UART子板和串口线，UART子板也能正常工作。
这个现象我和张建都遇到过多次，出现概率很大。
 
2）
今天在4号板或5号板上遇到这种现象
1，   插上JTAG子板（SYS,JTAG,TRACE子板，子板上未接ICE），开通5v电源，OSC3,OSC6的输出幅度只有1.5-2V；
2，   对1的情况，将输入电源提高到5.3~5.5v，OSC3,OSC6才输出3.3~3.5v的幅度；
3，   对2的情况，OSC3和OSC6的电源幅度不同，大约是3.1和3.5v的差别；
并不是每次都发生，但这个现象和问题1很相似，都是socket上接了子板，导致FPGA不稳定。
 
3）
6号板：
右上角的OSC4，上电时输出正常的3.3v；
加载了CF程序之后，输出电平变得只有1v多，波形很差。
每次都能复现，应该还好解决。
 
4）
4，5号板，都需要将电源提高到5.3v~5.5v，ICE才能扫描到或连接上；
但真正连接成功（ARM能发stop指令）的概率很低，今天只5号板连接成功一次。
 
以上问题的共性都是和电流负载有关，似乎是板子局部电压驱动能力不够，或者被电平冲突给拉下去了。
请帮忙想想有没有什么因素会导致驱动能力不足，或者socket有电平冲突。
 
fpga板，JTAG子板的layout图能发一份出来吗？ pdf格式的。 
谢谢！

9:21 2010-2-12
时间管理
0, 9:10

1, 计划
1), VC0882 AASP debug.<DONE>
2), 今天有时间的话把cache ID reg那个bug报上Issue. 
3), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

3, 次日计划
1), 填2月12日请假单. 

10:12 2010-2-12
VC0882, 最小环境, FPGA, AASP debug; rvct: armcc, armasm: 编译提示信息, 选择编译器输出风格
1, armcc和armasm用法:
1), armasm
使用INFO, ASSERT, OPT, TTL and SUBT, "DUI0204I_rvct_assembler_guide" p454: 
INFO numeric-expression, string-expression
如果 numeric-expression 是0, 会在console中输出这个提示信息. 如果不是0, 会报错, 例如: 
        INFO 0, "This expression evaluates to zero, so string-expression is printed during pass two."	
        INFO 1, "This expression does not evaluate to zero, string-expression is printed as an error message and the assembly fails."	
2), armcc和gcc: 
#error, #warning
3), 选择编译器输出风格(armcc, armasm相同):
--diag_style {arm|ide|gnu}
arm: 原有armcc, armasm格式. 
ide: arm workbench IDE格式, 在IDE->Project->Properties->C/C++ Build->Setting->Error Parsers, 选择"Realview Compilation Tools Error Parser"即可. 在IDE的代码标出错误, 警告等, 可以在"Problems"跳转到错误/警告位置. 
Problems可以从Windows->Show View->Other, General->Problems打开. 
gnu: gnu警告格式. 
4), arm workbench4.0: 
arm workbench会把c注释任何包TODO的字符串加入到Task中. 为了与doxygen兼容, 建议采取如下写法:
//\todo
/*
 * \todo 
 */

Task可以从Windows->Show View->Other, General->Task打开. 

2, 修改现有代码中warning.

3, 在OMAP3530上面测试aasp bug. 
1), 单步跟踪和分析代码, 看来aasp是假设链接时按照字母顺序排列, armcc也的确是这个行为, 但是反汇编文件中却是AASP_commands_do_dhry_global_test在前面. 
196  AASP_commands_do_dhry_global_test 0x8001012c   Lc    2  Sect  De   0xc
197  AASP_commands_do_dhry_test 0x80010138   Lc    2  Sect  De   0xc
2), 优化造成的? 关闭"-O2 -Otime"仍然如此. 
3), dhry_1.c中把这两个命令交换位置也是一样. 
4), 后面发现是命名问题, linker按照section排序, 我刚才是把写的
AASP_commands_do_dhry_test和AASP_commands_do_dhry_global_test, 这好是后者在前面. 改为AASP_commands_do_dhry_test和AASP_commands_do_dhry_test_global就可以了.
#pragma arm section rwdata="AASP_commands_do_dhry_test"
struct cmd _cmd_tab_do_dhry_test ={"dhry", "DHRYSTONE Benchmark", do_dhry_test};
#pragma arm section code,rwdata
#pragma arm section rwdata="AASP_commands_do_dhry_test_global"
struct cmd _cmd_tab_do_dhry_global_test ={"dhry_global", "DHRYSTONE Benchmark using a global cmd", do_dhry_global_test};
#pragma arm section code,rwdata
5), 原来OMAP3530上面输入dhry<TAB>_g<TAB><Enter>, 停止, 发生dataabort还是有. debug. 
6), debug"5)"描述的问题. 发现问题出自"cmdmatch()(aasp.c)", 没有考虑匹配dhry, dhryabc这类情况. matchlength会计算出-1. 在cmdmatch()返回前判断matchlength是否小于0, 如果小于0, 修正为0. 测试通过:
dhry<TAB>_<TAB><Enter>
help, vimicro, version等命令补齐, 完整输入正常.
7), 再修一个原有bug.
putty下输入vi<Backspace>e<TAB>无反应. 
发现是putty输入<Backspace>转为<del>(0x7f)报给aasp. aasp没有对0x7f处理. 所以会出问题. 
我认为比较合理的方式是aasp处理string_char, 处理设定的特殊功能字符, 其余字符丢弃. 这样能更好适应不同console, 而且便于将来扩展. 
8), VC0882 FPGA没法用, 先上传代码. 
下一步打算用1天时间修改aasp架构, 然后移植到panda中. 

4, 发信(aiguo, fengbeizhan):
解决了昨天问题, 又修了一个aasp比较致命的bug, 下一步打算用1-2天时间修改aasp架构, 然后移植到panda中(计划春节期间完成).

1, 昨天问题是dhry和dhry_global在section名字起的不好(AASP_commands_do_dhry_test和AASP_commands_do_dhry_global_test,, 正好是后者的section名字在前. 咱们的aasp是假设命令按照字符顺序排列的, 所以会有错误. 我今天把section名字修改就可以了
#pragma arm section rwdata="AASP_commands_do_dhry_test"
struct cmd _cmd_tab_do_dhry_test ={"dhry", "DHRYSTONE Benchmark", do_dhry_test};
#pragma arm section code,rwdata
#pragma arm section rwdata="AASP_commands_do_dhry_test_global"
struct cmd _cmd_tab_do_dhry_global_test ={"dhry_global", "DHRYSTONE Benchmark using a global cmd", do_dhry_global_test};
#pragma arm section code,rwdata

2, 在OMAP3530上运行aasp: 输入dhry<TAB>_g<TAB><Enter>, 停止后发生dataabort. 
发现问题出自"cmdmatch()(aasp.c)", 没有考虑匹配dhry, dhryabc这类情况. matchlength会计算出-1. 在cmdmatch()返回前判断matchlength是否小于0, 如果小于0, 修正为0. 测试通过:
dhry<TAB>_<TAB><Enter>
help, vimicro, version等命令补齐, 完整输入正常.
这个问题在VC0830上面也有. 

3, 今天VC0882 FPGA又没法用, 代码已上传(我每次简单测试通过的代码都会上传, 在CVS注释中写明修改内容), 目前OMAP3530和VC0882除了链接脚本起始地址不同, 其余都相同. . 

10:15 2010-2-16
VC0882, 最小环境, FPGA, 优化aasp代码
计划见"10:17 2010-2-16"
1, 去掉semihost:
1), 和mini_aasp一样, 从"VC0882/panda_os/adslib/In_custom.c"复制代码, 同时include "rt_sys.h". \todo, 这部分的arm文档还需要详细看.
2), 上传CVS: retarget.c v1.5
2, 调整AASP代码. 
1), 上: 24, 下: 25是dragon处理过的. 看看代码能不能兼容dragon和标准串口(支持三套键盘扫描码?).
先看明白aasp, 再看看u-boot是怎么处理的. 
2), aasp, 发现aasp中冗余代码太多了. 
A, cmdmatch, fgetsT和subcmdmatch, fgetssubT几乎相同. 
B, cmd和Subcmd完全一样(除了前者是结构体, 后者是类型).
C, cmd_search和cmdmarch的功能类似. 
这次修改aasp主要是目的是使用标准库(已完成), aasp功能键架构修改和去掉不必要uart代码(lidongliang在VC0598中基本完成, 不需要做). 暂时只有A会对此有映像. 所以暂时不修改C. 修改后保留原有代码, 在panda_os中. 用aasp_old表示. 调整前, 打了tag"mini_aasp_ncnb_ok". 这次修改都用"AASP_MERGE_COMMON_CODE"区分. 
(1), cmdmatch, subcmdmatch
A, 参数不同, 后者多了"Subcmd *subcmds". 这个其实是指定了cmd搜索范围. 对于全局搜索可以用NULL. 
B, 命令类型不同: cmd, Subcmd. 其实这两个类型是一样的. 只是一个是结构体, 一个是typedef. 
C, 终止条件不同: while(cmd != &__AASP_CMD_TAB_END__), while(cmd->str != NULL)
这个是cmd和Subcmd建立方式不同导致的. 没办法, 只能区分处理:
Subcmd是用数组建立的, 最后用全0表示结束. cmd分散在不同文件中, 不用全0表示结束. 
D, 是否要求按字母顺序排列. Subcmd不要求, 这个可以作为option. 与是否Subcmd无关. 
cmd是由链接器按符号排序. Subcmd使用数组维护, 只能是用户自己保证按字母顺序排列.
E, 匹配长度计算方法不同, 感觉Subcmd更合理: matchlength =strlen(match)-*sourcelength; 
(2), fgetsT, fgetssubT
两个函数几乎完全一样. 除了调用cmdmatch, subcmdmatch, 还有后者参数多了"Subcmd *subcmds".
(3), 准备工作: 为了整理代码, A, 首先要把cmd和Subcmd合并. B, 同时实验二级命令中dhry_repeat和dhry没有按顺序排列的影响. 
A, 合并cmd和Subcmd无问题.
B, 需要修改 subcmd_search:
在 subcmdmatch 中既然已经说明不要求按字母排序, dhry_repeat和dhry两个顺序应该是正确执行的. 但实际不行. subcmd_search和cmd_search都没有考虑dhry_repeat, dhry这种情况: 一个是另一个的子集. cmd_search就暂时不修改了, 有时间的话把 subcmd_search 和它合并. 
"OMAP3530+超级终端"测试通过, 已上传CVS
(4), 合并cmdmatch, fgetsT和subcmdmatch, fgetssubT
合并完成, 上传CVS(aasp.c v1.5):
合并AASP中部分代码, 用AASP_MERGE_COMMON_CODE宏区分. 
合并cmdmatch和subcmdmatch代码为cmdmatch_base. fgetsT和fgetssubT代码为fgetsT_base. 原有函数改为wrapper函数. 
详见本段2-2)-(1),(2). 
3), 看u-boot代码"TI PSP: uboot-02.01.03.11".
u-boot中与 fgetsT_base 功能类似的代码是 readline_into_buffer.
readline_into_buffer主体是switch case: 里面先处理所有特殊字符, 最后剩余字符都认为是普通字符在default中处理. 注意到'\t'是在default中处理的. 这样有什么好处?
4), 参考u-boot readline_into_buffer修改 fgetsT_base. 只是先处理可打印字符再处理特殊字符(TAB在特殊字符中处理, 暂时不处理上下).
TAB不正确: 发现是cmdmatch_base中要求用'\t'结尾, 同时fgetsT_base又要求不包括'\t', 所以只能: 
*s = '\t';
修改后简单测试通过. 上传CVS(aasp v1.5).

10:16 2010-2-16
时间管理
0, 9:50-

1, 计划<DONEor转移>
1), VC0882最小环境, aasp代码整理.
2), 今天有时间的话把cache ID reg那个bug报上Issue. 
3), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

2, 执行
1), VC0882最小环境. 见"10:15 2010-2-16"

10:17 2010-2-16
VC0882, 最小环境, FPGA, 任务分配, zhangjian, \todo
1, 最近四天完成panda_os: 1-2天完成aasp整理. 剩余时间尽量完成nucleus. 
1), 确认没有打开semihost;<DONE>
2), 有空试试timer和irq最基本功能. 
3), aasp整理: 希望把功能键作用单独提出. 便于代码维护. 
2, sd卡可能需要我调, beizhan请假. 
3, \todo, 看"13:06 2010-2-8".

10:02 2010-2-17
VC0882, 最小环境, FPGA稳定性, 
昨天实验情况: 
新电源上, ZouWeiRan调高输出电压保证FPGA输入电压在5.1v左右. 稳定性比原来有很大提高. 目前情况是:
凉: 不插串口线时基本都能正常连接. 插串口时有时会fail. 总体fail概率比原来小很多. 
热(运行dhry程序1小时左右): 不重新上电时按softreset或不按softreset可以重新连接. 重新上电后连接经常fail. 

10:29 2010-2-17
时间管理
0, 9:50-

1, 计划
1), VC0882最小环境, aasp代码整理. 参"10:17 2010-2-16".

2, 执行
1), 杂, 邮件. FPGA稳定性.
2), 10:40- VC0882最小环境, aasp代码整理, 见"10:40 2010-2-17"

3, 次日计划
1), 有时间的话把cache ID reg那个bug报上Issue. 
2), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

10:40 2010-2-17
VC0882, 最小环境, FPGA, 优化aasp代码, 续, 初步完成
计划见"10:17 2010-2-16"
1, 今日计划:
1), 改进cmdmatch:
(1), 支持"a dhry"情况, 会取"dhry"匹配. 只分析了代码, 还需要实际测试确认.<DONE>
(2), 用strstr没有用strncmp直观, 修改. <DONE>
(3), 看看cmdmatch能不能用cmd_search实现. <取消: 如果用cmd_search实现cmdmatch, 需要前者返回第一个匹配命令, 匹配命令个数等信息, 暂时不想修改cmd_search>
(4), "prematch == nowmatch"时用firstmatch判断停止是否问题, 感觉不会进入这个判断. <DONE>
(5), 命令超过31字符会溢出. <取消: 一般不会遇到, 暂时不处理>
(6), 简化参数. "FILE* fp"还是要保留, 使用文件还是stdio由aasp_shell决定. <取消: 本来是为了修(5)后简化参数个数, 后来(5)中match[]大小用宏MATCH_LEN_STR表示, 所以暂时就不简化参数了, 看了看, 也不好简化>
2), 对比新旧命令补齐相关代码(不限于cmdmatch函数), 确认正确. <DONE: 原来是s=s-2, 作用是去掉\n, 把\t作为s最后一个字符. 和下面"*s = '\t';"等价>
3), 改进fgetsT_base.
(1), 支持上下按键. <DONE>
(2), 支持左右按键. <取消: 时间关系, 取消>
(3), 避免输出其他控制按键. <取消, 分析后感觉有难度, 功能键长度不同, 除非记录全部键盘码表>
4), 实验aasp在semihost下能否使用.<转移到明天>

2, 改进cmdmatch:
1), 测试"1-1)-(1)": 如上面描述, 这其实不是bug, 而是灵活性. 不论命令, 文件名等等, 都可以用于匹配. 
2), "1-1)-(4)": 会进入. 如果两个命令dhry, dhry_repeat按顺序排列, 最多能匹配到dhry. 以后每次都是找到两个匹配(nowmatch=prematch=2), 必须通过"if( strlen(firstmatch->str) == strlen(match) )"判断停止. 
如果是dhry_repeat, dhry这样没有按字母顺序排列, match是"dhry_"时"(prematch != nowmatch)", 终止匹配. match数组多了一个字符, 所以matchlength要多减1. 
3), "1-1)-(2)": DONE
4), 发现从"-O2"改为"-O0"程序无法进入c环境. 这可严重了...
(1), "-O1"也有一定概率(1/3)无法进入main, 停止时报dataabort. 
(2), \todo 这个问题明天解决. 

3, 多做些测试: 
1), dragon, putty, 超级终端中多个命令(;分隔), 单一命令都工作正常. dragon中上下按键工作正常. 
2), 上传CVS: aasp.c v1.6. CVSlog为本段2,3两节内容.

4, 改进fgetsTbase
1), putty, 超级终端中支持上下按键. 
(1), 开始是这么写的:
if ( 1 == isWaitingSpecialFunc ) {
    switch ( specialCharCounts ) {
        //目前只支持第二个字符是0x5b的情况. 
        case 1:
            *s++ = c;
            specialCharCounts++;
            if ( 0x5b != c ) {
                isWaitingSpecialFunc = 0;
            }
            break;
        case 2:
            *s++ = c;
            specialCharCounts++;
            //目前只支持三个长度的功能按键, 所以到这里isWaitingSpecialFunc
            //肯定会恢复为0
            isWaitingSpecialFunc = 0;
            switch ( c ) {
                case 0x4c:
                    special_func = AASP_LEFT;
                    break;
                case 0x4d:
                    special_func = AASP_RIGHT;
                    break;
                default:
                    special_func = AASP_INVALID_KEY;
                    break;
            }
            break;
    }
    //功能按键输入完成(可能合法或不合法).
    if ( 0 == isWaitingSpecialFunc ) {
        //用户输入了合法的功能按键. 从s中删除功能按键字符, 并处理功能按键
        if ( AASP_INVALID_KEY != special_func ) {
            int i;
            s -= specialCharCounts;
            for ( i = 0; i < specialCharCounts; i++ ) {
                s[i] = '\0';
            }
            if ( AASP_RIGHT == special_func || AASP_LEFT == special_func ) {
                VIM_AASP_handleLeftRight(special_func, buf, &s, n, &sourcelength);
            }
            special_func = AASP_INVALID_KEY;
        } else {
        //不是合法功能按键, 输出用户输入的字符. 
            int i;
            s -= specialCharCounts;
            for ( i = 0; i < specialCharCounts; i++ ) {
                fputc(s[i], fp);
            }
        }

    }
感觉很乱, 而且不利于扩展. 
(2), 现在改为:
if ( 1 == isWaitingSpecialFunc ) {
    int i;
    PVIM_AASP_SpecialFunc find = NULL;
    *specialCharPtr++ = c;
    *specialCharPtr = '\0';
    switch ( VIM_AASP_matchSpecialFuncKey(s+1, &find) ) {
        case -1:
        case 0:
            isWaitingSpecialFunc = 0;
            while ( s < specialCharPtr ) {
                fputc(*s++,fp);
            }
            //输出specialCharPtr所有字符;
            break;
        case 1:
            isWaitingSpecialFunc = 0;
            while ( specialCharPtr > s ) {
                *--specialCharPtr = '\0';
            }
            find->handler(find->name, buf, &s, n, &sourcelength);
            break;
        default: 
            //继续匹配
            break;
    }
除了 PVIM_AASP_SpecialFunc->handler参数可能有变化, 其余部分应该是不变的. 
(3), 初步测试: Dragon, putty, 超级终端, dmw. 
A, 原有功能不受影响.
B, Dragon上下键不受影响. 
C, putty, 超级终端上下按键工作正常. 
D, 不支持dmw. 因为dmw吧把上下按键直接过滤了. aasp收不到. 
2), 上传代码(aasp.c v1.8):
(1), Dragon中上下按键处理部分提出为单独函数"VIM_AASP_handleUpDown()";
(2), specialFuncList: 在putty和超级终端等标准串口console中支持上下按键选择历史命令. 加入对应转义字符串和handler可以支持任意0x1b开始的功能按键. 

5, 总结: 整理昨天,今天进展和遗留问题:
Aasp代码调整初步完成, 代码已上传, 明天用部分时间解决遗留问题, 并开始nucleus移植. 
1, fputc, fgetc改为标准实现方式(节前完成). 
2, 昨天, 今天我集中精力改进命令匹配相关函数: 
1), 合并函数和结构体: cmdmatch/subcmdmatch, fgetsT/fgetssubT, cmd/Subcmd. 这三对很类似, 合并后代码简单很多. 便于整理和将来改进. 
2), 改进特殊功能处理方式: 一个ASCII码表示的特殊功能用switch case处理(例如退格, TAB, Dragon中的上下键). 多个ASCII码表示的特殊功能用specialFuncList数组和VIM_AASP_matchSpecialFuncKey函数处理(例如超级终端和putty中的上下键). 
在支持原有Dragon使用的基础上, 支持超级终端, putty等标准串口的上下按键选择历史命令功能. 

遗留问题: 
解决-O0, -O1不能运行的问题. 实验aasp能走在semihost下使用. 用宏可以选择新aasp代码和旧aasp代码(便于有问题时恢复, 对比). 

13:02 2010-2-17
(16:16 2010-2-19)
软件技巧, VC0882, rvds4.0, debug, 编译参数, 
1, 优化参数: 默认是-O2. 为了便于debug用-O0. 
2, rvdebugger技巧: rvds4.0 脚本语法与原来基本一样. 可以在script窗口中选择脚本. 
3, memory窗口: 与cexpression语法相同. 例如地址栏输入"@r0", 会取r0寄存器值为地址. 

8:59 2010-2-18
时间管理
0, 8:44-

1, 计划
1), VC0882最小环境, aasp代码整理. 参"10:17 2010-2-16".<DONE>
2), 开始移植nucleus
3), 有时间的话把cache ID reg那个bug报上Issue. 
4), 饭后, 用半小时把最近两周的时间管理和重要邮件看一下. 

2, 执行
1), 9:00- VC0882最小环境, aasp代码整理. 见"9:00 2010-2-18"
(30' 帮zhoudashan建立环境).

9:00 2010-2-18
VC0882, 最小环境, FPGA, 优化aasp代码, 续, DONE: 基本完成
1, 计划: 解决如下遗留问题: 
1), 解决-O0, -O1不能运行的问题. 
2), 实验aasp能走在semihost下使用. 
3), 用宏可以选择新aasp代码和旧aasp代码(便于有问题时恢复, 对比). 

2, "1-1)"
1), 对比编译映像(OMAP3530):
(1), -O2
==============================================================================

Image component sizes


      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   

     21492       4272        739        396      15068      71319   Object Totals
        16          8         32          0          0          0   (incl. Generated)
         0          0          1          2          3          1   (incl. Padding)
     14256        896        489         16        336       8088   Library Totals
        18          0          1          0          0          0   (incl. Padding)

==============================================================================


      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   

     35748       5168       1228        412      15404      73400   Grand Totals
     35748       5168       1228        140      15404      73400   ELF Image Totals (compressed)
     35748       5168       1228        140          0          0   ROM Totals

==============================================================================

    Total RO  Size (Code + RO Data)                36976 (  36.11kB)
    Total RW  Size (RW Data + ZI Data)             15816 (  15.45kB)
    Total ROM Size (Code + RO Data + RW Data)      37116 (  36.25kB)

==============================================================================

(2), -O0
==============================================================================

Image component sizes


      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   

     29748       4496        739        400      15068      73111   Object Totals
        16          8         32          0          0          0   (incl. Generated)
         0          0          1          2          3          3   (incl. Padding)
     14248        896        489         16        336       8088   Library Totals
        18          0          1          0          0          0   (incl. Padding)

==============================================================================


      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   

     43996       5392       1228        416      15404      75444   Grand Totals
     43996       5392       1228        144      15404      75444   ELF Image Totals (compressed)
     43996       5392       1228        144          0          0   ROM Totals

==============================================================================

    Total RO  Size (Code + RO Data)                45224 (  44.16kB)
    Total RW  Size (RW Data + ZI Data)             15820 (  15.45kB)
    Total ROM Size (Code + RO Data + RW Data)      45368 (  44.30kB)

==============================================================================

2), 把链接脚本, 堆栈地址都改大也不行. 单步代码查原因. 
发现原来调用"__scatterload_copy"的地方调用的是"__decompress". 发现单步没有问题. 
OMAP3530的异常向量在boot rom中. 这个不容易调试, 在VC0882上面实验. 
在VC0882上面试验5次, 未发现问题.

3, 调整代码, 把"AASP_MERGE_COMMON_CODE"单独提出来. 不定义这个宏会用旧的aasp函数. 另外"AASP_FIX_USER_IO"和"AASP_FIX_BUG"使aasp需要标准库就可以运行. 这两个宏不能去掉. 加入这两个宏是为了方便与原有代码比较. 

4, 现在OMAP3530在O0运行正常, 在O2, O2需要在Reset_Handler中单步到main才能正常运行. 

5, "1-2)": 原来从"VC0882/panda_os/adslib/In_custom.c"复制过来的_sys_xxx和__stdxxx_name这些在semihost下也需要注释. 用"USE_SERIAL_PORT"表示用实际串口还是semihost console. 
另外不能做回显. 把fgetsT_base中所有回显的fputc用echo_input代替, 通过"STANDALONE"区分是否回显. "STANDALONE"定义表示不使用semihost函数. 

6, 上传CVS. 1-1)是遗留问题. 

7, 总结: 今日进展, aasp代码调整基本完成, 下一步加入nucleus: 
1), 实验不同优化参数时对aasp是否有影响.
(1), VC0882在-O0, -O1, -O2, -O3下都能正常工作. 每种情况实验5次都PASS. 
(2), OMAP3530在不同优化参数时(-On)有时会出错. load程序后先执行几次单步就可以正常运行.
注: rvds4.0似乎会根据rw段大小决定是否进行压缩. 如果压缩, 在copy rw段时边解压边copy. 
2), "D:\VC0882\mini_env\mini_c_env_base\aasp\aasp.c"中保留原有aasp算法, 便于将来有问题时对比. "AASP_MERGE_COMMON_CODE"宏表示使用新aasp代码. 
3), console兼容性补充测试: 
(1), rvds semihost:输入命令, 执行正常, 但不支持特殊功能键. 定义"STANDALONE"表示不使用semihost方式. 
(2), secureCRT: aasp所有功能含(TAB补齐, 上下键等)正常.

注: 工程位置:” D:\VC0882\mini_env\mini_c_env_base”, 编译”make build_AASP_VC0882_M1M”.

11:42 2010-2-18
VC0882, 最小环境, FPGA稳定性差
今天FPGA2不插串口线也很不好用, 经常无法连接COrtex-a8(Issue Track[882]0008114, 提示"Error: 0x02410100: The run control operation could not be completed : .")
有时需要把memory片子和串口子板都拔掉才能连接.

注: 硬件编号: FPGA2, JTAG1, 串口子板3, mem子板1, CF子板2, CF卡1.

14:29 2010-2-18
VC0882, 文档, rvds4.0, 中英文文档
经lingming提醒, 我从infocenter.arm.com下载了最新rvds4.0中英文手册, 放到了"CVS D:\VC0882\document\arm\rvds". 中文手册不全, 可能没有英文手册新. 文档推荐用8.0以上adobe reader, 我下载了9.3放在: \\10.0.2.36\sqmshare\Utilities\Office-Editor\Pdf\AdbeRdr930_zh_CN.exe

14:41 2010-2-18
软件技巧, VC0882, rvds4.0, rvds4.0, debug
1, 从"rvds4.0 getting startted"可以看到rvds3.0支持cortex-a8.
2, 用armlink编译的动态库加上"--dynamic_debug"会加入"dynamic relocations": 
If you are debugging shared libraries created with the ARM linker, make sure that you have linked them with the --dynamic_debug option. This option generates dynamic relocations for debug sections.

18:41 2010-2-18
VC0882, 最小环境, FPGA, 最小环境讨论
aiguo邮件"关于882和未来项目的最小环境的讨论"20100218_1737
关于882初始化流程，最近zhangjian做了一些研究，目前感觉有几点需要讨论，我们先回顾一下以前的项目：

830和816用的gcc的编译器（也能够支持ADS 1.2，但没有怎么大批量用），用的系统库newlib c，主要为我们实现了getc，putc，printf，malloc，free等功能，其实getc和putc比较简单，主要是用malloc功能，后来我们的newlib c的malloc不能满足我们的需求，又增加了dongliang的malloc（主要是为了支持两块分离的memory）。
在598项目中，我们的编译器换成了RVDS 3.0，用了RVDS系统的库，其实库实现的东西并不多，malloc用nucleus实现，感觉没有必要用系统的库，这个需要dongliang确认，是考虑到继承，还是有其他原因？

因此现在遇到的问题是：598和882的流程很难统一，598虽然使用了RVDS推荐的流程，但并不是一个标准的实现，而是自己实现；而882在RVDS 4.0下不能使用这样的流程。

我个人希望：
1) 598和882用了OS，是否考虑放弃以前库的现实方式，这样，我们能够统一598和882，以及未来的项目，一个真正的OS是不会用到ARM的初始化流程；
2) 598和882用同一套编译系统，既我们都用RVDS 4.0编译（可以编译选项不一致），但debug tool自己用自己的，这样避免了我们在不同项目之间来切换机器或者改变环境变量，要研究其可能性，从理论上应该是完全可以的；
3) 同时我们要考虑未来项目中用到ARM11，我们的调试器用JLink的情况；
4) 进一步review 598和882 code，能够做成统一的code和流程；

我们等大家回来后，开会讨论一下相关架构和细节，大家都可以提前考虑一下，大家都对我们目前的系统比较熟悉，总的思想是，我们要提供一个统一的平台，多个项目保持一致性。

10:42 2010-2-19
时间管理
0, 10:28-

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882. <转移>

2, 执行
1), 10:52-19:28 VC0882最小环境, 移植nucleus到VC0882. 见"10:54 2010-2-19"
(11:35-14:20 午饭, 午休)
2), 14:20-15:02 与lingming讨论OMAP3530.

3, 次日计划
1), VC0882最小环境, 移植nucleus到VC0882.
2), 整理OMAP3530,cortex-a8资料. 

4, 其他
1), 重要不紧急:
(1), 整理cortex-a8学习内容. 计划下周内(2月26日)完成. 
(2), 移植nucleus完成后, 总结VC0882最小环境: rvds4.0初始化, aasp, nucleus等. 计划下下周(3月5日)完成. 
2), 不重要不紧急
(1), 把cache ID reg那个bug报上Issue. 
(2), 把最近两周的时间管理和重要邮件看一下. 

10:54 2010-2-19
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882
1, 计划:
1), 分析清楚VC0598下nucleus运行. <今天>
2), 实验VC0882 timer, irq是否可用.
3), 移植nucleus到VC0882. 

2, "1-1)":
1), 链接脚本(ada.lds)中NCNB这几个段是在哪里定义的? \todo 看运行时地址. 
SDRAM_NCNB_EXEC_ROM +0
{
      * (NCNB_RO)
}

SDRAM_NCNB_EXEC_RW  +0
{
        * (NCNB_RW) 
}
SDRAM_NCNB_EXEC_ZI +0 
{
        * (NCNB_ZI)
}
2), INT_Initialize是reset handler. 
直接在VC0598: VC0598_Init.s (appsentry\init_src\asm)分析. 分析后用脚本提取. 
3), 单步跟了VC0598_Init.s, 与nucleus有关的有:
(1), 定义nucleus中断向量. 
(2), 注册timer中断. 
问题是没有找到nucleus如何管理memory. 
4), 分析nucleus memory管理
(1), 与lingming讨论, 确定ncnb基本没有使用, VC0598有三个memory pol. VC0598 memory分配见"D:\VC0598\document\memory management\598 sdramAssign.xls".
(2), VIM_SYS_Config.h(sys)找到MEM_NOCACHE_SIZE, MEM_SMALLPOOL_SIZE定义. 
(3), "VIM_MMU_Init"通过VIM_MMU_Creat调用"NU_Create_Memory_Pool"建立了三个memory pool. 
在nucleus.h定义NU_Create_Memory_Pool为DMC_Create_Memory_Pool.
(4), nucleus中memory分配是"NU_Allocate_Memory", 这个函数在nucleus.h中定义为"DMC_Allocate_Memory".
(5), VC0598中实际分配memory的函数是"VIM_MMU_CacheMalloc"(VIM_MMU_CacheMalloc_Ex)和"VIM_MMU_Malloc"(VIM_MMU_Malloc_Ex).
前者根据申请的memory大小从"VIM_MMU_POOL_SMALL", "VIM_MMU_POOL_LARGE"两个pool分配. 
每个模块会定义自己的"VIM_MMU_CacheMalloc"用于malloc. 没有看到有模块使用"VIM_MMU_Malloc()", VIM_MMU_Driver.c中使用"VIM_MMU_Malloc()"的代码都被注掉了. 

5), "INC_Initialize"还没有细看. 目前感觉把汇编按"3)"修改. 在增加三个memory pool用于分配memory就可以了. 没什么太复杂的. 

10:52 2010-2-20
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续, 移植思路整理(准备下午讨论)
1, 调整启动流程:
1), 原有启动流程: 
reset->INT_Initialize->__rt_entry(重写)->INC_Initialize
INC_Initialize->Application_Initialize()初始化VC0598硬件. 
              ->TCT_Schedule()->...->task_aasp_func()->cyg_user_start().
原来项目中直接重写"__rt_entry", 这样很灵活, 但是如果rvds升级. 我们修改工作量大. 2), 建议把流程修改为: 
reset->INT_Initialize->_main(初始化rw, zi, 调用__rt_entry(rvds4.0))->main->INC_Initialize...->
这样修改后, __rt_entry中初始化lib c堆栈. nucleus自己管理的堆还是自己初始化. 
3), 或者直接去掉"__rt_entry". 目前没有看到printf需要初始化. 去掉后semihost console能不能使用不清楚. 
如果要考虑arm11, __rt_entry保留比较好. 

2, 具体修改: 
1), VC0598_Init.s
(1), 定义: 
A, 定义异常向量. 不需修改. 
B, 定义nucleus中断向量. 
C, nucleus其它全局变量. 不需修改. 
(2), INT_Initialize
A, 关闭中断, mmu, tlb. 
B, copyRW, 清bss: 如果没有NCNB区域, 可以由rvds自动生成这段代码. 
C, 设置栈.
D, 注册timer HISR.不需修改
E, SOC中断初始化.
F, 设置堆
(3), 其他(不需修改):
A, 定义异常向量处理函数
B, 定义irq处理函数. 
C, 定义timer中断.

2), memory分配: 
(1), rvds4.0建议如果由OS管理memory分配, 就不为c lib设置堆栈空间. \todo 查文档. 忘了在什么地方. 
(2), VC0598中实际分配memory的函数是"VIM_MMU_CacheMalloc"(VIM_MMU_CacheMalloc_Ex)和"VIM_MMU_Malloc"(VIM_MMU_Malloc_Ex). 前者根据申请的memory大小从"VIM_MMU_POOL_SMALL", "VIM_MMU_POOL_LARGE"两个pool分配. 每个模块会定义自己的"VIM_MMU_CacheMalloc"用于malloc. 没有看到有模块使用"VIM_MMU_Malloc()", VIM_MMU_Driver.c中使用"VIM_MMU_Malloc()"的代码都被注掉了. 
如果没有NCNB malloc, 就只要两个memory pool. rvds4.0本身支持两个堆, 第二个作为扩展. 和我们nucleus中两个堆的用法不同. 

3, 讨论: 
1), 如何支持浮点和NEON指令集.
__rt_entry->__rt_lib_init->_fp_init. 
如果打开NEON: _fp_init做初始化. 否则_fp_init为空. 

4, meeting minutes
1), 查INT_Loaded_Flag和Loaded_Flag作用. lidongliang.
2), VC0830中ads lib c堆是否分配了空间, 起什么工作. lidongliang.
3), VC0882最小环境, zhangjian, lidongliang. 
(1), 在VC0598中实验新讨论的初始化流程(不实现"__rt_entry"). 如果pass在VC0882中使用. 
(2), 2-3内完成VC0882 nucleus最小环境. 
4), rvds4.0, rvds3.0, ads1.2(axd)能否共存. zhangjian.

5, 其他会议记录:
1), VC0598链接脚本中三个NCNB_xxx区域都不再使用, 可以删除. 
2), VC0882: 在make target中通过不同链接脚本选择不同memory大小. 
3), VC0598_Init.s中只是初始化timer hisr. 其他HISR在VIM_INT_Driver.c中管理(dongliang增加).
4), VC0598中lib c的堆栈空间就是系统stack空间. 

11:04 2010-2-20
时间管理
0, 10:40-

1, 计划<转移>
1), VC0882最小环境, 移植nucleus到VC0882.
2), 整理OMAP3530,cortex-a8资料(先看工作日志). 
3), test plan review和其他杂事. 

2, 执行
1), 10:50-14:00 VC0882最小环境, 移植nucleus到VC0882. 见"11:06 2010-2-20"1,2,3
(1.5h: 午饭, 午休)
2), 14:05-16:00 VC0882最小环境, 讨论, 会议记录. 见"11:06 2010-2-20"4,5
3), 16:10-22:20 VC0882最小环境, 移植nucleus到VC0882, VC0598下实验不重写__rt_entry. 见"17:14 2010-2-20"
(2h: 晚饭, 休息)

3, 次日计划

4, 其他
1), 重要不紧急:
(1), 一但sd仿真通过, 就要开始调试sd卡. 
(2), 整理cortex-a8学习内容. 计划下周内(2月26日)完成. 
(3), 移植nucleus完成后, 总结VC0882最小环境: rvds4.0初始化, aasp, nucleus等. 计划下下周(3月5日)完成. 
2), 不重要不紧急
(1), VC0882加入irq test.
(2), 把cache ID reg那个bug报上Issue. 
(3), 把最近两周的时间管理和重要邮件看一下. 

17:14 2010-2-20
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续, VC0598下实验不重写__rt_entry
1, 在VC0598下实验"10:52 2010-2-20"讨论的流程. 如果pass移植到VC0882.
2, VC0598中. 不再自己重写__rt_entry, 使用编译器提供的版本. 
1), 停在"VIM_INT_SetPro"()": DRV_ASSERT(vector<IRQ_MAX_VECTOR);
发现是vector=0x6d(109), IRQ_MAX_VECTOR=30. 所以assert fail.
查上一级函数"VIM_INT_Init()". 发现"g_priority"数据都不正确.
对比反汇编文件, 发现"g_priority"里面的数据是错误的.
g_priority(adr: 0x0003a3ac)内容应该是:
    1095  g_priorityHigh             0x0003a394   Lc    2  Data  De   0x8
    1096  g_priorityMid              0x0003a39c   Lc    2  Data  De   0x8
    1097  g_priorityLow              0x0003a3a4   Lc    2  Data  De   0x5
实际是0x00039742, 0x0001DEF8, 0x00039151.
感觉下面的0x3a3f0才是g_priority:
0x0003A3D0 0x00000000 0x00000000 0x1814191C 
0x0003A3DC 0x17000B12 0x1015161B 0x03050607 
0x0003A3E8 0x1309080C 0x00000011 0x0003A3D8 
0x0003A3F4 0x0003A3E0 0x0003A3E8 0x00050808

0x3a3f0实际是代码修改前g_priority地址, 奇怪?!

3, 发现load映像有错误:
结束地址都是"0x0003A18B".
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module CACHE_TEST_CMD address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module CACHE_TEST_CMD address(es) [0x0003AAAC..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module FAT_TEST_CMD address(es) [0x0003AAC4..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module FAT_TEST_CMD address(es) [0x0003AAD0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module HAL_TEST_CMD address(es) [0x0003AAE8..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module HAL_TEST_CMD address(es) [0x0003AB0C..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.
Error: Module AASP_CMD_VERSION address(es) [0x0003AB60..0x0003A18B] not in range.
Error: Module COMMAND_S address(es) [0x0003AAA0..0x0003A18B] not in range.

4, 
*g_first_available_memory=0x0006F4D0.

5, 
	IF :DEF: ORI_CODE  
	B		__rt_entry	; 增加c lib的初始化
	ELSE
	IMPORT __rt_entry
	LDR r12, =__rt_entry
	BX r12
	ENDIF ;IF :DEF: ORI_CODE  
	]

改为:

	IF :DEF: ORI_CODE  
	B		__rt_entry	; 增加c lib的初始化
	ELSE
	IMPORT __main
	LDR r12, =__main
	BX r12
	ENDIF ;IF :DEF: ORI_CODE  
	]


__main
	b __rt_entry

会提示__main重定义. 

5, 没什么眉目, 明天在OMAP3530上面试验, 直接调用__rt_entry.
我还没有在rvds4.0上面试验过不搬移行不行. 

9:52 2010-2-21
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续, VC0598下实验不重写__rt_entry, 续
1, 计划
1), 发现昨天用的代码并不是CVS上最新版本. 下载最新代码重新做实验. 
2), 昨天"17:14 2010-2-20"3这个错误很有问题, 查. 
3), 可以考虑对比VC0882下直接调用__rt_entry效果. 
2, 在rvds4.0下试验:
1), 保留自己实现的"__rt_entry", 只要注释"__rt_stackheap_init()", 简单试验aasp可以正常运行.
2), 直接INT_Initialize结尾调用使用库的__rt_entry, 现象和3.0一样。
3), 通过__main调用__rt_entry. 重载"__main"后aasp工作正常. 这是今天lingming提醒的.
3, 下午重做试验, 代码上传CVS. 看看rvds4.0会不会判断地址是否相同. 如果不判断会把rw写坏.
1), 保证代码在rvds4.0和rvds3.0各自环境中都可以使用. rvds3.0(rvct, rvdebugger)与rvds4.0共存时能否正常使用.
2), rvds3.0, rvds4.0能否调试对方编译的映像.
3), 分析是否重载"__main"的差异.
4, "3-1)", "3-2)", 上传CVS:
1), 修改VC0598初始化流程, 新流程更符合arm推荐流程. 定义"OLD_INIT_SEQUENCE"表示使用旧流程:
涉及到函数和文件如下:
A, AppsEntry\init_src\asm\VC0598_Init.s, AppsEntry\init_src\Appstart.c
不再直接调用重载的"__rt_entry", 而是调用重载的"__main", 调用顺序如下:
"__main"->系统"__rt_entry"->系统"__rt_lib_init"
                          ->main->INC_Iniialize()
B, AppsEntry\init_src\io_custom.c: 
__rt_exit()不应该重载, main函数return时(实际我们的代码不会reture)调用顺序如下:
exit->__rt_shutdown->_sys_exit
C, Makefile
rvds4.0不在支持"--apcs /adsabi"这个参数. 删除.
2), 实验了min(sd fat aasp AppsEntry mmu cache clkrst hal sys timer interrupt uart pdma Nucleus padc)在rvds3.0, 4.0下编译运行. 以及rvdebugger3.0调试armcc4.0, rvdebugger4.0调试armcc3.0. 简单试验均pass.
3), 用tag区分: new_init_sequence_for_rvds40_and_rvds30

5, 发信(ICP):
Hi, all

为了与VC0882一致, 调整了VC0598 panda_os初始化代码, 对各模块代码没有任何影响. 
我只实验了"min(sd fat aasp AppsEntry mmu cache clkrst hal sys timer interrupt uart pdma Nucleus padc)"下在rvds3.0和4.0下编译, 调试和简单aasp命令. 大家遇到问题随时找我. 

具体情况如下: 
(见上面条目"4")

9:54 2010-2-21
时间管理
0, 9:40-22:10

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882.
2), 整理OMAP3530,cortex-a8资料(先看工作日志, 修改logAssistant: 输出keywords section到文件). 
3), test plan review和其他杂事. 

2, 执行
1), 10:04-11:25, 16:10-17:56 VC0882最小环境, 移植nucleus到VC0882. 见"9:52 2010-2-21"
2), 午饭, 休息;
3), 14:10-15:29 与yuyang讨论DMAC.
30' 休息.
4), -22:03 VC0882最小环境, 移植nucleus到VC0882, 见"20:18 2010-2-21"
(晚饭, 休息: 1.5h).
(30' 给aiguo发邮件: PB-A8作用)

3, 次日计划

4, 其他<永远置底>

18:11 2010-2-21
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续
1, VC0598初始化流程已经按rvds4.0推荐流程调整, 见"9:52 2010-2-21", 修改代码已经merge到VC0882 panda_os, 还需要修改:
1), 初始化代码和os支持. 
关mmu, cache代码. 
uart, 中断向量, timer. 
2), aasp: 直接用"D:\VC0882\mini_env\mini_c_env_base"的aasp.
2, 下午编译sram_1M时报错, 估计原因是: 
"--entry=0". 所以没法链接到0x20000000地址. 改为INC_Initialise. 
3, 编译通过后运行到下面add这句就走不了了(abt状态): 
MOV     a2,#IRQ_STACK_SIZE          ; Pickup IRQ stack size in bytes
ADD     a3,a3,a2                    ; Allocate IRQ stack area. 
BIC     a3,a3,#3                    ; Insure word alignment
直接跳过stack设置这段的话, 会在__init_alloc中走不动. 
难道是用法问题? 看看"mini_c_env_base"中stack是如何设置的. 
1), 参考init.s(mini_c_env_base)把
        MSR     CPSR_cxsf,a1                ; Move to ABORT mode
改为
	MSR     CPSR_c,a1                ; Move to ABORT mode
也不行.
2), 不设置堆栈. 也不行. 在库的初始化中会有问题. 
可能是cortex-a8初始化代码有变化, 或者是原来代码写的不规范. 按mini_c_env_base格式修改. 
4, 修改memory大小: 
MEM_MAX_SIZE 改为1M.
MEM_SMALLPOOL_SIZE 也从0xd8000改为0x10000.
5, (22:06 2010-2-22)今天实验发现由可以进入了. 保存了FPGA文件. "D:\work\VC0882\code\20100222_移植nucleus到VC0882"

21:17 2010-2-21
VC0882, 最小环境, FPGA, ddrc, 有一根数据线接触不好, 造成ddr访问时某些bit有问题, 现在是直接从ddr芯片飞到FPGA底板. 

11:35 2010-2-22
软件技巧, VC0882, rvds4.0, rvct, 默认数据类型, 不同类型比较大小, 与立即数比较大小
用一个short类型变量(赋值为0xaaaa)与0xaaaa比较. 发现前者实际是0xffffaaaa. 所以两个不等. 把0xaaaa强制转为short类似, 看汇编文件发现寄存器值是0xffffaaaa. 看来rvct是用f填充没有使用的bit. 以后与立即数比较大小时要注意

12:52 2010-2-22
时间管理
0, 10:10-

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882, 今天一定要试一下OMAP3530下能不能跑.
2), 计算本月迟到时间, 看看是否需要请假. <DONE: 暂不需要>

3, 次日计划:
1), 参见2月20日时间管理. 
2), VC0882 FPGA ace文件下载权限. 

16:50 2010-2-22
VC0830, SV, linux, android, 系统不稳定(zhaoyuan)
1, zhaoyuan bug
在u-boot中切频到336_112, VC0836 336_112跑android时会死, 240_120没事. 
死的时候jtag无法连接, irq没有(把irq用gpio引了出来, 系统正常运行时肯定有tick).
发现编译不同模块问题会不同, 目前可以构造一个case很容易死(android起service过程中). 
336_112关闭cache下没有问题. 
zhaoyuan和aiguo讨论后, 认为是cache问题. 
注: memory参数是weiyunlong组dangxiangfu搜出来的. 
2, 这个问题其实还有几个值得怀疑的地方:
1), jtag连不上不一定是死了. 
2), 编译不同模块的区别除了代码问题外, 就是使用的memory区域不同. VC0830调试eorex memory时发现过只是错个别几个word的情况. 当时比较幸运是经常在汇编初始化时会出错, 所以迅速定位了错误, linchuan调整了memory参数和切频流程(修改sdrc_mode). 
建议zhaoyuan做memory全空间的测试. 
3), mobile ddr下搜参数有没有问题还不好说, 毕竟没有像MP4那样经过客户测试和量产.
3, 另外切频代码zhaoyuan说是FPGA代码, 那肯定是有问题的. 建议他们做大量连续测试. 
4, 给aiguo, liaozhicheng发邮件:
刚才和zhaoyuan讨论两点值得注意: 
1), zhaoyuan说编译不同模块问题会不同. 我联想VC0830 SV调试eorex memory遇到过只有几个word错误的情况, 后来发现是memory参数和切频流程问题. 
建议zhaoyuan做全空间的memory测试. 
2), zhaoyuan说切频代码是咱们FPGA阶段代码. 我担心切频流程有风险, 以后可能会出问题. 建议他做连续大量切频测试. 
另外他可能不清楚830切频bug. Mobile ddr可能也需要sram切频. 

20:18 2010-2-22
VC0882, FPGA, DMAC, 寄存器
DMAC_LLI_ADDR要求8byte对齐: 
Each of the request Linked List Item registers contains a double word-aligned address of the next LLI. I
VC0830要求是4byte对齐. 

9:54 2010-2-23
时间管理
0, 9:40-

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882.
2), 改进logAssistant, 支持查找section keywords. 
3), 整理cortex-a8学习内容. 计划见"10:07 2010-2-23".
4), VC0882 FPGA ace文件下载权限. 找fanzhijun确认, 找aiguo发邮件. 

2, 执行:
1), VC0882最小环境, 实验cortex-a8在一条正确语句停住的问题, 见"10:19 2010-2-23"
2), 与yuyang讨论dmac.
3), VC0882最小环境, 研究rvds4.0技巧, 见"17:44 2010-2-23", "15:34 2010-2-23"
4), 22:18-22:48 VC0882, cortex-a8学习资料整理. 见"22:24 2010-2-23".
困了, 省下部分明天在地铁上看. 

3, 次日计划:

4, 其他

10:07 2010-2-23
VC0882, arm cortex-a8, 整理cortex-a8学习内容, 计划
1, 计划三天时间看完cortex-a8, OMAP3530日志, 26日列提纲,发信. 

10:19 2010-2-23
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续
1, 今天计划是对比VC0882和VC0598启动流程. 
2, 发现FPGA版本有影响. 
版本rev0_01022018_02020416错误, rev0_01020909_02020416正确.
后者的改动有clkrst, reset两部分. 
3, 下一步计划
1), 下午实验原来cortex-a8 cache dhry读cp15 cache type现在是否正确. 如果也错误, 发信. <DONE:正确>
2), 还有FPGA稳定性问题. 
3), 整理一下现有问题. 
4), FPGA cf code下载权限. 
4, "3-1)":
rev0_01020909_02020416(CF2), rev0_01022018_02020412(CF3)
1), FPGA1
(1), 直接运行会死. 原因是开了NEON指令, 注释后实验.
两个cf都pass
(2), 运行panda_os, 两个cf都可以运行到main.
在实验三次, rev0_01020909_02020416又不能运行到main了. 停在"add a3, a3, a2". 难道刚才是试错了?
重复5次实验:
2次停在汇编代码"add a3, a3, a2".
3次可以进入main函数.
代码和映像位置: D:\work\VC0882\code\milestone\20100223_panda_os_VC0882可以运行到main函数.rar.(未上传CVS).

5, Issue track 882: 0008177
出现频率: 重复出现
严重性: 系统崩溃
优先权: 高
摘要: cortex-a8停在一条正确语句无法继续运行, 且系统未报错
说明: rev0_01020909_02020416 FPGA版本下, FPGA1 cortex-a8有50%出现此错误.FPGA2(?)每次必定出错. 具体现象: 
在"add a3, a3, a2"汇编语句, rvdebugger单步执行或继续运行都无法通过这条指令. 如果注释这条命令会停在另外语句. 
同样代码只修改链接地址后在TI cortex-a8(OMAP3530)运行正常. 

使用"rev0_01022018_02020412"版本FPGA1运行正常, 连续试验10次未出错. 
附件是对应axf文件. 

6, 发信.
发送: yangzuoxing, jiajihua, fanzhijun, guohaifeng, zhangjian, huangwei
抄送: aiguo, fengbeizhan, wangxin
题目: cortex-a8在一条正确语句停住无法继续运行
新发现一个问题: cortex-a8停在一条正确语句无法继续运行, 且系统未报错(Issue track 882: 0008177). 这个问题出在软件进入c语言前的汇编代码(从VC0598继承), 在TI (OMAP3530)可以正常运行. FPGA版本是rev0_01020909_02020416, 对比发现在最新FPGA(rev0_01022018_02020412)版本无问题. 所以初步确定软件没有问题.

算上这个问题, Issue上有四个问题可能都是FPGA稳定性问题. 0008113和0008114现在仍然经常遇到.
0008113: rvdebugger写入memory(sram)失败 
0008114: rvdebugger有时连不上Cortex-a8 
0008148: 使用Rvdebugger单步调试中DSCR无法访问 
还有一个是debug问题.
0008115: csat访问dap fail 

除了0008148, 这些问题都很容易复现, 有没有可能module owner详细分析一下问题, 看看能不能避免. 

毕竟是第一次做cortex-a8, 很多东西拿不准, 如果FPGA不稳定, 软件很难分析.
担心将来FPGA集成更多模块后稳定性更差. 

7, (21:40 2010-5-11)Issue 8177 注释(0016538) fanzhijun:
rev0_01022018_02020412和 rev0_01020909_02020416 的A8部分相比较，我做的改动是增加PADC_SYS 的pready信号。 

15:34 2010-2-23
软件技巧, VC0882, rvds4.0, arm workbench4.0, 在outline view添加make target, 在Make targets中双击target即可编译. 这样很方便. 其实我感觉用perl辅助处理其实没必要, make本身功能很强. 不过现在也没发现perl太大问题, 所以没机会改. 

17:44 2010-2-23
软件技巧, VC0882, rvds4.0, rvdebugger
最终希望直接由eclipse启动rvdebugger, 并连接, 运脚本
1, 修改brd文件, 添加三行:
位置:"C:\Documents and Settings\830\Application Data\ARM\rvdebug\4.0"
[CONNECTION=VC0882] 
connect_with.Manufacturer=ARM-ARM-NW
configuration="VC0882.rvc"

如果建立单独的brd文件, 还需要加入: 
, 只写最后三行不行:
# RVDEBUG.BRD default Board-file. This file should not be hand edited. The
# Settings Window should be used to edit this file and any derivatives
# of it. 
# Copyright (c) 1997-2007 ARM Ltd. All rights reserved
$rvdebug

# The *.bcd include loads in files created by board manufacturers, ASIC
# chip designers, and custom board designers (or someone who wants to add
# the information). This allow use of the extended information by board
# entries of type DERIVED and DATFILE.
[INCLUDE] (*.bcd) Board/Chip Definitions\\ Custom Board and Chip definitions

[CONNECTION=VC0882] 
connect_with.Manufacturer=ARM-ARM-NW
configuration="VC0882.rvc"

"VC0882.rvc"是用rvi configuation工具auto configure(不选择adaptive clock)后保持的. 

2, 启动时连接:
rvdebug.exe --init=@Cortex-A8_0@VC0882
rvdebug位于"C:\Program Files\ARM\RVD\Core\4.0\1106\win_32-pentium\bin\rvdebug.exe"

3, VC0882.inc:
connect "@Cortex-A8_0@VC0882"
load/r 'D:\user\zhangjian\VC0882\panda_os\build\VC0882.axf'
break main

22:24 2010-2-23
(13:30 2010-2-24)
VC0882, arm cortex-a8, OMAP3530, coresight, 总结: VC0882 cortex-a8学习资料整理
1, 从10月开始看. 如果希望本周完成, 今天至少要看完10月的log. 
下面列出做了哪些事情:
2, 了解VC0882项目. MRD见1600 CVS.
3, qemu
4, sd代码整理, 这个没有做完. 有自己时间安排的原有, 也有VC0816量产的影响. 值得反思. 现在可能没机会做这个工作了. 
5, 研究调试: 看好openocd这个开源协议栈, 在OMAP3530上可以使用.
6, arm cortex-a8
1), 开始还看过一段arm11 debug部分, 确定用cortex-a8后没有继续看其他部分. 
1), "17:30 2009-10-28". 性能比较: \todo下载此文章给大家. FPGA也可以做类似测试. 
2), cortex-a8与arm11对比("17:30 2009-10-28", "14:14 2009-10-27"):
(1), the base restored Data Abort model.
(2), imprecise/precise data abort
3), 希望给一个cortex-a8 overview的介绍: 13级流水线, 两级cache等等. 打算用"Cortex-A8 Processor Product Brief.pdf"p2内容, 逐条向大家说明, 重点说明验证中会用到的, 和对软件的影响(thumb-2, cache: 软件读取cp15寄存器判断级数和类型(i/d分开, id统一), 然后配置), 对应用的影响(NEON, thumbEE).
参"12:55 2009-10-16", \todo 确定这个笔记已经上传, 更新. 
White Paper作为扩展知识就不详细说了. 
4), coresight调试架构单独介绍. 结合"DGI0012B_coresight_technology_r1p0_sdg"和VC0882调试结构("A8_and_CS")介绍. 
软件用途: trace(包括用ITM输出的软件trace), 便于debug. 
顺便说明VC0882 debug debug部分遇到的问题, 见"13:27 2010-2-24"

7, arm开发板调查. 
8, mas review. 对比了OMAP3530相关模块. 

9, (18:31 2010-2-26)
VC0882开发工具"11:19 2010-1-3": rvds4.0文档. 

9:22 2010-2-24
时间管理
0, 9:14

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882.
2), VC0882 sdio test plan review. 这个今天必须完成. 
3), 整理cortex-a8学习内容. 计划见"10:07 2010-2-23".
4), VC0882 FPGA ace文件下载权限. 找fanzhijun确认, 找aiguo发邮件. 

2, 执行
1), 9:44-11:40, 3)-23:36. VC0882最小环境, 移植nucleus到VC0882. 见"9:44 2010-2-24"
(11:40-12:43 午饭, 1h: 晚饭).
2), 12:30-13:45 VC0882, cortex-a8总结. 见"22:24 2010-2-23"
3), 40' 支持youhai EVB sdramSamsung切频. 见"14:21 2010-2-24"

3, 次日计划
1), 解决"14:21 2010-2-24"问题. 

4, 其他

9:29 2010-2-24
时间管理, 工作时间, 加班日, 休息日
加班日: 1,3-5,7-10,16-23. 其中7, 16-19是周末加班. 
休息日: 6,13,14

9:44 2010-2-24
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续
1, 昨天已经基本确认FPGA问题导致初始化无法通过. 今天希望能让nucleus跑起来. 
2, 死在"__cpu_mmu_create_large_page", 应该是memory方案问题. 
映像结束地址是0x20036320. 因为没有压缩. 所以运行时g_first_available_memory应该也是这里. 嗯, 实际不是. \todo 分析, 并看translation table在什么位置.
3, 现在可以先不开cache, mmu. 跳过这段代码. 用"MINI_NUCLEUS"表示注释的部分. 
1), build.pl会删除define, 暂时放在"include\VIM_DRIVER.h".
修改后停在"VIM_MMU_Init"中. arm无法停止:
> halt
Error: 0x02410100: The run control operation could not be completed : .

原来假设memory在0地址, 计算是直接用MEM_MAX_SIZE-size得到地址. 现在改为用MEM_TOP_ADDR-size得到. 
#define MEM_ADDR		(0x20000000)
#define MEM_TOP_ADDR	( MEM_ADDR + MEM_MAX_SIZE )
修改后错误依旧. 这次可能是uart没有初始化. 
2), 先用mini_aasp初始化uart. 还是不行. 发现fputc, fgetc所需的VIM_UART_SendOneChar, VIM_UART_ReceiveOneChar都没有实现. 
发现"st_uart_reg"数组数值不对. 

4, (16:18 2010-2-24)给kongyingqi发bin文件和生成命令: 
生成bin的命令:
fromelf –bin vc0882.axf --output vc0882.bin
Bin见附件. 同时上传到issue. 
生成反汇编和symbol命令:
fromelf –text –s –c vc0882.axf --output vc0882.s.dump 
反汇编代码在” vc0882.s.dump”Section #1, 符号表在Sectoin #12

fromelf详细用法见”DUI0382A_rvct_utilities_guide.pdf”

5, 续"3":
发现范了很弱的问题, panda_init.s里居然没有修改. 修改后, 停在"VIM_SYS_CreatTask"的DRV_ASSERT(stackpoint!=NULL);
(18:14 2010-2-24)晚饭后继续.

6, 错误如下:
[MMU   MSG]     start_memaddr=0x2003b30
[MMU   MSG]     SDRAM_NCNB_BSS_End_Ptr=0x2003620
[MMU   MSG]     SDRAM_BSS_End_Ptr=0x2003620
[MMU   MSG]     g_nocache_add
[MMU   MSG]     g_nocache_size=0x
[MMU   MSG]     g_cache_large_pool_addr=0x2003b31
[MMU   MSG]     g_cache_large_pool_size=0x8ccd
[MMU   MSG]     g_cache_small_pool_addr=0x200e800
[MMU   MSG]     g_cache_small_pool_size=0xfff
[MMU   ERROR]   NU_Create_Memory_Pool error 0xfffffff
[INT   ERROR]   Error for register lisr Reslut=-2
[MMU   ERROR]   caller  unde
[MMU   ERROR]   caller  unde
[MMU   ERROR]   VIM_MMU_Malloc status=-16,size=0x00000070,caller file = sys/VIM
SYS_Driver.c,len=20

[MMU   ERROR]   [MMU   LOG]     VIM_MMU_POOL_LARGE  MAX available =-2
[MMU   LOG]     VIM_MMU_POOL_SMALL  MAX available =-2
can get max buffer is 0xffffffe
[MMU   ERROR]   caller  unde
[MMU   ERROR]   caller  unde
[MMU   ERROR]   VIM_MMU_Malloc status=-16,size=0x00000030,caller file = sys/VIM
SYS_Driver.c,len=20

[MMU   ERROR]   [MMU   LOG]     VIM_MMU_POOL_LARGE  MAX available =-2
[MMU   LOG]     VIM_MMU_POOL_SMALL  MAX available =-2
can get max buffer is 0xffffffe
[MMU   ERROR]   caller  unde
[MMU   ERROR]   VIM_MMU_Malloc status=-16,size=0x00003010,caller file = sys/VIM
SYS_Driver.c,len=61

[MMU   ERROR]   [MMU   LOG]     VIM_MMU_POOL_LARGE  MAX available =-2
[MMU   LOG]     VIM_MMU_POOL_SMALL  MAX available =-2
can get max buffer is 0xffffffe

Assert error at sys/VIM_SYS_Driver.c, line=61
func = VIM_SYS_CreatTas

1), 看来要从源头解决:
[MMU   ERROR]   NU_Create_Memory_Pool error 0xfffffff
[INT   ERROR]   Error for register lisr Reslut=-2
单步跟踪发现是分配ncnb pool错误导致, large pool和small pool没有分配. 分配ncnb pool失败的原因是addr==NULL.
本来是在"VIM_MMU_Init"->"__cpu_mmu_init"赋值的, 但"__cpu_mmu_init"被我注释了.
\todo 希望把系统初始化与硬件抽象层的初始化分开. 
修改后aasp可以跑起来. 运行"start_thread"会data abort.

7, 上传代码
1), uart中使用了文件指针, 把fat加入min target. fat中有部分使用了sd, 用SD宏区分.
2), 编译通过后试验, 发现执行help正确, vimicro data abort
(1), 还没有进入"do_vimicro"就dataabort. 发现是在"fgetsT"的memcpy里面死的.
(2), 执行help都正常. version可能PASS可能FAIL.

S:2000D9DC E59D0008  LDR      r0,[sp,#8]
--- AASP\#1112         //don't copy '\n' and '\0' 
--- AASP\#1113         memcpy(backup,buf,sourcelength-1);
   S:2000D9E0 E2402001  SUB      r2,r0,#1
   S:2000D9E4 E1A01004  MOV      r1,r4
   S:2000D9E8 E1A00007  MOV      r0,r7
   S:2000D9EC EB00680E  BL       __rt_memcpy              <0x20027a2c>

  __rt_memcpy:
   S:20027A2C E3520003  CMP      r2,#3
   S:20027A30 9A000017  BLS      _memcpy_lastbytes        <0x20027a94>
   S:20027A34 E210C003  ANDS     r12,r0,#3
   S:20027A38 0A000008  BEQ      0x20027a60               <__rt_memcpy+0x34>
   S:20027A3C E4D13001  LDRB     r3,[r1],#1
   S:20027A40 E35C0002  CMP      r12,#2
   S:20027A44 E082200C  ADD      r2,r2,r12
   S:20027A48 94D1C001  LDRBLS   r12,[r1],#1
   S:20027A4C E4C03001  STRB     r3,[r0],#1
   S:20027A50 34D13001  LDRBCC   r3,[r1],#1
   S:20027A54 94C0C001  STRBLS   r12,[r0],#1
   S:20027A58 E2422004  SUB      r2,r2,#4
   S:20027A5C 34C03001  STRBCC   r3,[r0],#1
   S:20027A60 E2113003  ANDS     r3,r1,#3
   S:20027A64 0A00003B  BEQ      __rt_memcpy_w            <0x20027b58>
   S:20027A68 E2522008  SUBS     r2,r2,#8
   S:20027A6C 3A000004  BCC      0x20027a84               <__rt_memcpy+0x58>
   S:20027A70 E4913004  LDR      r3,[r1],#4
   S:20027A74 E491C004  LDR      r12,[r1],#4
   S:20027A78 E4803004  STR      r3,[r0],#4
   S:20027A7C E480C004  STR      r12,[r0],#4
   S:20027A80 EAFFFFF8  B        0x20027a68               <__rt_memcpy+0x3C>
   S:20027A84 E2922004  ADDS     r2,r2,#4
   S:20027A88 54913004  LDRPL    r3,[r1],#4
   S:20027A8C 54803004  STRPL    r3,[r0],#4
   S:20027A90 E1A00000  MOV      r0,r0

A, 在"   S:20027A88 54913004  LDRPL    r3,[r1],#4"会死. 
r1: 0x20031777, 没有word对齐, 改为0x20031778后通过.
S:0x20031770	0x00000000	0x696D6976	....vimi
S:0x20031778	0x006F7263	0x00000000	cro.....
但是cortex-a8应该支持不对齐的情况的, \todo 明天在OMAP3530上面实验.

编译器中可以通过"--[no_]unaligned_access"选择是否运行非对齐访问, 加入后没有作用.
再说cortex-a8是支持非对齐访问的, 这样修改也不合理.

8, 暂时不上传代码了, 发信:
发信: 'Ai Guo'; liao zhicheng; Li Dong Liang
标题: VC0882 nucleus aasp可以运行, 但是有时不对齐访问是会dataabort

今天nucleus aasp可以启动, 输入help命令正常, 命令补齐功能正常.
输入vimicro, version等命令时, 如果memcpy源地址不是word对齐, 有时会报dataabort. 但是cortex-a8是支持非对齐访问的.
进一步调试发现对于同样源地址, 用help命令就没事, 用vimicro就dataabort. 感觉要么是cortex-a8问题, 要么是bus或sram问题. 后者可能性大.
前两天CuiYunFei他们调试memory也发现了不对齐时会出错, 当时没细想.

另外在这个FPGA板上运行mini_aasp同样命令顺序未发现问题. 可能不同环境对稳定性也有影响.

明天用rev0_01020909_02020416(最开始跑mini_aasp的版本)实验和在OMAP3530实验.

FPGA版本: rev0_01022018_02020412. FPGA3号板.

9, \todo 
1), 确认MEM_MAX_SIZE修改完成. 
2), 加入uart, 测试timer和irq. 加入timer, irq.

13:27 2010-2-24
VC0882, 最小环境, FPGA, debug, coresight
1, huangwei总结VC0882 debug问题
Huangwei邮件"Re: Vc0882 FPGA platform is ready now"20100202_1805
[YANG ZUOXING] HUANGWEI, 请总结一下
[huangwei]
1). nSRST from ICE should be connected. Realview debugger will use this signal to reset Vc0882.
2). A8 can't run stablely at 48Mhz.
3). alternative APB-AP and AHB-AP access to debug apb will result in AHB-AP access failure. The reason is not identified yet.

2, "1-1)"这个问题与原来arm11 arm答复不同, 见"15:26 2009-11-6", \todo 查文档. 看到底怎么说的. 原来arm11用的也是ICE. 

14:21 2010-2-24
VC0830, SV, EVB, clkrst, clkswitch, sdramSamsung
今天帮youhai实验EVB板子跑三星sdram, 用CVS上面编译的代码有问题, 后来用"D:\work\VC0830\code\elf_bin\20090723_830切频代码比较\1513_timer_sv_new_LQFP176_sdramSamsung.pak"可以. 后者没有走sram切频流程. 
后来实验最新code, 注释sram切频流程后, 切频本身是对的. 但是切频时计算uart频率不正确, 今天要移植nucleus到VC0882. 明天解决这个问题.

20:04 2010-2-24
VC0882, 大项目组sync up, meeting minutes
1, YangZuoXing邮件"转发: 882 sync up meeting"20100224_1957
Meeting Minutes：
1. AIC：
a) 7882和882模拟部分的Layout资源，请根据以下状况确定需要招聘名额；(ZhengZhong)
i. 7882的7个DCDC，22个LDO，以及8个类LDO规模的电路；
ii. 7882中I2C接口(不包含I2C内部Layout)，顶层集成；
iii. 882的SAR_ADC和MIPI_CSI；
iv. 9611/9612/9613；(非882/7882项目)
b) MIPI_CSI前后仿结果不一致依然存在；(GaoJun)
2. SV：
a) FPGA板的全部元器件配齐，预计下周一可以提供6套，其余14套随后逐步提供。(XiaoDuan)
3. Foundry：
a) 高速Memory的Data已经拿到；(Kerry)
b) IP/Lib 价格List正在准备中。(Kerry)
c) Corner Split确认不需要在MPW阶段做。
4. Flow：
a) YingChun下周一到公司为882做咨询，需要提前准备好当前无法解决的问题。(Huamin)
b) 需要Huamin考虑是否可以或者需要从598Team借人。(Huamin)
c) 咨询是否可以请Brite的人员提前安排一个人到Vimicro帮忙做Check。(Zuoxing)
5. ICV：
a) LPDDR/Uart/SDIO基本没问题；
b) DE(YinQingli)/Uotg(GaoYong)/EMI(TuNingjie)有风险；其余在测，遇到FABRIC dead-lock； 
i. DE Memory(DMA)取数有些问题； DPI/DBI的基本case已跑通，预计下周四LCD和TV能过；目前有4-5个Bug，影响后续工作，需要ICD(LiNan)尽快处理；
ii. EMI Master已经改过3次，目前处于状态机的初始状态后的0ns。
iii. Uotg：目前在跑Otg的Device功能，目前connection还没有连上。预计本周末跑出Uotg的第一个Case。
c) 请ICD Fix Bug时给出方法解释；
d) ICV将自己的环境给ICD，ICD Release之前需要先在ICV的环境上跑通。
e) ICV会从明天开始每天更新10个Module的状态。
6. ICP：
a) 目前FPGA上没有一个稳定的DDR；ICD正在IO上加约束，以定位不稳定的原因，并尽量消除不稳定。
b) 先保证A8和3D的部分调好给AE。
7. ICD：
a) FPGA Delay, IP Delay, Flow来不及等造成MPW无法在Mar24 Tapeout。
b) L2 Normal Memory，L2:A8=1:3
c) TPI/Audio/Marb的Code没完成。Code Review有些Delay。
d) 7个MAS没有完成。
e) 本周末给Brite一个初始的netlist. (Zuoxing). 预计Mar7向Brite Release一个Full Chip的Netlist。(Huamin)

2, 我们组(beizhan组)status track见"D:\work\VC0882\Documentation\vc0882_status_track_20100224.xls". 
如果我去年年底能再提高效率的话, Linux porting可能还能是我们这边做. 

10:58 2010-2-25
VC0882, 最小环境, FPGA, 稳定性测试
1, Aiguo邮件"答复: VC0882 nucleus aasp可以运行, 但是有时不对齐访问是会dataabort"20100225_1008
目前看来，882的FPGA稳定性是一个很大的问题，这里面包括A8和ddr都是全新的，而且都有很大的难度，因此我们有必要构建一些case来测试arm和ddr，这个作为第一步上FPGA的前提，大家都先思考一下这个问题，我们下午找个时间一起讨论一下。
2, zhangjian(回复aiguo邮件): 
1), arm测试可以注重armv7新feature和相对arm9的变化测试:
(1), 功能测试: 常规指令(add, ldr...), L1, L2, mmu打开关闭下memory读写测试:
现在已经有了基于semihost的开cache(无L2), mmu的dhrystone测试程序. 可以去掉semihost.
位置: "D:\VC0882\mini_env\CortexA8dhry". 
(1), cortex-a8变化: 非对齐访问, cache管理方式(read cp15得到cache信息, CortexA8dhry就是这样实现的), 大端含义变化(BE32->BE).  abort模式(base restone model, imprecise data abort). monitor mode(用于security, 这个用不到, 是否需要测试?)
(2), 新feature: thumbEE, thumb2, NEON. 暂时没有测试代码. 
2), coresight: 
debug通路测试: 通过rvdebugger脚本连接, 断开, 连接.., 访问arm寄存器, memory等等. 
debugger访问arm寄存器, memory必须测试, 与软件(通过arm)访问通路不同. 
3), VC0882自身特点测试: 访问apb不能挂死. 
4), 鉴于arm不稳定, VC0882 panda_os 环境想支持多个SOC: VC0882, OMAP3530.

11:20 2010-2-25
VC0882, FPGA, 最小环境, 稳定性
1, ZouWeiRan邮件"答复: FPGA稳定性差"20100225_1115
目前状态：
1). 不改动电路，连接串口线，上电开机可以正常连接，但无法读写寄存器
2)．不改动电路，不连接串口线，上电开机可以正常连接，可以读写寄存器
3)．PC端串接10K电阻，连接串口线，上电开机可以正常连接，但无法读写寄存器
2, zhangjian, 注: 
不能读写寄存器指的应该是ddrc寄存器, 脚本是dashan给的. 
串接10K电阻是串口PC的sdo(tx). 怀疑PC有电源传过去. 

17:46 2010-2-25
VC0882, 最小环境, FPGA, 重新整理FPGA问题
1, 重新整理FPGA问题, 给大家发邮件
hi, aiguo
现有FPGA问题如下, 有些是2月8日前就发现的问题, 到现在也没有解决. 
1, 用LDR指令在非word对齐地址读word可能dataabort.
如果手工恢复abort 模式到SVC模式重复实验非对齐ldr很容易导致rvdebugger正常写入memory fail, 甚至出错退出.
由于这个错误, 基于nucleus的测试环境没法继续移植. 
但是从cortex-a8文档看, 是支持非对齐访问的. 
ARM_ARM_7AR, p109, p119: 
An ARMv7 implementation must support unaligned data accesses.
通过配置cp15 c1 SCTLR.A可以控制unalign的行为, SCTLR.A=0时允许unalign access, =1时不允许(Alignment fault). 其他load/stone指令非对齐访问暂时没有试验. 
2, 0008177: cortex-a8在一条正确语句停住无法继续运行. 最容易停在进入c语言前的一条加法指令. 在"rev0_01020909_02020416"版本出错, rev0_01022018_02020412正确. 
3, 0008113: rvdebugger写入memory(sram)失败. 插上memory子板和umonitor子板后访问sram容易出错. 
4, 0008114: rvdebugger有时连不上Cortex-a8. 无论是否插串口线都有这个问题. 调高电压后出错次数略有减少. 
现象也有变化: 原来是softreset后比断电重新上电容易连接, 调高电压后断电重新上电比softreset容易连接. 
5, 0008148: 使用Rvdebugger单步调试中DSCR无法访问: 这个问题只出现过一次, 当时单步次数比较多. 
6, coresight bug(0008115): csat访问dap fail. 这个是必现错误, 一直都没有解决. 

2, ARM_ARM_7AR p2018, 总体看armv4,armv5 非对齐word访问会忽略[1:0]
Non halfword-aligned LDRH, LDRSH, and STRH are UNPREDICTABLE.
  Non word-aligned LDR, LDRT, and the load access of a SWP rotate right the word-aligned data transferred
by a non word-aligned address one, two, or three bytes depending on the value of address[1:0].
  Non word-aligned STR, STRT, and the store access of a SWP ignore address[1:0].
  From ARMv5TE, it is IMPLEMENTATION DEFINED whether LDRD and STRD must be
doubleword-aligned or word-aligned. LDRD and STRD instructions that do not meet the alignment
requirement are UNPREDICTABLE.
  Non word-aligned LDM, LDC, LDC2, and POP ignore address[1:0].
  Non word-aligned STM, STC, STC2, and PUSH ignore address[1:0].
For Thumb

3, LiDongLiang, ZhouDaShan测试arm7, arm9访问不对齐地址, 写入会自动向下对齐, 读出为0. 与"2"描述基本一致. 
LiDongLiang邮件"arm 操作的内存不是word对齐情况"20100225_1833
测试了arm7 和 arm9上面，word访问不是4byte对齐的内存地址
结果如下
 
1. s3c44b0x, arm720t
         1). write: 不对齐，强制向下做4byte对齐，写入结果按对齐地址，正确
         2). read: 不对齐，读到的值为0
         
         注：
                   1). 第一次write不对齐时，报data abort
                   2). 利用axd 工具中脚本命令, 数据正常写入
                            smem 0x0c056781 0x12345678 32
 
         {
                   char *ptr;
                   int a, i;
                   
                   ptr = (char *)HALMalloc(100);
 
                   *((int *)(ptr + 1)) = 0x12345678;
                   a = *((int *)(ptr + 1));
                   
                   for(i=0; i<4; i++)
                   {
                            a = 0;
                            *((int *)(ptr + i)) = 0x12345678;
                            a = *((int *)(ptr + i));                      
                   }
                   
                            
         }
 
         // 反汇编如下
        0x00000034:    e3a00064    d...    MOV      r0,#0x64
        0x00000038:    ebfffffe    ....    BL       malloc
        0x0000003c:    e1a05000    .P..    MOV      r5,r0
        0x00000040:    e59f0068    h...    LDR      r0,0xb0
        0x00000044:    e3a01001    ....    MOV      r1,#1
        0x00000048:    e7810005    ....    STR      r0,[r1,r5]
        0x0000004c:    e3a00001    ....    MOV      r0,#1
        0x00000050:    e7907005    .p..    LDR      r7,[r0,r5]
        0x00000054:    e3a04000    .@..    MOV      r4,#0
        0x00000058:    e3540004    ..T.    CMP      r4,#4
        0x0000005c:    aa000007    ....    BGE      {pc} + 0x24  ; 0x80
        0x00000060:    ea000001    ....    B        {pc} + 0xc  ; 0x6c
        0x00000064:    e2844001    .@..    ADD      r4,r4,#1
        0x00000068:    eafffffa    ....    B        {pc} - 0x10  ; 0x58
        0x0000006c:    e3a07000    .p..    MOV      r7,#0
        0x00000070:    e59f0038    8...    LDR      r0,0xb0
        0x00000074:    e7850004    ....    STR      r0,[r5,r4]
        0x00000078:    e7957004    .p..    LDR      r7,[r5,r4]
 
 
2. 598, arm926ejs
 
         1). write: 不对齐，强制向下做4byte对齐，写入结果按对齐地址，正确
         2). read: 不对齐，读到的值不是0, 但不正确
         
         注:
                   1). 利用rvdebug30直接操作sram, 正确设置内存
                             setmem /W 0x20000013=0x12345678
 
         {
                   char *ptr;
                   int a, i;
                   
                   ptr = (char *)0x20000000;
 
                   *((int *)(ptr + 1)) = 0x12345678;
                   a = *((int *)(ptr + 1));
                   
                   for(i=0; i<4; i++)
                   {
                            a = 0;
                            *((int *)(ptr + i)) = 0x12345678;
                            a = *((int *)(ptr + i));                      
                   }                           
         }        
 
// 反汇编代码如下
 
>> APPSTART\#57         {
>>> APPSTART\#58                 char *ptr;
>>> APPSTART\#59                 int a, i;
>>> APPSTART\#60                 
>>> APPSTART\#61                 ptr = (char *)0x20000000;
   00017338 E3A00202  MOV      r0,#0x20000000
>>> APPSTART\#62 
>>> APPSTART\#63                 *((int *)(ptr + 1)) = 0x12345678;
   0001733C E59F30A4  LDR      r3,0x173e8                 
   00017340 E280C001  ADD      r12,r0,#1
   00017344 E58C3000  STR      r3,[r12,#0]
>>> APPSTART\#64                 a = *((int *)(ptr + 1));
   00017348 E2803001  ADD      r3,r0,#1
   0001734C E5931000  LDR      r1,[r3,#0]
>>> APPSTART\#65                 
>>> APPSTART\#66                 for(i=0; i<4; i++)
   00017350 E3A02000  MOV      r2,#0
>>> APPSTART\#66                 for(i=0; i<4; i++)
   00017354 EA000004  B        0x1736c                    <APPSTART\#66>
>>> APPSTART\#67                 {
>>> APPSTART\#68                         a = 0;
   00017358 E3A01000  MOV      r1,#0
>>> APPSTART\#69                         *((int *)(ptr + i)) = 0x12345678;
   0001735C E59F3084  LDR      r3,0x173e8                 
   00017360 E7803002  STR      r3,[r0,r2]
>>> APPSTART\#70                         a = *((int *)(ptr + i));                        
   00017364 E7901002  LDR      r1,[r0,r2]
>>> APPSTART\#66                 for(i=0; i<4; i++)
   00017368 E2822001  ADD      r2,r2,#1
>>> APPSTART\#66                 for(i=0; i<4; i++)
   0001736C E3520004  CMP      r2,#4
   00017370 BAFFFFF8  BLT      0x17358                    <APPSTART\#68>
>>> APPSTART\#71                 }                       
>>> APPSTART\#72         }    

19:39 2010-2-25
VC0882, 最小环境, FPGA, 移植nucleus到VC0882
1, 计划: 上传现有代码, 更新aasp代码到VC0882, 在mini_c_env_no_lib下测试time
, irq

2, 上传现有代码
使用rvds4.0编译通过. 定义MINI_NUCLEUS时可以运行到aasp. 但是非对齐ldr时可能有dataabort(感觉是IC问题).
1), 加入MINI_NUCLEUS(VIM_DRIVER.h)表示实验性nucleus小环境. 使用1M sram(start: 0x20000000). 
2), 加入"ld_scirpt\ads_sram_1M.lds"用于VC0882 1M sram下的memory方案.
需要手工选择config.ads.mk的"#SCATTER = $(LDSDRIPT_PATH)/ads_sram_1M.lds".
3), 其他在min target下无法编译通过的问题. 

3, 测试CVS代码能否运行, 在看汇编时发现LDRPL不一定执行.
1), 代码
__rt_memcpy:
S:20027A70 E3520003  CMP      r2,#3
S:20027A74 9A000017  BLS      _memcpy_lastbytes        <0x20027ad8>
S:20027A78 E210C003  ANDS     r12,r0,#3
S:20027A7C 0A000008  BEQ      0x20027aa4               <__rt_memcpy+0x34>
S:20027A80 E4D13001  LDRB     r3,[r1],#1
S:20027A84 E35C0002  CMP      r12,#2
S:20027A88 E082200C  ADD      r2,r2,r12
S:20027A8C 94D1C001  LDRBLS   r12,[r1],#1
S:20027A90 E4C03001  STRB     r3,[r0],#1
S:20027A94 34D13001  LDRBCC   r3,[r1],#1
S:20027A98 94C0C001  STRBLS   r12,[r0],#1
S:20027A9C E2422004  SUB      r2,r2,#4
S:20027AA0 34C03001  STRBCC   r3,[r0],#1
S:20027AA4 E2113003  ANDS     r3,r1,#3
S:20027AA8 0A00003B  BEQ      __rt_memcpy_w            <0x20027b9c>
S:20027AAC E2522008  SUBS     r2,r2,#8
S:20027AB0 3A000004  BCC      0x20027ac8               <__rt_memcpy+0x58>
S:20027AB4 E4913004  LDR      r3,[r1],#4
S:20027AB8 E491C004  LDR      r12,[r1],#4
S:20027ABC E4803004  STR      r3,[r0],#4
S:20027AC0 E480C004  STR      r12,[r0],#4
S:20027AC4 EAFFFFF8  B        0x20027aac               <__rt_memcpy+0x3C>
S:20027AC8 E2922004  ADDS     r2,r2,#4
S:20027ACC 54913004  LDRPL    r3,[r1],#4
S:20027AD0 54803004  STRPL    r3,[r0],#4
S:20027AD4 E1A00000  MOV      r0,r0
_memcpy_lastbytes:
S:20027AD8 E1B02F82  LSLS     r2,r2,#31
S:20027ADC 24D13001  LDRBCS   r3,[r1],#1
S:20027AE0 24D1C001  LDRBCS   r12,[r1],#1
S:20027AE4 44D12001  LDRBMI   r2,[r1],#1
S:20027AE8 24C03001  STRBCS   r3,[r0],#1
S:20027AEC 24C0C001  STRBCS   r12,[r0],#1
S:20027AF0 44C02001  STRBMI   r2,[r0],#1
S:20027AF4 E12FFF1E  BX       lr
2), 
CC: Carry clear Less than: C == 0
PL: Plus, positive or zero: N == 0
3), 输入help时不会执行
S:20027ACC 54913004  LDRPL    r3,[r1],#4
S:20027AD0 54803004  STRPL    r3,[r0],#4
所以没有问题. 输入vimicro时会执行.

4, 更新已整理的aasp代码(D:\VC0882\mini_env\mini_c_env_base\aasp)到VC0882
1), 更新aasp代码和CVS后, 编译提示:
make: *** No rule to make target `build/dmac/VIM_DMAC_Driver.o', needed by `all'.  Stop.
奇怪的是我没有编译dmac模块. 
从"build\mods.mk"查看编译到哪个*.mk出的错, 发现是sys编译完成, 应该是正在编译timer. timer模块怎么会有dmac VIM_DMAC_Driver.c文件呢? 查看timer\subdir.mk, 发现"C_OBJS"是DMAC. 可能是yuyang复制timer目录是同时复制了CVS信息. 

2), 可以运行. 

5, 发信:
VC0882最小环境今日进展
1), 使用之前在mini_c_env_base整理的aasp, 编译运行通过. 代码明天上传. 
2), unalign dataabort bug: 经过分析和实验, 只要使用arm libc memcpy很容易出现不对齐情况, 计算明天把aasp中memcpy用自己的memcpy代替. 
3), 明天计划测试irq和timer. 

6, (15:56 2010-2-26)上传CVS, 与dongliang讨论
1), dataabort只能用自己的memcpy绕过
2), 变化:
USE_ADS_MODE暂时保留, 与dongliang讨论为什么去掉. 
gets()(in_custom.c)起什么作用? 没找到谁调用. 

7, 上传AASP:
1), 避免semihost:
panda_init.s: 加入"IMPORT __use_no_semihosting".
2), 使用"mini_env\mini_c_env_base"整理好的aasp代码. 
(1), 库桩脚函数: 
残酷"mini_env\mini_c_env_base\source\retarget.c"修改"panda_os\AppsEntry\init_src\io_custom.c", 并删除其中已注释的无用代码. 
(2), 复制aasp_xxx.c共6个文件, 除了头文件等细节外, 与mini_c_env_base aasp相同. 
(3), 保留USE_ADS_MODE宏, 如果将来使用gcc会比较方便. 
(4), 加入aasp\bootscript.c: 启动脚本. 
3), 其他:
(1), "panda_os\AppsEntry\init_src\io_custom.c":
删除gets函数. 这个函数原来可能是用于aasp. 早就不用了, 删除. 
(2), Makefile, cleantemp规则
$(RM) $(BUILD)/$(NAME).elf
改为
$(RM) $(BUILD)/$(NAME).$(ELFTYPE)

10:53 2010-2-26
时间管理
0, 9:50-22:20

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882.
2), VC0882 sdio test plan review. 这个今天必须完成. 
3), VC0882 Cortex-a8 unalign data access实验. SCTLT.A=0,1. <DONE: 在OMAP3530上面实验, 不对齐时无论A=0, 1都是data abort>
4), VC0882 FPGA ace文件下载权限. 找fanzhijun确认, 找aiguo发邮件. 

2, 执行
1), 9:50-10:50 VC0882 DMAC讨论. 记录见研究记录簿-2,p12.
2), 18:16- VC0882最小环境, 加入memcpy避免unalign data abort. 见"18:16 2010-2-26"

3, 次日计划
1), VC0882最小环境: (1), 上传今日代码. (2), 测试timer0, irq是否正常. 

4, 其他
0), 希望每天工作时间一小时, 做有利于长远工作的事情. 每天上下班时间和午休时间做公司工作以外长远事情.
1), 重要紧急:
(1), 每天用1小时修改perl脚本: 改进logAssistant, 支持查找section keywords. 并输出. 
2), 重要不紧急:
(1), 一但sd仿真通过, 就要开始调试sd卡. 
(2), 整理cortex-a8学习内容. 计划2月26日内完成. 
(3), 移植nucleus完成后, 总结VC0882最小环境: rvds4.0初始化, aasp, nucleus等. 计划3月5日前完成. 
(4), 入职中星微以来总结: 具体项目, 软件技巧. 提高工作效率(时间管理, 工具软件ediltplus, logAssistant).
3), 紧急不重要
4), 不重要不紧急
(1), test plan review.
(2), VC0882加入irq test.
(3), 把cache ID reg那个bug报上Issue. 
(4), 把最近两周的时间管理和重要邮件看一下. 
(5), 解决"14:21 2010-2-24"问题. 

15:20 2010-2-26
VC0882, arm cortex-a8学习, coprocessor, cp15, 与arm926ej-s差异. 
1, Cp15 c1: System Control Register (SCTLR)(cortex-a8称为Control Register). rvds4.0 register->control->control. 
2, A=0, 1时, OMAP3530访问不对齐地址都有data abort. 看来这个还要认真分析, 原来aasp为什么不会不对齐呢? 暂时不查. 先自己实现一个memcpy用着. 
3, V: V=0: 由寄存器配置; =1: 映射到高地址. 
Determines the location of exception vectors, see c12, Secure or Nonsecure Vector Base Address Register on page 3-152. The primary input VINITHI defines the reset value of the V bit:
0 = Normal exception vectors selected, reset value. The Vector Base Address Registers determine the address range.
1 = High exception vectors selected, address range = 0xFFFF0000-0xFFFF001C.

1), Vector Base Address Register
The Secure or Nonsecure Vector Base Address Register is:
  a read/write register banked in Secure and Nonsecure states
  accessible in privileged modes only.
(1), bit[4:0]无效. 
(2), privileged mode: 是除了user mode以外的其余7个mode(含monitor)mode. 

4, v7真的是有很大的变化. 
1), cp15的寄存器实际数量都多了几倍, 从16个变为83个. 寄存器名字还是c0-c15. 新增功能用op2和CRm区分. 
2), 看cortex-a8时有些不明白的地方, 其实是对老arm了解太浅. 看来还需要对照老arm看. 
3), 灵活性增强: 例如异常向量可以放在0x20(32byte)对齐的任意地址. cache最高支持7级, 通过读cp15得到各级cache属性. 

17:54 2010-2-26
VC0882, 最小环境, FPGA, 开发工具, 
1, 回复Aiguo邮件"答复: A8 tools"20100226_1750
rvds4.0及其中英文最新文档已上传到"\\10.0.2.208\share\zhangjian\rvds4.0".
安装前请先阅读破解说明(crack\readme.txt).

18:16 2010-2-26
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续, 加入memcpy避免unalign data abort, 测试tick; "7": VC0882 FPGA稳定性测试文档1
1, 计划.
1), 加入memcpy避免unalign data abort. 完成后, 只要aasp运行正常就打tag. 
2), 测试tick

2, "1-1)"
1), memcpy原型是
原型: void *memcpy(void *restrict, const void *restrict, size_t)
需要把原有的
void memcpy(void *d, void *s, int len)
改为
void *memcpy(void *d, const void *s, size_t len)
2), 运行乱码
(1), 昨天遇到一次乱码是fputc传地址, VIM_UART_SendOneChar按数据处理:
VIM_UART_SendOneChar(UART_ASAP_CUR_NUM, &tempch);
改为
VIM_UART_SendOneChar(UART_ASAP_CUR_NUM, tempch);
即可.
今天一看还是这个问题. 另外BootScript(aasp\bootscript.c)也没有修改. 昨天果然太累了, merge有问题!!!!
(2), 发现没法重载, 直接加入VIM_LIB_Memcpy. 把VIM_SYS_Driver的VIM_HAL_MEMCPY改为此函数. 简单实验aasp运行正常, 原来会出错的vimicro, version都正常.
(3), timer没有运行(中断号是否不正确, timer0配置是否正确(timer0 read_time数据无变化)).

3, 上传代码:
1), 暂时绕开unalign问题
加入加入VIM_LIB_Memcpy, 定义"LIB_USING_USER_DEFINED_MEMCPY"(AppsEntry\subdir.mk)表示VIM_SYS_Driver.h VIM_HAL_MEMCPY使用VIM_LIB_Memcpy. 问题解决后应当注释这个宏. 
2), 修正fputc bug: 应该传给VIM_UART_SendOneChar数据而不是地址.
3), 删除BootScript(aasp\bootsrcipt.c)中多于命令.

4, 下一步加入uart初始化. 测试timer0.
1), 修改uart相关代码: 
(1), 建立"VIM_UART_HwInit()"负责uart硬件初始化(pdac+uart config).在"InitVC0882()"开始先调用这个函数, 保证VIM_MMU_Init, VIM_INT_Init等在VIM_UART_Init之前的函数可以串口打印. Linux中的做法是把console初始化前print的信息存入buffer, 串口初始化后一次输出这些信息.
(2), VIM_PADC_UartInit(void)为"VIM_PADC_UartInit(UINT32 uart);". 我只写了uart0初始化. 
(3), 为padc增加error(800开始). 

2), 未进入main函数
(1), load映像, 设置断电未报错, 运行时未进入main函数, 这时arm无法停止, 提示:
> halt
Error: 0x02410100: The run control operation could not be completed : .
(2), load后单步运行, 按第一次step后:
> stepo
Error: 0x02410100: The run control operation could not be completed : .
Warning: 0x021d0102: Error Failed to read value from register = 'R15' from target : Cortex-A8_0.^A
现可能和pc设置到0x20000000有关?

5, 系统测试, 不到50%正常. 发信

程序跑飞, arm无法停止, 58%概率fail. 

现在疑似FPGA问题7个, 本周5天就发现3个. 到目前为止一个也没解决. 

今天发现一个新问题: 
rvds4.0连接正常, load映像, 设置断点未报错, 但程序未正常运行, 且此时arm无法停止(没法判断死在什么地方).

硬件环境: FPGA3, 程序成功运行前不连接串口子板, FPGA版本"rev0_01022018_02020412". 
软件环境: 测试代码有nucleus(OS)的aasp(console). 但nucleus的线程调度未打开. 在main函数及其后两函数设置了三个断点. 

测试12次, 每次错误如下(测试次数: 现象):
1,2,3,11: fail
4,8: 连接错误.
5,6,7,10,12: pass

1), fail指load映像, 设置断电未报错, 运行时未进入main函数, 这时arm无法停止, 提示:
> halt
Error: 0x02410100: The run control operation could not be completed : .
前天报的issue track 0008177也是无法进入main函数. 但是arm可以停住.

2), 连接错误 issue track 8114, 错误提示同1).

3), pass指aasp(console)正确运行, 且简单5条命令测试通过(help;vimicro;version;timer;exit). 

附件是程序映像和rvdebugger脚本(保存为*.inc, 在rvdebugger命令行中运行).

6, 给aiguo发信
1), 今日进展;
(1), 用自己的VIM_LIB_Memcpy作为VIM_HAL_MEMCPY可以绕过unalign data abort. aasp简单命令测试通过. 
(2), nucleus无tick. 
2), 明日计划:
(1), 上传今日代码. 
(2), 测试timer0, irq是否正常. 

7, (12:11 2010-2-27)上传IssueTrack0008252(说明见"5"), 添加操作步骤文档.
问题已上报issuetrack(0008252, http://10.0.2.208/mantis/view.php?id=8252), 操作步骤已添加到注释, bug可以用自动脚本复现. 测试室7 PC19的环境已经配好.

操作步骤:
1), 下载issue track 8252两个附件到"D:\vc0882\issue_track\0008252", VC0882.axf是程序映像, init_sram.inc是rvdebugger脚本, 可能需要根据具体环境修改:
(1), init_sram.inc的第一行, 把第二个@后面的字符串改为configuration name(例如VC0882, 测试室7的PC19, PC8不需要修改):
connect "@Cortex-A8_0@VC0882"
(2), 如果放到"D:\vc0882\issue_track\0008252"以外目录, 需要修改init_sram.inc的第二行的目录:
load/pd/r 'D:\vc0882\issue_track\0008252\VC0882.axf'
2), FPGA上电config成功后运行脚本init_sram.inc脚本:
include D:\vc0882\issue_track\0008252\init_sram.inc
可以把该脚本添加到rvdebugger script toolbar, 以后单击run script即可.
运行脚本后, 会首先连接cortex-a8, 然后下载代码, 最后设置断点并运行. 硬件正常时应该会在三个断点依次停下并自动继续运行(停止时rvdebugger显示stop), 如果没有此过程会所面硬件有问题, 此时arm无法停止. 
正常运行时rvdebugger console会打出四个go. 可以在步骤(3)中运行aasp(console)进一步验证软件是否正常. 
3), 软件测试: 脚本运行后如果没有报错, 插上串口子板和串口线. 打开串口终端(115200 8n1), 输入回车+"he;vi;ve;ti;ex"回车, 在"[VERSION_MODULE]ASK:Display Vimicro?(yes/no)?"后面输入"yes"或"no". 如果程序运行log如下, 说明软件简单测试通过. 

AASP :/>he;vi;ve;ti;ex
Test cache function and effect!
   cache
Test dcache function and effect!
   dcache
Test icache function and effect!
   icache
fat cd
   cd
fat ls
   ls
fat
   fat
Test halory read and write
   hal
Help about help?
   help
Test interrupt function and effect!
   interrupt
halory read
   memread
halory write
   memwrite
Test nucleus
   nucleus
Test timer function and effect!
   timer
Test uart function and
   uart
Display AASP version information
   version
Display a string : Vimicro
   vimicro
[VERSION_MODULE]->do_vimicro()
[VERSION_MODULE]WARNING:Welcome to Vimicro 21:12:12!
[VERSION_MODULE]ASK:Display Vimicro?(yes/no)?yes
[VERSION_MODULE]MESSAGE:Got a positive confirm!
[VERSION_MODULE]todo:Need a new pattern!
[VERSION_MODULE]Equal 0:fail
[VERSION_MODULE]Equal 2:fail
[VERSION_MODULE]Not Equal 10:pass
[VERSION_MODULE]i==1:fail
[VERSION_MODULE]i<1:pass
[VERSION_MODULE]i>1:fail
[VERSION_MODULE]skip:Nothing to do!
[VERSION_MODULE]Good Bye!():pass!
[VERSION_MODULE]<-do_vimicro() with -1
[VERSION_MODULE]MESSAGE:Vimicro AASP V0.1 - built 21:12:12, Feb 26 2010

[TIMER]<-do_timer_exit() with 1
[TIMER]<-do_timer() with 1
AASP :/>

8, 上传代码, 给dongliang, fanxiaofan发信.
aasp简单测试("he;vi;ve;ti;ex")通过. nucleus无调度.
1), 我为padc单独增加了error: VIM_PADC_ERROR. 是这样用么? 还是放在SYS_xxx里面?
2), uart padc我增加了channel. 看所有硬件都的padc init都没有index. 感觉uart padc init初始化全部四个串口没必要. 

hi, xiaofan
uart代码有点修改, 麻烦你看看有没有不合适的地方. 

9, 可以建议一下按照doxygen格式写注释.

14:11 2010-2-27
时间管理
0, 11:50

1, 计划
1), VC0882最小环境, 移植nucleus到VC0882: 测试timer0 irq
2), VC0882 sdio test plan review. 这个今天必须完成. <DONE>
3), VC0882 FPGA ace文件下载权限. 找fanzhijun确认, 找aiguo发邮件. 

2, 执行
1), VC0882最小环境:
(1), 上传昨日代码: 已加入uart初始化. 
(2), 提交昨日FPGA bug(软件跑飞, arm无法停止)到issue track(8252), 并说明操作步骤. 映像和rvdebugger也已同时上传. 
2), VC0882 testplan review. 

3, 次日计划

4, 其他

16:22 2010-2-27
VC0882, 最小环境, FPGA, OS, 移植nucleus到VC0882, 续, 支持tick
1, 支持tick
1), 链接脚本指定memory地址和容量.
2), 修改异常向量基址改到sram地址. 
3), 在mini_c_env_nolib下面测试timer0 irq. 
2, 链接脚本制定memory地址和容量. 
1), rvds4.0的链接脚本也支持预处理, 这样可以生成更灵活的链接脚本. 参考kernel中的用法. 
2), unalign问题可能是链接器没有考虑4字节对齐. \todo 链接器4字节对齐实验. 
3), 开始定义成了整型, 应该定义为指针:
extern UINT32 *Image$$MEM_SIZE$$Base;
#define MEM_MAX_SIZE    (*Image$$MEM_SIZE$$Base)
这样也不对, 周一接着查.

13:58 2010-4-14
VC0882, cache
FPGA15
\\10.0.26.99\share\zhangjian\projects\VC0882\code\201002\20100223_Cortex-a8_dhry+nucleus移植
\\10.0.26.99\share\zhangjian\projects\VC0882\FPGA_CF\FPGA_1M_Sram+DDr\rev0_01030214_02030214.ace.rar 用CortexA8dhry pass, 此时mmu, L1 开. 
