.LOG
13:46 2013-12-02
GTD
0, 11:30-19:43

1, today
1), 13:48- 15:24- write ao_how without callback with Job. see"14:35 2013-12-02"
16:06- finish coding, try to compile.
2), ?-? 找lance
3), 10' 上网看opensuse13.1 release.

2), work report.

13:47 2013-12-02
GTD, weekplan
1, this week
1), finish ao_how patch send it to Jim.
2), snapshot.
(1), discuss with Chunyan.
(2), try to write hvm snapshot code.

14:35 2013-12-02
1, ref:
Linux 多线程应用中如何编写安全的信号处理函数
http://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/

2, consider call libxl_child_reaped in libvirt event handler. for now, call it direct from SIGCHLD handler.
in order to do this, i need get ctx in fork replacement.

3, add ao in each domain, do i need to add child in to each domain?
i handle child in order to call libxl_child_reaped. no other operation relative to the child.

4, today, only test SIGCHLD in libvirt. add ao in domain priv later.

5, error
if i waitpid, it would be influence the virProcessWait.
2013-12-02T17:26:27.937521+08:00 bjz-rd2 libvirtd[6240]: child info overflow!!! (pid<6758> status<256>)
2013-12-02T17:26:27.938603+08:00 bjz-rd2 libvirtd[6240]: unable to wait for process 6758: No child processes

1), try
-    pid = waitpid(-1, &status, WNOHANG);
+    pid = waitpid(0, &status, WNOHANG);

not work.

2), how about fork a new process for libxl?
is it acceptable in libvirt? at least, it is dangerous.

3), discuss with Gaoyan, his suggestion:
(1), direct loop. do not register signal action.
loop {
    check ao_complete
    waitpid, waitpid ...
    sleep(1)
}
(2), we do not know the status in BSD.
       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads  in  the  same  thread
              group.  This was the default before Linux 2.4.

(3), wait the specfic process group through setpgid and waitid.
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
       idtype == P_PGID
              Wait for any child whose process group ID matches id.

(4), another idea is signalfd which could convert the signal to fd, it is better than sigaction things, but it could not solved my problem.

6, TODO
1), try 5-3)-(1), and do others works. deal with it later.


12:35 2013-12-03
1, whether the libxl driver run in the dedicated thread?
if so, i could use the Linux specific thread.

2, do i need to update virProcessWait: add a flag for WNOHANG?
virProcessWait(pid_t pid, int *exitstatus)

13:25 2013-12-04
GTD
0, 11:20-18:15

1, today
1), 13:20-18:10 21:28-21:56 22:32-23:12 ao_how test. see"16:20 2013-12-04"
14:16-15:00(?) nap
2), 15:00-16:20
all hands

16:20 2013-12-04
libxl, ao_how
1, check the status:
WEXITSTATUS(status): returns true if the child terminated normally.
WIFSIGNALED(status): returns the exit status of the child.
WIFSIGNALED(status): returns true if the child process was terminated by a signal.
WTERMSIG(status):    returns the number of the signal that caused the child process to terminate.
WCOREDUMP(status):   returns true if the child produced a core dump.
WIFSTOPPED(status):  returns true if the child process was stopped by delivery of a signal.
WSTOPSIG(status):    returns the number of the signal which caused the child to stop.
WIFCONTINUED(status):returns true if the child process was resumed by delivery of SIGCONT.

2, it is ok after i add this code. and even ok after comment the code.
so, it might be ok i issue the libxl_child_reaped to the qemu parent process.
TODO: discuss it with xen community.

3, some corner case
1), in libxlEventHandler: the ao_complete will not be got because it will handled by libxlEventHandler itself.
2), libxlStateAutoStart: ao things is not ready.
solution: do not use ao. the domain started one by one.
3), FIXME: so as to libxlVmReap: use sync mode in libxlEventHandler. it will fail when multi-domain running.(similar to the assertion from jim)
(1), how about create thread for this?
TODO: thread or thread pool?
ref: qemuProcessEventHandler.
the thread pool seems more clear and easier for event handling.
for now, do not use thread pool. coding finish, try it tomorrow.
4), about reconnect? TODO

23:25 2013-12-4
TODO: ralf 1:1 chunyan
1, sle12 sp1 will not support xen.
2, btrfs bugs: don't worry, these will be fixed by suse lib.
3, bug fix is important. it is more impantant than new feature.

8:55 2013-12-5
mailing list, virtualization, xen
1,
Ian C
On Mon, 2013-12-02 at 13:34 +0800, 姚牧阳 wrote:

> This is Muyang Yao from Beijing, recently we have been working on > projects about hacking the xen kernel and reveal vulnerabilities to > arouse awareness.

This sounds like interesting work. Should you discover any security issues I would like to encourage you to please contact security@xen.org in the first instance. The Xen security problem response process is at http://www.xenproject.org/security-policy.html .

> Especially regarding the memory management mechanism. But I stll find > it hard to read through the source code of the hypervisor. > > > I'm wondering if there's any development document of the xen > hypervisor? How do you guys actually get started with xen source code? > are there any suggestions or good wiki pages to refer to? It seems > that the docs in "wiki.xenproject.org" are quite simple and have > limited help to reading the code.

There is a book "The Definitive Guide to the Xen Hypervisor" which I've not read myself but I have heard recommended (it's a bit dated, but still largely relevant I think)

http://www.amazon.com/The-Definitive-Guide-Xen-Hypervisor/dp/013234971X

If you are particularly interesting in memory management then a good understanding of the architectural (e.g. x86) memory management stuff is pretty much a prerequisite. As far as x86 PV memory management goes the basic principals are still those which are outlined in the original "Xen and the Art of Virtualization" paper from SOSP 2003.

Ultimately there isn't much substitute for being able to read and follow the code. Tools like TAGS or cscope, or even just grep, are a useful aid for this.

Ian.

2, grant table in arm, Ian C
The DT provided to guests (including dom0) includes a Xen node which, among other things, describes an MMIO region which can be safely used for grant table mappings (i.e. it is a hole in the physical address space). For domU we provide a hardcoded values based on our hardcoded guest virtual machine layout. However for dom0 we need to fit in with the underlying platform. Leaving this hardcoded was an oversight which on some platforms could result in the grant table overlaying RAM or MMIO regions which are in use by domain 0.

For the 4.4 release do as we did with the dom0 evtchn PPI and provide a hook for the platform code to supply a suitable hardcoded address for the platform (derived from reading the data sheet). Platforms which do not provide the hook get the existing address as a default.

After 4.4 we should switch to selecting a region of host RAM which is not RAM in the guest address map. This should be more flexible and safer but the patch was looking too complex for 4.4.

Platform Gnttab Address ========

exynos5.c 0xb0000000, confirmed and tested by Julien.
sunxi.c 0x01d00000, confirmed in data sheet.
midway.c 0xff800000, confirmed by Andre, boot tested by Ian.
vexpress.c 0xb0000000, existing hardcoded value was selected for vexpress.
omap5.c 0x4b000000, confirmed by Baozi 
xgene-storm.c 0x1f800000, confirmed by Pranavkumar

1), TODO: check 0x01d00000 in sunxi? which module?

3, support more than 4g on arm32
arm32 currently only makes use of memory which is contiguous with the first bank. On the Midway platform this means that we only use 4GB of the 8GB available.

Change things to make use of non-contiguous memory regions with the restriction that we require that at least half of the total span of the RAM addresses contain RAM. The frametable is currently not sparse and so this restriction avoids problems with allocating enormous amounts of memory for the frametable to cover holes in the address space and exhausting the actual RAM.

50% is arguably too restrictive. 4GB of RAM requires 32MB of frametable on arm32 and 56M on arm64, so we could probably cope with a lower ratio of actual RAM. However half is nice and conservative.

arm64 currently uses all banks without regard for the size of the frametable, which I have observed causing problems on models. Implement that same restriction as arm32 there.

Long term we should look at moving to a pfn compression based scheme similar to x86, which removes the holes from the frametable.

There were some bogus/outdated comments scattered around this code which I have removed.

4, (19:41 2013-12-5)
ttbcr in arm32 and aarch64. register_t is 32 or 64 according to architecture. so as to.READ/WRITE_SYSREG.
Ian C.
1), I think that actually only this hunk is required.

Actually, the correct type to use is register_t (which is defined to be the "native" register size, 32- or 64-bit as appropriate). That avoids the ifdef.

The READ/WRITE_SYSREG macros are also defined to deal in the "native" bit width so the other hunks are unnecessary.

The SYSREG32/64 variants are for use with a register which is a fixed width independent of the platform.

2),
Actually, it turns out there a few other places where ttbcr is incorrectly stored in a 32-bit variable. Including one which needed some careful consideration before it was safe to change. Here is what I came up with.

10:19 2013-12-05
GTD
0, 9:37-18:53

1, today
1), 9:37-10:19 cleanup my desk.
2), 10:24-11:38 13:17-17:36 18:41-18:53 21:35-23:57 ao. see"10:23 2013-12-05"
nap 13:50-14:18
30' talk with Bo yang.
3), 11:38-12:58 lunch. 12:59-13:08 aabill.
4), 16:10-16:18 obs.
5), 17:36-18:41 gcc and ld. see"18:30 2013-12-05"

10:23 2013-12-05
libxl, ao_how, cont1
1, plan
1), all the ao in one domain works
(1), debug pthread
2), add ao in private.

2, how to sync the event send to libxlEventHandler?
it seems that ao_complete not processed and the LIBXL_EVENT_TYPE_DOMAIN_DEATH is coming.

3, fail in malloc_consolidate.
#0  0x00007f63071e6d15 in malloc_consolidate () from /lib64/libc.so.6
#1  0x00007f63071e7f57 in _int_malloc () from /lib64/libc.so.6
#2  0x00007f63071e9648 in _int_realloc () from /lib64/libc.so.6
#3  0x00007f63071ea79d in realloc () from /lib64/libc.so.6
#4  0x00007f630a30af18 in virReallocN (ptrptr=ptrptr@entry=0x7f630b99fce8, 
    size=size@entry=1, count=count@entry=65540, report=report@entry=true, 
    domcode=domcode@entry=7, 
    filename=filename@entry=0x7f630a56de49 "rpc/virnetmessage.c", 
    funcname=funcname@entry=0x7f630a56e320 <__FUNCTION__.10821> "virNetMessageEncodeHeader", linenr=linenr@entry=222) at util/viralloc.c:243
#5  0x00007f630a4647a1 in virNetMessageEncodeHeader (
    msg=msg@entry=0x7f630b99fce0) at rpc/virnetmessage.c:222
#6  0x00007f630a4617fc in virNetServerProgramSendError (
    program=<optimized out>, version=1, client=client@entry=0x7f630b9a0620, 
    msg=msg@entry=0x7f630b99fce0, rerr=rerr@entry=0x7f63037c8c90, 
    procedure=163, type=1, serial=42) at rpc/virnetserverprogram.c:163
#7  0x00007f630a461ba9 in virNetServerProgramSendReplyError (
    prog=prog@entry=0x7f630b98ba10, client=client@entry=0x7f630b9a0620, 
    msg=msg@entry=0x7f630b99fce0, rerr=rerr@entry=0x7f63037c8c90, 
    req=req@entry=0x7f630b99fd00) at rpc/virnetserverprogram.c:202
#8  0x00007f630a4622f2 in virNetServerProgramDispatchCall (msg=0x7f630b99fce0, 
    client=0x7f630b9a0620, server=0x7f63ffffffff, prog=0x7f630b98ba10)
    at rpc/virnetserverprogram.c:497
#9  virNetServerProgramDispatch (prog=0x7f630b98ba10, server=0x7f63ffffffff, 
    server@entry=0x7f630b9812c0, client=0x7f630b9a0620, msg=0x7f630b99fce0)
    at rpc/virnetserverprogram.c:305
#10 0x00007f630a45bcb8 in virNetServerProcessMsg (msg=<optimized out>,
    prog=<optimized out>, client=<optimized out>, srv=0x7f630b9812c0)
    at rpc/virnetserver.c:165
#11 virNetServerHandleJob (jobOpaque=<optimized out>, opaque=0x7f630b9812c0)
    at rpc/virnetserver.c:186
#12 0x00007f630a35ae9e in virThreadPoolWorker (
    opaque=opaque@entry=0x7f630b98d850) at util/virthreadpool.c:144
#13 0x00007f630a35a4f6 in virThreadHelper (data=<optimized out>)
    at util/virthreadpthread.c:161
#14 0x00007f6307927e0f in start_thread () from /lib64/libpthread.so.0
#15 0x00007f63072547dd in clone () from /lib64/libc.so.6
1), reboot and run valgrind: the libvirtd not crashed, some error message:
(1),
2013-12-05 06:27:51.200+0000: 4576: info : ao_how_wait:136 : <0>:<4477>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <1>:<4493>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <2>:<4504>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <3>:<4587>
2013-12-05 06:27:51.202+0000: 4576: info : ao_how_wait:136 : <4>:<4590>
2013-12-05 06:27:51.369+0000: 4318: info : libxlEventHandler:521 : LIBXL_EVENT_TYPE_OPERATION_COMPLETE
==4318== Thread 14:
==4318== Invalid free() / delete / delete[] / realloc()
==4318==    at 0x4C2AF6C: free (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==4318==    by 0x529C578: virFree (viralloc.c:580)
==4318==    by 0x12A93385: libxlEventHandlerThread (libxl_driver.c:503)
==4318==    by 0x52EB4F5: virThreadHelper (virthreadpthread.c:161)
==4318==    by 0x7F01E0E: start_thread (in /lib64/libpthread-2.17.so)
==4318==    by 0x86057DC: clone (in /lib64/libc-2.17.so)
==4318==  Address 0x162485b0 is 0 bytes inside a block of size 16 free'd
==4318==    at 0x4C2AF6C: free (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==4318==    by 0x529C578: virFree (viralloc.c:580)
==4318==    by 0x12A89A81: libxlEventHandler (libxl_driver.c:539)
==4318==    by 0x12D01A8D: libxl__egc_cleanup (libxl_event.c:1142)
==4318==    by 0x12D022EC: libxl_osevent_occurred_fd (libxl_event.c:1077)
==4318==    by 0x52B9D17: virEventPollRunOnce (vireventpoll.c:501)
==4318==    by 0x52B823A: virEventRunDefaultImpl (virevent.c:274)
==4318==    by 0x53EE2A4: virNetServerRun (virnetserver.c:1112)
==4318==    by 0x11DB92: main (libvirtd.c:1513)
==4318== 
2013-12-05 06:27:52.202+0000: 4576: info : ao_how_wait:131 : got ao_complete, exit
==4318== Thread 13:
==4318== Conditional jump or move depends on uninitialised value(s)
==4318==    at 0x12A92463: libxlVmStart (libxl_driver.c:648)
==4318==    by 0x12A934BA: libxlEventHandlerThread (libxl_driver.c:488)
==4318==    by 0x52EB4F5: virThreadHelper (virthreadpthread.c:161)
==4318==    by 0x7F01E0E: start_thread (in /lib64/libpthread-2.17.so)
==4318==    by 0x86057DC: clone (in /lib64/libc-2.17.so)

(2), comment the VIR_FREE and try again.
should i free it after join? not use the detach mode?

4, get another crash: start -> save -> restore -> save:
Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ff8bd85f700 (LWP 3149)]
libxlEventHandlerThread (opaque=opaque@entry=0x7ff8cf180dd0)
    at libxl/libxl_driver.c:451
451         if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {

the event ptr is wrong.
considering the event is created by NEW_EVENT. and it is managed by gc. so it would be freed before libxlEventHandlerThread use it.
print event in libxlEventHandler and libxlEventHandlerThread. also trace the gc in libxl__free_all.

1), error in libxl_event_free.
2), error message:
Program received signal SIGBUS, Bus error.
---Type <return> to continue, or q <return> to quit---
0x00007f099fba745f in libxlEventHandlerThread (
    opaque=opaque@entry=0x7f09adc90c40) at libxl/libxl_driver.c:502
502         libxl_event_free(priv->ctx, (libxl_event *)event);

5, one domain test pass.
base on 7e6242e9.
hvm test pass: create -> save -> restore -> reboot -> save -> restore -> shutdown -> create -> save -> restore -> destroy

18:30 2013-12-05
gcc, ld; summary, doc, TODO
1, on opensuse factory(gcc 4.8): there is a fail in ledmon, when the -lsgutils2 before scsi.o, it will lead to undefined reference ...
but it work on SP3, it works on sp2.
according to gcc and ld manual, -l only works for the binary before it:
   The linker will search an archive only once, at the location where
   it is specified on the command line.  If the archive defines a
   symbol which was undefined in some object which appeared before the
   archive on the command line, the linker will include the
   appropriate file(s) from the archive.  However, an undefined symbol
   in an object appearing later on the command line will not cause the
   linker to search the archive again.

12:46 2013-12-06
GTD
0,

1, today
1), 13:33-14:06 tmux from lance.
2), 14:11-16:05 the sqlite3 database in android application.
nap 30'
3), 16:05-16:18 install GMS on android.
4), 16:52-18:23 ao: fix bug introduce by yestoday.
5), Summary: 在软件公司, 有个好处是总能知道新软件, 像今天尝试了tmux. 感觉很有帮助.

3), work report.
4), put waidpid exit status function in github.

13:37 2013-12-06
software skill, shell, multi terminal, tmux
0, reference
https://wiki.freebsdchina.org/software/t/tmux

1, ~/.tmux.conf
### change send-prefix as I am used to screen.
unbind C-b
set -g prefix ^A
bind   C-a         send-prefix
bind   a           send-prefix

###
set -g buffer-limit 9999
set -g display-time 1000

### key bindings
## reload config file
bind R source-file ~/.tmux.conf \; display-message "tmux.conf reloaded!"

2, shortcut
Ctrl+A
o: move panel
n: next window
p: previous window
c: create windows
[: copy mode, could scroll the screen as well.

3, copy and paste
http://joncairns.com/2013/06/copying-between-tmux-buffers-and-the-system-clipboard/
http://blog.csdn.net/yangzhongxuan/article/details/6890232

17:50 2013-12-8
mailing list, virtualization, xen
1, why qemu i386 is used in xen?
> I'm just curious why only i386 target is enabled for qemu-xen even > on my am64 machine? > I mean why x86_64 target not enabled

Xen only uses the device emulation capabilities of qemu and not the processor emulation capabilities, so it doesn't matter which processor target is used.
