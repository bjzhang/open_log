.LOG
13:46 2013-12-02
GTD
0, 11:30-19:43

1, today
1), 13:48- 15:24- write ao_how without callback with Job. see"14:35 2013-12-02"
16:06- finish coding, try to compile.
2), ?-? 找lance
3), 10' 上网看opensuse13.1 release.

2), work report.

13:47 2013-12-02
GTD, weekplan
1, this week
1), finish ao_how patch send it to Jim.
2), snapshot.
(1), discuss with Chunyan.
(2), try to write hvm snapshot code.

14:35 2013-12-02
1, ref:
Linux 多线程应用中如何编写安全的信号处理函数
http://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/

2, consider call libxl_child_reaped in libvirt event handler. for now, call it direct from SIGCHLD handler.
in order to do this, i need get ctx in fork replacement.

3, add ao in each domain, do i need to add child in to each domain?
i handle child in order to call libxl_child_reaped. no other operation relative to the child.

4, today, only test SIGCHLD in libvirt. add ao in domain priv later.

5, error
if i waitpid, it would be influence the virProcessWait.
2013-12-02T17:26:27.937521+08:00 bjz-rd2 libvirtd[6240]: child info overflow!!! (pid<6758> status<256>)
2013-12-02T17:26:27.938603+08:00 bjz-rd2 libvirtd[6240]: unable to wait for process 6758: No child processes

1), try
-    pid = waitpid(-1, &status, WNOHANG);
+    pid = waitpid(0, &status, WNOHANG);

not work.

2), how about fork a new process for libxl?
is it acceptable in libvirt? at least, it is dangerous.

3), discuss with Gaoyan, his suggestion:
(1), direct loop. do not register signal action.
loop {
    check ao_complete
    waitpid, waitpid ...
    sleep(1)
}
(2), we do not know the status in BSD.
       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads  in  the  same  thread
              group.  This was the default before Linux 2.4.

(3), wait the specfic process group through setpgid and waitid.
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
       idtype == P_PGID
              Wait for any child whose process group ID matches id.

(4), another idea is signalfd which could convert the signal to fd, it is better than sigaction things, but it could not solved my problem.

6, TODO
1), try 5-3)-(1), and do others works. deal with it later.


12:35 2013-12-03
1, whether the libxl driver run in the dedicated thread?
if so, i could use the Linux specific thread.

2, do i need to update virProcessWait: add a flag for WNOHANG?
virProcessWait(pid_t pid, int *exitstatus)

13:25 2013-12-04
GTD
0, 11:20-18:15

1, today
1), 13:20-18:10 21:28-21:56 22:32-23:12 ao_how test. see"16:20 2013-12-04"
14:16- nap
2), 15:00-16:20
all hands

2, next
1), put waidpid exit status function in github.

16:20 2013-12-04
libxl, ao_how
1, check the status:
WEXITSTATUS(status): returns true if the child terminated normally.
WIFSIGNALED(status): returns the exit status of the child.
WIFSIGNALED(status): returns true if the child process was terminated by a signal.
WTERMSIG(status):    returns the number of the signal that caused the child process to terminate.
WCOREDUMP(status):   returns true if the child produced a core dump.
WIFSTOPPED(status):  returns true if the child process was stopped by delivery of a signal.
WSTOPSIG(status):    returns the number of the signal which caused the child to stop.
WIFCONTINUED(status):returns true if the child process was resumed by delivery of SIGCONT.

2, it is ok after i add this code. and even ok after comment the code.
so, it might be ok i issue the libxl_child_reaped to the qemu parent process.
TODO: discuss it with xen community.

3, some corner case
1), in libxlEventHandler: the ao_complete will not be got because it will handled by libxlEventHandler itself.
2), libxlStateAutoStart: ao things is not ready.
solution: do not use ao. the domain started one by one.
3), FIXME: so as to libxlVmReap: use sync mode in libxlEventHandler. it will fail when multi-domain running.(similar to the assertion from jim)
(1), how about create thread for this?
TODO: thread or thread pool?
ref: qemuProcessEventHandler.
the thread pool seems more clear and easier for event handling.
for now, do not use thread pool. coding finish, try it tomorrow.
4), about reconnect? TODO

23:25 2013-12-4
ralf 1:1 chunyan
1, sle12 sp1 will not support xen.
2, btrfs bugs
3, bug fix is important. primary work?

8:55 2013-12-5
mailing list, virtualization, xen
1,
Ian C
On Mon, 2013-12-02 at 13:34 +0800, 姚牧阳 wrote:

> This is Muyang Yao from Beijing, recently we have been working on > projects about hacking the xen kernel and reveal vulnerabilities to > arouse awareness.

This sounds like interesting work. Should you discover any security issues I would like to encourage you to please contact security@xen.org in the first instance. The Xen security problem response process is at http://www.xenproject.org/security-policy.html .

> Especially regarding the memory management mechanism. But I stll find > it hard to read through the source code of the hypervisor. > > > I'm wondering if there's any development document of the xen > hypervisor? How do you guys actually get started with xen source code? > are there any suggestions or good wiki pages to refer to? It seems > that the docs in "wiki.xenproject.org" are quite simple and have > limited help to reading the code.

There is a book "The Definitive Guide to the Xen Hypervisor" which I've not read myself but I have heard recommended (it's a bit dated, but still largely relevant I think)

http://www.amazon.com/The-Definitive-Guide-Xen-Hypervisor/dp/013234971X

If you are particularly interesting in memory management then a good understanding of the architectural (e.g. x86) memory management stuff is pretty much a prerequisite. As far as x86 PV memory management goes the basic principals are still those which are outlined in the original "Xen and the Art of Virtualization" paper from SOSP 2003.

Ultimately there isn't much substitute for being able to read and follow the code. Tools like TAGS or cscope, or even just grep, are a useful aid for this.

Ian.

2, grant table in arm, Ian C
The DT provided to guests (including dom0) includes a Xen node which, among other things, describes an MMIO region which can be safely used for grant table mappings (i.e. it is a hole in the physical address space). For domU we provide a hardcoded values based on our hardcoded guest virtual machine layout. However for dom0 we need to fit in with the underlying platform. Leaving this hardcoded was an oversight which on some platforms could result in the grant table overlaying RAM or MMIO regions which are in use by domain 0.

For the 4.4 release do as we did with the dom0 evtchn PPI and provide a hook for the platform code to supply a suitable hardcoded address for the platform (derived from reading the data sheet). Platforms which do not provide the hook get the existing address as a default.

After 4.4 we should switch to selecting a region of host RAM which is not RAM in the guest address map. This should be more flexible and safer but the patch was looking too complex for 4.4.

Platform Gnttab Address ========

exynos5.c 0xb0000000, confirmed and tested by Julien.
sunxi.c 0x01d00000, confirmed in data sheet.
midway.c 0xff800000, confirmed by Andre, boot tested by Ian.
vexpress.c 0xb0000000, existing hardcoded value was selected for vexpress.
omap5.c 0x4b000000, confirmed by Baozi 
xgene-storm.c 0x1f800000, confirmed by Pranavkumar

1), TODO: check 0x01d00000 in sunxi? which module?

3, support more than 4g on arm32
arm32 currently only makes use of memory which is contiguous with the first bank. On the Midway platform this means that we only use 4GB of the 8GB available.

Change things to make use of non-contiguous memory regions with the restriction that we require that at least half of the total span of the RAM addresses contain RAM. The frametable is currently not sparse and so this restriction avoids problems with allocating enormous amounts of memory for the frametable to cover holes in the address space and exhausting the actual RAM.

50% is arguably too restrictive. 4GB of RAM requires 32MB of frametable on arm32 and 56M on arm64, so we could probably cope with a lower ratio of actual RAM. However half is nice and conservative.

arm64 currently uses all banks without regard for the size of the frametable, which I have observed causing problems on models. Implement that same restriction as arm32 there.

Long term we should look at moving to a pfn compression based scheme similar to x86, which removes the holes from the frametable.

There were some bogus/outdated comments scattered around this code which I have removed.


