.LOG
13:46 2013-12-02
GTD
0, 11:30-19:43

1, today
1), 13:48- 15:24- write ao_how without callback with Job. see"14:35 2013-12-02"
16:06- finish coding, try to compile.
2), ?-? 找lance
3), 10' 上网看opensuse13.1 release.

13:47 2013-12-02
GTD, weekplan
1, this week
1), finish ao_how patch send it to Jim.
2), snapshot.
(1), discuss with Chunyan.
(2), try to write hvm snapshot code.

14:35 2013-12-02
1, ref:
Linux 多线程应用中如何编写安全的信号处理函数
http://www.ibm.com/developerworks/cn/linux/l-cn-signalsec/

2, consider call libxl_child_reaped in libvirt event handler. for now, call it direct from SIGCHLD handler.
in order to do this, i need get ctx in fork replacement.

3, add ao in each domain, do i need to add child in to each domain?
i handle child in order to call libxl_child_reaped. no other operation relative to the child.

4, today, only test SIGCHLD in libvirt. add ao in domain priv later.

5, error
if i waitpid, it would be influence the virProcessWait.
2013-12-02T17:26:27.937521+08:00 bjz-rd2 libvirtd[6240]: child info overflow!!! (pid<6758> status<256>)
2013-12-02T17:26:27.938603+08:00 bjz-rd2 libvirtd[6240]: unable to wait for process 6758: No child processes

1), try
-    pid = waitpid(-1, &status, WNOHANG);
+    pid = waitpid(0, &status, WNOHANG);

not work.

2), how about fork a new process for libxl?
is it acceptable in libvirt? at least, it is dangerous.

3), discuss with Gaoyan, his suggestion:
(1), direct loop. do not register signal action.
loop {
    check ao_complete
    waitpid, waitpid ...
    sleep(1)
}
(2), we do not know the status in BSD.
       __WNOTHREAD (since Linux 2.4)
              Do not wait for children of other threads  in  the  same  thread
              group.  This was the default before Linux 2.4.

(3), wait the specfic process group through setpgid and waitid.
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
       idtype == P_PGID
              Wait for any child whose process group ID matches id.

(4), another idea is signalfd which could convert the signal to fd, it is better than sigaction things, but it could not solved my problem.

6, TODO
1), try 5-3)-(1), and do others works. deal with it later.


12:35 2013-12-03
virtualization, xen, libxl, async, ao
1, whether the libxl driver run in the dedicated thread?
if so, i could use the Linux specific thread.

2, do i need to update virProcessWait: add a flag for WNOHANG?
virProcessWait(pid_t pid, int *exitstatus)

13:25 2013-12-04
GTD
0, 11:20-18:15

1, today
1), 13:20-18:10 21:28-21:56 22:32-23:12 ao_how test. see"16:20 2013-12-04"
14:16-15:00(?) nap
2), 15:00-16:20
all hands

16:20 2013-12-04
libxl, ao_how
1, check the status:
WEXITSTATUS(status): returns true if the child terminated normally.
WIFSIGNALED(status): returns the exit status of the child.
WIFSIGNALED(status): returns true if the child process was terminated by a signal.
WTERMSIG(status):    returns the number of the signal that caused the child process to terminate.
WCOREDUMP(status):   returns true if the child produced a core dump.
WIFSTOPPED(status):  returns true if the child process was stopped by delivery of a signal.
WSTOPSIG(status):    returns the number of the signal which caused the child to stop.
WIFCONTINUED(status):returns true if the child process was resumed by delivery of SIGCONT.

2, it is ok after i add this code. and even ok after comment the code.
so, it might be ok i issue the libxl_child_reaped to the qemu parent process.
TODO: discuss it with xen community.

3, some corner case
1), in libxlEventHandler: the ao_complete will not be got because it will handled by libxlEventHandler itself.
2), libxlStateAutoStart: ao things is not ready.
solution: do not use ao. the domain started one by one.
3), FIXME: so as to libxlVmReap: use sync mode in libxlEventHandler. it will fail when multi-domain running.(similar to the assertion from jim)
(1), how about create thread for this?
TODO: thread or thread pool?
ref: qemuProcessEventHandler.
the thread pool seems more clear and easier for event handling.
for now, do not use thread pool. coding finish, try it tomorrow.
4), about reconnect? TODO

23:25 2013-12-4
TODO: ralf 1:1 chunyan
1, sle12 sp1 will not support xen.
2, btrfs bugs: don't worry, these will be fixed by suse lib.
3, bug fix is important. it is more impantant than new feature.

8:55 2013-12-5
mailing list, virtualization, xen
1,
Ian C
On Mon, 2013-12-02 at 13:34 +0800, 姚牧阳 wrote:

> This is Muyang Yao from Beijing, recently we have been working on > projects about hacking the xen kernel and reveal vulnerabilities to > arouse awareness.

This sounds like interesting work. Should you discover any security issues I would like to encourage you to please contact security@xen.org in the first instance. The Xen security problem response process is at http://www.xenproject.org/security-policy.html .

> Especially regarding the memory management mechanism. But I stll find > it hard to read through the source code of the hypervisor. > > > I'm wondering if there's any development document of the xen > hypervisor? How do you guys actually get started with xen source code? > are there any suggestions or good wiki pages to refer to? It seems > that the docs in "wiki.xenproject.org" are quite simple and have > limited help to reading the code.

There is a book "The Definitive Guide to the Xen Hypervisor" which I've not read myself but I have heard recommended (it's a bit dated, but still largely relevant I think)

http://www.amazon.com/The-Definitive-Guide-Xen-Hypervisor/dp/013234971X

If you are particularly interesting in memory management then a good understanding of the architectural (e.g. x86) memory management stuff is pretty much a prerequisite. As far as x86 PV memory management goes the basic principals are still those which are outlined in the original "Xen and the Art of Virtualization" paper from SOSP 2003.

Ultimately there isn't much substitute for being able to read and follow the code. Tools like TAGS or cscope, or even just grep, are a useful aid for this.

Ian.

2, grant table in arm, Ian C
The DT provided to guests (including dom0) includes a Xen node which, among other things, describes an MMIO region which can be safely used for grant table mappings (i.e. it is a hole in the physical address space). For domU we provide a hardcoded values based on our hardcoded guest virtual machine layout. However for dom0 we need to fit in with the underlying platform. Leaving this hardcoded was an oversight which on some platforms could result in the grant table overlaying RAM or MMIO regions which are in use by domain 0.

For the 4.4 release do as we did with the dom0 evtchn PPI and provide a hook for the platform code to supply a suitable hardcoded address for the platform (derived from reading the data sheet). Platforms which do not provide the hook get the existing address as a default.

After 4.4 we should switch to selecting a region of host RAM which is not RAM in the guest address map. This should be more flexible and safer but the patch was looking too complex for 4.4.

Platform Gnttab Address ========

exynos5.c 0xb0000000, confirmed and tested by Julien.
sunxi.c 0x01d00000, confirmed in data sheet.
midway.c 0xff800000, confirmed by Andre, boot tested by Ian.
vexpress.c 0xb0000000, existing hardcoded value was selected for vexpress.
omap5.c 0x4b000000, confirmed by Baozi 
xgene-storm.c 0x1f800000, confirmed by Pranavkumar

1), TODO: check 0x01d00000 in sunxi? which module?

3, support more than 4g on arm32
arm32 currently only makes use of memory which is contiguous with the first bank. On the Midway platform this means that we only use 4GB of the 8GB available.

Change things to make use of non-contiguous memory regions with the restriction that we require that at least half of the total span of the RAM addresses contain RAM. The frametable is currently not sparse and so this restriction avoids problems with allocating enormous amounts of memory for the frametable to cover holes in the address space and exhausting the actual RAM.

50% is arguably too restrictive. 4GB of RAM requires 32MB of frametable on arm32 and 56M on arm64, so we could probably cope with a lower ratio of actual RAM. However half is nice and conservative.

arm64 currently uses all banks without regard for the size of the frametable, which I have observed causing problems on models. Implement that same restriction as arm32 there.

Long term we should look at moving to a pfn compression based scheme similar to x86, which removes the holes from the frametable.

There were some bogus/outdated comments scattered around this code which I have removed.

4, (19:41 2013-12-5)
ttbcr in arm32 and aarch64. register_t is 32 or 64 according to architecture. so as to.READ/WRITE_SYSREG.
Ian C.
1), I think that actually only this hunk is required.

Actually, the correct type to use is register_t (which is defined to be the "native" register size, 32- or 64-bit as appropriate). That avoids the ifdef.

The READ/WRITE_SYSREG macros are also defined to deal in the "native" bit width so the other hunks are unnecessary.

The SYSREG32/64 variants are for use with a register which is a fixed width independent of the platform.

2),
Actually, it turns out there a few other places where ttbcr is incorrectly stored in a 32-bit variable. Including one which needed some careful consideration before it was safe to change. Here is what I came up with.

10:19 2013-12-05
GTD
0, 9:37-18:53

1, today
1), 9:37-10:19 cleanup my desk.
2), 10:24-11:38 13:17-17:36 18:41-18:53 21:35-23:57 ao. see"10:23 2013-12-05"
nap 13:50-14:18
30' talk with Bo yang.
3), 11:38-12:58 lunch. 12:59-13:08 aabill.
4), 16:10-16:18 obs.
5), 17:36-18:41 gcc and ld. see"18:30 2013-12-05"

10:23 2013-12-05
libxl, ao_how, cont1
1, plan
1), all the ao in one domain works
(1), debug pthread
2), add ao in private.

2, how to sync the event send to libxlEventHandler?
it seems that ao_complete not processed and the LIBXL_EVENT_TYPE_DOMAIN_DEATH is coming.

3, fail in malloc_consolidate.
#0  0x00007f63071e6d15 in malloc_consolidate () from /lib64/libc.so.6
#1  0x00007f63071e7f57 in _int_malloc () from /lib64/libc.so.6
#2  0x00007f63071e9648 in _int_realloc () from /lib64/libc.so.6
#3  0x00007f63071ea79d in realloc () from /lib64/libc.so.6
#4  0x00007f630a30af18 in virReallocN (ptrptr=ptrptr@entry=0x7f630b99fce8, 
    size=size@entry=1, count=count@entry=65540, report=report@entry=true, 
    domcode=domcode@entry=7, 
    filename=filename@entry=0x7f630a56de49 "rpc/virnetmessage.c", 
    funcname=funcname@entry=0x7f630a56e320 <__FUNCTION__.10821> "virNetMessageEncodeHeader", linenr=linenr@entry=222) at util/viralloc.c:243
#5  0x00007f630a4647a1 in virNetMessageEncodeHeader (
    msg=msg@entry=0x7f630b99fce0) at rpc/virnetmessage.c:222
#6  0x00007f630a4617fc in virNetServerProgramSendError (
    program=<optimized out>, version=1, client=client@entry=0x7f630b9a0620, 
    msg=msg@entry=0x7f630b99fce0, rerr=rerr@entry=0x7f63037c8c90, 
    procedure=163, type=1, serial=42) at rpc/virnetserverprogram.c:163
#7  0x00007f630a461ba9 in virNetServerProgramSendReplyError (
    prog=prog@entry=0x7f630b98ba10, client=client@entry=0x7f630b9a0620, 
    msg=msg@entry=0x7f630b99fce0, rerr=rerr@entry=0x7f63037c8c90, 
    req=req@entry=0x7f630b99fd00) at rpc/virnetserverprogram.c:202
#8  0x00007f630a4622f2 in virNetServerProgramDispatchCall (msg=0x7f630b99fce0, 
    client=0x7f630b9a0620, server=0x7f63ffffffff, prog=0x7f630b98ba10)
    at rpc/virnetserverprogram.c:497
#9  virNetServerProgramDispatch (prog=0x7f630b98ba10, server=0x7f63ffffffff, 
    server@entry=0x7f630b9812c0, client=0x7f630b9a0620, msg=0x7f630b99fce0)
    at rpc/virnetserverprogram.c:305
#10 0x00007f630a45bcb8 in virNetServerProcessMsg (msg=<optimized out>,
    prog=<optimized out>, client=<optimized out>, srv=0x7f630b9812c0)
    at rpc/virnetserver.c:165
#11 virNetServerHandleJob (jobOpaque=<optimized out>, opaque=0x7f630b9812c0)
    at rpc/virnetserver.c:186
#12 0x00007f630a35ae9e in virThreadPoolWorker (
    opaque=opaque@entry=0x7f630b98d850) at util/virthreadpool.c:144
#13 0x00007f630a35a4f6 in virThreadHelper (data=<optimized out>)
    at util/virthreadpthread.c:161
#14 0x00007f6307927e0f in start_thread () from /lib64/libpthread.so.0
#15 0x00007f63072547dd in clone () from /lib64/libc.so.6
1), reboot and run valgrind: the libvirtd not crashed, some error message:
(1),
2013-12-05 06:27:51.200+0000: 4576: info : ao_how_wait:136 : <0>:<4477>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <1>:<4493>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <2>:<4504>
2013-12-05 06:27:51.201+0000: 4576: info : ao_how_wait:136 : <3>:<4587>
2013-12-05 06:27:51.202+0000: 4576: info : ao_how_wait:136 : <4>:<4590>
2013-12-05 06:27:51.369+0000: 4318: info : libxlEventHandler:521 : LIBXL_EVENT_TYPE_OPERATION_COMPLETE
==4318== Thread 14:
==4318== Invalid free() / delete / delete[] / realloc()
==4318==    at 0x4C2AF6C: free (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==4318==    by 0x529C578: virFree (viralloc.c:580)
==4318==    by 0x12A93385: libxlEventHandlerThread (libxl_driver.c:503)
==4318==    by 0x52EB4F5: virThreadHelper (virthreadpthread.c:161)
==4318==    by 0x7F01E0E: start_thread (in /lib64/libpthread-2.17.so)
==4318==    by 0x86057DC: clone (in /lib64/libc-2.17.so)
==4318==  Address 0x162485b0 is 0 bytes inside a block of size 16 free'd
==4318==    at 0x4C2AF6C: free (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==4318==    by 0x529C578: virFree (viralloc.c:580)
==4318==    by 0x12A89A81: libxlEventHandler (libxl_driver.c:539)
==4318==    by 0x12D01A8D: libxl__egc_cleanup (libxl_event.c:1142)
==4318==    by 0x12D022EC: libxl_osevent_occurred_fd (libxl_event.c:1077)
==4318==    by 0x52B9D17: virEventPollRunOnce (vireventpoll.c:501)
==4318==    by 0x52B823A: virEventRunDefaultImpl (virevent.c:274)
==4318==    by 0x53EE2A4: virNetServerRun (virnetserver.c:1112)
==4318==    by 0x11DB92: main (libvirtd.c:1513)
==4318== 
2013-12-05 06:27:52.202+0000: 4576: info : ao_how_wait:131 : got ao_complete, exit
==4318== Thread 13:
==4318== Conditional jump or move depends on uninitialised value(s)
==4318==    at 0x12A92463: libxlVmStart (libxl_driver.c:648)
==4318==    by 0x12A934BA: libxlEventHandlerThread (libxl_driver.c:488)
==4318==    by 0x52EB4F5: virThreadHelper (virthreadpthread.c:161)
==4318==    by 0x7F01E0E: start_thread (in /lib64/libpthread-2.17.so)
==4318==    by 0x86057DC: clone (in /lib64/libc-2.17.so)

(2), comment the VIR_FREE and try again.
should i free it after join? not use the detach mode?

4, get another crash: start -> save -> restore -> save:
Program received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ff8bd85f700 (LWP 3149)]
libxlEventHandlerThread (opaque=opaque@entry=0x7ff8cf180dd0)
    at libxl/libxl_driver.c:451
451         if (event->type == LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN) {

the event ptr is wrong.
considering the event is created by NEW_EVENT. and it is managed by gc. so it would be freed before libxlEventHandlerThread use it.
print event in libxlEventHandler and libxlEventHandlerThread. also trace the gc in libxl__free_all.

1), error in libxl_event_free.
2), error message:
Program received signal SIGBUS, Bus error.
---Type <return> to continue, or q <return> to quit---
0x00007f099fba745f in libxlEventHandlerThread (
    opaque=opaque@entry=0x7f09adc90c40) at libxl/libxl_driver.c:502
502         libxl_event_free(priv->ctx, (libxl_event *)event);

5, one domain test pass.
base on 7e6242e9.
hvm test pass: create -> save -> restore -> reboot -> save -> restore -> shutdown -> create -> save -> restore -> destroy

18:30 2013-12-05
gcc, ld; summary, doc, TODO
1, on opensuse factory(gcc 4.8): there is a fail in ledmon, when the -lsgutils2 before scsi.o, it will lead to undefined reference ...
but it work on SP3, it works on sp2.
according to gcc and ld manual, -l only works for the binary before it:
   The linker will search an archive only once, at the location where
   it is specified on the command line.  If the archive defines a
   symbol which was undefined in some object which appeared before the
   archive on the command line, the linker will include the
   appropriate file(s) from the archive.  However, an undefined symbol
   in an object appearing later on the command line will not cause the
   linker to search the archive again.

12:46 2013-12-06
GTD
0,

1, today
1), 13:33-14:06 22:05-22:47 tmux. thanks lance. see"13:37 2013-12-06"
2), 14:11-16:05 the sqlite3 database in android application.
nap 30'
3), 16:05-16:18 install GMS on android.
4), 16:52-18:23 22:47-23:44 ao: fix bug introduce by yestoday.
5), Summary: 在软件公司, 有个好处是总能知道新软件, 像今天尝试了tmux. 感觉很有帮助.

13:37 2013-12-06
(22:43 2013-12-06)
software skill, shell, multi terminal, tmux
0, reference
https://wiki.freebsdchina.org/software/t/tmux

1, ~/.tmux.conf
### change send-prefix as I am used to screen.
unbind C-b
set -g prefix ^A
bind   C-a         send-prefix
bind   a           send-prefix

###
set -g buffer-limit 9999
set -g display-time 1000

### key bindings
## reload config file
bind R source-file ~/.tmux.conf \; display-message "tmux.conf reloaded!"

2, shortcut
Ctrl+A
o: move to the Other panel
n: Next window
p: Previous window
c: Create windows

3, copy and paste
1), in tmux
[: copy mode, could scroll the screen as well.
]: paste

#using vi style in tmux copy and paste
set-window-option -g mode-keys vi

2), between tmux and system clipboard
(1), ref
https://wiki.archlinux.org/index.php/tmux
#copy with system clipboard
bind C-c run-shell "tmux show-buffer | xclip -selection clipboard -i" \; display-message "Copied tmux buffer to system clipboard"
bind C-v run-shell "tmux set-buffer -- \"$(xclip -o -selection clipboard)\"; tmux paste-buffer"\; display-message "Copied system clipboard to tmux buffer"
(2), other
((1)), http://joncairns.com/2013/06/copying-between-tmux-buffers-and-the-system-clipboard/
((2)), http://blog.csdn.net/yangzhongxuan/article/details/6890232

17:50 2013-12-8
mailing list, virtualization, xen
1, why qemu i386 is used in xen?
> I'm just curious why only i386 target is enabled for qemu-xen even
> on my am64 machine?
> I mean why x86_64 target not enabled

Xen only uses the device emulation capabilities of qemu and not the
processor emulation capabilities, so it doesn't matter which processor
target is used.

11:26 2013-12-09
GTD
0, 11:00

1, today
1), 10' eating.

10:08 2013-12-10
GTD
0, 10:07-18:32

1, today
1), 10:12-11:45 16:15-18:29 send ao patch to Jim and Chunyan.
2), 11:45-12:40 lunch.
3), 12:40-12:53 nap.
4), 13:00-15:00 English class.
5), 15:00-15:48 eating. 360 children secure product.
6), 10' support about change disk image location in virt-manager. for Xia LI.
7), 20' nap.

11:39 2013-12-10
English
1, Jerry join the yestoday class.

11:04 2013-12-11
GTD
0, 10:50-18:15

1, today
1), 10' android.
2), 11:00-11:31 reply email about sunxi on opensuse.
3), 11:31-11:41 13:58-16:05 16:30-18:10 ao
10' help Xia li about libvirt. see"15:50 2013-12-11"
4), lunch 11:41-12:40
5), 12:50-13:37 nap 13:37-13:58 washing.
6), 10' fpu virtualization. see"16:11 2013-12-11"
7), Summary:
i meet the basic requirement which make me feel good.
git rebase is very cool. it could merge the commit i forget into the commit not in the HEAD.

11:40 2013-12-11
libxl, ao
1, plan
1), child_info
2), jobs
2, current status
1), finish the above code, simple test pass: create->save->restore->shutdown; create->destroy.
3, next
1), test two vm and send different command at the same time.
(11:02 2013-12-12)
test total 60times in two vm pass yestoday night.
"11:02 2013-12-12"end
2), fix the TODO
(1), add error handling in ao.
(2), do i need to use job in domain destroy?
if not, i could not release the vm lock during domain destroy.
how about using job in reboot, shutdown, destroy?
    will it be affected by the domain id changing?
if the destroy event is destroy, it is ok. but if it is the reboot. it should not conflict with the job started in libxlVmStart.
TODO: reference how qemu handle it.

12:20 2013-12-10
virtualization, cubieboard, kvm
Setting up Cubieboard2 to run kvmarm
https://groups.google.com/forum/?fromgroups#!category-topic/cubieboard/setting-up/other/4EGONZMoIAU

13:58 2013-12-11
mailing list, virtualization, xen, aarch64, UEFI
1, about boot xen on EFI
Chen Banzi reply to Ian C
> Are you using the EFI stub with Linux or are you launching via a
> bootloader e.g. Grub-EFI?

After reading the source code, I think it is neither the EFI stub
or a bootloader. A Linux Loader EFI application has been developed
for ARM in EFI. It is able to boot Linux either by tagged list or
dtb method. However, it hardcoded the start address of 0x80000
when loading Linux kernel, which make it unworkable for Xen after
paging is enable. But I’m not sure whether there would be other
problems for it to boot Xen. And I’ll continue to work on it until
it can boot Xen successfully at the end.

(At least, there are early printk messages on the UART now, :-))

15:50 2013-12-11
software skill, virtualization, libvirt, authentication, tcp; a easy way instead of transfer ssh public key
diff --git a/daemon/libvirtd.conf b/daemon/libvirtd.conf
index 5353927..6a870c9 100644
--- a/daemon/libvirtd.conf
+++ b/daemon/libvirtd.conf
@@ -30,7 +30,7 @@
 # DIGEST_MD5 and GSSAPI (Kerberos5)
 #
 # This is disabled by default, uncomment this to enable it.
-#listen_tcp = 1
+listen_tcp = 1
 
 
 
@@ -143,7 +143,7 @@
 # Don't do this outside of a dev/test scenario. For real world
 # use, always enable SASL and use the GSSAPI or DIGEST-MD5
 # mechanism in /etc/sasl2/libvirt.conf
-#auth_tcp = "sasl"
+auth_tcp = "none"
 
 # Change the authentication scheme for TLS sockets.
 #

16:11 2013-12-11
fpu
http://os.korea.ac.kr/publication_papers/inter_journal/1-s2.0-S1383762113001902-main.pdf
xen, kvm: lazy FP context switching on x86.

17:37 2013-12-11
GTD, plan
1, tools
1), ao_how
2), send-key
3), snapshot.
2, kernel or xen
1), kernel: sunxi framebuffer driver.
2), xen: A31 smp support.

19:12 2013-12-11
mailing list, virtualization; 48bit phy address;  huge pages, hugetlb
1, how to test huge pages.
> The code has been tested with LTP.

Hello,

Could you please test how this series interacts with huge pages? So please run LTP with THP enabled and always active: TRANSPARENT_HUGEPAGE=y TRANSPARENT_HUGEPAGE_ALWAYS=y (for both 4KB and 64KB base page sizes). This will give the pmd level code a workout.

Then could you please try libhugetlbfs to test HugeTLB? git://git.code.sf.net/p/libhugetlbfs/code (next branch) with the following enabled: HUGETLBFS=y

Please run the test suite against 2MB, 1GB (4KB base pages) and 512MB (64KB base pages) huge pages.

To set aside 1GB huge pages at boot time, please add the following to the kernel command line: hugepagesz=1G hugepages=x where x is the number of 1GB huge pages you can get away with :-).

For 2MB and 512MB: echo x > /proc/sys/vm/nr_hugepages again where x is the number of huge pages to set aside.

Ensure that the hugetlbfs filesystem is mounted: mount -t hugetlbfs hugetlbfs /mnt/hugepages

Then make check

The libhugetlbfs tests above will test out the pud and pmd interactions, please let me know whether or not anything breaks.

Thanks, --Steve

11:01 2013-12-12
GTD
0, 10:50-18:10

1, today
1), 10' work log.
2), 11:06-11:45 13:51-14:49 16:51-18:08 20:15-22:19 22:33-23:47 ao see"11:37 2013-12-12"
20' nap
3), 11:45-12:52 lunch and rest.
4), 13:41-13:50 医疗报销.
5), 14:49-16:15 Jia YAO: openstack.
6), 16:16-16:23 tip: git. see"16:17 2013-12-12"
7), 16:36-16:51 github account.
8), Summary: 今天有效工作时间是4小时。目标是扣除吃饭时间到达7小时。这样就可以开始另一条线。

2, next
1), snapshot.
2), work report.

2, coding excises
1), put waidpid exit status function in github.
2), use parentheses as return value in macro "(ao__rc);"

11:37 2013-12-12
libxl, ao
1, what's new
TODO
virObjectEventPtr
virDomainEventLifecycleNewFromObj

2, plan
do "11:40 2013-12-11"3-2).

3, about domain destroy
1), TODO why use domain destroy instead of libxlVmReap in libxlVmStart?
2), check how qemu handle: core dump, save, destroy, shutdown, reboot?
(1), core dump:
qemu: begin job -> core dump -> destroy -> endjob.
libxl: same as qemu. but libxlVmReap need release the vm lock during sleep.

4, finish vm lock in ao_how_wait.

5, plan: add error handling in ao.
1), use the return value in libxl__ao.rc;

6, (20:27 2013-12-12)
test.
1), create fail test
report internal error but got segment fault after that.
(gdb) p *logger
$19 = {vmessage = 0x0,
  progress = 0x7fa11a3f2daa <stdiostream_progress>,
  destroy = 0x7fa11a3f2b72 <stdiostream_destroy>}
xtl_logger_destroy is called in libxlDomainObjPrivateDispose
    from virDomainObjDispose
    from virObjectUnref(dom);
    from virDomainObjListRemove

but it is used in the libxl_ctx_free later:
    xtl_logger_destroy(priv->logger);
    ...
    libxl_ctx_free(priv->ctx);

modify:
    put xtl_logger_destroy after libxl_ctx_free.

it works after this.

(1), patch commit message:
fix segfault when domain create fail

there is segfault in libxl_ctx_free. because the log output handler vmessage
is empty at that time.
this situation is caused by xtl_logger_destroy. it free such handler before
libxl_ctx_free in virDomainObjListRemove.
move xtl_logger_destroy after libxl_ctx_free could fix this bug.

(2), notes: the full backtrace:
(gdb) where
#0  0x0000000000000000 in ?? ()
#1  0x00007fa11a3f2a2a in xtl_logv (
    logger=0x7fa0f00013b0, level=XTL_DEBUG,
    errnoval=-1, context=0x7fa11a3f5b3b "xc",
    format=0x7fa11a3f5b34 "%s%s%s",
    al=al@entry=0x7fa11f73c068) at xtl_core.c:50
#2  0x00007fa11a3f2ab2 in xtl_log (
    logger=logger@entry=0x7fa0f00013b0,
    level=level@entry=XTL_DEBUG,
    errnoval=errnoval@entry=-1,
    context=context@entry=0x7fa11a3f5b3b "xc",
    format=format@entry=0x7fa11a3f5b34 "%s%s%s")
    at xtl_core.c:62
#3  0x00007fa11a3eb3d4 in xc_reportv (
    xch=0x7fa0f00017d0, lg=0x7fa0f00013b0,
    level=XTL_DEBUG, code=0,
    fmt=0x7fa11a3f63b8 "hypercall buffer: total allocations:%d total releases:%d",
    args=args@entry=0x7fa11f73c7b8)
    at xc_private.c:353
#4  0x00007fa11a3eb463 in xc_report (
    xch=xch@entry=0x7fa0f00017d0, lg=<optimized out>,
    level=level@entry=XTL_DEBUG, code=code@entry=0,
    fmt=fmt@entry=0x7fa11a3f63b8 "hypercall buffer: tot---Type <return> to continue, or q <return> to quit---
    al allocations:%d total releases:%d")
    at xc_private.c:364
#5  0x00007fa11a3f1ca9 in xc__hypercall_buffer_cache_release (xch=xch@entry=0x7fa0f00017d0)
    at xc_hcall_buf.c:104
#6  0x00007fa11a3ec3d1 in xc_interface_close_common (
    xch=0x7fa0f00017d0) at xc_private.c:201
#7  0x00007fa11a3ec473 in xc_interface_close (
    xch=<optimized out>) at xc_private.c:240
#8  0x00007fa11a6128de in libxl_ctx_free (
    ctx=0x7fa0f00015a0) at libxl.c:150
#9  0x00007fa127abf2ab in virObjectUnref (
    anyobj=<optimized out>) at util/virobject.c:262
#10 0x00007fa127afdded in virDomainObjDispose (
    obj=0x7fa110021fb0) at conf/domain_conf.c:2095
#11 0x00007fa127abf2ab in virObjectUnref (
    anyobj=anyobj@entry=0x7fa110021fb0)
    at util/virobject.c:262
#12 0x00007fa127aed278 in virDomainObjListRemove (
    doms=0x7fa110071950, dom=dom@entry=0x7fa110021fb0)
    at conf/domain_conf.c:2422
#13 0x00007fa11a8a6ece in libxlDomainCreateXML (
    conn=0x7fa10c0022c0, xml=<optimized out>, flags=0)
    at libxl/libxl_driver.c:1388

2), vnc could not open.
get the wrong vncport. it should be 5900, but virt-viewer get 5903.
TODO: it might be the bug in cmdVNCDisplay()(tools/virsh-domain.c).

6, TODO
add job in cdrom insert.

16:17 2013-12-12
software skill, SCM, git log; archive
1, http://blog.nutsfactory.net/2010/02/01/git-archive-and-log/
取得 abbreviated commit hash 的作法如下
git log --pretty=format:"%h" -1
若你想將整份程式碼壓縮起來，可以使用
git archive --format zip -o filename.zip HEAD
倘若想加上日期作為檔名，請使用
git archive --format zip -o $(git log --date=short --pretty=format:"%ad" -1).zip HEAD

1), bamvor
(1), output to std and compress
git archive --format tar HEAD | gzip foo.tar.gz
(2), add prefix, very suitable for build service.
git archive --format tar --prefix=xen-4.4 b18e2d96

17:31 2013-12-12
(15:29 2013-12-16)
work summary, work report
1, 11-11 11-15
fate#315156: migrate from xm to virsh: reply lin MA email.
fate, Discussion: Add API to retrieve migration progress

2, 11-18 11-22
QA workshop.
discuss async  operation with xen community.
try Python kivy.

3, 11-25 11-29
send xen async operation patch to xen-devel
join arm technology symposia 2013: more server topic than last year.

4, 12-02 12-06
write code for async operation in libvirt.
study tmux.
Ralf's All-hands meeting.

5, 12-09 12-13
1), async operation in libvirt.
(1), discuss async operation with Jim and Chunyan.
(2), test async operation with jobs.
a, test 60 times pass with two vm
b, test create, save, restore, shutdown, destroy... and all these long running api is allowed the other quiry api running(e.g. "virsh list").

6, work report(week 49, 50)
1), async operation in libvirt libxl driver.
(1), the goal of do this is
a, support operation to different domains with same or differerent command.
b, support operation the same domain with different command. this is the rebase of Jim jobs patch.
(2), write code about in libxl driver according to the discussion with xen upstream.
(3), discuss async operation with Jim and Chunyan.
(4), test async operation with jobs.
a, test 60 times pass with two vm
b, test create, save, restore, shutdown, destroy... and all these long running api is allowed the other quiry api running(e.g. "virsh list").

2), Ralf's All-hands meeting.

3), US/China virtualization sync.

4), English Training.(4 hours).

7, work report(week 46, 47, 48)
1), discuss async operation with xen community.
after discussion, i found that there is only one way could implement async operation in libvirt libxl driver.

2), Join QA workshop(3 days).

3), fate#315156.
discuss about Lin MA's documentation.

4), arm
(1), finally got the cubietruck board donation from cubieboard.org, i apply it before the hack week...

(2), join arm technology symposia 2013
more server topic than last year.
discuss server and virtualization with ARM Server and Networking manager.

5), US/China virtualization sync.

6), English Training.

10:15 2013-12-13
GTD
0, 10:15

1, today
1), 10:15-10:45 check the mail.
bamvor: it takes so many time.
2), 11:07-12:25 ao: talk with Jim. see"12:26 2013-12-13"
3), 12:00-13:00 lunch and learning. see"12:27 2013-12-13"
4), 30' children books.
5), 14:14-17:40 snapshot. see"14:14 2013-12-13"
interrupted by 5).
6), 10' get guest ip. see"14:35 2013-12-13"

10:18 2013-12-13
suse, sle12, schdule, alpha1
1, bamvor: it seem that alpha1 for package check: whether the package is missing, or should not delivery.

"Stefan Behlert <behlert@suse.de>"_email_"[devel] [ANNOUNCE] SLE 12 Alpha1 is available"_20131212_2310
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  SUSE CONFIDENTIAL  !!  SUSE CONFIDENTIAL  !!  SUSE CONFIDENTIAL  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Hi,

We are happy to announce the first Alpha images of SLE 12, fulfilling these
milestone criterias:

o Milestone: Make sure that Autobuild/BuildService setup is in place and
  working
o Internal snapshot only, based on Factory, not released outside of SUSE


We offer 3 DVD ISOs: DVD1 contains the binaries, the second
DVD the sources and the third DVD the debuginfo packages.
The final product will not contain the debuginfo packages on the media.


This is the first Alpha, nearly all features are missing. It's based on
openSUSE Factory, with the filelist adjusted for SLES.
Some packages are still missing.

Never-the-less, you can already check if the package selection makes sense.
Especially if there are packages on the medias you do not think should be
delivered, or if you miss some packages that should be there.

In such cases, be so kind to check if there's already a feature request for
those, and if not, file one. (As SLE 12 products are past feature deadline,
file against the SP1 of the product, and add the responsible Release Manager to
the feature. He'll take care t move the feature to the right product(s) and to
add the package/remove the package from the package list.)


You can get the iso images from:

  http://download.suse.de/install/SLE-12-Server-Alpha1/
  http://download.suse.de/install/SLE-12-Desktop-Alpha1/
  http://download.suse.de/install/SLE-12-HA-Alpha1/
  http://download.suse.de/install/SLE-12-Server-VMware-Alpha1/



Next steps:

We will split off of Factory on January 7th.
Alpha 2 submission deadline is 

for base/core packages or packages with a huge dependency list:
        Friday January 10th, 15:00 CET

for leaf packages:
	Monday January 13th, 17:00 CET


Happy testing!

	Your SUSE Linux Enterprise Team

12:26 2013-12-13
explain why i need async and libxl_sigchld_owner_mainloop
but if we do not use async. if we only use job. the same api(create, restore. or others) will be called at the same time. which will lead to sighandler_ctx conflict.

Jim Fehlig: even if those are on different domains?
e.g. create domA, restore domB

yes. it is global varible. because there is only one sighandler.
reference libxl__sigchld_installhandler
    if (sigchld_owner != CTX) {
        struct sigaction ours;

        assert(!sigchld_owner);
        sigchld_owner = CTX;

i think this segment code lead to the segfault you mentioned in Sep.
Jim Fehlig: hmm
and it is only occurred when we have jobs.
because if we do not have job, the api could only called one by one .
Jim Fehlig: ok, starting to understand/remember :)
this is the start point of my async work recently .
i work on it, because i do not find any other solution about this assertion.
and when i working on the async, i need to choice the between libxl_sigchld_owner_mainloop and libxl_sigchld_owner_libxl_always.
at first, i want libxl lib could manage the child exit.
Jim Fehlig: yes, understood
but as Ian C mentioned in email. it is depend on only one ctx in the whole libvirt.  which is conflict with libxl driver.
so, i could only use the mainloop.
which lead to the SIGCHLD handler in libvirt. and libvirt do not want it.
it usually use waitpid. so as to me.
i use the waitpid wait all the child created by the same domain id.
reference the code in ao_how_wait.
0002-introduce-async-opeartion-in-libxl-driver-private.patch
patch 0005-call-ao-functions.patch use the ao thing introduced in patch 0002-introduce-async-opeartion-in-libxl-driver-private..
around patch 0005, 0003, 0004, 0006 focus on improve the ao things. i seperate these tree patches from patch 0005, it might be ealier to review.
the last two patch only the rebase of your job patch.
and from patch 2 to 8 is the whole thing about ao and job.
patch 0001 is a bug fix. such bug is existed with or without ao and job. i think we could send it seperate and earlier.

12:27 2013-12-13
lunch and learn, QA, QA Quality & Statistics
-- presented by Calen and Lance

1, real: user + sys + io
real: gettimeofday.
user, sys: getrusage.

2,
1), wait for port 3019
> time nc -l localhost 3019
23

real    0m2.840s
user    0m0.000s
sys     0m0.008s

2), send info to 3019
> echo 23 | nc localhost 3019

3, standard deviation.

13:52 2013-12-13
children, learning
sled@147.2.207.136:/home/jamie/ooo-test-repo/misc/others/videos/children_learning/Little_Blue_Truck/
http://147.2.207.136/repo/misc/others/videos/children_learning/Little_Blue_Truck/

14:14 2013-12-13
libxl, snapshot
1, Xen OPW project.
it is not selected by OPW finally.
1), VM Snapshots
http://wiki.xen.org/wiki/OutreachProgramForWomen/Round7#VM_Snapshots
Date of insert: 16/01/2013
Mentor: Anthony Perard <anthony.perard@citrix.com>
Difficulty: Medium
Skills Needed: C programming
Description: Although xl is capable of saving and restoring a running VM, it is not currently possible to create a snapshot of the disk together with the rest of the VM.
QEMU is capable of creating, listing and deleting disk snapshots on QCOW2 and QED files, so even today, issuing the right commands via the QEMU monitor, it is possible to create disk snapshots of a running Xen VM. xl and libxl don't have any knowledge of these snapshots, don't know how to create, list or delete them.
This project is about implementing disk snapshots support in libxl, using the QMP protocol to issue commands to QEMU. Users should be able to manage the entire life-cycle of their disk snapshots via xl.
The candidate should also explore ways to integrate QEMU disk snapshots and disk mirroring into the regular Xen save/restore mechanisms and provide a solid implementation for xl/libxl.
Outcomes:
Basic goal: disk snapshots can be handled entirely by xl.
Stretch goals: xl can automatically save a disk snapshot at the time of saving a VM. xl can also mirror the disk of a VM between two hosts and can do that automatically at the time of VM migration.
Steps:
Basic steps:
Study libxl APIs for storage
Study QEMU QMP commands for VM snapshots
Implement support for QMP snapshots commands in libxl
Implement VM snapshots functionalities in libxl using the QMP functions previously written
Add VM snapshot commands to XL
Stretch goals:
Add VM snapshot functionalities to libxl save/restore and migration functions
Evaluate QEMU QMP disk mirroring capabilities (QMP command "drive-mirror")
Implement support for QMP drive-mirror command in libxl
Hook disk mirroring into libxl VM save/restore and migration functions (migrating a VM from one host to another is also capable of migrating the VM disk from the two hosts).

2, plan
1), follow the steps above, try the basic step.

3, write a test code.
but qmp test fail.
libxl: error: libxl_qmp.c:315:qmp_handle_error_response: received an error message from QMP server: The command savevm has not been found

4, (16:42 2013-12-16)
the error in last week is because the parameter is wrong.(I guess)
i still do not know how to send the right savevm qmp command.

14:35 2013-12-13
software skill, network, get guest ip address, nmap; arp
1, nmap, ref"15:13 2012-11-22"1
SLES11Host:~ # nmap -sP -n 147.2.207.0/24 | grep 93 -B 1
Host 147.2.207.79 appears to be up.
MAC Address: 00:19:D1:E8:93:35 (Intel)
--
Host 147.2.207.123 appears to be up.
MAC Address: 52:54:00:42:54:93 (QEMU Virtual NIC)
--
Host 147.2.207.134 appears to be up.
MAC Address: 52:54:00:F6:C0:93 (QEMU Virtual NIC)
--
Host 147.2.207.156 appears to be up.
MAC Address: 00:21:70:93:B7:2D (Dell)
--
MAC Address: 78:2B:CB:7F:FD:3B (Unknown)
Host 147.2.207.193 appears to be up.

2, arp
SLES11Host:~ # arp -a | grep 93
? (147.2.207.134) at 52:54:00:f6:c0:93 [ether] on br0

21:46 2013-12-13
1, systemd is more suitable than sysv init in cloud system. because the hw of guest is changed rapidly.
2, continuous running system.
ZYpp, btrfs, snapper, grub2 bootloader integration.

23:04 2013-12-14
arm, kvm
If a KVM guest accesses memory that is outside its memory map (so no MMIO and no RAM), KVM will return -ENOSYS to userland, causing QEMU to do an abort() and kill the whole guest. This happens while executing dmidecode on ARM, which mmaps /dev/mem and scans the first Megabyte of memory for a DMI BIOS signature (sic!). Of course this is silly, but in any case crashing the whole guest does not seems appropriate. So lets mimic native hardware's behavior in this case and inject a Data Abort exception into the guest. In the previous case this will crash dmidecode with SIGSEGV, but keeps the guest alive.

I am not sure if this too coarse grained, but I just wanted to start discussion on this.

Signed-off-by: Andre Przywara <andre.przywara@linaro.org> ---arch/arm/kvm/mmio.c | 3 ++-1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/arch/arm/kvm/mmio.c b/arch/arm/kvm/mmio.c index 4cb5a93..04a105e 100644 --- a/arch/arm/kvm/mmio.c +++ b/arch/arm/kvm/mmio.c @@ -183,7 +183,8 @@ int io_mem_abort(struct kvm_vcpu *vcpu, struct kvm_run *run, return ret; } else { kvm_err("load/store instruction decoding not implemented\n"); - return -ENOSYS; + kvm_inject_dabt(vcpu, kvm_vcpu_get_hfar(vcpu)); + return 1; }

rt = vcpu->arch.mmio_decode.rt;

13:04 2013-12-16
sofware skill, fs, mount, chatset
> mount |grep sdb
/dev/sdb4 on /run/media/xxx/D439-F410 type vfat (rw,nosuid,nodev,relatime,uid=1001,gid=100,fmask=0022,dmask=0077,codepage=cp437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)
/dev/sdb4 on /var/run/media/xxx/D439-F410 type vfat (rw,nosuid,nodev,relatime,uid=1001,gid=100,fmask=0022,dmask=0077,codepage=cp437,iocharset=iso8859-1,shortname=mixed,showexec,utf8,flush,errors=remount-ro)

15:28 2013-12-16
GTD
0, 11:00-18:00

1, today
1), 15:30-16:25 work report. see"17:31 2013-12-12"
2), 16:42-17:51 try savevm qmp.

16:11 2013-12-16
software skill, suse, tools, fate
http://download.opensuse.org/repositories/FATE/openSUSE_12.3/

