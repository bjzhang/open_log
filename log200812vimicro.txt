14:25 2008-12-8
(11:02 2008-12-11)
新员工入职，网络设置，软件安装, vimicro入职文档1
zhangjian: 新员工入职培训位于研发记录簿p32-p35.
1，开始暂时借了一个笔记本，周四有了新机器（16层左手进去第二个写着销售部的房间）。
领新机器后，第一次启动蓝屏，使用安全模式也不行，后来使用“带命令行的安全模式”启动

2，找段晓辉（8688）分配ip地址：
-----------------------------
10.0.13.23, mask 255.255.254.0, 网关：10.0.0.3, 10.0.12.1
DNS: 10.0.8.16, 10.0.8.17
(13:44 2011-6-22)网关：10.0.12.1; DNS: 10.0.10.16, 10.0.10.17"13:44 2011-6-22"

3, 找李永罡加入域：
------------------
1), 改用户名，重启；
2), 域：vimicro.com，会要求输入用户名和密码，zhong, P/654321,李永罡提供。重启；
(13:15 2009-6-25)用户名密码问ZhongZengQun 8660"13:15 2009-6-25"
(18:37 2011-11-9)也可以用LuYao的, luyao@vimicro.com, Uu123456"18:37 2011-11-9"
3), 在用户管理中加入自己在vimicrom.com域的用户，这里是zhangjian。
如果不确定用户名，可以在添加->浏览中“输入要选择的对象”，例如zhang，再单击检查名称，输入上面李永罡的密码后，选择自己的用户名，系统会在添加新用户界面自动填写用户名和域。注销后用自己用户名和密码登录：姓名，Pp123456。首次登录需要修改密码。
4), 加入域后就可以进入portal(portal.vimicro.com)了。

4, 周报系统：姓名，1111111。我在IC-Division-Group1-Verification-4-1。不知道怎么改密码。

5, 软件服务器：
-------------
\\10.0.2.36。用户名：sqm，密码：sqm!#
参考"Freshman_Guide_V0.43.doc"(\\10.0.2.36\sqmshare\Utilities\FreshmanDoc)安装各种软件。
我安装了趋势杀毒，office2003（包括visio），daemon tools, winrar，winCVS，Eclipse,Putty,ultradit，sourceinsight等。
winCVS和Eclipse安装使用见"10:22 2008-12-9"。
另外：拼音加加，Editplus, msn，暴风影音。
注：拼音加加中输入“jt”可以输入今天日期，jt是软件设置的默认自带词库。

6，设置邮箱：
-----------
根据Freshman doc设置邮箱，为了保存个人信息方面，单独保存了自己的邮箱资料：
工具->电子邮件账户->“查看或更改现有电子邮件账户”->"新建Ootlook数据文件"->"Office Outlook 个人文件夹文件(.pst)"。
用临时机器时，无法使用邮件，提示用户名或密码错误。GONG Yan分析是由于密码没有修改所以账户不可用，建议我在其它已登陆域的电脑中登陆并修改密码。登陆密码就是邮箱密码。

7, 上网设置：
-----------
1), 按照文档提示设置上网工具(密码"MustChangePassword")，发现无法访问"http://10.0.10.3","http://10.0.10.4"。这是由于IE中局域网设置设置了代理服务器，把这两个地址加入exception列表中即可访问。
ftp的访问同理（ftp://10.0.2.109/）：mail.vimicro.com;10.0.8.15;portal.vimicro.com;10.0.8.3;10.0.8.14;10.0.2.208;10.0.10.3;10.0.10.4;10.0.2.109。
2), 找马桂军上网。
注：登录putty能自动打开firefox的原因：
[zhangjian@trm01 ~]$ cat .cshrc
setenv DISPLAY 10.0.13.23:1
firefox&

8, 改电话
---------
问前台（15层是8015）当前分机->找李永罡(8605, water)改电话分机为工号（7254）。

9, 社会保险
-----------
原单位开据的社会保险转移单已由春娇转给zhang wei。医疗保险需要15日之前给zhang wei这样就不会中断，其余情况：
请各位在12月15日前将你们的医疗保险手册交到人力资源部，从这个月起公司将给各位上保险和住房公积金．
如果在原单位没有上过保险的，请填写附件中的表格，尽快交到人力资源部．是外地户口的，请将户口本复印件一并交过来．
关于保险及公积金转移相关事宜，说明如下，请大家仔细阅读：
保险转移：
1). 除医疗保险以外险种转移，原单位停缴后，不需要开具转移单，新单位即可上缴；
2). 医疗保险转移：持医疗保险手册在原单位停缴后到新单位办理上缴。
公积金转移：
新开单位在为其上缴公积金，开具公积金开户证明后，交予本人，由本人递交给原单位，由原单位负责人办理公积金转移。

10, 打印机安装：
http://portal.vimicro.com/C13/打印机的安装方法/Document%20Library/HP8150打印机的安装方法(Beijing%20Office%2015层).mht
(20:56 2009-7-14)新打印机: ZhangMin邮件"转发:BJ15层新打印机更新驱动，请爱护使用"20090415_1009, 具体
没有安装过的打印机的用户，请参考
http://portal.vimicro.com/C13/打印机的安装方法/Document%20Library/HP5200打印机的安装方法(Beijing%20Office%2015层).mht
的安装方法，把8150的数据看成5200就可以了。

11, 注：
-------
1), 人力资源部位于16层，进门往左一直走，在左手边。门口有牌子。
2), outlook个人资料: 默认在“C:\Documents and Settings\zhangjian\Local Settings\Application Data\Microsoft\Outlook”，我一般是单独导出到自己的目录。因为c盘要备份，所以不留任何资料（包括桌面）。
目前outlook文件夹位于"D:\work\outlook". 具体修改方法是: 选项->电子邮件账户->新建个人文件夹: 选择适当目录保存, 保存后为个人数据取名, 注意不能与原来同名, 否则outlook会向两个文件夹同时操作. 
3), msn聊天记录: 我接受到的文件\用户名xxx。用户名xxx是指msn用户名，这是根据邮箱地址生成的固定字符串。

12, (14:35 2009-7-22)域控制器
如果登录本机, 或者远程桌面连接登录提示域控制器相关错误, 先退出域(加入工作组, 密码是本机密码(默认为空))再加入域(ZhongZengQun密码)可能可以解决问题. 

13, (13:45 2011-6-22)ghost系统后需要做什么? 
1), 如"12"所述重新加入域. 密码问ZhongZengQun.
2), 参考36 freshman guide里面的outlook补充说明设置outlook exchange server. 
设置outlook存档文件夹到D:\work\database\archive和D:\work\database\bak\archive
3), 安装perl.
4), 设置editplus ini file dir为: 
\\10.0.13.101\share\zhangjian\log\logAssistant\editplus_configuration

19:56 2008-12-8
(15:40 2008-12-9)
(14:38 2008-12-10)
下一步安排，待做完成
1，软件安装和使用
1), CVS：
安装CVS，学习使用方法，明天艾国会给我我的密钥。安装完成，使用艾国密钥check out了VC0830代码。
2), eclipse：
安装，学习.：需要Eclipse文档。
2, 了解项目：
0), 12月15日周会有人答疑，以"待做.*答疑"标识。
1), 看830芯片资料。优先看与Linux内核移植有关的部分：memory接口，定时器，中断控制器，uart，DMA；(转移）
2), 看启动代码：“D:\work\VC0830\code\VC0830\VC0830\bootloader”。(完成）
3), Linux内核选型和参考代码选择（不急）：优先考虑Liao zhicheng的2.6.25和at9261处理器代码。
3，看新人资料：(转移）
1), \\10.0.2.36\sqmshare\Utilities\FreshmanDoc\Doc
2), 公司portal上公司内控，期权等。
3), 周报。

19:57 2008-12-8
项目资料，文档，软件, VC0830, VC0816, mas
1，芯片资料：
830 mas: ftp://10.0.2.109/VC0830/ic/mas/
2，CVS：\\10.0.2.36\sqmshare\Utilities\Develop_Tools\WinCVS
3，Eclipse
\\10.0.2.36\sqmshare\Utilities\IDE\Eclipse

10:22 2008-12-9
软件安装，CVS，Eclipse, vimicro入职文档2
1, CVS：软件位置：“D:\work\software\WinCVS”，下载自10.0.2.36。
根据“CVS设置.doc”文档设置CVS，用aiguo的用户名和密钥没有问题。用zhangjian不行，估计是还没有开通我的账户。
其中：10.0.31.4是CVS服务器，"doing/public/methodology/ic-arch-verif/fpga_verif/VERIFY"是CVS目录。
下载了830代码到"D:\VC0830"，其中VC0830是CVS根目录。
注: 为了统一大家代码都放到"D:\VC0830".
问题解决: 
1), 如果提示目录无效, 建议cvs.exe与TortoiseCVS放同一目录,或加入路径. 可能是cvs.exe未加入路径. 加入用户或系统path即可, 例如我的"C:\Program Files\CVSNT\"
2), 如果提示cvsfail, 可能是没有加密钥. 启动pageant.exe后, 在任务栏中选择小帽子的右键菜单"add key"加入密钥. 
2，Eclipse：
1), 安装jdk-1_5_0_09-windows-i586-p和ESDE_V2-2_061128-Setup。
2), 导入830工程：
(1), 在Navigator中右键单击Import，选择弹出对话框中的“Select an import source: Existing Projects into Workspace”。
(2), 在"Select a root directory"，选择前面的CVS根目录"D:\work\830\code\VC0830"。导入完成后选择finish。
3), 问题：
a, 编译无法通过。
b, 导入工程文件都做了哪些配置？待做。


11:15 2008-12-9
(20:38 2009-1-7)
公司情况了解，待做
1, 各部门规模，digital, analog, software等，待做；
2, 830使用0.13um工艺，下一步打算使用90nm或65nm工艺。
3, 830芯片与pxa310类似用两级bootloader：
1), 第一级：片内32k rom，片内4k sram；
2), 第二级：片外nandflash，片外sdram或ddr。
如果系统比较简单，例如无操作系统或使用nucleus可能仅仅使用第一级bootloader，不使用第二级bootloader。
PXA310用三级bootloader，第一级是rom boot，第二级是obm，第三级是blob，blob引导Linux内核。
4, 有没有VC0830 Chip Specification（无）。
5, IC设计前端用的是Synopsys，后端呢？待做。
6, VC0830支持：VC1, RV8-10(RMVB)等格式。

17:17 2008-12-9
(14:21 2008-12-22)
VC0830学习，模块，深入了解，存储器，MARB，待做。
1, 0地址的重映射：
For software view, the 0x00000000 base address space is the virtual boot space, which can be remapped to ROM ( 0x10000000 ), or SDRAM ( 0x40000000 ), or EEPROM ( 0x30000000 ). The remap control is from PMU as pmu_marb_bootsel, and will be synchronized by marb.

2, Memory Arbiter (MARB) provides a unified interface for each module to access these memories and also for ARM to access control register file in each module. Total memory has unified address space from 0x0000_0000 to 0xFFFF_FFFF. 
there are eight modules use eight channels to access MARB: ARM instruction (ARMI)，ARM data (ARMD) or BIU，VDEC，LCDC，IPP，Storage，PDMA和DMAC。
the three memory blocks (SDRAM, ROM and APB-Bridge) can be simultaneously accessed by three different BUS masters.
1)	Only ARMI, ARMD can access ROM, and the burst can not be broken.
2)	Only ARMD can access control register in each module by APB Bridge 
3)	Support remap lowest 256Mbyte memory space to SDRM/DDR or ROM
4)	All masters shall use LITTLE ENDIAN notation.
And the 0x00000000 ~ 0x0FFFFFFF space can be mapping to ROM/SDRAM/EEPROM by the control of pmu.

Memory Map:
Memory		sizes (Bytes)	max valid address 
ROM		32K	0x10000000~0x10007FFF
SRAM		4K	0x20000000~0x20000FFF
SPI EEPROM		0x30000000~0x3FFFFFFF
SDRAM		256M	0x40000000~0x4FFFFFFF
Module Registers 256M	0x60000000~0x6FFFFFFF
这个map和p8页的图结合起来看，其中的AHB<->APB Bridge对应"Module Registers 256M	0x60000000~0x6FFFFFFF"。
此外，P11那张表也很重要，它描述了不同的Master之间访问memory space的权限。
ARMD/BIU和ARMI也就是CPU部分，能访问全部memory space,PDMA和Storage能访问SRAM和SDRAM。LCDC, DMAC, IPP, LCDC, VDEC只能访问SDRAM。
待做，疑问。什么情况下DMA和Storage需要访问SRAM？

3, 溢出的处理：
For ROM/SRAM/SDRAM/APB, there are address error detection in each master interface. Once the master burst request is overflow the address space, marb will break this transition into following pipeline, and store the error address into 0x6001000c as {1’b1, error_address[30:0]}. At the same time, if the error is caused by ARM/BIU, the error response will be feedback in AHB protocol. If the error is caused by other master, the interrupt vector related to the master will be set and send to IRQ.

17:42 2008-12-9
VC0830学习，模块，简单了解
0, 文档是VC0830mas文档，是每个模块的"Macro Architecture Specification"，不知有没有顶层的文档。如果没有标注跳过或略就是看过了模块的overview和框图。
1, bypass:
bypass的作用是使基带芯片不通过VC0830处理器直接控制连接到VC030上面的液晶屏。

2, clkrst：
负责时钟和复位。
The clkrst module generates clock and reset signals for VC0830 PSO power domain. It includes two portion:  clock controller and reset controller. PMU and RTC power domain have their separate clock and reset controllers.

3, DMAC
(15:11 2008-12-22)
兼容AMBA 3.0 AXI_lite规范，DMAC用于memory之间传送数据。
Compliance to the AMBA 3.0 Specification---AXI_lite protocol for easy integration into SoC implementation.
DMA controller module is used to process the software request of data transfer. It can transfer data between memories, It includes five submodules: dmac_ctrl, dmac_reg, dmac_irq and dmac_fifo (dmac_fifo_mem).
结合P7页和P14页：DMAC对外接口有AXI Master和APB Slave，前者是DMAC的Master Interface，后者是DMAC的AMBA Peripheral Bus Interface。

4, i2c，略；

5, ipp: the image post-processing unit. 
The image post-processing unit provides zoom control, special effect, re-size processing, OSD processing and data format conversion for image capture and display.
Support YUV422, YUV420 format and JPEG data stream when writing to MARB unit
Support YUV422, YUV420, YUV411, YUV444, YUV400 and RGB888 format when reading  from MARB unit

6, LBUF.
LBUF module is used to do data format transition for  hardware JPEG codec and software video codec. LBUF can support line mode and frame mode. There are two sets of memory space in MARB, as ping-pang architecture, used for LBUF to do data format transition. 
包括preshift( 0~255 <-> -128~+127)和yvu格式转换两部分功能。
四种工作模式：
1),Capture Image (use hardware JPEG codec)
Capture Datapath : 
SIF->IPP (capture sizer)->LBUF(line_write)->MARB->LBUF(block_read)->JPEG
2), Display image (use hardware JPEG codec)
Display Datapath : 
JPEG->LBUF(block_write)->MARB->LBUF(line_read)->IPP->LCDC
3), Capture video (use software video codec)
Capture Datapath: SIF->IPP (sizer)-> LBUF(line_write)-> MARB->Video codec
4), Display video (use software video codec)
Display datapath: Video codec->MARB -> LBUF(line_read) -> IPP -> LCDC -> LCDIF

7, SIF: The sensor interface

9:58 2008-12-10
VC0830学习，模块，简单了解，续
1, PERI: peripheral
自：“VC0830_KPD_MAS_V0.3”
The peripheral (PERI) module contains twelve submodules: PDMA, AUD, UART0, UART1, UART2, UART3, SPI1, SPI2, I2C, KPD, TPI, PWM.  Each module has its own base address for register mapping as follows, where PERI_BASE_ADDR is the base address for PERI module.  The KPD submodule base address  is set to 6004_9000H in VC0830.

Submodule	Submodule base address
PDMA	PERI_BASE_ADDR + 0000H
AUD	PERI_BASE_ADDR + 1000H
UART0	PERI_BASE_ADDR + 2000H
UART1	PERI_BASE_ADDR + 3000H
UART2	PERI_BASE_ADDR + 4000H
UART3	PERI_BASE_ADDR + 5000H
SPI1	PERI_BASE_ADDR + 6000H
SPI2	PERI_BASE_ADDR + 7000H
I2C	PERI_BASE_ADDR + 8000H
KPD	PERI_BASE_ADDR + 9000H
TPI	PERI_BASE_ADDR + A000H
PWM	PERI_BASE_ADDR + B000H
Reserved	PERI_BASE_ADDR + C000H

2, KPD: keypad
We can configure the 10-bit as output ports for C(column) or input ports for R(row) by writing to keypad control registers. R(row) are inputs of keypad module ,while C(column) are outputs of keypad module. 
The sum of R and C must be 10. The pad drive can be configured accordingly to support the keypad operation, i.e., the row input pins need to have internal pull-ups and the column output pins can be configured as open drain outputs. 

3, LCDC, 待做。
有三层：
A：YUV，链接ipp的视频；
----------------------
B：RGB，CPU数据；
----------------------
BG：单色，背景层。

Display layers
There are 3 layers to display on the LCD panel: layer A , layer B (B0 and B1) and background layer, layer B0/B1 shall be prior cover to layer A for most popular overlay application reverse to figure above in general.
Layers format
Layer A is YUV422 video frame data from the direct output of IPP module. It is rotated (if rotation needed) and merged with layer B,  then stored in merged frame buffer(MFB) by LCDC via AXI-system data bus. 数据来自ipp。
Layer B0 and layer B1 are the RGB format graphics data from the host CPU, which is stored in graphics buffer and can be accessed by LCDC via AXI-system data bus. 数据来自memory，通过MARB+AXI lite得到。
The background layer is monochrome as the color register which can be set by the host CPU, and shall be manual update by SW in DBI panel. 

4, LCDIF
========
Supports Display Bus Interface (DBI) output mode, compliant to the MIPI Alliance Display Bus Interface protocol v2.0. 待做：查DBI和MIPI Alliance。
Support dual LCD panels;
Supports Display Pixel Interface (DPI) output mode, compliant to the MIPI Alliance Display Pixel Interface protocol.
Support for CCIR656 interface;待做：查。
Support for UPS051&UPS052 interface.待做：查。
待做：疑问：为什么把LCDIF和LCDC分开？有什么好处？

5, MARB
=======
见"17:17 2008-12-9"。

6, NFC
======
有AXI和APB两个接口。

7, padc目录
===========
PIN-PAD CONTROL and PACKAGE
引脚定义，含义见"VC0830 Pin List v0.94.xls"

8, PDMA
=======
Peripheral DMA Controller (PDMA for abbreviate) sets one direct transfer path between the peripheral devices and the memory arbiter,
Use the AXI_Lite bus for easy integration into SoC implementation. 

9, PMU
======
根据VC0830处于AP(application processor)模式还是CP(co-processor)模式，PMU功能有所不同。
待做：这部分需要认真看看，排在"19:56 2008-12-8"2-2)中优先内容之后。

10, PWM, 跳过。待做：看。
=======

11, RTC, 跳过。待做：看。
=======

12, SARB:SUB MARB
=================
SARB is a general AXILITE bus multiplexer, which can package 1~8 AXILITE buses to 1 AXILITE bus with the main memory arbiter.
round-robbing priority for AXILITE masters 

13, SDIO, 跳过。待做：看。
========

14, SDRC: SDRAM Controller
==========================
Its main function is to convert internal master memory access timing to SDRAM access timing. In addition, it also controls other functions besides data access, such as the SDRAM initialization and refresh.

15, SPI
=======
已有详细分析日志，见"10:24 2008-12-22"。

16, timer, watechdog
====================
已有详细分析日志，见"14:20 2008-12-12"。
The vc0830 dual-timer module has two identical 32-bit programmable timers . The two counters operate from a common timer clock but with separate enable signals tmr_start for each timer, which gives flexible control of timers.

17, TPI, Touch Panel Interface
==============================
触摸屏接口使用逐次逼进型ADC，

待做：
x, Storage System. SDIO,nfc,usb都有AHB和APB连个接口。待做：看。
xx, 还有uart, udc三个目录没有看。

16:57 2008-12-10
计划，自"19:56 2008-12-8"，待做完成：
0, 由于明天下午四点开会，计划需要提前；
1, 看完所有模块的overview；
2, 初步看完bootloader。
基本文档：D:\work\VC0830\code\VC0830\VC0830\bootloader。
(21:29 2008-12-10)对bootloader有了基本的了解。明天可以考虑看看video部分了。
3, 初步看完video driver。（看的不多，本来是为了开会时便于理解卡看的，会议上没有涉及到，暂缓）

20:27 2008-12-10
VC0830代码阅读，bootloader
0, 这里分析的是二级bootloader吧。"VC0830\code\VC0830\vc0830_bootloader"是一级bootloader，"VC0830\code\VC0830\vc0830_bootloader\document"有文档，待做完成。
1, 简要说明：
===========
自："VC0830\code\VC0830\VC0830\bootloader\note.txt"
vc0830init.s为上电以后最开始的汇编代码（就和一般的44BINIT.s和2410init.s一样，但是使用的是GCC的伪指令）
功能如下：初始化时钟，关闭所有中断，初始化sdram，为cpu各个状态分配栈，将.data搬到运行时位置，将.bss段
清0，提供异常路由，IRQ路由。
vc0830_main.c提供系统级的软硬件初始化。
uart.c
newlibport.c
dev_uart.c
提供和newlib的接口，包括以最简单的方式使用串口和内存使用的桩脚函数。
bootscript.c
进入一级shell时，要执行的最初的命令脚本。

2, 汇编和c语言阶段。
GNU: vc0830init.s    ---"BL vc0830_main"--> vc0830_main()(vc0830_main.c)
ADS：vc0830adsinit.s ---"B __rt_entry"  --> __rt_entry()(vc0830_main.c) -> vc0830_main()(vc0830_main.c)
#ifdef USE_ADS_MODE
void __rt_entry(void)
{
	__rt_stackheap_init ();
	__rt_lib_init(); // Hua, must call it here. For detail, see http://www.arm.com/support/faqdev/1217.html	
	vc0830_main();
	__rt_lib_shutdown();
	_sys_exit();
}
#endif
大致了解VC0830代码后，可以考虑看ADS与GNU不同的部分，包括汇编和c，尤其是__rt_stackheap_init()，__rt_lib_init()的作用。

3, 汇编阶段
结合注释可以大致看懂。
疑问，待做完成：
1), arm从不同工作状态中返回时，PC如果跳转？待做完成：看《arm SOC体系结构》；
2), "Copy and paste .data, sdram4driver"这部分具体复制了什么东西？需要看下链接文件。NCNB sdram4driver含义。（转移），参见"14:46 2008-12-17"。
3), set_clockrst_pll_switch函数没有看，使用大量nop的目的？等待PLL生效

4, 后面有看了看c代码，感觉和汇编一样注释清晰代码易懂。

20:41 2008-12-10
如果加班，在"\\10.0.2.36\sqmshare\Share\jiaban"中填表。

20:59 2008-12-10
VC0830项目，疑问
1, arm926用什么协处理器？

18:46 2008-12-11
123abcABC。

18:47 2008-12-11
小组会议，Aiguo主持，VC0830
1, 目前有830, 816, 747, 347等项目。
其中347是摄像头芯片，747是监控芯片，816, 830是MP4芯片，816是830的简化版。
2, 后面可能有个usb连FPGA的软件要做。不懂：待做，关注。
3, 公司下一步要做SOC，SOC+DSP。
4, Aiguo希望Liao zhicheng两周内完成现有任务。可能意味着给我熟悉830芯片的时间也就是两周。
似乎Liao负责830项目nand和spi部分。
5, 830,816验证环境：两个virtex-4完成830/816芯片功能，这两个芯片在底板上。底板上有扩展接口连接外设：上面第一个是sdram/ddr接口；左侧有一个是sd卡，lcd，sensor, nand flash等的接口，其中nand flash有插座，可以用于烧写nand flash；下面有个接口是连接jtag，串口的。
FPGA上电后通过CF卡读取FPGA配置文件（RTL代码综合的结果）进行FPGA的配置。这个CF卡相当于一般FPGA板子上的prom，用CF卡配置FPGA，这样FPGA板子相当于是一个通用平台，插不同的卡跑不同的东西，便于IC设计，验证。

19:53 2008-12-11
计划，部分自"19:56 2008-12-8"和"18:47 2008-12-11"，待做
1, 写周报（取消）；
2, 看文档和代码：定时器（完成），中断控制器（完成），RTC，memory接口，uart，DMA。
3, 看其他未浏览的文档：见"17:42 2008-12-9"和"9:58 2008-12-10"
4, 看新人资料，见"19:56 2008-12-8"3;

21:05 2008-12-11
(18:05 2008-12-15)
VC0830，AASP，代码和文档
bamvor: aasp对于Linux移植影响不大，所以暂时不考虑细读，今晚是顺路看了看。如果没有特殊说明，代码都位于"D:\work\VC0830\code\VC0830\VC0830"。
0), 感觉AASP对于写测试程序的人来说，像是
(1), getopt, getlongopt这类参数解析程序；
(2), printk等调试辅助信息；
等等。可能AASP还有其他用途吧。待做，疑问。
1, 打印log：
//当AASP_DebugLevel不为0，且指定的打印级别小于AASP_DebugLevel，以及cond为真时才打印
#define AASP_PrintCond( ilev, cond, _x_) \
        if( AASP_DebugLevel && ( ilev <= AASP_DebugLevel ) && ( cond )) { \
			iprintf _x_ ; \
	}

#define AASP_Print( ilev, _x_)  AASP_PrintCond( ilev, true, _x_ )
注：
1), "_x_"是包含括号的完整printf参数。
2), 调试级别：
a, aasp.c(aasp):
int AASP_DebugLevel = DBGLVL_HIGH ; 
除此之外暂时没有找到可以修改调试级别的地方，难道不可以动态修改？待做：确认。
b, aasp.h(aasp):
// Defines for debug verbosity level
extern int AASP_DebugLevel; 
#define DBGSTR_PREFIX "AASP: " 

#define DBGLVL_OFF              0       // if AASP_DebugLevel set to this, there is NO debug output 
#define DBGLVL_MINIMUM			1		// minimum verbosity	
#define DBGLVL_DEFAULT			2		// default verbosity level if no registry override
#define DBGLVL_MEDIUM			3		// medium verbosity
#define DBGLVL_HIGH             4       // highest 'safe' level (without severely affecting timing )
#define DBGLVL_MAXIMUM			5		// maximum level, may be dangerous
这里的调试级别高意味着调试信息多，这和Linux一样。

2, aasp.h(aasp)
//关于__FUNCTION__这个变量可以参见一下gcc文档，gcc自动的在每个函数里面暗地里声明了如下变量
//static const char __func__[] = "function-name";所以就能用了，呵呵，一个 const字符数组
//只有函数名，没有参数哦
//Enter a function 以->xxx()表示
gcc4.2.4手册，p310:
"__FUNCTION__"是非标准的，不建议使用，gcc手册建议采用下面方法兼容：
#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2
# define __func__ __FUNCTION__
# else
# define __func__ "<unknown>"
# endif
#endif
"__PRETTY_FUNCTION__": c语言中与"__func__"相同，c++中是包括了类型的函数名，例如：

class a {
public:
void sub (int i)
	printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
}
"ax.sub (0)”的输出信息是：
__PRETTY_FUNCTION__ = void a::sub(int)

14:20 2008-12-12
VC0830，定时器timer，代码和文档
0, 结合timer.c和timer_test.c阅读文档。
The vc0830 dual-timer module has two identical 32-bit programmable timers . The two counters operate from a common timer clock but with separate enable signals tmr_start for each timer, which gives flexible control of timers.
1, PCLK: pclk: This clock times all the APB bus transfers. All signal timings are related to the rising edge of APB bus clock
2, timer base: 提供timer1, timer2的定时单位T：
T = TMRBASE * TMR_CLK period
TMRBASE是16位的，默认TMRBASE是16’h5dbf，默认TMR_CLK是24MHz，这样T=(23999+1)*(1/24000000)=0.001s，也就是定义timer1, timer2的时间单位是1ms。
疑问：timer.c中注释说下面语句是设置1us（微秒）中断：
Timer_TimerbaseSet(TIMER_MODULE_CLOCK);	
这个函数就是写的24，而不是上面写的23999.原因？！待做，疑问。
void Timer_TimerbaseSet(unsigned short int timerBase)
{
    HAL_WRITE_REG32(TIMER_TMRBASE,timerBase); 
}
3, timer1, timer2分别是32位，64位定时器。
1), TMR1_TGT, TMR2_TGTL, TMR2_TGTH。根据TMRBASE定义的时间单位T，TGT设置经过多少个T定时器到期。例如前面提到timer.c设置了T是1微秒，下面语句定义timer0 1ms定时。
Timer_Timer0TargetValueSet(1000);	
2), 为什么"//configure timer1 forever，//we don't want use us interrupt, that is a crash"？
3), 看门狗wdog_tgt的单位是wdog_clk。在看门狗作为普通定时器时wdog_clk与TMR_CLK相同，作为看门狗时暂时没有找到在哪里设置wdog_clk，

4, 用定时器实现微秒，毫秒，秒级延时。timer.c(timer)
1), 毫秒级延时：
volatile unsigned int msDelayCounter;
volatile unsigned int msTimerDelayFlag;

void timer0_isr(void)
{
    if (msTimerDelayFlag == 1)
    {
		msDelayCounter ++;
	}
	HAL_WRITE_REG32(TIMER_SRCPND,0x1);
}

void Timer_DelayMs(unsigned int ms)
{
	msDelayCounter = 0;
	msTimerDelayFlag = 1;
	if( msTimerDelayFlag == 1)
	{
		while (msDelayCounter < ms)	continue;
	}
	msDelayCounter = 0;
	msTimerDelayFlag = 0;
}
timer0_isr是timer0的中断处理程序，Timer_DelayMs实现实际的延时，完成延时后返回。二者通过volatile变量msTimerDelayFlag，msDelayCounter设置定时开始，判断定时结束。

2), 微秒级延时
void timer1_isr(void)
{
    HAL_WRITE_REG32(TIMER_SRCPND,0x1<<1);
}

void Timer_DelayUs(unsigned int us)
{
    unsigned long long us_basic_value = 0;
	unsigned long long us_target = 0;
	unsigned long long us_counter = 0;
	int us_timer_delay_flag = 0;
	
	us_basic_value = Timer_Timer1CurrentValueGet();
	us_target = Timer_Timer1TargetValueGet();
	us_counter = us_basic_value;
	if (us_target < (us_basic_value+us) )
	{
		us_timer_delay_flag = 1;
		while (((us_timer_delay_flag == 1)&&((us_target+us_counter-us_basic_value) < us))||(us_counter > us_basic_value)) 	
		us_counter = Timer_Timer1CurrentValueGet();
	}
	else
	{
		us_timer_delay_flag = 1;
		while ((us_timer_delay_flag == 1)&&((us_counter-us_basic_value) < us)) 	
		us_counter = Timer_Timer1CurrentValueGet();
	}
	us_counter = 0;
	us_timer_delay_flag = 0;
}
微秒的延时没有采取中断模式，timer1设定的溢出值是64个1，Timer_DelayUs中通过timer1计数值是否经过了“unsigned int us”判断是否到时。具体实现上区分延时时间是否超过了time1的溢出值—。如果没有超过很简单，如果超过了，判断两个情况：
a, 当前没有溢出：us_counter > us_basic_value满足。
b, 当前已经溢出：us_target+us_counter-us_basic_value满足。
如果a,b都成立，说明到时了。

3), 秒级延时：
volatile unsigned int sDelayCounter;
volatile unsigned int sTimerDelayFlag;

void wdog_isr(void)
{
    if (sTimerDelayFlag == 1)
    {
		sDelayCounter ++;
	}
	HAL_WRITE_REG32(TIMER_SRCPND,0x1<<2);
}

void Timer_DelayS(unsigned int s)
{
	sDelayCounter = 0;
	sTimerDelayFlag = 1;
	if( sTimerDelayFlag == 1)
	{
		while (sDelayCounter < s)	continue;
	}
	sDelayCounter = 0;
	sTimerDelayFlag = 0;
}

5, 不过这三个Timer_DelayXs函数，没有找到谁在用，可能是使用Timer_DoTimerX函数了：
void Timer_DoTimer0(unsigned int targetValue, aasp_ISR_t *timer0_isr)
{
    Timer_Timer0Stop();
    
    //clear second srcpend
    HAL_WRITE_REG32(TIMER_SRCPND,0x1);
    //unmask second srcpend
    HAL_WRITE_REG32(TIMER_UNMASK,0x1);
    
	//注册一级中断函数
	AASP_DRV_INTERRUPT_CREATE(CYGNUM_HAL_INTERRUPT_TIM0,
	                             8, // Priority
	                             (aasp_ISR_t *)timer0_isr,
	                             &TIMER0_handle,
	                             &TIMER0_intr);
	AASP_DRV_INTERRUPT_ATTACH(TIMER0_handle);
	//清除一级的intpend
	AASP_DRV_INTERRUPT_ACKNOWLEDGE(CYGNUM_HAL_INTERRUPT_TIM0);
	//unmask timer0的一级中断
	AASP_DRV_INTERRUPT_UNMASK(CYGNUM_HAL_INTERRUPT_TIM0);
	
    Timer_Timer0TargetValueSet(targetValue);	
    
    Timer_Timer0Start();
}
////////////////////////timer.c阅读完成/////////////////////////////

15:36 2008-12-12
VC0830，中断，代码和文档
中断号定义在interrupt.h(interrupt)。
注册中断的方法，以定时器为例：
1, 注册：
=======
为什么这里的注册中断函数需要用create和attach两个函数完成，感觉用一个函数完成就可以。待做完成，参考了其他opensouce的代码，为了更为通用。
timer.c(timer): 
//注册一级中断函数
AASP_DRV_INTERRUPT_CREATE(CYGNUM_HAL_INTERRUPT_TIM0,
         8, // Priority
         (aasp_ISR_t *)timer0_isr,
         &TIMER0_handle,
         &TIMER0_intr);
AASP_DRV_INTERRUPT_ATTACH(TIMER0_handle);
//清除一级的intpend
AASP_DRV_INTERRUPT_ACKNOWLEDGE(CYGNUM_HAL_INTERRUPT_TIM0);
//unmask timer0的一级中断
AASP_DRV_INTERRUPT_UNMASK(CYGNUM_HAL_INTERRUPT_TIM0);

2, 使用，
interrupt.c(interrupt):
//由于打开了cache 和 buf，而且使用了段表，所以以前44box，2410的那种存中断向量表的
//方式就不好用了，改为采用数组，但是数组在NCNB区域
//为了保证这段内存空间的安全，在前后各使用一个空数组，进行占位。
//前占位
unsigned int hal_interrupt_handler[100]  ;
//正经的中断向量表
unsigned int hal_interrupt_handlers[CYGNUM_HAL_ISR_COUNT]  ;
//后占位
unsigned int hal_interrupt_handlersa[100]  ;
待做，疑问：
1), 看2410 test_code中是如何存中断向量表的。
2), 打开cache和buf的目的？buf是否指bufferable?

11:40 2008-12-15
VC0830，定时器timer，代码和文档，续
/////////////////////timer_test.c阅读开始///////////////////////////
6, timer_test.c：
1, 数据结构
0), 待做：在适当位置总结Key，Subcmd结构体。
1), Timer_Key是key类型的结构体，如果按下"s"，会调用timer_stop()函数异步停止定时器isr；
2), Timer_cmds是Subcmd类型结构体，说明了命令名，命令帮助，命令回调函数这些内容，例如："delay", "Test timer delay (ms)", do_timer_delay。
1, 分析do_timer_delay()函数：
aasp相关函数稍后分析。
(15:04 2008-12-15)timer代码阶段性完成。

14:26 2008-12-15
VC0830，AASP，代码和文档，续
0, 编程模式，自"AASP_tutorial_LMread.pdf"。
0. 复制并修改suddir.mk
1. 包含aasp头文件及模块信息宏定义
2. 注册一级Shell命令
3a. 建立模块级命令表
3b. 调用命令行解释服务:AASP_CMDWAIT
4a. 建立属性表和参数表
4b. 调用参数解析服务:AASP_REQUEST/AASP_REQUESTMAIN
5a. 建立热键映射表
5b. 调用热键绑定服务:AASP_KEY_WAIT

1, 结合定时器代码，分析下列函数：
0), 参考"AASP.ppt"。
1), AASP_REQUESTMAIN：aasp shell命令行中输入的参数由AASP_REQUESTMAIN获取。命令运行时请求参数解析用AASP_REQUEST。
2), AASP_KEYWAIT_UNBLOCK：AASP_KEYWAIT和AASP_KEYWAIT_xxx是绑定热键及对应回调函数。
3), 
声明名为_cmd_tab_functionName的cmd类型结构体，并放在AASP_commands section。"AASP_commands" section的起始地址是"AASP_commands section"，结束地址是"__AASP_CMD_TAB_END__"。
__AASP_CMD_TAB__
(1), 
#ifdef USE_ADS_MODE
#pragma arm section rwdata="AASP_commands_do_timer"
struct cmd _cmd_tab_do_timer ={"timer", "Test timer and watchdog function and effect!", do_timer};
#pragma arm section code,rwdata
#else
AASP_cmd("timer",
			" Test timer and watchdog function and effect!",
           do_timer
    );
#endif

(2), 
考虑不使用ADS的情况：
aasp_shell.h(aasp):
/*
    以下这段，负责将AASP_cmd("help", "Help about help?", do_help );
    转变为：
    cmd_fun do_help;声明一个 函数变量。
    指定将结构体放到哪一个section并赋予初值
    struct cmd _cmd_tab_do_help ".aasp.table.AASP_commands.data.do_help" = {"help", "Help about help?", do_help};
*/
#define AASP_cmd(_s_,_h_,_f_) _cmd_entry(_s_,_h_,_f_,AASP_commands)

a, 
#define _cmd_entry(_s_,_h_,_f_,_n_)                                   \
cmd_fun _f_;                                                      \
struct cmd _cmd_tab_##_f_ CYG_HAL_TABLE_QUALIFIED_ENTRY(_n_,_f_) = {_s_, _h_, _f_};

a), 
typedef int cmd_fun(int argc, char *argv[]);
struct cmd {
    char    *str;
    char    *help;
    cmd_fun *fun;
};

b), 
#ifndef CYG_HAL_TABLE_QUALIFIED_ENTRY
#define CYG_HAL_TABLE_QUALIFIED_ENTRY( _name, _qual ) \
        CYGBLD_ATTRIB_SECTION(".aasp.table." __xstring(_name) ".data." \
                              __xstring(_qual))
#endif

(a), 
#define CYGBLD_ATTRIB_SECTION(__sect__) __attribute__((section (__sect__)))
aasp具体内容稍后分析。下面分析中断。
4), AASP_CMDWAIT，自lingming注释。
一旦调用这个函数，程序就会陷入子模块的子shell循环，该子shell只处理输入的本模块的命令，对于加了'!'号的1级命令也可以支持。

15:11 2008-12-15
VC0830学习，模块，简单了解，续，待做：补充完整。
1, IRQ，已有详细分析日志，见"15:12 2008-12-15"。

2, BIU: bus interface unit
--------------------------
1), The BIU (bus interface unit) receives the access signals from the Baseband Processor, and convert them into AHB bus protocol to access registers and memory of VC0830. In another word, the Baseband Processor can control the VC0830 chip by the BIU.
Internal standard bus: AHB bus;
The main quantity of BIU is following:
	Silicon area: 		66461.2 um*um, not include the interconnect area;
	Max frequency:	125MHz;
	Bandwidth:		48MB if VC0830 works at 96MHz with 16 bits baseband bus.
2), 结合Visio-VC0830 Chip Block Diagram 0.51
可以看到这两条AHB总线：
BIU/ARMD AHB Bus, ARM instruction AHB Bus. ARMD(ARM Data)
其中第一条总线通过Arbiter判定由BIU还是ARMD控制总线。
3), 待做：查TI Locosto。

15:12 2008-12-15
VC0830，中断irq，代码和文档
1, 对BIU只有IRQ没有FIQ。参见irq mas figure2-1。
2, interrupt controller register中有BIU 中断的相关设置，待看。
3, AASP_DRV_INTERRUPT_LEVEL设置中断优先级。中断优先级有16级，优先级相同者先执行中断号小者。所以每个中断源在中断优先级寄存器中占4位。
#define AASP_DRV_INTERRUPT_LEVEL 		davinci_interrupt_set_level
davinci_interrupt_set_level()(interrupt_drv.c(interrupt))：
感觉这个函数写的尤其不好。下面这个语句可以简化很多：
switch(Prio_reg_num)
{
	case 0:
	    HAL_READ_REG32(IRQ_PRIORITY1, IRQPrio);
	    IRQPrio &= 0xffffffff-(0x0000000f<<(Prio_vector_num*4));
	    IRQPrio |= level<<(Prio_vector_num*4);
	    HAL_WRITE_REG32(IRQ_PRIORITY1, IRQPrio);
		break;
	case 1:	
	    HAL_READ_REG32(IRQ_PRIORITY2, IRQPrio);
	    IRQPrio &= 0xffffffff-(0xf<<(Prio_vector_num*4));
	    IRQPrio |= level<<(Prio_vector_num*4);
	    HAL_WRITE_REG32(IRQ_PRIORITY2, IRQPrio);
		break;
	case 2:	
	    HAL_READ_REG32(IRQ_PRIORITY3, IRQPrio);
	    IRQPrio &= 0xffffffff-(0xf<<(Prio_vector_num*4));
	    IRQPrio |= level<<(Prio_vector_num*4);
	    HAL_WRITE_REG32(IRQ_PRIORITY3, IRQPrio);
		break;
	case 3:
	    HAL_READ_REG32(IRQ_PRIORITY4, IRQPrio);
	    IRQPrio &= 0xffffffff-(0xf<<(Prio_vector_num*4));
	    IRQPrio |= level<<(Prio_vector_num*4);
	    HAL_WRITE_REG32(IRQ_PRIORITY4, IRQPrio);
		break;
	default:
		break;
1), switch-case: IRQ_PRIORITY1-4地址相差4，完全可以算出来。
2), "IRQPrio &= 0xffffffff-(0xf<<(Prio_vector_num*4));"
为了给下个语句位置做准备——把对应位清零，这样做减法感觉挺费解的。直接取反多清楚。
(21:26 2008-12-16)
interrupt.c/h, interrupt_drv.c基本看完了。待做：明天看interrupt_video/audio.c/h。

17:07 2008-12-15
(11:49 2008-12-16)
待做完成：
1, 看完中断后，看Makefile.（完成）
2, 下载arm926文档。（完成）
3, 看完"17:09 2008-12-15"中的文档。（转移）

2008-12-18
(11:00 2008-12-17)
VC0830项目，文档
0, 先前没有注意"work\VC0830\code\VC0830\VC0830\document"目录。
1, AASP.ppt：AASP介绍和编程方法。"AASP_tutorial_LMread.pdf"与此类似。
2, "先进测试环境设计.pdf"，描述ATE和AASP的文档。从Ling ming的注释看，文档有点旧。
3, "builder user guide.txt"，build命令文档。
4, "coding_style.txt"，编码风格。重要！
5, "davinci Enviroment", VC0830开发环境介绍。
6, "gcc.pdf"，gcc官方文档。
7, "NCNB不可cache不可buf说明.doc"：对NCNB的情况的说明和代码修改方法。
8, "Nucleus PLUS源码分析.pdf"，Nucleus内核中文文档。
9, "sdramAssign.xls"，几种sdram分配方案。
10, "speed.xls"，似乎是测试性能（速度）的结果，没看懂。
11, "uCOS-II"，uconII书第一版的电子版。
12, "830-Video-Storage.pdf"，VC0830FPGA板video-storage FPGA子板原理图。包括LCD，SD/MMC，Touch Panel ADC（触摸屏ADC），Nand Flash，Sensor(Camera Senor，摄像头)等。
13, "libc.pdf"，Red Hat newlib C Library, Full configuration, 1.12.0。
14, "libm.pdf"，The Red Hat newlib C Math Library, 1.12.0。
15, "RealViewDebugger Getting Started.doc"，如何使用RVD调试器调试代码。
未知：
1, "01061701.doc"，未知。

16:10 2008-12-16
(19:18 2008-12-17)
(11:38 2008-12-18)
配置虚拟机，Fedora Core 10
0, 虚拟机采用的是NAT方式，DHCP分配地址有效期是356天。
1, 杂项配置：
1), 为Zhangjian加入root权限。
su	//切换为root用户
visudo	//修改sudo的配置文件：
查找"root.*ALL"，复制这行，把用户名从root改为Zhangjian，输入":wq"退出
exit	//退出root。
2), 用fdisk建立分区，并用mke2fs格式化Development盘；

2, 配置samba
1), 修改配置文件"/etc/samba/smb.conf"：
我的samba配置文件位于"work\log\samba\smb.conf"，主要内容如下：
[global]
	workgroup = VIMICRO
	server string = FedoraCore10_Embedded
	netbios name = Zhangjian_FC10
	security = share
[public]
	comment = Embedded
	path = /usr/src/embedded
	public = yes
	writable = yes
;	printable = no
;	write list = +staff
	guest ok = yes
	guest account = nobody
	create mask = 0666
	directory mask = 0777

其中security = share 表示不需要输入密码，guest ok = yes 表示允许使用默认的guest用户访问。
"create mask"和"directory mask"给所有用户都开了读写权限, 目录都有读写执行权限.
注: testparm可以检查smb.conf是否有语法错误, 用法: testparm path/to/smb.conf

2), 使用root权限执行脚本"/etc/init.d/smb restart"，重启smb服务。如果配置正确，可以通过smbclient访问：
[Zhangjian@ZhangjianFC10 src]$ smbclient -L //192.168.31.128
Enter Zhangjian's password: 
Domain=[VIMICRO] OS=[Unix] Server=[Samba 3.2.4-0.22.fc10]

	Sharename       Type      Comment
	---------       ----      -------
	IPC$            IPC       IPC Service (FedoraCore10_Embedded)
	embedded        Disk      Embedded Root Directories
Domain=[VIMICRO] OS=[Unix] Server=[Samba 3.2.4-0.22.fc10]

	Server               Comment
	---------            -------

	Workgroup            Master
	---------            -------

(14:27 2009-8-23)使用类似ftp的方式访问smb, 与windows 运行中访问方式类似只是把反斜杠替换为斜杠:
smbclient //Domain_or_ip/Sharename
这里的Domain是windows下的hostID(计算机名)
例如访问VIMICRO(192.168.31.218)的embedded目录. 
smbclient //192.168.31.218/embedded
或
smbclient //VIMICRO/embedded
"14:27 2009-8-23"

3), 关闭防火墙，设置selinux
(1), 关闭iptables："service iptables stop"。
(2), 设置selinux权限，
a, 方法一: 为samba目录加入访问权限：
chcon -l samba_share_t /usr/src
chcon -R -l samba_share_t /usr/src/embedded
b, 方法二: setsebool -P samba_export_all_rw on
c, 方法三: 关闭sellinux，命令行"setenforce 0", reboot. 

4), 这是可以在windows中通过//192.168.31.128访问了。
查看samba是否启动: "netstat -tlnp | grep smb" 

5), 修改/etc/rc.d/rc.local
service iptables stop
/etc/init.d/smb restart

参考资料：
1), "一步一学Linux与Windows 共享文件Samba （v0.2b）"配置smba服务器，"http://www.linuxsir.org/main/?q=node/158"，位置:"bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\软件设计\OS操作系统\linux\网络\工具"。
2), samba配置文件"/etc/samba/smb.conf"，里面注释很详细，包括对selinux的处理。
3), samba配置文件手册"man smb.conf"
4), selinux介绍："转载一些关于SElinux的中文资料，希望能给在samba,ssh方面的问题提供一些信息"
http://www.linuxsir.org/bbs/showthread.php?p=1808279
注：
1), 如果FC10未完全安装，可能缺少samba服务器程序(smbd，nmbd是否也在这个包中？)和perl convert ANS。从Fodeda10光盘中的rpm安装
2), "/etc/selinux/config"是selinux配置文件，其中设置了SELINUX=disable，但是selinux仍然在运行，不知道为什么。

9:46 2008-12-17
i386，中断学习，I/O APIC
I/O高级可编程中断控制器（I/O Advanced Programmable Interrupt Controller）。
Intel从PIII开始引入。
I/O APIC的组成：一组24线IRQ，一张24项的中断重定向表(Interrupt Rediection Table)，可编程寄存器，通过APIC总线发送和接收接收APIC信息的一个信息单元。
在SMP中一般使用下面的多APIC系统：
     CPU0的本地APCI				CPU1的本地APCI
(处理本地IRQ(LINT0, LINT1)）		(处理本地IRQ(LINT0, LINT1)）
	   ^						^
	   |						|
	   v						v
	   ------------中断控制器(ICC)总线---------------
				^
				|
				v
			    I/O APIC
				^
				|
			     外部IRQ
来自外部设备的中断请求以两种方式在可用CPU之间分发：
静态分发：IRQ信号传递给重定向表中相应项列出的本地APIC：一个特定的CPU，一组CPU或所有CPU（广播方式）‘
动态分发：根据进程优先级和仲裁优先级判断。
每个本地APIC都有一个可编程任务优先级寄存器(task priority register, TPR)，Intel希望OS内核中每次进程切换时修改此寄存器。中断会动态分发给任务优先级低的CPU。如果多个CPU的任务优先级最低且相同，根据仲裁优先级判断。仲裁优先级是0-15的数字，当有中断传给CPU时，此CPU的仲裁优先级设为0，其余CPU仲裁优先级加1。
待做：当仲裁优先级大于15时如何处理？

另外，如果没有APIC情况下，中断都会发给启动OS的CPU，一般是CPU0。自"linux-2.6.25.20\Documentation\i386\IO-APIC.txt"：
Without an IO-APIC, interrupts from hardware will be delivered only to theCPU which boots the operating system (usually CPU#0).

14:46 2008-12-17
VC0830，存储器分配，链接脚本，bootloader.SDRAM.lds
参考"NCNB不可cache不可buf说明.doc"，"sdramAssign.xls"。
NCNB是不可cache，不可buf的错写。
对于驱动来说使用NCNB的sdram4driver区域有两个方法，这里重要使用的是方法二——修改makefile。把驱动部分和测试部分的分开，驱动部分的文件是DRIVERC_SOURCES(NCNB)，测试部分文件保存在C_SOURCES。具体修改方法和例子见上面的NCNB参考文档。
此外，build.perl脚本中，可以通过"-sdram4driver"选项在编译的过程中支持将某些数据段放在不可cache不可buf的SDRAM里面。
section"sdram4driver"0x41E00000--0x41eff000保存驱动程序的全局和静态变量，约1M的区域。0x41eff000-0x41f00000这4k的内存用于ARM7 ARM9通信。0x41E00000--0x41f0000的1M区域都是NCNB的。
分析"bootloader.SDRAM.lds"中相关部分：
/*新分配方案(4bank use )，自bootloader.SDRAM.lds
type				start addr			end addr		len				CB情况
Text(ro)			0x40000000			0x40400000	0x400000	4M		cNb
Data(rw),bss(zi)	0x40400000			0x40D00000	0x900000	9M		cb
					
Mmu ttb				0x40400000			0x40408000	0x8000		cb
Newlib				Bss end				0x40D00000			 	cb
					
NCNB_Malloc			0x40D00000			0x41D00000	0x1000000	16M		NCNB
lcdc mergerbuf		0x41D00000			0x41E00000	0x100000	1M		NCNB
"sdram4driver
最后4K通信"			0x41E00000			0x41F00000	0x100000	1M		NCNB
cpu Stack			0x41F00000			0x42000000	0x100000	1M		cb
ISR					
Nucleus					
*/
/* for 32 m */
	MEMORY
	{
	    rom 	: ORIGIN = 0x00000000, LENGTH = 0x00400000
	    ram 	: ORIGIN = 0x40400000, LENGTH = 0x00900000
	    sdram 	: ORIGIN = 0x41E00000, LENGTH = 0x000ff000
	}
.sdram4driver :  
AT ((LOADADDR (.rodata) + SIZEOF (.rodata) + 4 - 1) & ~ (4 - 1)) 
{ 
	__ram_sdram_data_start = ABSOLUTE (.);
	
	libsdram4driver.a(.data .data* .bss .bss* COMMON COMMON*)
	*(.sdram4driver*)
	
	__ram_sdram_data_end = .; 
	PROVIDE (__ram_sdram_data_end = .);		
} > sdram 
__rom_sdram_data_start = LOADADDR (.sdram4driver); 

PROVIDE (__rom_sdram_data_end = LOADADDR (.sdram4driver) + SIZEOF(.sdram4driver));
//...

ld文档，每个section的基本结构如下：
     SECTION [ADDRESS] [(TYPE)] :
       [AT(LMA)] [ALIGN(SECTION_ALIGN)] [SUBALIGN(SUBSECTION_ALIGN)]
       {
         OUTPUT-SECTION-COMMAND
         OUTPUT-SECTION-COMMAND
         ...
       } [>REGION] [AT>LMA_REGION] [:PHDR :PHDR ...] [=FILLEXP]

You can assign a section to a previously defined region of memory by using `>REGION'
所以上面的">sdram"的结果是把sdram4driver的section设置为"sdram"，而"sdram"的起始地址是0x41E00000，长度是0x000ff000。

12:16 2008-12-18
待做：
1, 看Linux定时器相关代码。
2, 找Liao要Linux下GNU编译器。针对s3c2440和at9261编译Linux2.6.25内核。（取消）
3, 看VC0380项目Makefile.

14:21 2008-12-18
Linux2.6.25.20，arm926
目前此内核中支持了arm926的板子有：
[Zhangjian@ZhangjianFC10 configs]$ pwd
/usr/src/embedded/linux-2.6.25.20/arch/arm/configs
[Zhangjian@ZhangjianFC10 configs]$ grep ARM926.*=y 
at91cap9adk_defconfig:CONFIG_CPU_ARM926T=y
at91sam9260ek_defconfig:CONFIG_CPU_ARM926T=y
at91sam9261ek_defconfig:CONFIG_CPU_ARM926T=y
at91sam9263ek_defconfig:CONFIG_CPU_ARM926T=y
at91sam9rlek_defconfig:CONFIG_CPU_ARM926T=y
netx_defconfig:CONFIG_CPU_ARM926T=y
ns9xxx_defconfig:CONFIG_CPU_ARM926T=y
omap_h2_1610_defconfig:CONFIG_CPU_ARM926T=y
omap_osk_5912_defconfig:CONFIG_CPU_ARM926T=y
pnx4008_defconfig:CONFIG_CPU_ARM926T=y
realview_defconfig:CONFIG_CPU_ARM926T=y
s3c2410_defconfig:CONFIG_CPU_ARM926T=y
versatile_defconfig:CONFIG_CPU_ARM926T=y
令人费解的是s3c2410是定义了ARM926T=y，它应该是920t啊。

16:17 2008-12-18
VC0830，Linux，调试
将来如何对Linux内核进行调试？
如果用RVD进行调试，工位PC装虚拟机跑Linux。在实验室没法进行编译，等于就得实验室和工位来回跑。
这样的话还不如做个Linux服务器，从实验室连到Linux服务器进行编译。
其实问题的关键就是从实验室能不能编译Linux。如果实验室能远程登录虚拟机也可以。

17:52 2008-12-18
Linux，arm，启动代码，分析，脚本和Makefile
从vmlinux.lds.S(arch\arm\kernel):
OUTPUT_ARCH(arm)
ENTRY(stext)
可以看出arm linux的入口点是stext。为什么用.S结尾？Makefiles.txt(Documentation\kbuild)其中提到：
	When the vmlinux image is built, the linker script
	arch/$(ARCH)/kernel/vmlinux.lds is used.
	The script is a preprocessed variant of the file vmlinux.lds.S
	located in the same directory.
	kbuild knows .lds files and includes a rule *lds.S -> *lds.
也就是说，*.lds是*.lds.S预处理的结果。详见"16:07 2008-12-24"。
而且在Makefile(arch\arm\kernel)中有语句：
extra-y := $(head-y) init_task.o vmlinux.lds
见"16:07 2008-12-24"

->stext位于head.S(arch\arm\kernel)

->head.S最后会"#include "head-common.S"，此文件会调用"b	start_kernel"启动内核，进入"17:31 2008-11-21"提到的c语言阶段，执行start_kernel函数。

目前无mmu的arm soc（待做：查是哪些芯片）也进入了Linux主线代码，对于无mmu的arm其入口stext位于"head-nommu.S(arch\arm\kernel)"。

(18:28 2008-12-18)
参考"http://hi.baidu.com/operationsystem/blog/item/e90e55221324c0559922ede2.html"，分析，待做，补充。
Makefile(arch\arm\boot):
ZRELADDR    := $(zreladdr-y)
zreladdr-y定义在"Makefile.boot(arch\arm\{MACHINE})"，例如"arch\arm\mach-s3c2410":
   zreladdr-y	:= 0x30008000
params_phys-y	:= 0x30000100

vmlinux.lds.S
SECTIONS
{
#ifdef CONFIG_XIP_KERNEL
	. = XIP_VIRT_ADDR(CONFIG_XIP_PHYS_ADDR);
#else
	. = PAGE_OFFSET + TEXT_OFFSET;
#endif
PAGE_OFFSET，在定义了MMU情况下"memory.h(include\asm-arm)"：
/*
 * Page offset: 3GB
 */
#ifndef PAGE_OFFSET
#define PAGE_OFFSET		UL(0xc0000000)
#endif

TEXT_OFFSET见"11:04 2008-12-19"，Makefile(arch\arm)。

11:04 2008-12-19
Linux，arm，启动代码，分析，脚本和Makefile，续，待做：该Makefile很多问题，还需要再看。
1, Makefile(arch\arm)分析：
LDFLAGS_vmlinux	:=-p --no-undefined -X
CPPFLAGS_vmlinux.lds = -DTEXT_OFFSET=$(TEXT_OFFSET)
OBJCOPYFLAGS	:=-O binary -R .note -R .note.gnu.build-id -R .comment -S
GZFLAGS		:=-9
#KBUILD_CFLAGS	+=-pipe
# Explicitly specifiy 32-bit ARM ISA since toolchain default can be -mthumb:
KBUILD_CFLAGS	+=$(call cc-option,-marm,)

# Do not use arch/arm/defconfig - it's always outdated.
# Select a platform tht is kept up-to-date
KBUILD_DEFCONFIG := versatile_defconfig

//定义MMUEXT。如果MMUEXT未定义是有MMU的SOC，否则是无MMU的SOC。用于定义head-y时使用对于的head${MMUEXT}.o
# defines filename extension depending memory manement type.
ifeq ($(CONFIG_MMU),)
MMUEXT		:= -nommu
endif

ifeq ($(CONFIG_FRAME_POINTER),y)
KBUILD_CFLAGS	+=-fno-omit-frame-pointer -mapcs -mno-sched-prolog
endif

ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
KBUILD_CPPFLAGS	+= -mbig-endian
AS		+= -EB
LD		+= -EB
else
KBUILD_CPPFLAGS	+= -mlittle-endian
AS		+= -EL
LD		+= -EL
endif

comma = ,

//待做，补充

//后面就是head.o和内核的相对运行地址：
//-----------------------------------
#Default value
//待做："//Makefile (arch\arm\kernel):head-y			:= head$(MMUEXT).o"
//两个文件都是定义head-y，但是内容不同。
head-y		:= arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o
//如果machine有特殊的textofs，在定义machine部分设置。
textofs-y	:= 0x00008000
这里的init_task.c是与具体平台无关的，其实arm和x86平台的init_task.c也相差不大。
初始化fs_struct, files_struct, signal_struct, sighand_struct, mm_struct, thread_union, task_struct这些结构体/联合：init_fs, init_files, init_signals, init_sighand, init_mm, init_thread_union, init_task。从文件名看应该是任务相关的结构体。

//下面是定义machine和machine相关特殊配置
//--------------------------------------
machine-$(CONFIG_ARCH_S3C2410)	   := s3c2410
machine-$(CONFIG_ARCH_AT91)	   := at91
//如果有特殊的textofs：
ifeq ($(CONFIG_ARCH_SA1100),y)
# SA1111 DMA bug: we don't want the kernel to live in precious DMA-able memory
 textofs-$(CONFIG_SA1111)	   := 0x00208000
endif
//如果incdir和machine的名字不同：
 machine-$(CONFIG_ARCH_OMAP1)	   := omap1
 machine-$(CONFIG_ARCH_OMAP2)	   := omap2
  incdir-$(CONFIG_ARCH_OMAP)	   := omap
//其他特殊配置，略。

//定义TEXT_OFFSET，INCDIR，MACHINE和FASTFPE
//-----------------------------------------
//对浮点数的支持见"11:44 2008-12-19"。
//GZFLAGS：没有查到GZFLAGS在哪里使用，也没有查到"%.gz"规则（包括Make隐含规则）
//(13:37 2008-12-29)暂时只查到cmd_gzip: "cmd_gzip = gzip -f -9 < $< > $@"。待做，继续。
//待做：GZFLAGS MMUEXT，下午继续。
# The byte offset of the kernel image in RAM from the start of RAM.
TEXT_OFFSET := $(textofs-y)

ifeq ($(incdir-y),)
incdir-y := $(machine-y)
endif
INCDIR   := arch-$(incdir-y)

ifneq ($(machine-y),)
MACHINE  := arch/arm/mach-$(machine-y)/
else
MACHINE  :=
endif

export	TEXT_OFFSET GZFLAGS MMUEXT

# Do we have FASTFPE?
FASTFPE		:=arch/arm/fastfpe
ifeq ($(FASTFPE),$(wildcard $(FASTFPE)))
FASTFPE_OBJ	:=$(FASTFPE)/
endif

# The byte offset of the kernel image in RAM from the start of RAM.
TEXT_OFFSET := $(textofs-y)

//定义machine相关的目录，影响core-y和drivers-y
//--------------------------------------------
# If we have a machine-specific directory, then include it in the build.
core-y				+= arch/arm/kernel/ arch/arm/mm/ arch/arm/common/
core-y				+= $(MACHINE)
//...
core-$(CONFIG_ARCH_S3C2410)	+= arch/arm/mach-s3c2440/
//...
core-$(CONFIG_FPE_NWFPE)	+= arch/arm/nwfpe/
core-$(CONFIG_FPE_FASTFPE)	+= $(FASTFPE_OBJ)
core-$(CONFIG_VFP)		+= arch/arm/vfp/

//定义公共platform目录，将来移植VC0830, VC0816等系列SOC是否需要呢？如果为了简单可以830移植中不使用，将来再加入。
//待做：查。看功能platform目录起的作用。
# If we have a common platform directory, then include it in the build.
//...
core-$(CONFIG_PLAT_S3C24XX)		+= arch/arm/plat-s3c24xx/
//...

drivers-$(CONFIG_OPROFILE)      += arch/arm/oprofile/
drivers-$(CONFIG_ARCH_CLPS7500)	+= drivers/acorn/char/
drivers-$(CONFIG_ARCH_L7200)	+= drivers/acorn/char/

//定义lib，包括memxxx, strxxx,  内核用户数据交换(copy_from_user, copy_to_user)等。
//待做：查。这里lib/与$之间有个空格，似乎含义就不一样了。
libs-y				:= arch/arm/lib/ $(libs-y)

# Default target when executing plain make
ifeq ($(CONFIG_XIP_KERNEL),y)
KBUILD_IMAGE := xipImage
else
KBUILD_IMAGE := zImage
endif

//使用正则表达式":[^=]"，查找，发现这是否是第一个规则。也就是调用
//arch\arm\Makefile，会执行all规则，编译KBUILD_IMAGE，对于我们是zImage。
all:	$(KBUILD_IMAGE)

boot := arch/arm/boot

#	Update machine arch and proc symlinks if something which affects
#	them changed.  We use .arch to indicate when they were updated
#	last, otherwise make uses the target directory mtime.

include/asm-arm/.arch: $(wildcard include/config/arch/*.h) include/config/auto.conf
	@echo '  SYMLINK include/asm-arm/arch -> include/asm-arm/$(INCDIR)'
ifneq ($(KBUILD_SRC),)
	$(Q)mkdir -p include/asm-arm
	$(Q)ln -fsn $(srctree)/include/asm-arm/$(INCDIR) include/asm-arm/arch
else
	$(Q)ln -fsn $(INCDIR) include/asm-arm/arch
endif
	@touch $@

archprepare: maketools

PHONY += maketools FORCE
maketools: include/linux/version.h include/asm-arm/.arch FORCE
	$(Q)$(MAKE) $(build)=arch/arm/tools include/asm-arm/mach-types.h

# Convert bzImage to zImage
bzImage: zImage

//待做：查。此句不懂。
//$(Q)见""对顶层Makefile的分析，是"@"或""，也就是是否显示这条命令。
zImage Image xipImage bootpImage uImage: vmlinux
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@

zinstall install: vmlinux
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $@

CLEAN_FILES += include/asm-arm/mach-types.h \
	       include/asm-arm/arch include/asm-arm/.arch

# We use MRPROPER_FILES and CLEAN_FILES now
archclean:
	$(Q)$(MAKE) $(clean)=$(boot)

# My testing targets (bypasses dependencies)
bp:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/bootpImage
i zi:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $@


define archhelp
  echo  '* zImage        - Compressed kernel image (arch/$(ARCH)/boot/zImage)'
  echo  '  Image         - Uncompressed kernel image (arch/$(ARCH)/boot/Image)'
  echo  '* xipImage      - XIP kernel image, if configured (arch/$(ARCH)/boot/xipImage)'
  echo  '  uImage        - U-Boot wrapped zImage'
  echo  '  bootpImage    - Combined zImage and initial RAM disk' 
  echo  '                  (supply initrd image via make variable INITRD=<path>)'
  echo  '  install       - Install uncompressed kernel'
  echo  '  zinstall      - Install compressed kernel'
  echo  '                  Install using (your) ~/bin/installkernel or'
  echo  '                  (distribution) /sbin/installkernel or'
  echo  '                  install to $$(INSTALL_PATH) and run lilo'
endef


11:46 2008-12-19
Linux，arm，浮点数运算
1, 内核对浮点数运算的支持，在Floating point emulation中：
NWFPE, FASTFPE和VFP。前两个是模拟，VFP似乎是硬件支持。
但是内核的模拟是通过未定义指令处理的，如果浮点运算很多会降低效率。

2, arm gcc对浮点数运算的支持
使用arm gcc实现软件模拟或硬件浮点算法比内核模拟效率高。-mfloat-abi=soft要求所有程序都要用这个参数。-mfloat-abi=softfp没有这个要求。
`-mhard-float'
     Generate output containing floating point instructions.  This is
     the default.

`-msoft-float'
     Generate output containing library calls for floating point.
     *Warning:* the requisite libraries are not available for all ARM
     targets.  Normally the facilities of the machine's usual C
     compiler are used, but this cannot be done directly in
     cross-compilation.  You must make your own arrangements to provide
     suitable library functions for cross-compilation.

     `-msoft-float' changes the calling convention in the output file;
     therefore, it is only useful if you compile _all_ of a program with
     this option.  In particular, you need to compile `libgcc.a', the
     library that comes with GCC, with `-msoft-float' in order for this
     to work

`-mfloat-abi=NAME'
     Specifies which ABI to use for floating point values.  Permissible
     values are: `soft', `softfp' and `hard'.

     `soft' and `hard' are equivalent to `-msoft-float' and
     `-mhard-float' respectively.  `softfp' allows the generation of
     floating point instructions, but still uses the soft-float calling
     conventions.

3, 参考资料：
1), PXA310 平台上的浮点数支持方案研究，"http://blog.csdn.net/zjujoe/archive/2008/06/27/2592780.aspx"。
2), 交叉GCC与浮点处理，"http://blog.chinaunix.net/u/30686/showart_355691.html"。

4, 待做，疑问。
VC0830中是否支持？似乎v5te不支持；应该用哪个参数？似乎是"-mfloat-abi=softfp"

15:37 2008-12-19
Linux，arm，启动代码，分析，顶层Makefile，续
//Q和quiet的作用
//# If $(quiet) is empty, the whole command will be printed.
//# If it is set to "quiet_", only the short version will be printed. 
//# If it is set to "silent_", nothing will be printed at all, since
//# the variable $(silent_cmd_cc_o_c) doesn't exist.
//如果定义了"KBUILD+VERBOSE"是1，则："quiet=quiet_"，"Q = @"。
//顶层Makefile中如果命令行中传递了变量"V"，把V值赋给KBUILD_VERBOSE。否则KBUILD_VERBOSE是0。
//内核注释：这样可以把更多精力放在warning上。
例子："16:07 2008-12-24"

17:33 2008-12-19
Aiguo，学习VC0830进展
1, 中断：一般来说VC0830中断都是二级中断。
2, bootloader: 计划从sd卡启动，主要为了开发方便。
linux bootloader: 需几项工作，放在什么位置（sd卡？）。
3, Visio-VC0830 Chip Block Diagram 0.51。中红线是memory相关的东西，一般是连接master和memory。memory一共有八个master。
4, 查
ftl format

18:17 2008-12-19
VC0830学习，模块，简单了解，续
1, vdec: video decoder。包括7170 ip core和RV解码器。

10:24 2008-12-22
VC0830学习，模块，简单了解，续
1, SDIO
待做：trans-flash和micro-sd有什么区别？

16:22 2008-12-22
计划：
1, 继续项目文档和代码；
2, Linux启动相关；
3, 编译器。

17:46 2008-12-22
GNU，编译器，gcc，交叉编译
1, www.kegel.com/crosstool，crosstool：交叉编译的自动化脚本。
2, 现在基本了解了crosstool的编译过程，打算今晚编译，看看缺什么patch。
参考已有文章和脚本。
3, (20:20 2008-12-22)明天尝试编译。
4, 可下载编译器的网站：
1), http://www.gnuarm.com

11:09 2006-12-23
今天虚拟机网络不通。
重启后无法正常启动，无论是否启动vmware tools，都会在"Start service local"后停止。

11:40 2008-12-23
项目文档，资料，待做
1, 看"D:\work\Documentation\arm 综合培训"。
2, 看下面服务器文档
现在服务器上的文档比较乱，但主要是在这两个目录下：
 \\10.0.2.36\sqmshare\Document
 \\10.0.2.36\sqmshare\Knowledge
现在window ce的文档我们尽量放在一起吧，大家最好把具体的文档名字写清楚：
  \\10.0.2.36\sqmshare\Document\WindowsCE
  Linux的文档比较乱，也比较多，我们暂时先分开，以后来整理，主要有以下几个目录：
     \\10.0.2.36\sqmshare\Document\Linux
     \\10.0.2.36\sqmshare\Knowledge\OS\Linux
     \\10.0.2.36\sqmshare\Knowledge\linux （新的文档暂时放在这里）

15:50 2008-12-23
toolchain，工具链，crosstool
0, crosstool是脚本工具，只要制定工具链版本和参数就可以自动下载并编译出工具链。感觉上是可以把建立工具链的主要精力集中到版本的搭配问题。
用crosstool主要有三部分工作：
1), build.sh脚本，可以参考demoxxx.sh。主要是设置目录，设置环境变量，调用顶层脚本。
2), 设置环境变量：arch_xxx.dat和gccxxx_glibcxxx.dat两个文件，需要设置系统结构相关，gcc，binutils，glibc等的版本，参数等；
3), 顶层脚本：all.sh。包括下载，打补丁，编译等工作。
1，复制demo-armv5b-softfloat.sh为build.sh。
2，armxxx.dat中是处理器的配置。
建立arm-vimicro.dat，删除了"GLIBC_EXTRA_CONFIG="--without-fp""。即使硬件没有FP，OS也会仿真的。
暂时没有加入"GLIBC_EXTRA_CC_ARGS="-finline-limit=10000""
3，需要下载：
 ftp://ftp.gnu.org/pub/gnu/glibc/glibc-linuxthreads-2.9-20081222.tar.bz2
4, i686-host-pc_gnu-linux-ar命令未找到。简单起见，直接用符号链接解决。待做。

参考资料：
1, http://hi.baidu.com/arm_dsp/blog/item/86709b51f3c2fd2143a75b15.html
2, http://blog.chinaunix.net/u1/58780/showart_1076533.html 

17:22 2008-12-23
Linux，代码阅读，启动
Linux非压缩内核启动的要求，自head.S(arch\arm\kernel):
 * This is normally called from the decompressor code.  The requirements
 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags pointer.

18:10 2008-12-23
文档阅读，work\Documentation\Linux\Linux2，自"11:40 2008-12-23"，
1, 试玩UML(User Mode Linux)
利用用户模式Linux学习Linux内核。

10:43 2008-12-24
Linux，代码阅读，启动，续
结合liao文档看相关代码。
head.s(arch\arm\boot\compressed):
用下列语句判断是否是用户模式：
mrs	r2, cpsr	@ get current mode
tst	r2, #3		@ not user?
为什么只是测试低两位是否有11呢？难道因为只有User模式低两位是00？听起来挺合理的。

14:26 2008-12-24
Linux，代码阅读，启动，续
为了便于分析代码利用arm-linux-gcc4.1.1编译"at91sam9261ek_defconfig"配置。
使用下列步骤编译两次（其中其二次加参数V=1，这样显示编译时全部命令，便于分析）：
make distclean
make at91sam9261ek_defconfig
make 
编译日志加入到sourceinsight中。

16:07 2008-12-24
Linux学习, 移植, 代码阅读, 启动, c语言阶段, 其它移植相关分析, vmlinux.lds分析, "vimicro_Linux移植文档"4-11-1, DONE
11, 其它移植相关分析
1), vmlinux.lds分析
(1), vmlinux.lds(arch\arm\kernel)是内核vmlinux的链接脚本. 由vmlinux.lds.S (arch\arm\kernel), vmlinux.lds.h(include\asm-generic)预处理得到.
vmlinux.lds的生成语句：
  arm-linux-gcc -E -Wp,-MD,arch/arm/kernel/.vmlinux.lds.d  -nostdinc -isystem /usr/src/embedded/personal/olympia/pxalinux/toolchain/arm-linux-4.1.1/bin/../lib/gcc/arm-iwmmxt-linux-gnueabi/4.1.1/include -D__KERNEL__ -Iinclude  -include include/linux/autoconf.h -mlittle-endian   -DTEXT_OFFSET=0x00008000 -P -C -Uarm -D__ASSEMBLY__ -o arch/arm/kernel/vmlinux.lds arch/arm/kernel/vmlinux.lds.S
命令来自Makefile.build(scripts):
# Linker scripts preprocessor (.lds.S -> .lds)
# ---------------------------------------------------------------------------
quiet_cmd_cpp_lds_S = LDS     $@
      cmd_cpp_lds_S = $(CPP) $(cpp_flags) -D__ASSEMBLY__ -o $@ $<

$(obj)/%.lds: $(src)/%.lds.S FORCE
	$(call if_changed_dep,cpp_lds_S)
if_changed_dep会调用cmd_cpp_lds_S，根据Q定义为quiet还是空确定显示"quiet_cmd_cpp_lds_S"还是"cmd_cpp_lds_S"。

16:08 2008-12-24
Linux学习, 移植, 代码阅读, 启动, c语言阶段, vmlinux.lds分析, 续
预处理vmlinux.lds.S涉及到的参数说明：
-Wp,MD,arch/arm/kerenl/.vmlinux.lds.d
           -Wp是使用-E情况下专用的，用于给preprocessor直接传递参数，与"-Wl"类似，只是后者是把参数直接传给linker。但文档中不建议使用。arch/arm/kernel/.vmlinux.lds.d未找到，"-MD"的作用暂时不了解，待做。
           You can use -Wp,option to bypass the compiler driver and pass
           option directly through to the preprocessor.  If option contains
           commas, it is split into multiple options at the commas.  However,
           many options are modified, translated or interpreted by the
           compiler driver before being passed to the preprocessor, and -Wp
           forcibly bypasses this phase.  The preprocessor’s direct interface
           is undocumented and subject to change, so whenever possible you
           should avoid using -Wp and let the driver handle the options
           instead.

       -MD -MD is equivalent to -M -MF file, except that -E is not implied.
           The driver determines file based on whether an -o option is given.
           If it is, the driver uses its argument but with a suffix of .d,
           otherwise it takes the name of the input file, removes any
           directory components and suffix, and applies a .d suffix.

           If -MD is used in conjunction with -E, any -o switch is understood
           to specify the dependency output file, but if used without -E, each
           -o is understood to specify a target object file.

           Since -E is not implied, -MD can be used to generate a dependency
           output file as a side-effect of the compilation process.

       -nostdinc，不搜索系统标准目录中的头文件。
           Do not search the standard system directories for header files.
           Only the directories you have specified with -I options (and the
           directory of the current file, if appropriate) are searched.

       -isystem dir，头文件搜索目录，在"-I"后和系统标准目录头文件前使用。
           Search dir for header files, after all directories specified by -I
           but before the standard system directories.  Mark it as a system
           directory, so that it gets the same special treatment as is applied
           to the standard system directories.  If dir begins with "=", then
           the "=" will be replaced by the sysroot prefix; see --sysroot and
           -isysroot.

       -mlittle-endian
           Generate code for a processor running in little-endian mode.  This
           is the default for all standard configurations.

-P
           Inhibit generation of linemarkers in the output from the
           preprocessor.  This might be useful when running the preprocessor
           on something that is not C code, and will be sent to a program
           which might be confused by the linemarkers.

-C
           Do not discard comments.  All comments are passed through to the
           output file, except for comments in processed directives, which are
           deleted along with the directive.

           You should be prepared for side effects when using -C; it causes
           the preprocessor to treat comments as tokens in their own right.
           For example, comments appearing at the start of what would be a
           directive line have the effect of turning that line into an
           ordinary source line, since the first token on the line is no
           longer a #.

11:17 2008-12-25
Linux, arm, 启动代码, 分析, 脚本和Makefile, 续, "if_changed"分析, <TODO>补充</TODO>
自："16:07 2008-12-24"
if_changed, if_changed_dep, 以及if_changed_rule等定义在Kbuild.include(scripts):
# Execute command if command has changed or prerequisite(s) are updated.
#
if_changed = $(if $(strip $(any-prereq) $(arg-check)),                       \
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	echo 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd)

# Execute the command and also postprocess generated .d dependencies file.
if_changed_dep = $(if $(strip $(any-prereq) $(arg-check) ),                  \
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	scripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).tmp;\
	rm -f $(depfile);                                                    \
	mv -f $(dot-target).tmp $(dot-target).cmd)

1, 参考："Linux 2.6内核Makefile分析", 自："http://blog.csdn.net/mbtrend/archive/2008/10/05/3016889.aspx"。
2, if_changed作用: "如同if_changed  的名称一样，如果命令行改变，则会重新生成"
自: 请教：关于编译内核生成的cmd文件, xpl:
"http://linux.chinaunix.net/bbs/thread-1062669-1-1.html"


11:52 2008-12-25
软件技巧，sourceinsight，待做：arm汇编
detect comment不应选中，如果选中后，需要在detect comment中加入.#后，#if, .equ就可以被识别了。
arm汇编的格式还是有问题。以后再解决。

14:25 2008-12-25
(15:56 2009-1-9)
(11:45 2009-2-1)
Linux学习，移植，arm，启动代码，分析，内核前传, "vimicro_Linux移植文档"2, DONE0206
二, 内核前传
这里分析bootloader准备内核启动环境到vmlinux开始运行前涉及到的移植相关问题. 
内核启动前, 需要为内核准备启动环境. 并把压缩内核zImage(如果根文件系统是ramdisk, 还包括ramdisk)载入到memory. 压缩内核会解压缩内核并把内核搬移到内核启动地址, 此后PC跳转到内核启动地址, 开始内核启动. 内核启动分汇编阶段和c语言阶段. 汇编阶段代码Liao zhicheng"linux启动分析.doc"已经有详细分析, 这里不再详细说明.

1, bootloader为Linux内核准备启动环境:
arm Linux启动条件是(arch\arm\kernel\head.S): 
MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags pointer. 
1), 这里的machine nr是后文machine_desc.nr, arm linux中每种开发板对应一个. 
2), atags pointer: 是bootloader传给kernel的atags的起始地址. atag可以描述内核启动所需的部分信息, 例如memory大小, 使用何种lcd屏等等, 这样可以提高Linux内核的灵活性. 例如我们可以用一个内核+不同tag参数测试一组lcd屏. 
3), 把zImage复制到指定地址.

2, 内核自解压阶段
自解压阶段涉及到uart和watchdog两个硬件, 参考文档："porting_to_new_arm_platform=++.pdf"，p9，"Early Init".
1), uncompress.h(include\asm-arm\plat-s3c)中定义arch_decomp_setup()和putc()供"decompress_kernel()"调用. 
注意内核自解压阶段不能调用Linux内核的函数, uart和watchdog函数需要自行定义.

2), 函数分析：
head.s (arch\arm\boot\compress)
    ->decompress_kernel()(arch\arm\boot\compress\misc.c)
        ->arch_decomp_setup()

(1), decompress_kernel()分析:
 * 1, 调用"arch_decomp_setup"为解压缩内核初始化相关硬件，该函数假设uart已经由初
 * bootloader始化。
 * 2, 调用"gunzip()"解压缩内核. 解压缩前后调用putc输出字符串;

(2), "arch_decomp_setup()"(include\asm-arm\plat-s3c)分析:
 * 根据CPU类型确定fifo_mask和fifo_max。
 * 初始化并使能Watchdog，如果Watchdog超时会产生复位信号。

3, 内核启动--汇编语言部分
内核解压缩成功后实现内核vmlinux启动, 这里只对移植相关内容做说明
1), 内核入口地址
vmlinux.lds.S(arch\arm\kernel)指明Linux内核入口是"stext":
ENTRY(stext)

"stext"在Makefile(arch\arm)定义:
arch\arm\kernel\head.S:
	.section ".text.head", "ax"
	.type	stext, %function
ENTRY(stext)

注意到它位于".text.head"section, 这个section在"vmlinux.lds.S(arch\arm\kernel)"定义:
#ifdef CONFIG_XIP_KERNEL
	. = XIP_VIRT_ADDR(CONFIG_XIP_PHYS_ADDR);
#else
	. = PAGE_OFFSET + TEXT_OFFSET;
#endif
	.text.head : {
		_stext = .;
		_sinittext = .;
		*(.text.head)
	}

所以内核入口地址是"PAGE_OFFSET + TEXT_OFFSET",arm linux中有这两个变量都有默认值:
"memory.h (include\asm-arm)":
#ifndef PAGE_OFFSET
#define PAGE_OFFSET		UL(0xc0000000)
#endif

"Makefile(arch\arm)":
textofs-y	:= 0x00008000
TEXT_OFFSET := $(textofs-y)

PAGE_OFFSET是系统memory 1:1 映射的起始地址(详见4.3节), 所以内核实际位于物理memory+0x8000, 对于s3c2440是0x30008000.

注: 
a, 实际链接脚本"vmlinux.lds"由"vmlinux.lds.S"生成, 详见"vmlinux.lds"分析.
b, "textofs-y"也可以由开发板定义的.

2), machine type在mach-types定义. 编译内核时由awk脚本gen-mach-types根据mach-types生成mach-types.h(include\asm-arm):
awk -f arch/arm/tools/gen-mach-types arch/arm/tools/mach-types > include/asm-arm/mach-types.h || { rm -f include/asm-arm/mach-types.h; /bin/false; }
具体生成的三个内容：
```````````````````
a, MACH_TYPE_xxx
b, machine_arch_type
c, machine_is_smdk2440(): 系统运行时判断是否此种machine--"machine_arch_type==MACH_TYPE_xxx"
mach-types格式如下；
```````````````````
machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
smdk2440	MACH_SMDK2440		SMDK2440		1008

移植成功后可以去arm linux网站http://www.arm.linux.org.uk/developer/machines/?action=new申请新的machine nr。
machine_desc在后面专门分析，这是移植中比较重要的结构体。
根据"Kernel Notes for Machine Developers", 只能用"if (machine_is_xxx())"的形式测试machine number.
自: http://www.arm.linux.org.uk/developer/kernelnotes.php. 
You should not test the value of machine_arch_type nor __machine_arch_type directly since this will give you less efficient code than the above. You should definitely not use a switch() statement, since this does not allow any code to be optimised away. If you have a group of machines that you want to check, use the following:
    do {
        if (machine_is_ebsa285()) {
            ...;
            break;
        }
        if (machine_is_cats()) {
            ...;
            break;
        }
        ...
    } while (0);

(1), 检查atag指针是否有效, 在Liao zhicheng"linux启动分析.doc"已有说明. 

(2), 汇编启动阶段需要一些变量相对于结构体的偏移量, 在asm-offsets.c(arch\arm\kernel)，定义偏移地址, 编译内核时经过  asm-offsets.s(arch\arm\kernel)->asm-offsets.h(include\asm-arm)生成汇编语言所需的变量.
具体是asm-offsets.c的DEFINE宏中第一个参数的值定义为第二个参数。BLANK()产生一个空行。例如：
  BLANK();
  DEFINE(PROC_INFO_SZ,		sizeof(struct proc_info_list));
转为
"

#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
"

文档中提到.s->.h通过awk脚本实现的，暂时没有找到这个对应脚本. 参考：Standard way of generating assembler offsets=++.txt, 网址"http://marc.info/?l=linux-kernel&m=100219616028442&w=2"和"http://www.linuxforum.net/forum/showflat.php?Cat=&Board=linuxK&Number=660113"。

18:01 2008-12-25
待做:
1, 继续"14:25 2008-12-25"；
2, 整理12月25日下午会议内容。文档。
ARM training，文档见"work\Documentation\arm 综合培训"。
1), Trace interface port是什么？（完成）
2), Write back PATAG RAM是什么？（完成）
3), irq的最小反应周期是7？确认。（未查到，可能需要arm9e参考手册）
4), arm9中编译器是否处理ldr引起的互锁问题。（未查到）
5), 830中断向量表是否可以放在低地址和高地址。应该是与大端，小端无关的。（完成）
看arm vimicro trainning.pdf 向量表举例页。大约是p60.
复习arm处理器模式和异常模式。（完成）
6), 异常（尤其是中断）嵌套时，CPSR如何保存？软件是否根据是否嵌套有不同处理？
7), 软件断点，硬件断电的实现方式。
8), AMBA总线：AXI, AHB, APB介绍和性能差异。
9), MARB编程。
3, "11:42 2008-12-26"上午会议，830寄存器读写测试

13:30 2008-12-26
同事，财务，Zhao linmei，PWC6年+生育

14:17 2008-12-26
项目资料, VC0830, Dragon, 寄存器属性, 寄存器测试
VS.net的Dragon 测试工具
寄存器测试，在vc工程共有文件描述了每个模块的每个寄存器属性：名称，地址，属性（RW, RO, WC, RC, W1C, W0C。W1C表示写1清零）, mask（表示每个寄存器中哪几位是有用的）等。

14:25 2008-12-26
待做<DONE>：
1, 下载ARM9TDMI Technical Reference Manual

14:52 2008-12-26
ARM学习，ARM926EJ-S
1, 关于ARM926EJ-S的一些特性：
1), Embedded Trace Macrocell (ETM)，嵌入式测试宏单元
----------------------------------------------------
连接在ARM926外，SOC片内的ETM进行trace，trace信息由SOC片外的Trace Port Analyzer (TPA)获得。
ARM920t的框图中称为Trace Interface Port，TIP连接的就是ETM。
To support real-time trace, the ARM926EJ-S processor provides an interface to enable
connection of an Embedded Trace Macrocell (ETM). For more information on the
ETM, see the ETM9 Technical Reference Manual. 
(1), Trace Port: A trace port is required to understand the operation of the processor.
(2), Triggering facilities.
The ETM is used to compress the trace information and export it through a narrow trace
port. An external Trace Port Analyzer (TPA) is used to capture the trace information.
待做：下载
a, ETM9 Technical Reference Manual
b, ARM9EJ-S Technical Reference Manual.

2), Tightly-Coupled Memory (TCM) interface.
-------------------------------------------
TCM见ARM_ARM p823.
看起来是提到存储器效率，可以使4KB到1MB的memory有很高的效率。
暂时不是很理解。待做：查找，下载。找进一步文档。参考已有的arm926 SOCdata sheet，例如at91的。

3), Write back PA TAG RAM
-------------------------
关于DCache: 
The caches are four-way set associative, with a cache line length of eight words per line, 32 bytes per line, and with two dirty bits in the DCache.
PATAG RAM属于DCache的组成部分。但在arm920t中Write back PATAG RAM在DCache外，二者功能应该类似。
arm920t中PA TAG RAM用于DCache需要Write Back时，根据PA TAG中指明的物理地址把数据写回memory。
arm926ej-s:
DCache保存每个DCache entry对应的PA tag供write-back时使用。VA tag保存在tag RAM。这样MMU不参与DCache write back操作，这就避免了TLB miss与write-back地址的关系。原文：
The DCache stores the Physical Address (PA) tag corresponding to each DCache entry in the tag RAM for use during cache line write-backs, in addition to the Virtual Address tag stored in the tag RAM. This means that the MMU is not involved in DCache write-back operations, removing the possibility of TLB misses related to the write-back address.

4), ARM中断和处理器模式
-----------------------
(1), 向量表的位置
由CP15的寄存器1(Control Register)决定：
V (bit[13]) This bit is used to select the location of the exception vectors:
0 = Normal exception vectors selected (address range 0x00000000-0x0000001C)
1 = High exception vectors selected (address range 0xFFFF0000-0xFFFF001C).
An implementation can provide an input signal that determines the state of this bit after
reset.
(2), 处理器模式和中断模式复习
处理器模式：
Processor   mode  Mode number Description
User        usr   0b10000     Normal program execution mode
FIQ         fiq   0b10001     Supports a high-speed data transfer or channel                                  process
IRQ         irq   0b10010     Used for general-purpose interrupt handling
Supervisor  svc   0b10011     A protected mode for the operating system
Abort       abt   0b10111     Implements virtual memory and/or memory protection
Undefined   und   0b11011     Supports software emulation of hardware                                         coprocessors
System      sys   0b11111     Runs privileged operating system tasks (ARMv4 and                               above)
中断模式：
Exception type			Mode	   VEa	Normal	   High vector
						address	   address
Reset				Supervisor	0x00000000 0xFFFF0000
Undefined instructions		Undefined	0x00000004 0xFFFF0004
Softwareinterrupt (SWI)		Supervisor	0x00000008 0xFFFF0008
Prefetch Abort (instruction	Abort		0x0000000C 0xFFFF000C
fetch memory abort)
Data Abort (data access		Abort		0x00000010 0xFFFF0010
memory abort)
IRQ (interrupt)			IRQ	    0	0x00000018 0xFFFF0018
					    1	IMPLEMENTATION DEFINED
FIQ (fast interrupt)		FIQ	    0	0x0000001C 0xFFFF001C
					    1	IMPLEMENTATION DEFINED
Notes: The normal vector at address 0x00000014 and the high vector at address 0xFFFF0014 are reserved for future expansion.
bamvor: 0x00000014本来用于处理早期采用26位地址的arm产生地址异常。现在文档中说可以用于未来扩展。

(3), 中断返回地址的确定
Exception Return instruction	Previous state(r14_x)	Notes
or entry			ARM     Thumb Jazelle
SWI	  MOVS PC, R14_svc	PC + 4  PC+2	-	Where the PC is the address
							of the SWI or Undefined
UNDEF	  MOVS PC, R14_und	PC + 4  PC+2	-	instruction. Not used in
							Jazelle state.
PABT	  SUBS PC, R14_abt, #4	PC + 4	PC+4  PC+4	Where the PC is the address
							of instruction that had the
							Prefetch Abort.
FIQ	  SUBS PC, R14_fiq, #4	PC + 4	PC+4  PC+4	Where the PC is the address
							of the instruction that was
IRQ	  SUBS PC, R14_irq, #4	PC + 4	PC+4  PC+4	not executed because the
							FIQ or IRQ took priority.
DABT	  SUBS PC, R14_abt, #8	PC + 8	PC+8  PC+8	Where the PC is the address
							of the Load or Store
							instruction that generated
							the Data Abort.
RESET	  NA			-	-	-	The value saved in r14_svc
							on reset is UNPREDICTABLE.
BKPT	  SUBS PC, R14_abt, #4	PC + 4	PC+4  PC+4	Software breakpoint.

后面的notes说明了返回地址如何计算。

关于二次进入同一异常状态的问题。
System programmers need to be careful about such interactions. The usual way to deal with them is to
ensure that the appropriate version of R14 does not hold anything significant at times when nested
exceptions can occur. When this is hard to do in a straightforward way, it is usually best to change to another
Programmers’ Model
ARM DDI 0100I Copyright © 1996-1998, 2000, 2004, 2005 ARM Limited. All rights reserved. A2-9
processor mode during entry to the exception handler, before re-enabling interrupts or otherwise allowing
nested exceptions to occur. (In ARMv4 and above, System mode is often the best mode to use for this
purpose.)

杂：
当处理器处于ARM状态时，所有指令必须word 对齐，因为pc值由bits [31:2]决定,bits [1:0] 未定义。
当处理器处于Thumb状态时，所有指令必须haldword 对齐，因为pc值由bits [31:1]决定,bits [0] 未定义。
(19:02 2008-12-26)
待做：未完，看xterm01上未完成pdf，并整理文档，继续完成。

17:57 2008-12-26
摄像头，sensor
1, 自：VC0830_FPGA_TestReport.xls
名称	类型	size
MI1320	YUV	640x480	
MI2010	YUV	640x480		
ov9655	YUV	1280x1024		
MI360	YUV	640x480		
s5k4aa	YUV	640x480		
MI1320	CCIR656	640x480		
ov2640	JPEG(带头）	1600x1200		
ov2010	JPEG(不带头）	640x480	1600x1200

2, 自：VC0830_FPGA_StorageTestReport.xls
Ominivision	OV7660	YUV/RGB	0.3M
	OV9640	YUV/RGB	1.3M
	OV9650 	YUV	1.3M
	OV9660	YUV/RGB	1.3M
	OV2640	RGB	2M
	OV3630	RGB	3M
Micron	MI1310	YUV/RGB	1.3M
	MI1320  	YUV/RGB	1.3M
	MT9D111(MI2010SOC)	YUV/RGB	2M

10:51 2008-12-29
组内同事信息，(软件工程师, Vimicro Corp.
1, 蔡进 (Jin CAI), caijin@vimicro.com
010-68948888-7089
13810090788
2, 吕博学
Tel: 68948888-8475, 13683199696
Email: lvboxue@vimicro.com MSN: netboxue@hotmail.com
3, 冯备战
Tel: 8610-68948888-8255
Fax: 8610-68944075
mobile:13810890945
E_Mail: fengbeizhan@vimicro.com

12:38 2008-12-29
午饭：
1, "12:39 2008-12-29"liao，4.88

15:02 2008-12-29
待做
1. 看VC0830bootloader。
2. start_kernel。与移植有关内容认真分析，无关内容梳理关系。

16:22 2008-12-29
文档，《复兴之路》
讨论记录："work\Documentation\《复兴之路》小组讨论会议记录"
1, 感觉自己真实不太会表达。但有可能是知识结构不同。
2, 《复兴之路》上说的改革，大家都有发言。其实我认为，改革其实说着容易但具体做起来很难。我认为说改革首先要有长远的目标，长远目标的制定需要有理论做指导。

19:14 2008-12-29
公司信息，项目
1, 747计划2009年6月做demo(linux)（与另一组合作），2009年年底流片，计划采用65nm。目前830 Linux移植一方面是将来提供830 Linux方案；另一方面也是为747 Linux移植积累。
2, VC0830 bootloader review
自Ai guo 2008/12/30 15:19邮件：
接下来，我们会重点review bootloader，我们首先在组内review，接着我们叫上所有相关的人review，这个是下个礼拜的重点工作。

17:52 2008-12-30
社会保险，待做
每月13日前，把“户口簿，身份证，劳动合同”的原件复印机给单位，可以补缴。
由于中星微一月份才会帮我上好保险，所以2月13日前给这些资料可以补上12月的四险（养老，工伤，失业及生育）。
据Zhangwei说停缴一个月影响不大，待做：查实。
听说社会保险每月25日后停止办理，未查证。
经验：看来换工作的时候必须注意停缴这个事情，如果是医疗停缴就很麻烦了。

18:17 2008-12-30
FPGA，Achronix
号称1.5G的世界上最快的FPGA，没有细看，想知道跑CPU能多快。
http://www.achronix.com/index.php

18:51 2008-12-30
公司制度，报销，请假
work\Documentation\杂项

20:09 2008-12-30
学习，项目学习，VC0830
6点多时Aiguo过来问我今天进展。自己完全没有准备。以后可能每隔1-2天注意一下我的进度。

13:42 2008-12-31
VC0830学习，VC0830 bootloader
1, Bootloader 512 INFO
0), 512 info中每部分后面都留有reserve位，这样便于扩展。学习ing。
1), 文档中提到的存放“指定份数”，具体情况如何？
2), 待做，疑问：“padc 12个寄存器的值,由于都要配，所以不用存地址”。前面sdramRegAddr和sdramRegVal是否是有选择的配置寄存器？
3), Nand Info。待做，疑问
(1), 现在nand flash page最大是多大？
“page的大小512;2048;4096，现在只支持到4K。”
(2), Spare区是什么？
4), 待做，查：nand flash的cache模式，plane模式，ftl含义。
关于FTL: 参考文档"Understanding the Flash Translation Layer (FTL) Specification.pdf"，位置"bamvor张健的文档\micro微电子与计算机\Embeded嵌入式系统\存储器\flash闪存"

16:43 2008-12-31
项目资料，VC0830，MAS
format rule for register MAS.rar：包括MAS寄存器表格的要求及范例
位置：work\VC0830\Documentation

18:47 2008-12-31
(20:35 2009-1-6)
VC0830学习，VC0830 bootloader，代码阅读
0, 
===========
1), VC0830基础
--------------
(1), <转移至"16:23 2009-3-16">自：YangZuoXing邮件"答复: about pso and pmu module"20090104_1544, 关于VC0830的电源域及复位对不同电源域的映像
下面列出的受影响的寄存器指恢复为默认值。
RTC 电源上电后，会产生RTC域的RESET,此RESET会RESET RTC域的寄存器。不影响PSO/PMU的寄存器。
830主电源上电后，会产生XRESET,此RESET会RESET, PMU/PSO域的寄存器。不影响RTC域。
从SLEEP唤醒后，会产品PMU_HW_RESET,此RESET会RESET PSO域的寄存器。不影响RTC/PMU域。
WATCHDOG RESET, 会RESET 除TIMER/WATCHDOG模块的以外的所以PSO域寄存器。不影响RTC/PMU域。(待做：待Lv pin确定，查邮件)
域的划为：
Pso: Sif, Ipp ,Lcdc ,Vdec ,Udc ,Nf ,Sdio ,Uart/spi/i2c ,Tpi ,Aud ,Pdma ,Dmac ,Marb ,Sdrc ,Cpu ,Clkrst ,Timer/watchdog ,Biu
Pmu: Pmu_top, Pad/padc, Abi, Lcd bypass, Sar adc(触摸屏？待做：查)
Rtc: Rtc

(2), bootloader的启动条件：
power on, reset, watchdog, sleep中恢复，cp模式中lcd bypass转为nomal，cp模式中从sleep恢复。其中power on, reset, watchdog三者对于bootloader本身没有影响。

2), VC0830 Bootloader基础
------------
(1)链接脚本
vc0830bootloader.rvd.lds是用于RealView Debugger调试的。

1, 汇编阶段：
===========
这里的汇编阶段说明的是rom boot的情况。SPI boot后，从pll初始化部分二者。
1), 硬件初始化
待做，疑问。对下面的语句不理解。待做，deal cp15 至 warm_reset间代码为具体分析含义。
/* allow access to all coprocessors */
    ldr     r0, =0x2001           
    mcr     p15,0,r0,c15,c1,0
但是《Arm926ejs_Technical Reference Manual_r0p5》P204：
Use the following Debug and Test Address Register instruction to access a main
TLB entry:
MCR p15, 0, <Rd>, c15, c1, 0 ; select TLB entry

2), 为进入第二阶段（c语言阶段）做准备：
我理解从“warm_reset:”开始是为第二阶段做准备：
(1)，把bootloader从片内rom复制到片内sram。
(2), 清空bss段，bss段是未初始化数据段，使用前应该都是0；
(3), 切换CPU进入SVC状态并设置SVC状态下堆栈。
汇编语言中定义了堆栈栈顶：
.equ	SVCStack,	0x20001000                  //512bytes
但lds文件没有完全看懂，没有理解其中“0x20000c00到0x20001000, 0.5K,  SVC状态stack”的含义。待做。
(4), 跳入c语言，“Cyg_Start”是入口：
bl	Cyg_Start

2, c语言阶段
============
待做，见"16:14 2009-1-4"。
