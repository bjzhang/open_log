14:39 2007-11-01
QT, QEmbed
QEmbed是一个在QT中直接嵌入文件和图像的工具，位于"qt/tools/qembed"，参见"qt/doc/html/qembed.html"。

15:38 2007-11-01
QT学习，待做
examples/iconview/main.cpp中，ListenDND类继承了QObject类。分析这段代码，也许可以解释威盛那道题----什么情况下我们需要从QObject继承？
另外，"iconview/main.cpp"中，dropped信号的作用不明白，什么是drop信号？

15:58 2007-11-01
周四周五的工作还没有具体计划，这点不好。
总的计划是完成包括与FV通信部分的用户注册的界面设计。不包括数据库。尽量完成Validator。
感觉真的很需要UML工具，现在没有UML工具觉得总是想的有遗漏。
1，正确使用QInfoWidget，建立UserBasicInfo类，包括设置是否可写，实现getInfo和setInfo。是否可写考虑用WFlags。
2，建立UserInfo类，包括UserBasicInfo, UserFingerInfo, UserDateInfo三个类，也都继承自"QInfoWidget". 
3, 重新实现UserAdd类（继承自QWizard类），现在的考虑是这个层次才考虑和数据库的接口，因为这里才需要和外界进行通信。看来还是没有用UML吃的亏。
以上为今天要完成的內容。
4，实现删，改，查。剩余这三个类；
5，与硬件通信。

17:25 2007-11-01
QT学习，编译
[root@localhost InfoWidget]# make -f Makefile.qiw
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -DNO_DEBUG -I/usr/src/FV_Project/qt/qt/include -o qinfowidget.o qinfowidget.cpp
In file included from qinfowidget.cpp:8:
/usr/src/FV_Project/qt/qt/include/qvariant.h:47: semicolon missing after
   declaration of `QInfoWidget'
/usr/src/FV_Project/qt/qt/include/qvariant.h:47: multiple types in one
   declaration
make: *** [qinfowidget.o] Error 1
仔细对比uic生成的文件和自己写的代码，发现是class声明后没有加";"结尾。
class QInfoWidget: public QWidget
{
    Q_OBJECT
}
改为
class QInfoWidget: public QWidget
{
    Q_OBJECT
};
即可。

17:54 2007-11-01
由于要把界面中的按钮等组件在独立的UserBasicInfo类中声明，现在只能从UserAddTemp.ccpp中一个一个提取出来。以后还是独立一个一个画QWidget比较好。这样就可以直接把QWidget类修改为QInfoWidget类。

18:24 2007-11-01
需要在QInfoWidget中加入：
1, 头文件
(1), 布局和其他QWidget；
(2), (1)所需的头文件；
(3)，(1)所有class的声明，如
class QLabel;
2，cpp文件：
如果设置了颜色，一般需要加入：
    QPalette pal;
    QColorGroup cg;

19:14 2007-11-01
c++，虚函数，纯虚函数
原有QInfoWidget的getInfo和setInfo是虚函数但不是纯虚函数，所以需要实现。但是这里实际不需要实现，所以改为纯虚函数：
    virtual QObjectList* getInfo() = 0;
    virtual void setInfo(QObjectList* info) = 0;
如果没有实现虚函数，会有下面的错误：
gcc  -o userbasicinfo qinfowidget.o userbasicinfo.o moc_qinfowidget.o moc_userbasicinfo.o  -L/usr/src/FV_Project/qt/qt/lib -lm -lqte
moc_qinfowidget.o(.gnu.linkonce.d._ZTV11QInfoWidget+0x1a0): undefined reference
to `QInfoWidget::getInfo()'
moc_qinfowidget.o(.gnu.linkonce.d._ZTV11QInfoWidget+0x1a4): undefined reference
to `QInfoWidget::setInfo(QObjectList*)'
collect2: ld returned 1 exit status
make: *** [userbasicinfo] Error 1

19:19 2007-11-01
gdb, 内核转储文件(core file)
[root@localhost InfoWidget]# ./userbasicinfo -qws
User Basic Info Debug.
Connected to VFB server: 320 x 240 x 16
段错误 (core dumped)
用gdb查看内核转储文件，删除了Makefile的gcc和g++的-DNO_DEBUG，加入"-ggdb"：
[root@localhost InfoWidget]# gdb userbasicinfo core.3452
GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...
Core was generated by `./userbasicinfo -qws'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/tls/libm.so.6...done.
Loaded symbols for /lib/tls/libm.so.6
Reading symbols from /usr/src/FV_Project/qt/qt/lib/libqte.so.2...done.
Loaded symbols for /usr/src/FV_Project/qt/qt/lib/libqte.so.2
Reading symbols from /lib/tls/libc.so.6...done.
Loaded symbols for /lib/tls/libc.so.6
Reading symbols from /usr/lib/libstdc++.so.5...done.
Loaded symbols for /usr/lib/libstdc++.so.5
Reading symbols from /lib/libgcc_s.so.1...done.
Loaded symbols for /lib/libgcc_s.so.1
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  0x00004ff1 in ?? ()
(gdb) where
#0  0x00004ff1 in ?? ()
#1  0x0805a9ec in ~QUserBasicInfo (this=0x42130920) at userbasicinfo.cpp:206
#2  0x0805aa98 in main (argc=1, argv=0xbffff2c4) at userbasicinfo.cpp:224
#3  0x42015574 in __libc_start_main () from /lib/tls/libc.so.6
(gdb) 
可以看到是"~QUserBasicInfo"引起的。知道"~QUserBasicInfo"之前会调用"QInfoWidget::~QInfoWidget"，查看该函数，发现有delete *info，由于info没有指向有意义的内存区域，所以delete失败。
但是不知道如何查地址"0x00004ff1"的內容。待做：看u-boot Makefile中System.map是如何生成的。查如何进一步利用内核转储文件。
对策，修改"QInfoWidget::~QInfoWidget"为：
QInfoWidget::~QInfoWidget()
{
    if ( !info ) {
        delete info;//TODO: do it here or do it by children. which is more
better?
    }
}
但现在不明白为什么info没有赋值为0，但是上面的语句正确，难道是c++自动设置info为0？查，待做。

20:44 2007-11-01
由于部分QWidget移到了UserBasicInfo类，注释了UserAddTemp里面397行"// tab order"开始的17行"QWidget::setTabOrder"。
这个函数是设置按下键盘TAB键时的移动顺序的。对于我们这个嵌入式系统没有必要。


20:51 2007-11-01
又没有完成任务，明天继续吧......

09:45 2007-11-02
1, 叶涛CVS服务器：
export CVSROOT=:pserver:zhj@192.168.200.248:/var/cvs
cvs -d $CVSROOT login
cvs co fvdac
(16:26 2007-11-06)
先用，cvs add 加入目录和文件；
再用，cvs ci，更新服务器上的文件。
(17:08 2007-11-06)
待做，加入详细日志。
(15:03 2007-11-13)
上传程序时使用"ci -r rel-1-1 模块"。
下载：cvs co -r rel-1-1 fvdac
(10:48 2007-11-20)
1, CVS目录很重要。对于CVS服务器已有的目录，该目录的CVS目录应该是从服务器上下载的，否则check in可能会有问题。
2, 删除文件：
[root@localhost useradmin]# rm changeMakefile.sh
[root@localhost useradmin]# cvs remove changeMakefile.sh
cvs server: scheduling `changeMakefile.sh' for removal
cvs server: use 'cvs commit' to remove this file permanently
[root@localhost useradmin]# cvs ci -r rel-1-1 changeMakefile.sh

Log message unchanged or not specified
a)bort, c)ontinue, e)dit, !)reuse this message unchanged for remaining dirs
Action: (continue) 
Removing changeMakefile.sh;
/var/cvs/fvdac/useradmin/Attic/changeMakefile.sh,v  <--  changeMakefile.sh
new revision: delete; previous revision: 1.1.2.1
done
(18:26 2007-12-18)
加入log信息
cvs ci -m 'log信息' 文件名

2，Bugzilla
外网：http://192.168.200.225/bugzilla/
内网：http://10.96.2.21/bugzilla/
项目名称：FVDAC
用户名：zhangjian@ossl.hitachi.org
密码：zhangjian
权限：可以添加或编辑BUG

11:00 2007-11-02
编译qtopia arm出错：
arm-linux-g++  -c -I/usr/src/FV_Project/qt_embedded/qtopia_embedded_arm/include -I/usr/src/FV_Project/qt_embedded/qt_embedded_arm/include -pipe -DQWS -fno-exceptions -fno-rtti -O2 -Wall -W -DNO_DEBUG -fPIC -DQTOPIA_APP_INTERFACE -I.moc/linux-arm-g++/ -I/usr/src/FV_Project/qt_embedded/qtopia_embedded_arm/src/server -o .obj/linux-arm-g++//global1.o global1.cpp
global1.cpp:39: uuid/uuid.h: ?????????
global1.cpp: In function `static struct QUuid Global::generateUuid()':
global1.cpp:188: implicit declaration of function `int uuid_generate(...)'
make[1]: *** [.obj/linux-arm-g++//global1.o] 错误 1
make[1]: Leaving directory `/usr/src/FV_Project/qt_embedded/qtopia_embedded_arm/src/libraries/qtopia1'
make: *** [libraries/qtopia1] 错误 2
后来发现是uuid/uuid.h没有加入路径中。
参考buildx86.exe，把头文件和库分别复制到qtopia include和lib目录：
[root@localhost qtopia_embedded_arm]# cp -ar ../../qt/uuid ./include/ -p
[root@localhost qtopia_embedded_arm]# cp ../../qt/uuid/libuuid.a ./lib/ -p
(11:42 2007-11-02)
/usr/local/arm/2.95.3/arm-linux/bin/ld: cannot find -lqtopia
collect2: ld returned 1 exit status
make[1]: *** [/usr/src/FV_Project/qt_embedded/qtopia_embedded_arm/bin/sysinfo] >错误 1
make[1]: Leaving directory `/usr/src/FV_Project/qt_embedded/qtopia_embedded_arm/src/applications/sysinfo'
make: *** [applications/sysinfo] 错误 2
这个库的确没有，现在暂时不知道如何，编译。暂缓。

11:58 2007-11-02
QT学习，感觉有点感觉了
参考examples/xform/xform.cpp
这样定义了EditType。
class EditType: public QObject
{
public:
    enum editType {Create_c, Edit_c, View_c, Max_ET_c};
};

class QInfoWidget: public QWidget, public EditType
{
    Q_OBJECT
    
public:
    QInfoWidget( QWidget* parent = 0, const char* name = 0, WFlags f = 0,
                 enum editType et = Create_c);
......
}
另外在"QInfoWidget::QInfoWidget"中，使用QIntDict生成editType和editDict的对应关系。

12:10 2007-11-02
c++学习
如上QInfoWidget多重继承了QWidget和QEditType两个类，这时原来在"userbasicinfo.cpp"中使用的"info = queryList( 0, "^value" );"会提示错误：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -ggdb -DUSER_ADMIN_DEBUG -DUSING_UBI -I/usr/src/FV_Project/qt/qt/include -o userbasicinfo.o userbasicinfo.cpp
userbasicinfo.cpp: In constructor `QUserBasicInfo::QUserBasicInfo(QWidget*,
   const char*, unsigned int)':
userbasicinfo.cpp:205: request for member `queryList' is ambiguous in multiple
   inheritance lattice
/usr/src/FV_Project/qt/qt/include/qobject.h:101: candidates are: QObjectList*
   QObject::queryList(const char* = 0, const char* = 0, bool = TRUE, bool =
   TRUE)
/usr/src/FV_Project/qt/qt/include/qobject.h:101:                 QObjectList*
   QObject::queryList(const char* = 0, const char* = 0, bool = TRUE, bool =
   TRUE)
这是因为c++无法知道要调用哪个类的"queryList"函数，因为QWidget和QEditType两个类都继承自QObject。同样修改为"info = QObject::queryList( 0, "^value" );"，也会报错：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -ggdb -DUSER_ADMIN_DEBUG -DUSING_UBI -I/usr/src/FV_Project/qt/qt/include -o userbasicinfo.o userbasicinfo.cpp
userbasicinfo.cpp: In constructor `QUserBasicInfo::QUserBasicInfo(QWidget*,
   const char*, unsigned int)':
userbasicinfo.cpp:205: cannot call member function `QObjectList*
   QObject::queryList(const char*, const char*, bool, bool)' without object
道理相同，改为"info = QWidget::queryList( 0, "^value" );"就正确了。
同理，如果把QEditType改为不继承QOjbect也可以。这是现在的修改方法。

17:44 2007-11-02
现有任务：
1，完成用户管理界面，不包括数据库，不包括用户注册时收集指静脉信息。
2，国际化；
3，数据库
4，用户注册同时收集指静脉信息。

18:53 2007-11-02
学习CVS
http://www.linux.ie/articles/tutorials/cvs.php
待做：下载。

11:21 2007-11-03
觉得editType还有更好的办法。
可以建立EditType和EditCollection类。前者提供对于每个EditType name的edit函数，edit函数的输入参数是迭代器，根据自身的EditType的name设置迭代器中QObejct的edit类型。后者是1...n个EditCollection的集合。
感觉现在主要是对模板类，了解太少，没法实现上面这个想法。稍后实现，待做。

12:16 2007-11-03
在userbasicinfo中实现qinfowidget的
    virtual void setEditType(enum editType new_et) = 0;
    virtual enum editType getEditType() = 0;
两个函数。
避免UserAddTemp中初始化找不到editType:
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -ggdb -DUSER_ADMIN_DEBUG -DUSING_UBI -I/mnt/hgfs/FV_project/qt/qt/include -o UserAdminTemp.o UserAdminTemp.cpp
UserAdminTemp.cpp: In constructor `UserAdd::UserAdd(QWidget*, const char*,
   bool, unsigned int)':
UserAdminTemp.cpp:280: `View_c' undeclared (first use this function)
UserAdminTemp.cpp:280: (Each undeclared identifier is reported only once for
   each function it appears in.)
make: *** [UserAdminTemp.o] Error 1
待做。继续思考。

15:47 2007-11-03
QT
使用isA判断是否是某个类的实例：
if ( ((QWidget*)obj)->isA( "QLineEdit" ) )
开始用的下面这个办法，晕了......
if ( ( ((QWidget*)obj)->className() ) == "QLineEdit" )
(18:22 2007-11-03)
现在的确状态不好，居然忘了字符串比较需要使用strcmp。两次出了这个问题。

17:58 2007-11-03
设置ComboBox中被选中的条目。
void QComboBox::activated ( const QString & string ) [signal]
This signal is emitted when a new item has been activated (selected). string is the activated string.
You can also use activated(int) signal, but be aware that its argument is meaningful only for selected strings, not for typed strings. 

18:24 2007-11-03
测试getInfo和setInfo

22:27 2007-11-03
QCString类实现了c语言中char*的字符串和str*函数(qstr*)，qstr*函数考虑了传入空指针的情况。

22:32 2007-11-03
现在又回到发电实习时编程的能力了，在setInfo函数中，没有考虑QLineEdit::text()返回的可能是空指针。直接把这个空指针赋给QLineEdit::setText()，造成了段错误。

22:58 2007-11-03
FVDAC项目进度
终于完成了周四，周五计划的第一条。
遇到的困难：
1，编程能力下降。
2，面向对象掌握的不好，尤其是不会UML。
3，公司状态不好。
今天争取完成：
1，建立UserFingerInfo, UserDateInfo类。现在首先需要把UserBasicInfo的通用函数移到QInfoWidget类。
2，中上述三个类重新实现UserAdd类。手指认证暂缓。
明天完成周四周五计划的最后一条。

11:14 2007-11-04
bool UserAdd::event( QEvent* ev )
会处理设置字体为构造函数设置的状态。
为什么要这样？是为了防止字体被修改么？
暂时注释了这个功能。查，待做。

12:18 2007-11-04
实现UserFingerInfo加入QListBox功能。

15:03 2007-11-04
加入QUserFingerInfo用了三个小时。
主要是QUserFingerInfo和QUserBasicInfo差异较大，而且前者需要加入对QListBox的操作。过程中，感觉QListBox功能不能完全满足需要，建立了QEListBox，是实现了下面两个方法：
    void insertItemNoDup ( const QString & newText, int index=-1 );
    void removeItemSetNxtSel ( int index );
问题：现在最大的问题是敲键盘时不注意看屏幕，总是有很多小错。
待做完成：
1，用1小时完成QUserDateInfo类；
2，把UserAdd类抽象为UserAdmin类，支持例化为增删改查四个实例。
3，加入与FV通信部分，应该只是对UserAdd修改就可以。

20:42 2007-11-04
待做：用KDevelop做QT开发。

21:31 2007-11-04
#include <qlabel.h>
写成了
1, 
userdateinfo.h
userdateinfo.cpp
#include <qlabel.h>
写成了
#inlcude <qlabel.h>
2, 
    QUserDateInfo( QWidget* parent = 0, const char* name = 0, WFlags f = 0,
                   enum editType newEt = Create_c);
写成了
    QUserDateInfo( QWidget* parent = 0, const char* name = 0, WFlags f = 0
                   enum editType newEt = Create_c);
3, userdateinfo.cpp
QWidget* privateLayoutWidget_11 = new QWidget( this, "layoutModTime" );
等多行，写成了
QWidget* privateLayoutWidget_11 = new QWidget( UserDateInfo, "layoutModTime" );
4, userdateinfo.h的
#ifndef USER_DATE_INFO_H
写成了
#ifdef USER_DATE_INFO_H
这个错误出现时，会出现很莫名其妙的错误：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline
-ggdb -DUSER_ADMIN_DEBUG -I/usr/src/src2/FV_project/qt//qt/include -o
userdateinfo.o userdateinfo.cpp
userdateinfo.cpp:16: 错误：syntax error before `::' token
userdateinfo.cpp:21: 错误：syntax error before `->' token
......

其中"userdateinfo.cpp:16-18"是：
QUserDateInfo::QUserDateInfo( QWidget* parent, const char* name, WFlags f,
                                enum editType newEt )
    : QInfoWidget(parent, name, f, newEt)
因为如果用"#ifdef"实际"userdateinfo.h"里面的内容就都没有包含进去。
经验：实际上，一般来说出现"syntax error"，都是变量，函数或类的声明出了问题，一般可以通过查看gcc的预定义结果确定原因。例如对于上面的情况，可以修改上面的g++语句为
[bamv26@localhost InfoWidget]$ g++ -c -pipe -DQWS -fno-exceptions -fno-rtti
-Wall -W -O2 -fno-default-inline -ggdb -DUSER_ADMIN_DEBUG -I/usr/src/src2/FV_project/qt//qt/include -o userdateinfo.E userdateinfo.cpp -E
最后的"-E"表示仅仅进行预处理，"serdateinfo.E"是预处理的输出文件。
(待做：查，gcc默认的预处理文件扩展名是什么？)
在"userdateinfo.E"查找"QUserDateInfo"，发现第一个结果是：
7640 # 15 "userdateinfo.cpp" 2
7641 
7642 QUserDateInfo::QUserDateInfo( QWidget* parent, const char* name, WFlags
f,
7643                                 enum editType newEt )
说明类QUserDateInfo未声明，这时去查声明类QUserDateInfo的文件即可。
5, userdateinfo.h
"{"和"}"没有配对：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline
-ggdb -DUSER_ADMIN_DEBUG -I/usr/src/src2/FV_project/qt//qt/include -o
userdateinfo.o userdateinfo.cpp
userdateinfo.cpp: In member function `virtual void 
   QUserDateInfo::updateEditType()':
userdateinfo.cpp:192: 错误：parse error at end of input
make: *** [userdateinfo.o] 错误 1


22:51 2007-11-04
编译QT，提示
gcc  -o UserAdminTemp qinfowidget.o userbasicinfo.o userfingerinfo.o
userdateinfo.o qelistbox.o UserAdminTemp.o moc_qinfowidget.o
moc_userbasicinfo.o moc_userfingerinfo.o moc_UserAdminTemp.o
-L/usr/src/src2/FV_project/qt//qt/lib -lm -lqte
userdateinfo.o: In function `QUserDateInfo':
/usr/src/src2/FV_project/project/useradmin/InfoWidget/userdateinfo.cpp:19:
undefined reference to `vtable for QUserDateInfo'
......
userdateinfo.o:/usr/src/src2/FV_project/project/useradmin/InfoWidget/userdateinfo.cpp:83:
more undefined references to `vtable for QUserDateInfo' follow
userdateinfo.o: In function `QUserDateInfo::metaObject() const':
/usr/src/src2/FV_project/project/useradmin/InfoWidget/userdateinfo.h:24:
undefined reference to `QUserDateInfo::staticMetaObject()'
collect2: ld 返回 1
make: *** [UserAdminTemp] 错误 1
反复查程序找不到错误，偶然发现如果注释"QUserDateInfo"的Q_OBJECT宏，可以解决这个问题，但是道理说不通，这时注意了一下gcc编译的过程，发现最终链接UserAdminTemp时也没有链接moc_userdateinfo.o。
SRCMOC  =       moc_UserAdminTemp.cpp \
                moc_qinfowidget.cpp \
                moc_userbasicinfo.cpp \
                moc_userfingerinfo.cpp
OBJMOC  =       moc_UserAdminTemp.o \
                moc_qinfowidget.o \
                moc_userbasicinfo.o \
                moc_userfingerinfo.o

TARGET  =       UserAdminTemp
$(TARGET): $(UICDECLS) $(OBJECTS) $(OBJMOC)
        $(LINK) $(LFLAGS) -o $(TARGET) $(OBJECTS) $(OBJMOC) $(LIBS)

手工修改如下：
1，分别加入moc_userdateinfo.cpp和moc_userdateinfo.o到SRCMOC和OBJMOC
SRCMOC  =       moc_UserAdminTemp.cpp \
                moc_qinfowidget.cpp \
                moc_userbasicinfo.cpp \
                moc_userfingerinfo.cpp \
                moc_userdateinfo.cpp
OBJMOC  =       moc_UserAdminTemp.o \
                moc_qinfowidget.o \
                moc_userbasicinfo.o \
                moc_userfingerinfo.o \
                moc_userdateinfo.o
2，加入moc_userdateinfo.cpp和moc_userdateinfo.o的规则
moc_userdateinfo.o: moc_userdateinfo.cpp \
                userdateinfo.h \
                qinfowidget.h \
                qelistbox.h

moc_userdateinfo.cpp: userdateinfo.h
        $(MOC) userdateinfo.h -o moc_userdateinfo.cpp
这样编译正确。
这说明Makefile有错，这很奇怪。进一步分析，确定是pro文件编写的问题，造成tmake生成Makefile出现bug，如果把
HEADERS         = UserAdminTemp.h \
		  qinfowidget.h \
                  userbasicinfo.h \
                  userfingerinfo.h \
                  qelistbox.h \
                  userdateinfo.h 
SOURCES         = UserAdminTemp.cpp \
		  qinfowidget.cpp \
                  userbasicinfo.cpp \
                  userfingerinfo.cpp \
                  qelistbox.cpp \
                  userdateinfo.cpp 
改为
HEADERS         = qinfowidget.h \
                  userbasicinfo.h \
                  userfingerinfo.h \
                  userdateinfo.h \
                  qelistbox.h \
                  UserAdminTemp.h
SOURCES         = qinfowidget.cpp \
                  userbasicinfo.cpp \
                  userfingerinfo.cpp \
                  userdateinfo.cpp \
                  qelistbox.cpp \
                  UserAdminTemp.cpp
既UserAdminTemp.*处于结尾，就没有问题。

00:20 2007-11-05
效率低，不过希望下次能够效率高一些。
明天计划：
1，修改UserAdd类，使其可以例化为增删改查四个实例。通过设置opType选择例化为哪个实例。需要修改内部的一些提示信息，比如现在的"User Add Successful"QLabel。
2，完成手指的注册。

10:55 2007-11-05
待做，查qDebug能否输入。

11:51 2007-11-05
QInfoWidget的showInfo没有继承：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -DNO_DEBUG -I/usr/src/FV_Project/qt/qt/include -o userbasicinfo.o userbasicinfo.cpp
userbasicinfo.cpp: In member function `virtual QObjectList* 
   QUserBasicInfo::getInfo()':
userbasicinfo.cpp:214: no matching function for call to `QUserBasicInfo::
   showInfo()'
userbasicinfo.h:35: candidates are: virtual void 
   QUserBasicInfo::showInfo(QObjectList*)


14:06 2007-11-05
待做：useradmin_1106.tar.gz有错，待修改。
(23:23 2007-11-05)
现在是各自实现了showInfo()，这样不好。
待做：明天做实验，解决这个问题。改为QInfoWidget::showInfo()，而不是自类各自实现showInfo()。

10:48 2007-11-06
项目计划
12月3日需要做demo。计划11月15日完成demo所需内容。11月25日前完成测试。
需要我完成的内容：
1，手指注册，与fv通信，指静脉暂时不放到数据库中；
2，国际化，软键盘，输入法；
3，用户管理与数据库通信。

15:20 2007-11-06
fingervein的enroll方法基本完成，还需要做：
1，函数的默认值
2，测试程序，main函数；
3，在PC机上连接进行测试。

18:32 2007-11-06
编写FingerVein时遇到了不能解决的问题：
[root@localhost fv]# g++ -o fingervein fingervein.cpp -ggdb -Wall
In file included from /usr/include/bits/types.h:31,
                 from /usr/include/sys/select.h:28,
                 from fingervein.cpp:21:
/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stddef.h:213: extraneous `int' 
   ignored
/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stddef.h:213: long, short, 
   signed or unsigned invalid for `size_t'
In file included from /usr/include/libio.h:32,
                 from /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stdio.h:84,
                 from fingervein.cpp:28:
/usr/include/_G_config.h:47: member `__gconv_info <anonymous union>::__cd' with 
   constructor not allowed in union
/usr/include/_G_config.h:47: member `__gconv_info <anonymous union>::__cd' with 
   destructor not allowed in union
/usr/include/_G_config.h:52: member `<anonymous union>::<anonymous struct> 
   <anonymous union>::__combined' with constructor not allowed in union
/usr/include/_G_config.h:52: member `<anonymous union>::<anonymous struct> 
   <anonymous union>::__combined' with destructor not allowed in union
In file included from /usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stdio.h:84,
                 from fingervein.cpp:28:
/usr/include/libio.h:333: 数组维数溢出
/usr/include/libio.h:333: size of array `_unused2' is too large
/usr/include/libio.h：333：不能从先前的错误中恢复，退出
(19:13 2007-11-06)
原因是把"#include "fingervein.h""放在了第一条#include语句。把"#include
"fingervein.h""移到include的最后一个，问题解决。

19:14 2007-11-06
又忘了在class后面加入";"。
由于后面(fingervein.cpp)是FingerVein类的构造函数，没加分号，相当于是用前面的FingerVein类做FingerVein类的构造函数的返回值。

20:38 2007-11-06
改写FV程序初步完成
建立FingerVein类，包括enroll, sensor, upload和download等方法。现在的问题是原有代码结构不好，造成类内部的函数和变量很乱。
编译：
g++ -o fingervein_pc fingervein.cpp -ggdb -DFINGER_VEIN_DEBUG
待做：有精力时改进。

09:22 2007-11-07
今日任务：
0，本来计划昨天走的时候编译qt arm，后来忘了。以后要改进。记日志这个习惯还是没有完全起到作用。
1，完成qt下手指注册；
2，国际化（英文，中文），输入法：
(1)，国际化，需要在板子上运行；
(2)，输入法；
估计难点可能在输入法上。
预计8点完成。

10:30 2007-11-07
QT，学习
QWizard：examples/wizard/wizard.cpp
值得注意的是，Wizard类，建立了自己的showPage()函数：
1，做QWizard::showPage()之前要做的事，例如写入下一页要显示的信息；
2，调用QWizard::showPage()；
3，做showPage之后要做的事。例如设置输入焦点，设置next button再何种情况下有效。


11:58 2007-11-07
比预定计划慢了一些。已经把对话框加入到userfingerinfo.cpp，下午实现具体的指静脉采集功能即可。
下午要完成PC上的国际化和软键盘。

16:00 2007-11-07
文件中包含的预处理指令，可能导致moc认为出现了语法错误：
由于FingerVein类，可能需要在没有qt的情况下运行，所以使用了预处理指令
#define USING_QT
#ifdef USING_QT
class FingerVein:public QObject
#else
class FingerVein
#endif	
但是在"class FingerVein"会提示syntax error。

16:39 2007-11-07
调试加入FV模块的图形界面：
	1，出现段错误：用core file很容易找到了原因。是由于~FingerVein释放了没有分配的指针造成的。它是由于定义NO_FV时，没有考虑到不使用FV模块时，也需要给recv ＝ 0。否则~FingerVein就会出错。

16:47 2007-11-07
现在是先enroll，后显示的界面。
不应该在构造函数中enroll，应该在界面显示后enroll。

16:59 2007-11-07
考虑用多线程，好像过于复杂。暂时这个思路，改为：
直接在预留的prompt提示。

17:43 2007-11-07
c语言，c++，编译错误
parse error
从parse error提示的位置往前找，可能是"case 1"后面没有加":"

18:17 2007-11-07
基本功能实现，发现两个问题：
1，enroll成功条件不是大于0，应该是等于406字节；查原来的错误处理，尽量用原来的。 
2，setInfo如果涉及到listbox，combobox等多项选择，应该先清空原有记录。
原来的出错处理，没有把错误号转为字符串。问题2已解决。
现有版本：useradmin_11071845.tar.gz
待做：加入错误处理。

18:39 2007-11-7
QT，国际化
findtr
msg2qm
mergetr21:29 2007-11-07
是字符集的问题，回去解决。

18:34 2007-11-08
自己尝试建立的最简单的国际化程序，失败。
继续努力！

12:53 2007-11-09
继续解决国际化问题：
现在已经排除了工程文件，*.po, *.qm文件的问题。只剩下代码的问题了。

13:01 2007-11-09
QT, 国际化
中文情况下，如何设置快捷键
msgid "MyWidget::&File"
msgstr "文件[&F]"


14:28 2007-11-09
qt/examples/i18n/main.cpp
里面的qApp没有找到定义，不知道为什么可以这么用。

15:37 2007-11-09
终于发现了问题的原因：
需要指定字符集(QFont::setCharSet)是Unicode或其它支持中文的字符集，同时指定的字体(QFont::setFamily)也支持中文。
但是，使用designer设计时，自动设定的字体是不支持中文的，而且没有修改字符集为支持中文的字符集

18:15 2007-11-09
国际化问题解决。下面是输入法问题。

18:46 2007-11-09
qtopia
qtopia英文输入法肯定有，关键是如何配置qtopia。应该难度不大。

12:07 2007-11-12
待做：
1, Cancel, back, next和标题没有做国际化。（完成）
2, 还是没有提示"请插入手指"
3, 识别手指注册超时错误。（完成）
(16:57 2007-11-12)
fingervein.cpp/h，超时的时候，times是4。原因待查。
(18:16 2007-11-21)
使用arm测试时，超时错误是正确的。

12:31 2007-11-12
GUI, QT国际化(i18n)，详细过程, 文档, translator
1，需要编译两个工具：
msg2qm和mergetr，前者用于把*.po文本文件转为*.qm文件，qt读取qm文件显示po文件中指定的信息。后者用于从po文件更新po文件。位于"qt/tools"，编译后放在moc, findtr等程序所在的"qt/bin/"，以便于使用。
2，国际化步骤：
QString支持Unicode，国际化实际借助Unicode实现。
(1)，界面中所有字符串应该用tr函数。
例如setText(tr("test"))。
对于特殊情况（参见参考文献2）：
(1), 在定义某些变量中使用的字符串，不能使用上述方法，但是为了让Qt提取并翻译该字符串，必须用某种方法标志出来。Qt定义了QT_TR_NOOP() 和 QT_TRANSLATE_NOOP()
来标志它们。前者用于单个字符串，后者用于多个字符串。比如，
static const char* strings[] = {
QT_TR_NOOP( "Hello" )，
QT_TR_NOOP( "World" )
};
//自examples/i18n/mywidet.cpp
static const char* choices[] = {
    QT_TRANSLATE_NOOP( "MyWidget", "First" ),
    QT_TRANSLATE_NOOP( "MyWidget", "Second" ),
    QT_TRANSLATE_NOOP( "MyWidget", "Third" ),
    0
};
(2), 有时需要动态生成字符串，对这种使用方式的国际化是使用 arg() 函数。
QString s = tr( "Button %1" ).arg(i);
but->setText( s );
(2)findtr *.cpp *.h > useradmin.po
从源代码中提取tr函数中字符串，生成po文件
(3)分语言保存为对应po文件，
cp useradmin.po useradmin_zh.po
cp useradmin.po useradmin_en.po
修改msgstr引号内文字为相应语言的文字，例如
#: fvdialog.cpp:25
msgid "FvDialog::finger registration"
msgstr "手指注册"
(4)，po文件转为qm文件，qt通过加载qm文件实现国际化：
msg2qm useradmin_zh.po useradmin_zh.qm
(5)，在程序中使用：
注意：一定注意要在显示界面之前"installTranslator"，否则不会提示错误，但是也没有国际化！！！
QApplication app(argc, argv);
QFont font;
font.setFamily("unifont");
font.setCharSet(QFont::Unicode);
app.setFont(font);
QTranslator translator(0);      //(10:56 2009-7-1)translator应该在ad_start生存期都存在, 否则国际化会出问题"10:57 2009-7-1"end
String lang = useradmin_zh.qm;
translator.load(lang, ".");
app.installTranslator(&translator);
/**********先加载Translator，再"show"****************/
UserAdmin ad_start(ADD_c, 0, 0, TRUE);
app.setMainWidget(&ad_start);
ad_start.show();

要注意设置的字体和字符集要能满足国际化的需要（例如需要显示中文），这里设置的是unifont和Unicode。用designer绘制GUI时，会自动指定字体，需要手工注释对应语句，例如注释"f.setFamily("adobe-helvetica");"
(16:43 2009-7-1)
note: 后来有个朋友做qt时, 发现有时可以汉化, 有时不能汉化, 查流程没有问题, 后来发现是在不同目录运行的程序. 可以汉化时是在qm文件目录下执行的. 修改translator路径后问题解决. 
"16:43 2009-7-1"end
(6), tr函数是QT函数，由moc实现。所以调用tr函数的类一定要加入"Q_OJBECT"宏
待做：分析QT国际化机制，QT国际化补充完整，

注
1，在修改源代码后，更新po和qm文件：
findtr *.cpp *.h > useradmin_zh.po
mergetr useradmin_zh.po useradmin.po
msg2qm useradmin_zh.po useradmin_zh.qm
mergetr格式："mergetr 目标po文件 新生成的po文件"
2, 字符集，如果是中文需要把ISO-8859-1改为gbk，Unicode等其它支持中文的字符集。
"ISO-8859-1":
自：http://blog.csdn.net/nilxin/archive/2005/07/22/432005.aspx
ISO 8859是一系列标准的，多语言的、单字节编码(8位)图形等字符集。其中第一个字符集即使ISO 8859-1 也被称之位 ISO 8859-(Latin-1),用来映射西欧字符到Unicode。ISO 8859
还包括Latin-2(东欧),土耳其、希腊、希伯来语、日耳曼及其他。ISO 8859标准是欧洲电脑制造商联盟(ECMA)20世纪80年代中期建立的，并被国际ISO组织认可。 
3, findtr只是搜索代码文本，所以tr函数的参数需要直接是字符串，否则findtr找不到需要翻印的字符串。
4, Unix国际化通过gettext函数实现。
http://i18n.linux.net.cn/gnu/
开源软件国际化·简体中文组

参考资料：
1)，"24小时学通QT"第21学时。
2)，"Qt 国际化编程，真正解决汉字显示方块、乱码问题！"，"http://www.akae.cn/space/2/viewspace-5864.html"

12:47 2007-11-12
今天编译qt出现一个错误：
arm-linux-gcc  -o useradmin qinfowidget.o userbasicinfo.o fingervein.o userfingerinfo.o userdateinfo.o qelistbox.o useradmin.o moc_qinfowidget.o moc_userbasicinfo.o moc_fingervein.o moc_userfingerinfo.o moc_userdateinfo.o moc_useradmin.o  -L/mnt/hgfs/FV_Project/qt/qt/lib -lm -lqte
/mnt/hgfs/FV_Project/qt/qt/lib/libqte.so: could not read symbols: Invalid operation
上网查，发现有人提到可能是库是i386的。用file命令查看，的确如此。这才发现是buildarm.sh的位置错了。开始运行的是qt目录下的，不是qt_embedded目录的。
待做：还是要做成qt_pc和qt_arm统一的开发环境，包括编译脚本中需要加入mergetr和msg2qm.

16:49 2007-11-12
本周安排：
1，中文输入法；
2，数据库；
3，界面。

17:16 2007-11-12
具体计划：
1，完成用户管理总界面；
2，qpe在开发板上运行。
arm_s3c2410_傅立叶/傅立叶提供烧写的文件/新/fftroot.cramfs是做好的qt文件系统。明天尝试。
3，如果没有中文输入法，找中文输入法。

14:05 2007-11-13
分析现有2410开发板上的启动过程
1, init部分
linuxrc：挂载文件系统，/sbin/init
/sbin/init：rcS
rcS：/usr/etc/rc.local
/usr/etc/rc.local：加载各种硬件驱动，启动QT。
2，具体分析QT启动：
if [ -f /qt/etc/pointercal ]; then                                              
cp /qt/etc/pointercal /etc                                                      
else                                                                            
calibrate -qws                                                                  
cp /etc/pointercal /qt/etc                                                      
fi                                                                              
server -qws 
注：文件"/qt/etc/pointercal"存在
server是qtopia程序。界面和傅立叶光盘上提供的qtopia不一样。

17:47 2007-11-13
用linux ftp烧写文件系统
如果出现"Permission deny"可能是服务器权限问题，也可能是客户端权限的问题。比如arm开发板当前目录不可写。
(17:56 2007-11-13)
imagewrite是傅立叶提供的烧写程序，查其原理，待做。
# ./imagewrite /dev/mtd/0 fftroot.cramfs:1m
meminfo size = 67108864
size = 23465984
size = 23465984
image is too big for this partition
失败

17:58 2007-11-13
root
123456

18:25 2007-11-13
1, 用vivi tftp烧写文件系统
重试次数太多每次都要重新开始传，当然，这很正常。原来我在实验室做的时候也是不行，后来是改u-boot源代码中的重试次数才解决。
2, 最后只好用xmodern协议，就是慢点儿......
20:35 2007-11-13
设置开发板上的环境变量
#!/bin/sh
 export QTDIR=/mnt/qte16
 export LD_LIBRARY_PATH=/mnt/qte16/lib:/mnt/qte16/lib/lib:/lib:/usr/lib:/qt/lib:/linuette/lib


20:59 2007-11-13
QT资料，网址
1, calibrate是屏幕校准软件
2, QT4中：
./hi -qws，无法显示中文
修改为：
./hi -qws -font unicode，这样就能显示中文了
自：http://www.qtcn.org/bbs/read.php?tid=9107&fpage=2

21:03 2007-11-13
内核是zImage2.5.2。
下载fftroot.cramfs，有错误
vivi> load flash root x
Ready for downloading using xmodem...
Waiting...                                                                              Downloaded file at 0x30000000, size = 23465984 bytes
An image size is too large to write flash.
				wanted = 0x00300000, loaded = 0x01661000
vivi> bon part info
BON info. (4 partitions)
No: offset      size            flags     bad
---------------------------------------------                                    0: 0x00000000  0x00030000      00000000    0  192k
 1: 0x00030000  0x000d0000      00000000    0  832k
 2: 0x00100000  0x00200000      00000000    0    2M
 3: 0x00300000  0x03cf8000      00000001    1   60M+992k
运行失败：
cramfs: wrong magic
FAT: bogus logical sector size 65535
yaffs: dev is 24834 name is "61:02"
Kernel panic: VFS: Unable to mount root fs on 61:02

21:33 2007-11-13
应该是内核的不支持cramfs造成的。明天编译内核。
（实际不是这个原因）待做：补充。

10:19 2007-11-15
主机建立NFS
[root@localhost kernel]# cat /etc/exports 
/usr/src/fft_linux/fs (rw,sync,no_root_squash)
提示：
[root@localhost kernel]# /etc/rc.d/init.d/nfs restart
关闭 NFS mountd：                                          [确定]
关闭 NFS 守护进程：                                        [确定]
关闭 NFS quotas：                                          [确定]
关闭 NFS 服务：                                            [确定]
启动 NFS 服务： exportfs: No host name given with /usr/src/fft-linux/fs (rw,sync,no_root_squash), suggest *(rw,sync,no_root_squash) to avoid warning
							   [确定]
关掉 NFS 配额：                                            [确定]
启动 NFS 守护进程：                                        [确定]
启动 NFS mountd：                                          [确定]
改为：
[root@localhost kernel]# cat /etc/exports 
/usr/src/fft_linux/fs *(rw,sync,no_root_squash)

10:23 2007-11-15
尝试用NFS烧写qt文件系统(fftroot.cramfs)
用"old"目录下的root.cramfs
配置ip地址，网关，子网掩码
# ifconfig eth0 192.168.200.203                                                 
# route add default gw 192.168.200.10 netmask 255.255.255.0            
mount nfs文件系统：
# mount -o loop 192.168.200.200:/usr/src/fft_linux/fs /mnt/ext1                 
mount: RPC: Unable to receive; errno = No route to host                         
mount: nfsmount failed: Bad file descriptor                                     
mount: Could not find a spare loop device

用"新"目录下的root.cramfs
ifconfig eth0 192.168.200.203                                                 
ifconfig lo inet 127.0.0.1 up                                                 
route add default gw 192.168.200.10 netmask 255.255.255.0                     
# ping 192.168.200.200                                                          
PING 192.168.200.200 (192.168.200.200): 56 data bytes                           
64 bytes from 192.168.200.200: icmp_seq=0 ttl=64 time=0.9 ms                    
64 bytes from 192.168.200.200: icmp_seq=1 ttl=64 time=0.4 ms                    
										
--- 192.168.200.200 ping statistics ---                                         
2 packets transmitted, 2 packets received, 0% packet loss                       
round-trip min/avg/max = 0.4/0.6/0.9 ms                                         
										
# ping 192.168.200.251                                                          
PING 192.168.200.251 (192.168.200.251): 56 data bytes                           
64 bytes from 192.168.200.251: icmp_seq=0 ttl=128 time=1.1 ms                   
64 bytes from 192.168.200.251: icmp_seq=1 ttl=128 time=0.6 ms                   
										
--- 192.168.200.251 ping statistics ---                                         
2 packets transmitted, 2 packets received, 0% packet loss                       
round-trip min/avg/max = 0.6/0.8/1.1 ms                                         
mount nfs文件系统仍然出现上面的错误                                          

10:47 2007-11-15
minicom -o
不执行moderm初始化指令

11:11 2007-11-15
待做：保存网页
http://dev.yesky.com/364/2547364.shtml
linux内核初始化及启动之用户模式开始

12:26 2007-11-15
用ftp烧写qt文件系统(fftroot.cramfs)，建立ftp服务器的方法
从http://download.fedora.redhat.com/pub/fedora/linux/releases/7/Fedora/i386/os/Fedora/，下载vsftpd-2.0.5-16.fc7.i386.rpm，安装。看/usr/share/doc/vsftpd-2.0.5/EXAMPLE/INTERNET_SITE/README文档进行配置，做了如下修改：
/etc/xinetd.d/vsftpd
no_access               = 192.168.1.3
server                  = /usr/local/sbin/vsftpd
改为：
no_access               = 
server                  = /usr/sbin/vsftpd
/etc/vsftpd.conf
下面字段的NO改为YES
local_enable=YES
write_enable=YES
anon_upload_enable=YES
anon_mkdir_write_enable=YES
anon_other_write_enable=YES

本机访问ftp正确，从开发板访问，提示：
# ftp 192.168.200.200
输入用户名和密码，这里都是zhangjian。
ftp: connect: No route to host                                                  
ftp> quit   
看来是网络问题。
上网搜索，与iptables有关，关闭即可：
service iptables stop
启动用
service iptables restart
自：http://linux.chinaunix.net/bbs/thread-911216-1-1.html

12:51 2007-11-15
修改后，可以登录ftp
cd /usr/src/fft_linux/fs
get fftroot.cramfs   (下载qt文件系统)
get imagewrite       （下载烧写工具）
e                     （退出
chmod 777  imagewrite
./imagewrite /dev/mtd/0 fftroot.cramfs:1m
# ./imagewrite /dev/mtd/0 fftroot.cramfs:1m                                     
meminfo size = 67108864                                                         
size = 23465984                                                                 
size = 23465984                                                                 
image is too big for this partition                                             
# ./imagewrite /dev/mtd/0 fftroot.cramfs:3m                                     
meminfo size = 67108864                                                         
size = 23465984                                                                 
size = 23465984                                                                 
nand_erase: attempt to erase a bad block at page 0x00004580                     
bad_block = 1     

12:26 2007-11-15
12:51 2007-11-15
12:54 2007-11-15
问傅立叶，让我修改mtd分区信息：
vivi> part show                                                                 
mtdpart info. (5 partitions)                                                    
name              offset        size        flag                                
------------------------------------------------                                
vivi            : 0x00000000    0x00020000     0  128k                          
param           : 0x00020000    0x00010000     0   64k                          
kernel          : 0x00030000    0x000d0000     0  832k                          
root            : 0x00100000    0x00300000     4    3M                          
usr             : 0x00400000    0x003cfc00    32    3M+831k  
part del user
part del root
part add root 0x00100000 0x03ef8000
vivi> part show                                                                 
mtdpart info. (4 partitions)                                                    
name              offset        size        flag                                
------------------------------------------------                                
vivi            : 0x00000000    0x00020000     0  128k                          
param           : 0x00020000    0x00010000     0   64k                          
kernel          : 0x00030000    0x000d0000     0  832k                          
root            : 0x00100000    0x03ef8000     0   62M+992k         

仍然提示"image is too big for this partition"
重新分bon分区
vivi> bon part 0 128k 192k 1m                                                   
doing partition                                                                 
offset = 0                                                                      
flag = 0                                                                        
offset = 131072                                                                 
flag = 0                                                                        
offset = 196608                                                                 
flag = 0                                                                        
offset = 1048576                                                                
flag = 0                                                                        
check bad block                                                                 
part = 0 end = 131072                                                           
part = 1 end = 196608                                                           
part = 2 end = 1048576                                                          
part = 3 end = 67108864                                                         
8B0000: is bad                                                                  
k = 0 block = 492                                                               
part0:                                                                          
	offset = 0                                                              
	size = 131072                                                           
	bad_block = 0                                                           
part1:                                                                          
	offset = 131072                                                         
	size = 65536                                                            
	bad_block = 0                                                           
part2:                                                                          
	offset = 196608                                                         
	size = 851968                                                           
	bad_block = 0                                                           
part3:                                                                          
	offset = 1048576                                                        
	size = 66027520                                                         
	bad_block = 1                                                           
 492                                                                            
vivi> bon part info                                                             
BON info. (4 partitions)                                                        
No: offset      size            flags     bad                                   
---------------------------------------------                                   
 0: 0x00000000  0x00020000      00000000    0  128k                             
 1: 0x00020000  0x00010000      00000000    0   64k                             
 2: 0x00030000  0x000d0000      00000000    0  832k                             
 3: 0x00100000  0x03ef8000      00000000    1   62M+992k                        

13:33 2007-11-15
flash分区信息似乎有问题：
Creating 2 MTD partitions on "NAND 64MiB 3,3V":
0x00000000-0x04000000 : "bon"
0x00400000-0x03ef8000 : "mtd"
bon0: 00000000-00020000 (00020000) 00000000
bon1: 00020000-00030000 (00010000) 00000000
bon2: 00100000-001d0000 (000d0000) 00000000
bon3: 00100000-03ff8000 (03ef8000) 00000000
待做：查Linux代码
qtopia正确启动。imagewrite烧写过程见"19:29 2007-11-21"

13:51 2007-11-15
成功。
傅立叶电话：029-82080535-1044
没有中文输入法，移植。

14:47 2007-11-15
使用fftroot.cramfs(QT文件系统)的过程是：
1, 修改分区：
见"12:54 2007-11-15"

2，下载bootloader, kernel和根文件系统：
位于"傅立叶提供烧写的文件"目录：
./old:
vivi-cs8900 
./新:
root.cramfs       uzImage2410v4

3，修改Linux启动命令行
修改分区后，根文件系统分区变为/dev/bon/3，需要对应修改Linux内核启动参数。
vivi> param set linux_cmd_line "noinitrd root=/dev/bon/3 init=/linuxrc
console=ttyS0"
vivi> param save

4，烧写fftroot.cramfs
见"12:26 2007-11-15"和"12:51 2007-11-15"
步骤一中修改分区表后，就没有"image is too big for this partition"错误了。再次重启开发板，QT运行正常。启动日志见"fv/Linux_boot_log_fftroot.cramfs"

待做：需要改进文件系统，无法保存写入的数据，这很不方面。例如无法保存屏幕定位信息：
[root@(none) /]# ls -l /etc/pointercal
lrwxrwxrwx    1 root     root           17 Dec 31  1969 /etc/pointercal -> ../tmp/pointercal
[root@(none) /]# cat /etc/pointercal
23632 0 -208064 0 -18904 17297224 65536

15:35 2007-11-15
为QT加入中文输入法：
编译MurphyPinyin 0.0.3
用Makefile.x86出错：
gcc -shared -Wl,-soname,libmurphypinyin.so.0 -o libmurphypinyin.so.0.0.1 PinyinFrame.o PinyinImpl.o PinyinEngine.o scim/scim_pinyin.o phrase/PinyinPhrase.o public.o Config.o moc_PinyinFrame.o  -L/usr/src/FV_Project/qt/qt/lib -lm -lqpe -lqte
/usr/bin/ld: cannot find -lqpe
bamvor: 这是编译共享库的命令：gcc -shared -o shared-lib-name xxx(*.c or *.o) $(CFLAGS)
collect2: ld 返回 1
make: *** [/opt/Qtopia/plugins/inputmethods/libmurphypinyin.so.0.0.1] 错误 1
参考：http://www.qtopia.org.cn/phpBB2/viewtopic.php?p=3682&sid=2d008e23ca7173d5f170294b705370ef
修改Makefile.x86：
#bamvor.modified.2007-111-15
#LIBS   =       $(SUBLIBS) -L$(QTDIR)/lib -lm -lqpe -lqte
LIBS= $(SUBLIBS) -L$(QPEDIR)/lib -L$(QTDIR)/lib -lm -lqpe -lqte
编译完成后，把
libmurphypinyin.so    libmurphypinyin.so.0.0
libmurphypinyin.so.0  libmurphypinyin.so.0.0.1
按原样（文件是文件，链接是链接）复制到"qtopia/plugins/inputmethods"目录：
cp libmurphypinyin.so* $QTBASE/qtopia/plugins/inputmethods/ -a
然后建立"$QTBASE/qtopia/plugins/inputmethods/murphypinyin.desktop"文件：
[Desktop Entry]
Name=Pinyin
Comment=Pinyin input method.
X-QPE-Library=libmurphypinyin.so

在qpe下仿真运行，可以启动拼音输入法，但是没有汉子出现在提示栏中：
输入z h a n g时终端中依次出现输入的字母：
key code is 0x5A
z,0 matched
key code is 0x48
zh,0 matched
key code is 0x41
zha,73 matched
key code is 0x4E
zhan,84 matched
key code is 0x47
zhang,50 matched
如果按回车，同时终端中提示：
key code is 0x1004
参考："http://www.hi-pda.com/forum/viewthread.php?tid=312205"和PinyinFrame.cpp：
const char table_file[]=
#ifdef X86
"/root/pinyin_table.txt";
#else
"/home/zaurus/.murphytalk/pinyin_table.txt";
#endif
把pinyin_table.txt复制到/root/目录，覆盖了原有的文件。原来哪个文件做什么用的？查，待做。
重启qpe就可以输入汉子了：
key code is 0x5A
z,0 matched
key code is 0x48
zh,0 matched
key code is 0x41
zha,73 matched
key code is 0x4E
zhan,84 matched
key code is 0x47
zhang,50 matched
key code is 0x20
(这时回车，"张"就显示到文本编辑器中了)
get unicode:first visible index 0,current index 0,global index 0

17:41 2007-11-15
patch -p1 < /media/NEW/log/fv/qt/pinyin/murphytalk-patch
[root@localhost MurphyPinyin_softkb]# make -f Makefile.x86 all
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fPIC -DX86 -DNO_DEBUG -I/usr/src/FV_Project/qt/qtopia/include -I/usr/src/FV_Project/qt/qt/include -o PinyinFrame.o PinyinFrame.cpp
PinyinFrame.cpp: In member function `virtual bool QPinyinFrame::filter(int, 
   int, int, bool, bool)':
PinyinFrame.cpp:238: warning: unused parameter `int modifiers'
PinyinFrame.cpp:238: warning: unused parameter `bool autoRepeat'
PinyinFrame.cpp: In member function `virtual void 
   QPinyinFrame::paintEvent(QPaintEvent*)':
PinyinFrame.cpp:332: `kb_xpm' undeclared (first use this function)
PinyinFrame.cpp:332: (Each undeclared identifier is reported only once for each 
   function it appears in.)
make: *** [PinyinFrame.o] 错误 1
打上patch-03后，可以使用，但是没有软键盘，中文也不能输入了。

关于分辨率：
./PinyinFrame.cpp，有两处涉及到屏幕大小的问题：
161 int QPinyinFrame::init_gui_dimention()
//FIXME: how to get screen size
unsigned int width  = 640;
177         int width=640;

232 void QPinyinFrame::paintEvent(QPaintEvent * e)
239         //FIXME: how to get screen size
240         unsigned int width  = 640;

18:43 2007-11-15
继续编译Murphytalk，最终完成
输入法修改总结。
总代码位于：https://sourceforge.net/projects/murphypinyin/
下面的代码下载自QT中文论坛。
使用murphytalk-0.3代码：
1，改Makefile
#bamvor.modified.2007-111-15
#LIBS   =       $(SUBLIBS) -L$(QTDIR)/lib -lm -lqpe -lqte
LIBS= $(SUBLIBS) -L$(QPEDIR)/lib -L$(QTDIR)/lib -lm -lqpe -lqte -lqtopia
2, 改代码，修改配置文件的位置。如果配置文件位置不正确，可能无法在候选区显示汉子，或者在输入词组时出现段错误。
./phrase/PinyinPhrase.cpp，修改词组数据库文件的位置：
140 #ifdef X86
141 //"/home/chyang/murphytalk_phrase.dat";
142 "/root/murphytalk_phrase.dat";
143 #else
144 "/home/zaurus/.murphytalk/murphytalk_phrase.dat";
145 #endif
./PinyinFrame.cpp，修改拼音码表，配置文件，词组索引的位置，替换：
":46,65s/home\/chyang/root/g"
（输入法修改完成）编译完成后，把
libmurphypinyin.so    libmurphypinyin.so.0.0
libmurphypinyin.so.0  libmurphypinyin.so.0.0.1
按原样（文件是文件，链接是链接）复制到"qtopia/plugins/inputmethods"目录：
cp libmurphypinyin.so* $QTBASE/qtopia/plugins/inputmethods/ -a
3, 复制拼音码表(pinyin_table.txt)，词组文件(murphytalk_phrase.dat, murphytalk_phrase_idx.txt)和配置文件(murphytalk.conf)到指定目录（我设置的是root目录）
cp murphytalk-0.3/phrase/murphytalk_phrase* /root/
cp murphytalk.conf /root/
4，murphypinyin.desktop文件同上
有软键盘，打开软键盘时汉子少了一半，是字体问题。

19:38 2007-11-15
现有qt字体，没有10点阵的这类中文字库，使用10点大小的字体时要么是方块，要么是其他可用大小。
参考下面的文章建立，适合的字体：
http://www.dzkf.cn/html/qianrushixitong/2007/0823/2526.html
在嵌入式Linux及QT/Embedded-2.3.7下制作QPF字库

11:30 2007-11-16
QT文档，Qtopia部分内部机制浅析_自QT中文论坛.ppt
进程间通信：QCopChannel
待做：1， 学习使用和机制，qt2.3.7是否支持。2，细看"Qtopia部分内部机制浅析.ppt"
自：QT中文论坛，mzl626
http://www.qtcn.org/bbs/read.php?tid=7750
mzl626在联想上海研究院工作。

13:37 2007-11-16
QT字库
unifont是完整的Unicode字库，好像只有16*16点阵的。
http://czyborra.com/unifont/里面有详细的说明
/media/NEW/log/fv/qt/font/是我下载的资料
hex2bdf用于转换字库。
注意把第一行的perl路径设置正确即可。
./hex2bdf unifont.hex > unifont.bdf

14:38 2007-11-16
用QT应用程序生成字体
If an application is run with the -savefonts command-line option, then
whenever a font other than a QPF font is used, a corresponding QPF file is
saved. This allows you to easily find the font usage of your applications and
to generate QPF files so that you can eventually reduce the memory usage of
your applications by disabling TTF and BDF support from Qt/Embedded. option,
or by modifying the initialization of qws_savefonts in
kernel/qapplication_qws.cpp of the Qt/Embedded library source code. In extreme
cases of memory-saving, it is possible to save partially-rendered fonts (eg.
only the characters in "Product NameTM") if you are certain that these are the
only characters you will need from the font. See
QMemoryManager::savePrerenderedFont() for this functionality.
1，首先把所需ttf或bdf字体复制到"qt/lib/fonts"目录，并修改"qt/lib/fonts/fontdir"文件。
zysong zysong.ttf FT n 50 100 su
su: smooth, unicode encoding
2，运行应用程序时加上"-savefonts"参数。
这里使用的是"fontcreator.tar.gz"位于"fv/qt/font"
"zysong_100_50.qpf  zysong_120_50.qpf  zysong_160_50.qpf zysong.ttf"是结果。保存在"qt/font"。
参考资料：
1， Fonts in Qt/Embedded，qt/doc/html/fonts-qws.html
2, http://jserv.sayya.org/qtopia/doc/qte.txt
Qt/Embedded 中文處理實戰。
3, http://www.dzkf.cn/html/qianrushixitong/2007/0823/2526.html
在嵌入式Linux及QT/Embedded-2.3.7下制作QPF字库
待做：保存网页
4, 字库
http://font.xker.com/sort/Catalog231/231_1.htm
5, TTC与TTF
TTC 和 TTF 的解释和区别。    CSDN
自：http://blog.csdn.net/xiaorui0328/archive/2007/06/26/1666979.aspx
Blog推出文章指数概念，文章指数是对Blog文章综合评分后推算出的，综合评分项分别是该文章的点击量，回复次数，被网摘收录数量，文章长度和文章类型；满分100，每月更新一次。
TTC
TrueType Collection file. A scheme where multiple TrueType fonts can be stored
in a single file, typically used when only a subset of glyphs changes among
different designs. They're used in Japanese fonts, where the Kana glyphs
change but the Kanji remain the same.
TTF
The recommended file extension for TrueType font files on the PC. On the
Macintosh, exactly the same data is in an *'sfnt' resource. The recommended
file extension for the TrueType flavour of *OpenType fonts is also TTF. (But
Type 1 flavour OpenType fonts should have an OTF extension.) 
所以我个人认为TTF才是一个将一种字体定义好的文件格式，它里面应该包括每个字的写法。而TTC是一个链接容器，可能只有部分字体的写法，其他的字体是从别的TTF中链接过来的。
ttc 是TrueType的集合，可能会在一个ttc文件中包含多个type 接口。可以用FontLab, 或者 breakttc.exe 将一个ttc文件分离成多个ttf文件。
宋体是TTC, 黑体是TTF
5, 提取单独一些字库的方法：
http://www.dzkf.cn/html/qianrushixitong/2007/0823/2525.html
QT/Embedded从ttf字库中提取指定汉字生成qpf字库的办法
待做：保存网页

17:18 2007-11-16
项目中使用sqlite 3.4

18:11 2007-11-16
数据库操作时，ID号是自动增加的，用NULl即可。

20:10 2007-11-16
QT相关资料：
http://www.qtcn.org/bbs/
QT中文论坛，网址

20:15 2007-11-16
现有进展：
"fv/backup/fvdac_11162014.tar.gz"，其中common目录是c++调用sqlite的程序。
需要编译RH9下的sqlite库。

20:26 2007-11-16
网址
http://book.51cto.com/art/200707/51439.htm
http://book.51cto.com/ 有很多电子书
待做：细看

17:55 2007-11-17
网址，学习SQLite
http://www.sqlite.org/
sqlite网站
http://www.sqlite.org/cvstrac/wiki?p=HowToCompile
如何编译sqlite
http://sqlite.com.cn/bbs/index.asp
SQLite中文社区
http://www.codeproject.com/database/CppSQLite.asp
CppSQLite - C++ Wrapper for SQLite，待做，保存网页
待做：1，看上述网址；2，确定开发板所用的SQLite版本。与3.5的差异。
http://www.sqlite.org/lang.html
SQL As Understood By SQLite（SQLite支持的SQL语言）重要。

18:04 2007-11-17
http://blog.csdn.net/jixingzhong/archive/2007/11/10/1877445.aspx
C99与C89比较，新增特性内容
待做：1，看作者博客；2，林锐的高质量c编程
13:19 2007-11-19
上班时间：13：00

15:27 2007-11-19
今天ftp不能用了。奇怪....
使用NFS文件系统：
自己建立的loop设备仍然无法使用NFS文件系统：
[root@(none) dev]# ls loop* -l
lr-xr-xr-x    1 root     root            5 Mar  1 04:52 loop -> loop0
brw-r--r--    1 root     root       7,   0 Mar  1 04:47 loop0
brw-r--r--    1 root     root       7,   1 Mar  1 04:52 loop1
[root@(none) dev]# mount -o loop 192.168.200.200:/usr/src/fft_linux/fs /tmp
mount: nfsmount failed: Bad file descriptor
mount: Could not find a spare loop device
重新编译内核。

15:35 2007-11-19
自己编译的内核可以使用液晶屏，触摸功能正确。
位于："/media/NEW/log/fv/kernel/zImage_loop_11191531"

16:11 2007-11-19
Linux, NFS文件系统挂载遇到问题，重要
1，Permission denied一般是"/etc/exports"设置有问题。
一般可以使用如下设置：
[root@localhost sqlite3]# cat /etc/exports 
/usr/src/fft_linux/fs 192.168.200.204(rw,sync,no_root_squash) 192.168.200.200(rw,sync,no_root_squash)
然后重启NFS
/etc/rc.d/init.d/nfs restart
或
service nfs restart
这是两种启动系统服务（包括网络服务）的方法。
2， [root@(none) /]# mount 192.168.200.200:/usr/src/fft_linux/fs /home
mount: nfsmountNfailed: Bad file descriptor
FS: mount program didn't pass remote address!
mount: Mounting 192.168.200.200:/usr/src/fft_linux/fs on /home failed: Invalid argument
是iptables（和防火墙什么关系？待做，查）的问题，关闭即可：
[root@localhost useradmin]# /etc/init.d/iptables stop
清除防火墙规则：                                           [确定]
把 chains 设置为 ACCEPT 策略：filter                       [确定]
正在卸载 Iiptables 模块：                                  [确定]
现在有个奇怪的问题，如果关闭iptables后，再打开FC7防火墙的配置菜单，开发板mount就无法成功，似乎是iptables有生效了。待做：查清FC7防火墙设置方法。
3, 使用 
[root@(none) Qtopia]# mount -t nfs -o loop 192.168.200.200:/usr/src/FV_Projectqt_embedded/opia qtopia-free-1.7.0
或
[root@(none) Qtopia]# mount -o loop 192.168.200.200:/usr/src/FV_Project/qt_embedded/opia qtopia-free-1.7.0
都提示：
mount: 192.168.200.200:/usr/src/FV_Project/qt_embedded/qtopia: No such file or directory
mount: Could not setup loop device
但是使用下面的命令正确：
[root@(none) Qtopia]# mount 192.168.200.200:/usr/src/FV_Project/qt_embedded/opia qtopia-free-1.7.0
有点奇怪，待做，查。

17:03 2007-11-19
今日进展：
1，设置NFS用了很长时间，>2h；
2，修改UserFingerInfo再加入数据库前，使用随即数确定FV ID。template index=valueRegisteredFinger->count()+1。但是这样设置template有问题，如果删除了手指，index和count就没有对应关系了。
待做：1，加入手指信息结构体；2，查SQLite中BLOB类型的含义。
struct fingerData
{
	int tempIndex;
	unsigned char* template;
}
template每次在注册手指时由addVRF申请空间。
3，待做：重新考虑国际化的文件是各个功能独立存在，还是统一。

18:18 2007-11-19
Linux2.4内核，用NFS作为根文件系统
选中下面的选项：
Networking options 
    [*]   IP: kernel level autoconfiguration
Network File Systems
    <*> NFS file system support
        [*]   Provide NFSv3 client support
        [*]   Root file system on NFS

18:54 2007-11-19
挂载NFS遇到问题，完整过程见：
/media/NEW/log/fv/kernel/nfs_boot
明天用2小时查。不行就把部分文件系统挂为NFS。
现有问题：
1，gatewayip设置有问题
2，其他原因。
跟踪代码，查看-13的含义。

01:20 2007-11-20
c++, QT，操作符重载
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -DNO_DEBUG -I/usr/src/src2/FV_project/qt//qt/include -o useradmindialog.o useradmindialog.cpp
useradmindialog.cpp: In member function `void 
   UserAdminDialog::launchUserAdmin(int)':
useradmindialog.cpp:193: 错误：ISO C++ says that `QString operator+(const 
   QString&, char)' and `operator+' are ambiguous even though the worst 
   conversion for the former is better than the worst conversion for the latter
make: *** [useradmindialog.o] 错误 1
程序：
192        promptLabel->setText( tr("execute") + tr(opName[index+1].latin1())
193                                + ret==1?tr("successful"):tr("fail"));
给"?:"运算符加上括号即可
192        promptLabel->setText( tr("execute") + tr(opName[index+1].latin1())
193                                + (ret==1?tr("successful"):tr("fail")));

01:33 2007-11-20
完成建立UserAdminDialog类，用于启动四个用户管理程序。
现有进展：useradmin_11200134.tar.gz
现在对于国际化的考虑：
主界面（包括UserAdminDialog类）使用一个Translator，子界面使用独立的Translator，进入子界面时加载Translator，退出时卸载。如果同时加载全部Translator界面切换时速度快，但是占用系统资源多。
void QApplication::installTranslator ( QTranslator * mf )
Adds mf to the list of message files to be used for localization. Message
files are searched starting with the most recently added file. 

10:18 2007-11-20
(09:57 2007-11-21)
待做，项目进展，现有任务：
1，完成文件系统，可以运行已有的中文输入法。输入法无法输入词组（完成）
2，加入数据库。
讨论：1)，SQLite是否有TIMESTAMP功能？2)，TIME_START和TIME_END不应该使用TIMESTAMP，定义日期格式。
3，界面调整，对齐；（完成）
4，加入validator，看"13:15 2007-11-21"是否有重要内容需要解决。
4，用户连续注册。
在useradmin中加入一个返回值，useradmindialog根据返回值决定操作：(1)，重新例化同样实例（借此实现用户连续注册，等连续操作）；(2)，用户操作成功；(3)，用户操作失败。
5，文件系统不完善：文件系统不可写，无法保存数据库。
6，qtopia国际化。
file:///usr/src/FV_Project/qt_embedded/qtopia/doc/html/i18n-qtopia.html
7，改界面颜色为默认颜色。（完成）
8，修改，查询，删除需要先输入ID。（完成）
9，系统需要正确时间，安装电池，确认RTC工作正常。

11:46 2007-11-20
在开发板上加入输入法：
qpe加载输入法时出错：
/Qtopia/qtopia-free-1.7.0/plugins/inputmethods/libmurphypinyin.so: undefined symbol: __get_eh_context
Plugin not loaded: murphypinyin
/Qtopia/qtopia-free-1.7.0/plugins/inputmethods/libmurphypinyin.so: undefined symbol: __get_eh_context
Plugin not loaded: murphypinyin
上网，查资料，发现可能是编译器版本问题，于是用3.3.2 arm-linux-gcc编译器编译。
这次可以加载拼音输入法(Murphytalk)，但是写1，2个字后出现段错误，下面是三次段错误的信息：
先输入了一个字，再输入两个nn后：
pc : [<40b3a540>]    lr : [<40b375c4>]    Not tainted
sp : bffff5e0  ip : 40b3a4ec  fp : bffff69c
r10: 40b57390  r9 : 00134cf8  r8 : 001326b4
r7 : 00000000  r6 : bffff6c4  r5 : 00000000  r4 : 00000000
r3 : 00000000  r2 : 00000000  r1 : 001326b4  r0 : 00000000
Flags: nzCv  IRQs on  FIQs on  Mode USER_32  Segment user
Control: C000317F  Table: 33CC8000  DAC: 00000015
Aborted
输入第二个字时：
pc : [<40b3a540>]    lr : [<40b375c4>]    Not tainted
sp : bffff87c  ip : 40b3a4ec  fp : bffff938
r10: 40b57390  r9 : 0014c638  r8 : 001326fc
r7 : 00000000  r6 : bffff960  r5 : 00000000  r4 : 00000000
r3 : 00000000  r2 : 00000000  r1 : 001326fc  r0 : 00000000
Flags: nzCv  IRQs on  FIQs on  Mode USER_32  Segment user
Control: C000317F  Table: 321D0000  DAC: 00000015
Aborted
输入第三个字时。
pc : [<40b3a540>]    lr : [<40b375c4>]    Not tainted
sp : bffff87c  ip : 40b3a4ec  fp : bffff938
r10: 40b57390  r9 : 00134c80  r8 : 001326fc
r7 : 00000000  r6 : bffff960  r5 : 00000000  r4 : 00000000
r3 : 00000000  r2 : 00000000  r1 : 001326fc  r0 : 00000000
Flags: nzCv  IRQs on  FIQs on  Mode USER_32  Segment user
Control: C000317F  Table: 33CC8000  DAC: 00000015
Aborted
另外，汉子显示为白方块。是字库问题。
加入汉子字库后，段错误很少出现。
接"17:58 2007-11-20"

16:35 2007-11-20
c语言，gcc，编译动态链接库(*.so)
LINK    =       arm-linux-g++
LFLAGS  =       -shared -Wl,-soname,libmurphypinyin.so.0
TARGETD =       libmurphypinyin.so.0.0.3
OBJECTS =       PinyinFrame.o \
                PinyinImpl.o \
                PinyinEngine.o \
                scim/scim_pinyin.o \
                phrase/PinyinPhrase.o \
                public.o \
                Config.o
BJMOC  =       moc_PinyinFrame.o
LIBS= $(SUBLIBS) -L$(QPEDIR)/lib -L$(QTDIR)/lib -lm -lqpe -lqte -lqtopia
$(LINK) $(LFLAGS) -o $(TARGETD) $(OBJECTS) $(OBJMOC) $(LIBS)


17:32 2007-11-20
Qtopia
如果启动两个qpe，会出现不能打开socket的错误：
QServerSocket: failed to bind or listen to the socket                           
Failed to bind to port 4243

17:34 2007-11-20
现有启动脚本内容
mount 192.168.200.200:/usr/src/FV_Project/qt_embedded_board/qtopia/ /Qtopia/qtopia-free-1.7.0
mount 192.168.200.200:/usr/src/FV_Project/qt_embedded_board/qt/lib/fonts/ /Qtopia/qt-2.3.7/lib/fonts/
mount 192.168.200.200:/usr/src/fft_linux/qt_root/root/ /home

17:58 2007-11-20
用QT开发板的库和3.3.2编译器尝试。
今天状态不好，日志记录不全。
进一步观察发现，输入单个文字时不会出错。都是在输入词库中已有的词组（不论是否是不完整拼音）时出现的错误。
pc : [<40c176b0>]    lr : [<40c144cc>]    Not tainted
sp : bffff5f0  ip : 40c1765c  fp : bffff6ac
r10: 40c34b14  r9 : 00137930  r8 : 001353f4
r7 : 00000000  r6 : bffff6d4  r5 : 00000000  r4 : 00000000
r3 : 00000000  r2 : 00000000  r1 : 001353f4  r0 : 00000000
Flags: nzCv  IRQs on  FIQs on  Mode USER_32  Segment user
Control: C000317F  Table: 31B64000  DAC: 00000015
Aborted  
把murphytalk_phrase.dat和murphytalk_phrase_idx.txt改名后，问题消失。
进一步跟踪发现：
是PinyinFrame.cpp的paintEvent函数384行开始的，"printX86"语句后面出的错。这个不影响输入单字，暂时进行下一步（应用程序运行在QPE，加入数据库），明天有时间继续查找。
if(m_engine.isPhrase()){
	printX86("[paintEvent]This is a phrase");
	str+=get_phrase(i);
}
现有代码：murphytalk-0.3_11201830.tar.gz
(17:31 2007-12-13)
后来发现是由于缺少词组文件造成的。输入法代码如何修改见"18:43 2007-11-15"

22:02 2007-11-20
嵌入式，手写输入法
几个开源的手写输入法
http://www.qtcn.org/bbs/read.php?tid=9397
手写输入法讨论专区！
几个开源的手写输入法：
kanjipad(日文手写识别,最新为2.0.0版)，
chinput（中文输入服务，最新版为3.0.2版），
cellWriter（全能开源手写识别，最新版为1.3.2版）。
待做：查相关资料。

11:51 2007-11-21
pro文件加入：
DEFINES                += QTOPIA_APP_INTERFACE
会提示没有main函数：
g++ -c -pipe -DQWS -fno-exceptions -fno-rtti -Wall -W -O2 -fno-default-inline -DQTOPIA_APP_INTERFACE -DNO_DEBUG -I/usr/src/FV_Project/qt/qt/include -I/usr/src/FV_Project/qt/qtopia/include -o moc_useradmindialog.o moc_useradmindialog.cpp
gcc  -o useradmindialog qinfowidget.o userbasicinfo.o fingervein.o userfingerinfo.o userdateinfo.o qelistbox.o useradmin.o useradmindialog.o main.o moc_qinfowidget.o moc_userbasicinfo.o moc_fingervein.o moc_userfingerinfo.o moc_userdateinfo.o moc_useradmin.o moc_useradmindialog.o  -L/usr/src/FV_Project/qt/qtopia/lib -L/usr/src/FV_Project/qt/qt/lib -lm -lqpe -lqtopia -lqte
/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crt1.o: In function `_start':
(.text+0x18): undefined reference to `main'
collect2: ld 返回 1
make: *** [useradmindialog] 错误 1
待做：再看文档，查。

11:53 2007-11-21
下午尝试在Qtopia中运行useradmindialog。
完成文件系统。
数据库。

13:15 2007-11-21
待做转移：现有小问题
1, 
qt，qpe中如何禁止窗口的右上角的关闭（小叉子）？与style和setStyle函数有无关系？
qpe的开始菜单和任务栏怎么禁止或隐藏？
2, validator。重要！
加入日期
QPEDateEdit	Compact widget for selecting a date
QPEDatePicker	Allows a date to be selected from a calendar view
3，查看手指注册信息时，应该可以看到全部注册手指，而不需要用滚动条。
4，小板文件系统挂载优盘。

14:21 2007-11-21
在RH9下加入qpe成功，加入到arm板上：
cp useradmindialog /usr/src/FV_Project/qt_embedded_board/qtopia/bin/ -p
cp qpe_resources/useradmindialog.desktop /usr/src/FV_Project/qt_embedded_board/qtopia/apps/Applications/ -p
cp qpe_resources/useradmindialog.png /usr/src/FV_Project/

16:44 2007-11-21
cp useradmin/libuseradmindialog.so release/ -p
cp query/libquerywnd.so release/ -p
cp verify/fv-gui release/ -p
cp common/lib/libsqlite3.so* -a release/

17:03 2007-11-21
测试整体程序：
临时措施：
1，fv.db保存在/home
2, 复制
libquerywnd.so         libsqlite3.so.0        libuseradmindialog.so
libsqlite3.so          libsqlite3.so.0.8.6    
到/usr/src/fft_linux/qt_root/lib/，然后挂载到板子/lib。

18:34 2007-11-21
文件系统已经制作完成，饭后格式化为cramfs和下载实验。
先去吃饭了.

19:24 2007-11-21
远峰的mkcramfs复制到/usr/bin。也可以从网上下载源代码编译。

19:29 2007-11-21
对原有文件系统的改动：
1，加入了murphytalk中文拼音输入法。
现有代码位于："fv/qt/pinyin/murphytalk-0.3_bamvor1121.tar.gz "
2，加入了自己的程序(Finger Vein)。
注：
1, 修改前文件系统是23M，现在是28M。
2, 由于不需要编译，文件系统的qtopia-free-1.7.0中不需要include和src目录
./imagewrite /dev/mtd/0 hitachi_qt_root.cramfs:1m
[root@(none) home]# ./imagewrite /dev/mtd/0 hitachi_qt_root.cramfs:1m
meminfo size = 67108864
size = 29331456
size = 29331456
nand_erase: attempt to erase a bad block at page 0x00004580
bad_block = 1
文件系统启动出错，见"fv/log/boot_hitachi_qt_root"：
发现少两个目录：proc var
3, if由地址"usr/etc/rc.local"设置，改为所需地址。
删除了sysconfig/network-scripts目录
再次烧写：
bash-2.05b# ./imagewrite /dev/mtd/0 hitachi_qt_root_11211954.cramfs:1m
meminfo size = 67108864
size = 29331456
size = 29331456
nand_erase: attempt to erase a bad block at page 0x00004580
bad_block = 1
再次出错，这次是没有复制隐藏文件"/.bashrc"
怎么才能完整的复制？
20:18 2007-11-21
1，verify的修改：
(1)Makefile-arm LIBS中增加了-lqpe
(2)src/fv-gui.cpp中根据是否是X86把fv.db放在不同位置。
395 #ifdef X86
396         char db_p[]="../common/fv.db";
397 #else
398         char db_p[]="/root/fv.db";
399 #endif
2，verify BUGS：
[root@(none) /]# Create pluginlibman in libqpe
QObject::connect: No such slot fv_gui::about()
QObject::connect:  (sender name:   'unnamed')
QObject::connect:  (receiver name: 'fv_gui')
reg value=3
reg value=23 
program is running in verification mode 3
Send V_P with mode = 0
Terminal works normal
enter thrd_waitVerify
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Send V_P with mode = 1
Terminal send V_AR up to fvcinf
%Terminal start-up by power recovery.
                        --Verification Status--                                                                             
%Verification Failed!
insert into USER_LOG_T values (null, -1, '2025- 1-27 19:23: 7','');
如果出错是再次启动：
[root@(none) /]# Create pluginlibman in libqpe
QObject::connect: No such slot fv_gui::about()
QObject::connect:  (sender name:   'unnamed')
QObject::connect:  (receiver name: 'fv_gui')
reg value=3
reg value=23
program is running in verification mode 3
Send V_P with mode = 0
ERROR! Terminal response wrong type after upper system sending V_P
error after check fv terminal
第三次启动时可以正常启动。
错误原因是数据库无法写入数据。
现有文件系统需要改进的地方：
1，不可写；
2，字库占17M空间，如果精简字库可以节省大量空间。

20:39 2007-11-21
文件系统：
1, http://www.yaffs.net/
yaffs网站。
2, 资料
http://blog.chinaunix.net/u1/33412/showart_271853.html
yaffs和jffs2
http://www.linux-mtd.infradead.org
http://www.aleph1.co.uk/yaffs/index.html
http://www.aleph1.co.uk/yaffs/index.html
3, http://edu.stuccess.com/KnowCenter/Embedded/questions/3.8/00000011.htm
yaffs制作 

20:51 2007-11-21
待做：看，下载嵌入式资料
http://www.arm9.net/download.asp
友善之臂下载中心

21:24 2007-11-21
现有文件系统：
vivi-cs8900，root.cramfs。
自己编译的：
fv/kernel/zImage_loop_11191531
自己建立的：
hitachi_qt_root_finish.cramfs

21:25 2007-11-21
按傅立叶文档写入usr.yaffs，失败。
内核panic错误。
待做：查张志霞板子根文件系统的库，然后建立user为yaffs。

21:29 2007-11-21
useradmin_11212129.tar.gz fvdac_new_11212128.tar.gz
前者是最后独立修改的useradmin，后者应该是全部工程的最终板。
待做：比较后确认。

00:33 2007-11-25
待做：下一步计划：
1，完成数据库。
(19:17 2007-11-21)
管理员ID是9999，注册程序是否容易实现。
如果有问题，在与张志霞商量。
(19:17 2007-11-21).end
2，给叶涛打电话，请假，周一上午毕业手续。（完成）
3，调整界面。看wizard例子或其他例子，看是否有更好的排列的方法，例如网格，表格。
4，挂载一个只读的文件系统。需要明白2.4内核中bon分区和mtd分区的关系。
5，完成"10:18 2007-11-20"现有任务的剩余内容。

10:09 2007-11-25
fvdac项目资料，SQLite数据库定义
异常日志：
EXP_LOG_T
[ID] integer PRIMARY KEY AUTOINCREMENT NOT NULL
[USER_ID] INT(11)
[TYPE] VARCHAR(1)
[DATE] TIMESTAMP
[MSG_CODE] VARCHAR(10)
[MSG_1] VARCHAR(100)
[MSG_2] VARCHAR(100)
[DEL_FLG] VARCHAR(1)

操作日志
OPER_LOG_T
[ID] integer PRIMARY KEY AUTOINCREMENT NOT NULL
[OPER_ID] INT(11)
[USER_ID] INT(11)
[OPER_TYPE] VARCHAR(2)
[COMMENT_TEXT] VARCHAR(64)
[DATE] TIMESTAMP
[DEL_FLG] VARCHAR(1)

用户信息
USER_T
[ID] integer PRIMARY KEY AUTOINCREMENT NOT NULL
[USERNO] VARCHAR(8)
[USERNAME] VARCHAR(80)
[COMPANY] VARCHAR(80)
[DEPARTNO] VARCHAR(8)
[DEPARTMENT] VARCHAR(80)
[BIRTHDAY] VARCHAR(8)
[GENDER] INT(1)
[TYPE] VARCHAR(2)
[MOBILENO] VARCHAR(13)
[PHONE1] VARCHAR(13)
[F_1_PATTERN] BLOB
[F_2_PATTERN] BLOB
[F_3_PATTERN] BLOB
[F_4_PATTERN] BLOB
[F_5_PATTERN] BLOB
[VALIDFLAG] INT(1)
[COMMENT_TEXT] VARCHAR(64)
[REGISTER] TIMESTAMP
[LASTMODIFIED] TIMESTAMP
[TIME_START] TIMESTAMP
[TIME_END] TIMESTAMP
[DEL_FLG] INT(1)

用户开门信息（？）
USER_LOG_T
[ID] integer PRIMARY KEY AUTOINCREMENT NOT NULL
[USER_ID] INT(11)
[DATE] TIMESTAMP
[DEL_FLG] VARCHAR(1)

注：
(9) What is the maximum size of a VARCHAR in SQLite?
自http://www.sqlite.org/faq.html#q9
    SQLite does not enforce the length of a VARCHAR. You can declare a
VARCHAR(10) and SQLite will be happy to let you put 500 characters in it. And
it will keep all 500 characters intact - it never truncates. 

11:17 2007-11-25
待做：用户管理中加入结构清楚的数据库操作函数：
readDB读取数据到UserData，setUserData把前者读入的UserData数据写入界面。
getUserData把界面数据保存到UserData，writeDB把UserData数据写入数据库。
暂时不考虑数据库操作效率的问题。
函数：
1, protected: void UserAdmin::readDB(int seq)
输入：USER_LOG的序号；
输出：无
操作：从USER_LOG读取数据，保存在UserData类型中。
2, protected: int UserAdmin::writeDB()
输入：无
输出：写入的USER_LOG序号。出错提示（？，待做，加入）
操作：向USER_LOG表写入UserData数据。OPER_LOG_T写入数据库修改信息（可以简化）。
3, protected: bool UserAdmin::setUserData()
输入：无
输出：是否正确写入数据。
操作：UserData通过QInfoWidget（UserBasicInfo，UserFingerInfo和UserDateInfo）的setInfo()保存数据。
4, protected: bool UserAdmin::getUserData()
输入：无
输出：是否正确读取数据。
操作：通过QInfoWidget（UserBasicInfo，UserFingerInfo和UserDateInfo）的getInfo()读取数据并保存在UserData中。
5, protected: void QInfoWidget::setInfo(UserData* ud)
输入：ud
输出：无
操作：把ud数据写入到"QObjectList *info"，保存过的数据做标记。
6, protected: void QInfoWidget::getInfo(UserData* ud)
输入：ud
输出：无
操作：把数据"QObjectList *info"写入到ud，写入的数据做标记。

疑问：
1，数据库读写放到useradmin中还是放到useradmindialog？
useradmin的优点：如果放到useradmindialog，例化useradmin时需要给useradmin传递数据库数据，useradmin退出时需要把要写入的数据返回给useradmindialog。
useradmindialog的优点：数据库查询放在了启动useradmin之前，useradmin不会有不必要的启动。
2，是一次写入/读出数据库数据，还是分次？
USER_T数据项多，指静脉数据量大，一次写入不方便。待做：查，这种情况下，一般是如何实现的。
分次写入比较方便，但是显然不能重复写几十个update语句，所以需要可以用统一的函数处理。使用循环（或迭代器）和模板类。

数据结构：
class UserDataElem
{
	QString name;
	valueType value;
	QString getName();
	valueType getValue();
}
valueType有所不同，如何处理？
(15:04 2007-11-25)
使用模板类。

12:21 2007-11-25
待做：
继续完成前面的数据结构。

19:59 2007-11-25
QCString QString::utf8 () const
Returns the string encoded in UTF8 format. 

23:01 2007-11-25
SQLite学习，SQL语句
1，select语句：
select * from USER_T where ID == 10 order by 1
从USER_T表中选择ID=10的元素。
待做：查"select *"和"order by l"的含义。
2，update
update USER_T set COMPANY = 'Christiano Ronaldo' where ID = 10;
更新ID=10数据的COMPANY字段为"Christiano Ronaldo"。

23:47 2007-11-25
待做：看c++编程金典的第十七章，预处理。
看"#"和"##"的作用。

00:00 2007-11-26
又是因为时间原因放弃UserDataElem类，感觉自己对c++，模板类还不了解，估计需要2天才能完成。只有稍后实现。待做。

00:03 2007-11-26
改为最简单的办法：
读数据库：从数据库读取数据，直接通过getInfo得到的指针写入界面；
写数据库：从界面中顺序得到数据，通过insert语句写入数据库。

13:25 2007-11-26
待做：问题。USER_T数据库中没有保存指静脉是哪个手指。

16:03 2007-11-26
Program terminated with signal 11, Segmentation fault.
#0  0x08069ba3 in QList<QObject>::current (this=0x0)
    at /usr/src/FV_Project/qt/qt/include/qglist.h:184
184     {
(gdb) where
#0  0x08069ba3 in QList<QObject>::current (this=0x0)
    at /usr/src/FV_Project/qt/qt/include/qglist.h:184
#1  0x0806818c in UserAdmin::DB2GUI (this=0xbffb4270, query=0xbffb41f0, 
    guiInfo=0x85988d0) at useradmin.cpp:303
#2  0x08067c25 in UserAdmin (this=0xbffb4270, opT=DEL_c, parent=0x0, name=0x0, 
    fl=0) at useradmin.cpp:175
#3  0x080683e3 in main (argc=1, argv=0xbffb44b4) at useradmin.cpp:365
(gdb) quit

查看代码发现是：
void UserAdmin::DB2GUI(CppSQLite3Query* query, QObjectList* guiInfo)
{
	QObjectListIt it(*guiInfo);
	QWidget *obj;
	qDebug("DEBUG: entering DB2GUI");
	while ( (obj = (QWidget*)(it.current())) != 0) {	// for each found object...
		++it;
写成了
void UserAdmin::DB2GUI(CppSQLite3Query* query, QObjectList* guiInfo)
{
	QWidget *obj;
	qDebug("DEBUG: entering DB2GUI");
	while ( (obj = (QWidget*)(guiInfo->current())) != 0) {	// for each found object...
		++guiInfo;

知道
class Q_EXPORT QObjectList : public QList<QObject>
class Q_EXPORT QObjectListIt : public QListIterator<QObject>
所以查QList和QListIterator文档：
QList
type * QList::current () const
Returns a pointer to the current list item. The current item may be null (implies that the current index is -1).
See also at(). 

QListIterator
type * QListIterator::current () const
Returns a pointer to the current iterator item

原因是QList::current()返回了null。
待做：查为什么会返回null，index=-1？

16:11 2007-11-26
界面元素与数据库对应关系
[ID] integer PRIMARY KEY AUTOINCREMENT NOT NULL
[USERNO] VARCHAR(8)
 valueUserID     ( class: QLineEdit )
[USERNAME] VARCHAR(80)
 valueName       ( class: QLineEdit )
[COMPANY] VARCHAR(80)
 valueCop        ( class: QLineEdit )
[DEPARTNO] VARCHAR(8)
 TODO
[DEPARTMENT] VARCHAR(80)
 valueDepart     ( class: QComboBox )
[BIRTHDAY] VARCHAR(8)
 valueBirth      ( class: QLineEdit )
[GENDER] INT(1)
 valueSex        ( class: QComboBox )
[TYPE] VARCHAR(2)
 valueType       ( class: QComboBox )
[MOBILENO] VARCHAR(13)
 valueMobile     ( class: QLineEdit )
[PHONE1] VARCHAR(13)
 valueTel        ( class: QLineEdit )
[F_1_PATTERN] BLOB
 TODO
[F_2_PATTERN] BLOB
 TODO
[F_3_PATTERN] BLOB
 TODO
[F_4_PATTERN] BLOB
 TODO
[F_5_PATTERN] BLOB
 TODO
[VALIDFLAG] INT(1)
[COMMENT_TEXT] VARCHAR(64)
[REGISTER] TIMESTAMP
 valueRegTime    ( class: QLineEdit )
[LASTMODIFIED] TIMESTAMP
 valueModTime    ( class: QLineEdit )
[TIME_START] TIMESTAMP
 valueValFr      ( class: QLineEdit )
[TIME_END] TIMESTAMP
 valueValTo      ( class: QLineEdit )
[DEL_FLG] INT(1)
 NONE
[TODO]
 valueRegisteredFinger   ( class: QListBox )

17:19 2007-11-26
编译SQLite时需要修改Makefile：
SQLite需要异常处理，所以去掉CXXFLAGS的"-fno-exceptions"选项。
LIBS加入-lsqlite3
SOURCES =       qinfowidget.cpp \
		...... \
                ../common/CppSQLite3.cpp
OBJECTS =       qinfowidget.o \
		...... \
                ../common/CppSQLite3.o
####### Compile
../common/CppSQLite3.o: ../common/CppSQLite3.cpp

17:35 2007-11-26
项目进展，加入数据库
待做完成：现在从数据库读数据已经正确，但是中文无法测试。用qpe或修改UserAdmin类使其可以接收语言参数。（转移）

17:52 2007-11-26
如何定义类的数组？
class FieldName {
	FieldName(char* dfn, char* gfn): dbFieldName(dfn), guiFieldName(gfn)
	{}
	char* dbFieldName;
	char* guiFieldName;
}

FieldName fn[] = new FieldName{
	{"USERNO", "valueUserID"},
	{"USERNAME", "valueName"}
}
错误：
g++ -c -pipe -DQWS -fno-rtti -Wall -W -O2 -fno-default-inline -DUSER_ADMIN_DEBUG -DNO_FV -DUSER_ADMIN_MAIN -ggdb -DX86 -I/usr/src/FV_Project/qt/qt/include -o useradmin.o useradmin.cpp
useradmin.cpp:69: ISO C++ forbids defining types within return type
useradmin.cpp:69: syntax error before `[' token
make: *** [useradmin.o] 错误 1

18:32 2007-11-26
修改"UserAdmin::getDBFieldName"为简洁形式。
DBValue2GUIValue函数也需要修改。
今晚待做完成：
1，完成结构清楚的DBValue2GUIValue（完成）
2，完成数据库写入；（完成）
3，学习类的数组，解决"17:52 2007-11-26"问题。（转移）
4，待做完成：
(1)修改fingerTempIndex的产生方式。（转移）
(2)UserAdmin()的read db内容单独建立一个方法。（完成）

18:35 2007-11-26
c++学习, string转为char*
string的c_str()函数可以转化为char*类型：
string c = "abc";
char * p = 0;
p = c.c_str();

23:43 2007-11-26
写入数据库。
1，修改，把UserBasicInfo，UserDateInfo和UserFingerInfo的变量改为public。长远需要改为容器，用名字访问。

00:46 2007-11-27
项目进展：
初步完成数据库写入。
lastRowId()是获得当前操作的最后一个ID。所以改为在构造函数中先插入所需行，再查询出结果。
待做完成：考虑注册失败的情况，删除已经插入的记录。（完成）

11:25 2007-11-27
为了解决NULL显示问题，用strcmp比较，发现只有用：
strncmp(s, obj, 4)，才正确。奇怪？
UserAdmin::DBValue2GUIValue
      else //if ( !strcmp(fieldValue.latin1(), "NULL") ) 
        {
                const char* s = fieldValue.latin1();
                char* obj = "NULL";
                qDebug("DEBUG: %s, %s: %d", s, obj, strncmp(s, obj, 4));
//              for ( int i = 0; i < strlen(obj); i++ )
//              {
//                      qDebug("DEBUG: %dth: %d - %d", i, *s++, *obj++);
//              }
                return "";
后来发现是写入数据库时"NULL"写成了"NULL "。
但是其实应该写入NULL（不加引号），这样读出时就不需要特殊处理了。

12:18 2007-11-27
c++学习
1，case语句，"crosses initialization"
g++ -c -pipe -DQWS -fno-rtti -Wall -W -O2 -fno-default-inline -DNO_DEBUG -DNO_FV -ggdb -DX86 -I/usr/src/FV_Project/qt/qt/include -I/usr/src/FV_Project/qt/qtopia/include -o useradmin.o useradmin.cpp
useradmin.cpp: In member function `UserAdmin::UserAdmin(opType, QWidget*, const 
   char*, bool, unsigned int)':
useradmin.cpp:164: warning: unused variable `QComboBox*cb'
useradmin.cpp: In member function `int UserAdmin::writeDB()':
useradmin.cpp:411: 跳转至 case 标号
useradmin.cpp:348:   crosses initialization of `QTextOStream tsSF'
useradmin.cpp:347:   crosses initialization of `QString value'
useradmin.cpp:346:   crosses initialization of `QString suffix'
useradmin.cpp:345:   crosses initialization of `QString prefix'
useradmin.cpp:415: 跳转至 case 标号
useradmin.cpp:348:   crosses initialization of `QTextOStream tsSF'
useradmin.cpp:347:   crosses initialization of `QString value'
useradmin.cpp:346:   crosses initialization of `QString suffix'
useradmin.cpp:345:   crosses initialization of `QString prefix'

内部编译器错误：重入错误报告程序。
请提交一份完整的错误报告，
如有可能请附上经预处理后的源文件。
具体步骤请参见 <URL:http://www.gnu.org/software/gcc/bugs.html>。
make: *** [useradmin.o] 错误 1

上网查找，发现错误原因是在case语句中定义了对象，这些对象实际是在所有case中共享的。
2，QString和char*
useradmin.cpp:488: cannot pass objects of non-POD type `const class QString' 
   through `...'

 qDebug("DEBUG: current opType is <%s>, "
        "which do not need to write db",
         opName[(int)op]);
改为：
 qDebug("DEBUG: current opType is <%s>, "
        "which do not need to write db",
         opName[(int)op].latin1());
即可。
待做（重要）：是个POD问题，在google上搜索"cannot pass objects of non-POD type"，细看。
3，段错误。这次是op没有赋初值造成的。
编程能力还是有问题。对于初值，边界没有有意识的考虑。

13:14 2007-11-27
项目进展，QT，构造函数
为了解决QT构造函数出错难以处理的问题，
把读数据库改为SLOT，到时后启动。
//readDB
        QTimer *timer = new QTimer( this );
        connect( timer, SIGNAL(timeout()), this, SLOT(readDB()) );
        timer->start( 1, TRUE );
待做：查更好的方法。

14:47 2007-11-27
待做，目前
1, "18:32 2007-11-26"
修改fingerTempIndex的产生方式。
2, "17:52 2007-11-26"
如何定义类的数组？
3, "17:35 2007-11-26"数据库
待做完成：现在从数据库读数据已经正确，但是中文无法测试。用qpe或修改UserAdmin类使其可以接收语言参数。中文可以用QCString，写入数据库时强制转化为"char*"
4, "00:33 2007-11-25"数据库。（完成）
管理员USERNO是9999，注册程序是否容易实现。
5, "13:15 2007-11-21"现有小问题
6，"NULL"改为NULL（完成）；writeDB提高效率
7, (09:56 2007-11-28)
USERNO不能输入字符，只能输入数字。（完成）

15:11 2007-11-27
现在使用
qt_embedded_board
目录。

16:29 2007-11-27
编译错误
1，c++
如果源文件中使用了string类型，2.95.3中需要加入"#include <string>"，否则会报syntax error。gcc 3.x以上不用加入。
2，QT信号和槽
用connect函数连接信号和槽时，对于有参数的情况，只需要加入参数类型，不能加入参数名，否则会提示"No such signal"。
费解，待做，查清楚。

17:02 2007-11-27
待做：
1，USERNO不与ID关联；（取消）
2，界面对齐，大小不变。（转移）
3，注册手指时提示清楚；（完成）
4，查询可以使用USERNO和USERNAME，不使用ID。（完成）
(15:23 2007-11-30)
增加一页便于用户输入USERNO和USERNAME，主要是考虑到适应以后的复杂查询。
(18:00 2007-11-30)
进展：界面已经画完。
界面文件：queryPrep.ui。
需要考虑：
1)，是否继承QInfoWidget，使用getInfo函数。还是独立。
2)，是继续用next() -> collectCPInfo，还是用"example/wizard/wizard.cpp"的showPage方法。
3)，要把整个QWizard每页的处理做成通用的。
当前页结束时看数据是否合法，并进行相应的操作（查询数据库，翻页；翻页）
5，数据库传入指针，（完成）
6，注册时，如果取消，可以删除条目，不影响autoincreasment：（完成）
参考"http://www.xrss.cn/Info/12473.Html"学习了如何使用rollback：
--开始一个transaction
sqlite> begin transaction;
--执行insert和update操作
sqlite> insert into USER_T (ID) values (NULL);
sqlite> update USER_T SET COMPANY = 'hitachi' where ID = 3;
--查看操作结果是否正确
sqlite> select * from USER_T where ID = 3;
3|||hitachi|||||||||||||||||||
--rollback，回滚--撤销刚才的操作。
sqlite> rollback transaction;
--再次查看同样的条目，已经没有了。
--如果再次执行插入，操作，ID仍是3，说明的确是回滚了。
sqlite> select * from USER_T where ID = 3;
sqlite> insert into USER_T (ID, USERNO ) values (NULL, '2222');
sqlite> select * from USER_T where USERNO = '2222';
3|2222|||||||||||||||||||||
注：
1)，现在的SQLite不支持transaction name，文档中建议不要使用name，避免和将来的版本冲突。
2)，rollback是完全撤销了begin transaction后面的操作，游标也回到的原来的位置。如果是delete，可以删除条目，但是游标位置不会变。即，delete后auto increasment还是包括delete的条目。
3)，待做：根据文档"http://www.sqlite.org/lang_transaction.html"，rollback可能会出错，细看。
4)，待做完成：在程序中实现。
7, (13:23 2007-11-27)解决del flag和valid flag问题。
建立是del flag无效。删除时有效。而不是直接删除记录。
8, 改界面，右手在前，左手在后。（转移）
9，(12:25 2007-11-28)
updateEditType效率低，改进。不急。

17:09 2007-11-27
程序修改
1，fingervein.cpp
去掉多余的print语句；X86不需要做某些设置。通过是否定义X86区分。

22:20 2007-11-27
待做：删除cvs上面的useradmin/test.*文件。

11:50 2007-11-28
c++学习，编译错误
g++ -c -pipe -DQWS -fno-rtti -Wall -W -O2 -fno-default-inline -DNO_DEBUG -DNO_FV -ggdb -DX86 -I/usr/src/FV_Project/qt/qt/include -I/usr/src/FV_Project/qt/qtopia/include -o useradmin.o useradmin.cpp
In file included from /usr/src/FV_Project/qt/qt/include/qobjectdefs.h:42,
                 from /usr/src/FV_Project/qt/qt/include/qwindowdefs.h:43,
                 from /usr/src/FV_Project/qt/qt/include/qwidget.h:42,
                 from qinfowidget.h:34,
                 from userbasicinfo.h:35,
                 from useradmin.h:35,
                 from useradmin.cpp:32:
/usr/src/FV_Project/qt/qt/include/qglobal.h:382: syntax error before `typedef'
/usr/src/FV_Project/qt/qt/include/qglobal.h:387: syntax error before `*' token
......
无数错误
......

经过比较昨天的版本，发现是"useradmin.cpp"文件的最开始多了"cp"这两个字母。
经验：前面的错误提示都不是自己的文件，但是库（QT）的头文件又不会有错，所以只能是引用头文件之前出了错。

12:27 2007-11-28
程序修改：
1，加入了transaction，根据需要commit或rollback。修改了构造函数UserAdmin，writeDB，readDB，~UserAdmin。修改"~UserAdmin"是为了UserAdmin类意外退出时rollback。
2，去掉了UserID(USERNO)的编辑状态的只读属性。

13:26 2007-11-28
待做
1，使用delflag, （完成）
2，close时如果数据库是自己打开的关闭，否则不关闭（完成）
3，查询使用用户名和用户ID。（完成）
！！！现在如果用户没有输入ID，界面没有出错处理。
4, 加入前面待做：数据库结果写入表格需要修改：根据fieldType写入。用MVC时一定要改。
5，fv-gui修改：修改调用UserAdminDialog的方法。（完成）
fv_gui::onUserAdmin()
//例化UserAdminDialog时需要传入数据库指针：
        useradmindlg = new UserAdminDialog(this, "uad", 0, db);
//连接uadDestroy信号，该信号在useradmindlg的closeEvent事件中发射。
        QObject::connect(useradmindlg, SIGNAL(uadDestroy()), this,
SLOT(onQuitUserAdmin()));
6，保证USERNO不重复！（转移）
7，UserAdminDialog从QWidget改为QDialog
8，query模块修改：
(1)，finddlg.cpp：FindDlg::onStartFind，fvID中输入*表示查询所有数据。
(2)，querywnd.cpp：QueryWnd::onTableShow，显示前清空上一次显示结果。
9，SQLite不支持时间戳，时间格式YYYY-MM-DD hh:mm:ss。
10，加入前面，待做：
1), 如何处理UserAdmin多个查询结果
2), 应用MCV重新设计用户注册界面. 
模型部分需求:每个fields: fieldName, fieldValue, fieldRule, 
界面和数据库的name相同.fieldRule是Validator(适用于QLineEdit等由用户直接输入的组件)或Selector(适用于QComboBox,等由用户选择已有值的组件, 
扩展性: 需要支持可修改的Selector, 例如系统可能需要增加部门.
界面部分需求: 同列内容需要对齐.
控制器需求：待补充。
11，(18:17 2007-11-28)
用下面方法修改Sex和Type两个ComboBox。
QT学习
QComboBox::insertItem可以指定插入的index，如果index是事先定义好的（预定义，枚举，QStringList），选择时会很简单。
void QComboBox::insertItem ( const QString & t, int index=-1 )
自: fvdac/query/finddlg.cpp

13:56 2007-11-28
可变参数
1, 如果用：
#ifdef USERADMIN_PAGEDEBUG
#define PDEBUG qDebug
#else
#define PDEBUG
#endif  /*PAGEDEBUG*/
编译时会提示：
userdateinfo.cpp:206: warning: 逗号表达式的左操作数不起作用
调试信息可以正常使用。
2, 用
#ifdef PAGEDEBUG
#define PDEBUG(args...) qDebug(##args)
#else
#define PDEBUG(args...)
#endif  /*PAGEDEBUG*/
也有提示：
userbasicinfo.cpp:191:68: 警告：pasting "(" and ""Class name is %s."" does not
give a valid preprocessing token
调试信息可以正常使用。
3, C99方法。
这个没有警告。
待做（今晚）：查《实战Linux编程精髓》

18:10 2007-11-28
为保存中文数据做准备：
1，QCString QString::utf8 () const
可以利用QTextOStream使代码更简洁。
2，和预计的一样，QCString可以转为char*类型：
QCString的const char*被重载为：
inline QCString::operator const char *() const
{ return (const char *)data(); }

19:04 2007-11-28
待做，回家学习
1，学习SQLite：如何实现，已知USETNO，查询用户进门时间：
首先要从USER_T中通过USETNO找到ID(USER_ID)，再用USER_ID在USET_LOG_T中查询出入时间。

19:59 2007-11-28
QT学习，国际化失败
根据语言选择实时更新语言。但是有一个菜单项(Log query)不正确，经过仔细检查发现：更新语言和显示菜单使用了独立的两个变量，在程序初始化时后者列表遗漏了(Log query)，因此就只有Log query没有翻译。
开始怀疑是po，qm文件的问题。
还是一个思考问题的顺序。
经验：从一件事的运行过程考虑每步是否有问题，注意边界问题，最容易忽略的是开始，结尾和一般不出现的情况（异常），上面的例子就是这样：更新国际化时有遗漏。

21:01 2007-11-28
修改query遇到内存泄漏。
用gdb和core file查看，每次结果都不同。用valgrind找到的都是qt程序自己库出的错。
fv/backup/fv-gui.log，fv/backup/valgrind.log
(09:51 2007-11-29)
昨天的段错误换成gcc4.1.2无问题。
待做：查原因；

10:01 2007-11-29
待做：SQLite3中用".table"可以看当前数据库的所有表的名称。查代码是如何实现的。

11:18 2007-11-29
待做：如果USERNAME查询失败，表格没有清空。但是如果USERID查询失败，表格清空。
	try
	{
		//other jobs
                q = m_dbp->getTable(queryChar.latin1());
                emit findCompleted(&q);

        }
        catch (CppSQLite3Exception& e)
        {
                cerr<<e.errorCode() << ":" << e.errorMessage() << endl;
                TRACE("error occur, emit findCompleted either\n");
                emit findCompleted(&q);
        }
二者都显示了"TRACE("error occur, emit findCompleted
either\n");"和进入了onTableShow函数的信息。
奇怪......

12:50 2007-11-29
待做转移：
query模块需要的修改：
1，查询结果显示USERNO, USERNAME和DATE。（完成）
2，查询用户姓名有时会失败。（没有错误，完成）
3，用"*"查询时，结果不全。(没有错误，完成）
4，表格列数应该等于numFields()，行数等于numRows()。（完成）
5，内容居中，不支持这个功能？

待做转移：
修改手指注册界面：
1，如何删除手指？如何控制FV模块删除一个手指的数据。
2，改为不指定手指个数？
1)现在查询，修改，删除界面其实不需要显示注册了几个手指。
2)这样可以根据数据库中有几个fv数据判断注册了几个手指。

14:47 2007-11-29
Qtopia，QPE错误
PC机下运行qpe出错
Can't open framebuffer device /dev/fb0
上网查
从"http://www.minigui.org/cgi-bin/lb5000/topic.cgi?forum=28&topic=408"得到，需要先执行"export QWS_DISPLAY=:0"(开发板上可能是"export QWS_DISPLAY=0:0，"export QWS_DISPLAY=Qvfb:0"")和qvfb&，然后qpe -qws或qpe即可。
如果仍然不行，删除用户目录/Setting/qpe.conf，然后再次启动qpe，会重设所有qpe参数。
待做完成：自定义qpe启动配置，修改开发板的"用户目录/Setting/qpe.conf"，可以配置为自己需要的内容。

15:22 2007-11-29
调试query
1，query函数名
libquerywnd.so, onTableShow, 00017350 T _ZN8QueryWnd11onTableShowEP15CppSQLite3Table
libquerywnd.so, onStartFind, 0001da80 T _ZN7FindDlg11onStartFindEv
2，getTable函数中用下面语句，没有结果。
select * from USER_LOG_T where DATE between '2007-11-29 00:00:00' and '2007-11-29 14:00:00' ;
很奇怪，先用execQuery试试，然后看CppSQLite代码看问题原因。
(17:58 2007-11-29)
后来发现query程序没有问题，是表中时间插入有误（verify模块），应该是11月29日，表格中是10月29日。
待做转移：张志霞查原因。

17:51 2007-11-29
待做转移，改进findDlg
1，初始值是最小大小；
2，永远在顶层，但不是model=TRUE（允许对下面的QWidget进行操作。
3，查询失败时给出提示。
4，单击find时，如果FindDlg存在，应该显示原有FindDlg。

10:05 2007-11-30
待做完成：
项目问题：
verify，没有加入del_flg的处理。

10:17 2007-11-30
待做转移，11-30：
改进UserAdmin
1，界面对齐，大小不变。
2，国际化；public UserAdmin::setTranslator( const char* lang), public
UserAdmin::rmTranslator( const char* lang).
待做: 查:QT或QPE如何表示语言。
(12:07 2007-11-30)
国际化没有起作用，也没有错误提示。奇怪。
见"10:43 2007-12-05"2(3)
3，手指界面，右手在前，左手在后。
4, "13:26 2007-11-28"6，保证USERNO不重复！（完成）

10:48 2007-11-30
QT工程文件
改进了工程文件useradmindialog.pro.x86，现在只需要删除生成的Makefile中CXXFLAGS的"-fno-exception"即可。
待做：解决这个问题；
参考：tmake/doc/tmake_ref.html，tmake/doc/tmake.html。
现有工程文件：
[root@localhost useradmin]# cat useradmindialog.pro.x86 

TEMPLATE         = app
CONFIG           = qtopia warn_on debug
#DEFINES                += QTOPIA_APP_INTERFACE
DEFINES          = X86 NO_FV
LIBS             = -lsqlite3
HEADERS          = qinfowidget.h \
                   userbasicinfo.h \
                   fingervein.h \
                   userfingerinfo.h \
                   userdateinfo.h \
                   qelistbox.h \
                   useradmin.h \
                   ../common/CppSQLite3.h \
                   useradmindialog.h 
SOURCES          = qinfowidget.cpp \
                   userbasicinfo.cpp \
                   fingervein.cpp \
                   userfingerinfo.cpp \
                   userdateinfo.cpp \
                   qelistbox.cpp \
                   useradmin.cpp \
                   ../common/CppSQLite3.cpp \
                   useradmindialog.cpp \
                   main.cpp
TARGET           = useradmindialog

11:18 2007-11-30
QT学习
qApp是QApplication的全局指针。
自"qt/doc/html/qapplication.html#details"。

11:58 2007-11-30
待做完成，更新cvs：
1，加入useradmindialog.pro.x86，删除useradmindialog.pro
2，增删国际化文件。

14:21 2007-11-30
c++学习，QT学习，编译错误
/usr/src/FV_Project/qt/qt/include/qtextstream.h:169: `bool QTextStream::latin1' 
   is private
useradmin.cpp:693: 在此上下文中
make: *** [useradmin.o] 错误 1
`bool QTextStream::latin1'是变量
实际使用的是：
CppSQLite3Query q = db_p->execQuery(eQ.latin1());

15:11 2007-11-30
QT学习
确保数据库中USERNO不重复。
看CppSQLite3Query查询结果是否存在，应该用"CppSQLite3Query::eof()"，而不是"CppSQLite3Query::numFields()"

17:26 2007-11-30
项目进展：
通过增加QELabel类和"void QELabel::setText(const QString &content, textType tT)"函数，设定普通提示和警告的字体颜色。
但是如果使用setText(const QString&)函数，会提示没有这个方法，加入Q_OBJECT后问题解决。待做：查变量和函数的继承。原来也有类似的问题。
加入Q_OBJECT前，是这样使用setText(const QString&)函数的。
void QELabel::setText(const QString &content)
{
        QLabel::setText(content);
}
现有进展：useradmin_11301735.tar.gz。

