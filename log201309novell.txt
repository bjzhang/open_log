.LOG
09:49 2013-09-02
GTD
0, 9:35-18:25

1, today
1), 9:51-9:59 check the mail.
2), 9:59-10:10 10:48-11:40 12:40-14:00 17:12-17:45 try ao_how with callback. see"09:59 2013-09-02"
3), surf 20'
4), support xiaofei for kvm vm install: wrong br0 network bridge.

09:49 2013-09-02
1, week plan
1), finish ao_how callback.
2), finish sun6i gic test code.
3), finish uart issue in sun6i upstream kernel.
2, next week
1), try sun6i android v3.2 kernel.

09:59 2013-09-02
virtualization, xen, libxl, async, try ao_how, cont4, callback
1, the code in libxlVmReap is totally wrong
        if(VIR_ALLOC(ao_how_p) < 0)
            return -1;
        if (ao_how_enable_cb)
            return -1;
            ao_how_p->callback = ao_how_callback;

12:47 2013-09-02
Jim reply 20130831_1823

Bamvor Jian Zhang wrote:
> Hi, Jim
>
> i got ao_how work in libxl driver without callback, and i test create, save, restore, destroy. 

Nice.

> meanwhile i found somethings different from libxl doc. i am not sure if it need to send it to xen-devel. during last virtualization sync call, i report this and Jason suggest me discuss with u. here is the details:
>
> 1, libxl_event_check do not work in libxl driver:
> in libxl.h doc, it says:
>  * If ao_how->callback==NULL, a libxl_event will be generated which
>  * can be obtained from libxl_event_wait or libxl_event_check.  The
>  * event will have type OPERATION_COMPLETE (which is not used
>  * elsewhere).
>
> but, in libvirt, because we regsiter the libxl_event_hooks through libxl_event_register_callbacks, when the event will append to egc->occurred_for_callback not to CTX->occurred, the latter one is the waited by libxl_event_check.
>   

AFAIK, you only use libxl_event_{check,wait} when you have *not*
registered event callbacks via libxl_event_register_callbacks.  From
libxl_event.h

void libxl_event_register_callbacks(libxl_ctx *ctx,
                                    const libxl_event_hooks *hooks, void
*user);
  /*
   * Arranges that libxl will henceforth call event_occurs for any
   * events whose type is set in event_occurs_mask, rather than
   * queueing the event for retrieval by libxl_event_check/wait.

So I don't think we should be using those functions in the libxl driver
since we register event callbacks.

> at this point, ao_how without callback mode accually use the libxlEventHandler callback. if xen guys want to keep document right, they need to update libxl__event_occurred and distinguish the ao_how callback(egc->aos_for_callback) and event_hooks callback.
>   

I think the documentation is correct, albeit split across libxl.h and
libxl_event.h.  But maybe I'm not understanding the problem correctly. 
Does this clarify your question here?

> 2, add a new api in libxl and i need to register a new event to libvirt except the fd and timeout.
> in libxl, there are two ways for libvirt get the child exit event from libxl: libxl_sigchld_owner_mainloop and libxl_sigchld_owner_libxl_always.
> the first need libvirt handle the SIGCHLD. currently only virLXCControllerMain handle this through virNetServerAddSignalHandler. So, i use the second one.
> when the child(libxl-save-helper) exit, libxl will write to sigchld_owner->sigchld_selfpipe[1], So, i need read sigchld_selfpipe[1] by adding a new api libxl_get_pipe_handle. notes that libvirt could not access the item in ctx because ctx in defined in libxl internal.
>   

I'm not sure I understand this question...

> i append the libxl and libxl driver patch in this email.  this patch is far from send it out. it just a referece for what i am doing to ao_how.

but you forgot to attach the patches, which would have probably helped
me understand it :).

>  
> if we realy send the patch out, i wll remove handle in libxlVmReap and remve lots of duplicated code.
>
> BTW: i am trying with callback this week.
>   

Cool.  One thing to keep in mind is which approach will work better with
the job support patches you worked on a while back.  The qemu job
support centers around interacting with the qemu monitor.  For job
support in the libxl driver, would it be easier to implement against
events or callbacks?

BTW, I'll finally have some free time in the evenings so we can chat on
IM next week.  It has been a hectic summer for me with visitors and work
being done on my house, preventing me from working much more than an 8
hour day. Thankfully I'm getting some of my free time back now :).

Jim

08:09 2013-09-05
GTD
0, 8:15

1, today
1), 8:15-11:30 12:45- ao_how

08:12 2013-09-05
1, create qcow2 image
# qemu-img create -f qcow2 -o cluster_size=2M disk0.qcow2 8192M
Formatting 'disk0.qcow2', fmt=qcow2 size=8589934592 encryption=off cluster_size=2097152 lazy_refcounts=off 

if add "-o preallocation=metadata", qemu-img will alloc 8.1G for this file compare with only 6.1M without this options.
qemu-img create -t qcow2 -o cluster_size=2M -o preallocation=metadata disk0.qcow2 8192M

2, about qcow2 and pv guest
1), patch from chunyan
http://old-list-archives.xen.org/xen-devel/2011-10/msg01943.html

3, it seems that i need collect all subprocess pid which created by libxl.
e.g. qemu process pid will used while destroy.

4, missing after libxl__ao__destroy:
libxl: debug: libxl_event.c:1737:libxl__ao_progress_report: ao 0x7f5944001e00: progress report: ignored
libxl: debug: libxl_event.c:1569:libxl__ao_complete: ao 0x7f5944001e00: complete, rc=0
libxl: debug: libxl_event.c:1541:libxl__ao__destroy: ao 0x7f5944001e00: destroy
libxl: debug: libxl_event.c:559:libxl__ev_xswatch_register: watch w=0x7f5944002900 wpath=@releaseDomain token=3/1: register slotnum=3
libxl: debug: libxl_event.c:503:watchfd_callback: watch w=0x7f5944002900 wpath=@releaseDomain token=3/1: event epath=@releaseDomain
libxl: debug: libxl.c:999:domain_death_xswatch_callback: [evg=0x7f5944009280:17] from domid=17 nentries=1 rc=1
libxl: debug: libxl.c:1010:domain_death_xswatch_callback: [evg=0x7f5944009280:17]   got=domaininfos[0] got->domain=17
libxl: debug: libxl.c:1037:domain_death_xswatch_callback:  exists shutdown_reported=0 dominf.flags=ffff0002
libxl: debug: libxl.c:1003:domain_death_xswatch_callback: [evg=0] all reported
1), libvirt do not get the complete event after libxl__ao_complete.
    } else if (ao->how.callback) {
        LIBXL__LOG(ctx, XTL_DEBUG, "ao %p: complete for callback",ao);
        LIBXL_TAILQ_INSERT_TAIL(&egc->aos_for_callback, ao, entry_for_callback);

i think this is a issue in libxl, according to the libxl.h:
 * If ao_how->callback!=NULL, the callback will be called when the
 * operation completes.  The same rules as for libxl_event_hooks
 * apply, including the reentrancy rules and the possibility of
 * "disaster", except that libxl calls ao_how->callback instead of
 * libxl_event_hooks.event_occurs.  (See libxl_event.h.)

ao_how->callback should have a similar routine as libxl_event_hooks.event_occurs.

15:30 2013-09-05
software skill, zypper
1, list all the package in repo_name repo:
zypper packages repo_name
zypper pa repo_name

10:43 2013-09-06
GTD
0, 10:35

1, today
1), discuss with jim about ao_how.

10:43 2013-09-06
1, jim reply to me on 0831_0623
Bamvor Jian Zhang wrote:
> Hi, Jim
>
> i got ao_how work in libxl driver without callback, and i test create, save, restore, destroy. 

Nice.

> meanwhile i found somethings different from libxl doc. i am not sure if it need to send it to xen-devel. during last virtualization sync call, i report this and Jason suggest me discuss with u. here is the details:
>
> 1, libxl_event_check do not work in libxl driver:
> in libxl.h doc, it says:
>  * If ao_how->callback==NULL, a libxl_event will be generated which
>  * can be obtained from libxl_event_wait or libxl_event_check.  The
>  * event will have type OPERATION_COMPLETE (which is not used
>  * elsewhere).
>
> but, in libvirt, because we regsiter the libxl_event_hooks through libxl_event_register_callbacks, when the event will append to egc->occurred_for_callback not to CTX->occurred, the latter one is the waited by libxl_event_check.
>   

AFAIK, you only use libxl_event_{check,wait} when you have *not*
registered event callbacks via libxl_event_register_callbacks.  From
libxl_event.h

void libxl_event_register_callbacks(libxl_ctx *ctx,
                                   const libxl_event_hooks *hooks, void
*user);
 /*
  * Arranges that libxl will henceforth call event_occurs for any
  * events whose type is set in event_occurs_mask, rather than
  * queueing the event for retrieval by libxl_event_check/wait.

So I don't think we should be using those functions in the libxl driver
since we register event callbacks.

> at this point, ao_how without callback mode accually use the libxlEventHandler callback. if xen guys want to keep document right, they need to update libxl__event_occurred and distinguish the ao_how callback(egc->aos_for_callback) and event_hooks callback.
>   

I think the documentation is correct, albeit split across libxl.h and
libxl_event.h.  But maybe I'm not understanding the problem correctly. 
Does this clarify your question here?

> 2, add a new api in libxl and i need to register a new event to libvirt except the fd and timeout.
> in libxl, there are two ways for libvirt get the child exit event from libxl: libxl_sigchld_owner_mainloop and libxl_sigchld_owner_libxl_always.
> the first need libvirt handle the SIGCHLD. currently only virLXCControllerMain handle this through virNetServerAddSignalHandler. So, i use the second one.
> when the child(libxl-save-helper) exit, libxl will write to sigchld_owner->sigchld_selfpipe[1], So, i need read sigchld_selfpipe[1] by adding a new api libxl_get_pipe_handle. notes that libvirt could not access the item in ctx because ctx in defined in libxl internal.
>   

I'm not sure I understand this question...

> i append the libxl and libxl driver patch in this email.  this patch is far from send it out. it just a referece for what i am doing to ao_how.

but you forgot to attach the patches, which would have probably helped
me understand it :).

>  
> if we realy send the patch out, i wll remove handle in libxlVmReap and remve lots of duplicated code.
>
> BTW: i am trying with callback this week.
>   

Cool.  One thing to keep in mind is which approach will work better with
the job support patches you worked on a while back.  The qemu job
support centers around interacting with the qemu monitor.  For job
support in the libxl driver, would it be easier to implement against
events or callbacks?

BTW, I'll finally have some free time in the evenings so we can chat on
IM next week.  It has been a hectic summer for me with visitors and work
being done on my house, preventing me from working much more than an 8
hour day. Thankfully I'm getting some of my free time back now :).

Jim

2, discuss with Jim
there are two way to using ao_how: with callback and without callback. and there are two way to handle the libxl child exit: libxl_sigchld_owner_mainloop, libxl_sigchld_owner_libxl_always. want to choice a better way for job support patches.

1), ao_how
(1), without callback
according to the libxl doc, when use ao_how without callback, user could call libxl_event_wait/check to wait or check the event. but because libxl driver register the event handler(libxlEventHandler), the event will send to it.
for this choice, we do not need to change the code in libxl.
(2), with callback.
if i register the callback, it should be called when event occurred. the callback is inserted into list in libxl__ao_complete_check_progress_reports which is same as without ao and ao without callback. but, currently, only egc_run_callbacks will iteration these callbacks. in fact, it will call other callback at the same time. So, the egc_run_callbacks is not a choice for us.
right now, i just call the callback in libxl__ao_complete_check_progress_reports for test. it works. 

Index: xen-4.3.0-testing/tools/libxl/libxl_event.c
===================================================================
--- xen-4.3.0-testing.orig/tools/libxl/libxl_event.c
+++ xen-4.3.0-testing/tools/libxl/libxl_event.c
@@ -1575,6 +1575,23 @@ void libxl__ao_complete(libxl__egc *egc,
     libxl__ao_complete_check_progress_reports(egc, ao);
 }
 
+void libxl__ao_occurred(libxl__egc *egc)
+{
+    EGC_GC;
+    libxl__ao *ao, *ao_tmp;
+    LIBXL_TAILQ_FOREACH_SAFE(ao, &egc->aos_for_callback,
+                             entry_for_callback, ao_tmp) {
+        LIBXL_TAILQ_REMOVE(&egc->aos_for_callback, ao, entry_for_callback);
+        LOG(DEBUG,"ao %p: completion callback", ao);
+        ao->how.callback(CTX, ao->rc, ao->how.u.for_callback);
+        CTX_LOCK;
+        ao->notified = 1;
+        if (!ao->in_initiator)
+            libxl__ao__destroy(CTX, ao);
+        CTX_UNLOCK;
+    }
+}
+
 void libxl__ao_complete_check_progress_reports(libxl__egc *egc, libxl__ao *ao)
 {
     /*
@@ -1598,6 +1615,7 @@ void libxl__ao_complete_check_progress_r
     } else if (ao->how.callback) {
         LIBXL__LOG(ctx, XTL_DEBUG, "ao %p: complete for callback",ao);
         LIBXL_TAILQ_INSERT_TAIL(&egc->aos_for_callback, ao, entry_for_callback);
+        libxl__ao_occurred(egc);
     } else {
         libxl_event *ev;
         ev = NEW_EVENT(egc, OPERATION_COMPLETE, ao->domid, ao->how.u.for_event);
Index: xen-4.3.0-testing/tools/libxl/libxl_internal.h
===================================================================
--- xen-4.3.0-testing.orig/tools/libxl/libxl_internal.h
+++ xen-4.3.0-testing/tools/libxl/libxl_internal.h
@@ -1758,6 +1758,7 @@ _hidden int libxl__ao_inprogress(libxl__
        const char *file, int line, const char *func); /* temporarily unlocks */
 _hidden void libxl__ao_abort(libxl__ao *ao);
 _hidden void libxl__ao_complete(libxl__egc *egc, libxl__ao *ao, int rc);
+_hidden void libxl__ao_occurred(libxl__egc *egc);
 _hidden libxl__gc *libxl__ao_inprogress_gc(libxl__ao *ao);
 
 /* Can be called at any time.  Use is essential for any aop user. */

(3), compare
> Cool.  One thing to keep in mind is which approach will work better with
> the job support patches you worked on a while back.  The qemu job
> support centers around interacting with the qemu monitor.  For job
> support in the libxl driver, would it be easier to implement against
> events or callbacks?
maybe i do not fully understand how qemu jobs works. if talk about quering result while save/migration in progress in qemu daemon. both could set the flag, then i know the status in the loop(done or not).

2), child handler
(1), libxl_sigchld_owner_mainloop
doc saids user will got event when the child exit.
there are two problems. firstly, i need to add the libxl_get_pipe_handle for get the fd and then register this fd to libvirt event loop. after doing this i could know the child exit. secondly, i do not know which child exit. it is important because i will call libxl_childproc_reaped with the pid and exit status.

diff --git a/tools/libxl/libxl.h b/tools/libxl/libxl.h
index 37e4d82..99b98ef 100644
--- a/tools/libxl/libxl.h
+++ b/tools/libxl/libxl.h
@@ -1016,6 +1016,8 @@ int libxl_flask_loadpolicy(libxl_ctx *ctx, void *policy, uint32_t size);
 int libxl_fd_set_cloexec(libxl_ctx *ctx, int fd, int cloexec);
 int libxl_fd_set_nonblock(libxl_ctx *ctx, int fd, int nonblock);
 
+int libxl_get_pipe_handle(libxl_ctx *ctx, int num);
+
 #include <libxl_event.h>
 
 #endif /* LIBXL_H */
diff --git a/tools/libxl/libxl_fork.c b/tools/libxl/libxl_fork.c
index 044ddad..1989258 100644
--- a/tools/libxl/libxl_fork.c
+++ b/tools/libxl/libxl_fork.c
@@ -418,6 +418,11 @@ int libxl__ev_child_xenstore_reopen(libxl__gc *gc, const char *what) {
     return rc;
 }
 
+int libxl_get_pipe_handle(libxl_ctx *ctx, int num)
+{
+    return ctx->sigchld_selfpipe[num];
+}
+
 /*
  * Local variables:
  * mode: C

(2), libxl_sigchld_owner_libxl_always
in this way, libvirt libxl driver handler the SIGCHLD. i do not need to change the libxl code.

3, \TODO: no COMPLETE while reap when ao without callback?

16:21 2013-09-06
Work report - week 35, 36
1, libvirt
use async operation in libvirt libxl driver. there are some issues in libxl. discuss it with Jim
2, opensuse arm
package sun6i upstream kernel. found a uart issue in it.

16:43 2013-09-06
Cortex-A7
1, do not support divide instruction.
2, L1 I$
1), 
a7: vipi.
a15: pipt.
\TODO why?
2), smallest cache line in I$.
a7: 8 words
a15: 8 words or 16 words, defined by hardware(input IMINLN for cpu).
3, \TODO compare
    a7//a15
    cpu->id_mmfr0 = 0x10101105;// cpu->id_mmfr0 = 0x10201105;
    cpu->id_mmfr1 = 0x40000000;// cpu->id_mmfr1 = 0x20000000;
    cpu->id_isar0 = 0x01101110;// cpu->id_isar0 = 0x02101110;

18:47 2013-09-06
write sun6i qemu code, ref:
1), afaerber
http://repo.or.cz/w/qemu/afaerber.git/shortlog/refs/heads/tegra
2), hw/arm/highbank.c

14:18 2013-09-09
qemu command line for xen hvm
/usr/lib/xen/bin/qemu-system-i386 -xen-domid 2 -chardev socket,id=libxl-cmd,path=/var/run/xen/qmp-libxl-2,server,nowait -mon chardev=libxl-cmd,mode=control -name 05_win7_xen -vnc 127.0.0.1:0,to=99 -global isa-fdc.driveA= -vga cirrus -global vga.vram_size_mb=8 -boot order=d -smp 1,maxcpus=2 -net none -M xenfv -m 3064 -drive file=/home/bamvor/vm/xen/images/win7/disk0.raw,if=ide,index=0,media=disk,format=raw,cache=writeback -drive file=/home/bamvor/vm/iso/windows7.iso,if=ide,index=2,media=cdrom,format=raw,cache=writeback,id=ide-5632

16:34 2013-09-09
On Fri, 2013-08-30 at 10:51 +0100, Ian Campbell wrote:
> I'll try that shortly and let you know how I get on. 

Success! My failure previously was not getting the kernel command line
in the right place, so no printk...

Starting from
https://github.com/linux-sunxi/u-boot-sunxi.git sunxi
I merged your stuff:
git pull git://git.linaro.org/people/aprzywara/u-boot.git hypmode_v4
and applied the patch below (NB: u-boot doesn't support SMP on this
platform yet, hence stubbing out the kicking of secondaries etc) and
https://groups.google.com/forum/#!topic/linux-sunxi/7oS0CM2WSy4.

Then built with:

$ make Cubieboard2_FEL CROSS_COMPILE=arm-linux-gnueabihf- 

Then I could boot via FEL (http://linux-sunxi.org/FEL/USBBoot) using
usb-boot from git://github.com/linux-sunxi/sunxi-tools.git:
usb-boot ~/devel/u-boot.git/spl/u-boot-spl.bin ~/devel/u-boot.git/u-boot.bin 
uImage

where uImage is the zImage+dtb (cat into tmp) and mkimage -A arm -O
linux -T kernel -a 0x40008000 -e 0x40008000 -C none -d tmp uImage

Linux says:
[    0.000000] CPU: All CPU(s) started in HYP mode.
[    0.000000] CPU: Virtualization extensions available.

(All == all 1)

Kernel is https://github.com/mripard/linux.git sunxi-next-a20-cubie2
multi_v7_defconfig + CONFIG_DEBUG_LL w/ CONFIG_DEBUG_SUNXI_UART0 and
CONFIG_EARLY_PRINTK.
I used appended dtb and set /chosen/bootargs = "console=ttyS0,115200
earlyprintk" in arch/arm/boot/dts/sun7i-a20-cubieboard2.dts (only
because usb-boot doesn't happen to load dtb and pass it to bootm, will
fix that up...)

Now to try Xen!

Ian.

commit 9267730ab1c3b6be5cf9118b2ce4e708e9d4ba66
Author: Ian Campbell <ijc@xxxxxxxxxxxxxx>
Date:   Fri Aug 30 13:52:07 2013 +0100

    sunxi: Enable hyp mode boot on sunxi platforms
    
    Required a call to cleanup_before_linux in order to disable caches before
    switching to NS world, otherwise we switch to an incorrecly configured banked
    version of SCTLR.
    
    Signed-off-by: Ian Campbell <ijc@xxxxxxxxxxxxxx>

diff --git a/arch/arm/cpu/armv7/virt-v7.c b/arch/arm/cpu/armv7/virt-v7.c
index 4dc8c45..a76dcf7 100644
--- a/arch/arm/cpu/armv7/virt-v7.c
+++ b/arch/arm/cpu/armv7/virt-v7.c
@@ -132,6 +132,8 @@ int armv7_switch_nonsec(void)
        unsigned int reg;
        unsigned itlinesnr, i;
 
+       cleanup_before_linux();
+
        /* check whether the CPU supports the security extensions */
        reg = read_id_pfr1();
        if ((reg & 0xF0) == 0) {
diff --git a/board/sunxi/Makefile b/board/sunxi/Makefile
index 4780c99..d756091 100644
--- a/board/sunxi/Makefile
+++ b/board/sunxi/Makefile
@@ -76,9 +76,13 @@ COBJS-$(CONFIG_UHOST_U1A)    += dram_sun4i_360_1024_iow8.o
 COBJS-$(CONFIG_WOBO_I5)                += dram_wobo_i5.o
 COBJS-$(CONFIG_XZPAD700)       += dram_xzpad700.o
 
+ifneq ($(CONFIG_ARMV7_NONSEC)$(CONFIG_ARMV7_VIRT),)
+SOBJS                           := smp.o
+endif
+
 COBJS  := $(COBJS-y)
-SRCS   := $(COBJS:.o=.c)
-OBJS   := $(addprefix $(obj),$(COBJS))
+SRCS   := $(COBJS:.o=.c) $(SOBJS:.o=.S)
+OBJS   := $(addprefix $(obj),$(COBJS) $(SOBJS))
 
 all:   $(LIB)
 
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 50c07e2..4b8c732 100755
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -40,6 +40,20 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+/* Setting the address at which secondary cores start from.
+ * SMP currently unsupported.
+ */
+void smp_set_core_boot_addr(unsigned long addr, int corenr)
+{
+       printf("WARNING: ignoring attempt to set core boot address %lx on core %d\n",
+              addr, corenr);
+}
+
+void smp_kick_all_cpus(void)
+{
+       printf("WARNING: Not kicking secondary CPUs\n");
+}
+
 /* add board specific code here */
 int board_init(void)
 {
diff --git a/board/sunxi/smp.S b/board/sunxi/smp.S
new file mode 100644
index 0000000..6a6e08c
--- /dev/null
+++ b/board/sunxi/smp.S
@@ -0,0 +1,33 @@
+/*
+ * code for redirecting secondary cores to their start address
+ *
+ * Copyright (c) 2013  Andre Przywara <andre.przywara@xxxxxxxxxx>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <linux/linkage.h>
+
+/* void _smp_waitloop(unsigned previous_address); */
+ENTRY(smp_waitloop)
+       /* SMP currently unsupported */
+1:     wfi
+       b 1b
+ENDPROC(smp_waitloop)
diff --git a/include/configs/sun7i.h b/include/configs/sun7i.h
index a6ede2a..f0d9222 100644
--- a/include/configs/sun7i.h
+++ b/include/configs/sun7i.h
@@ -34,6 +34,8 @@
 #define CONFIG_SYS_PROMPT              "sun7i# "
 #define CONFIG_MACH_TYPE               4283
 
+#define CONFIG_ARMV7_VIRT
+
 #if defined(CONFIG_SYS_SECONDARY_ON)
 #define CONFIG_BOARD_POSTCLK_INIT 1
 #endif



_______________________________________________
Xen-devel mailing list
Xen-devel@xxxxxxxxxxxxx
http://lists.xen.org/xen-devel

17:51 2013-09-09
1, lastest u-boot could be booted after preinstalled u-boot.
2, not apply
1), 0003:
diff --git a/include/configs/vexpress_ca15_tc2.h b/include/configs/vexpress_ca15_tc2.h
index 9e230ad..4f425ac 100644
--- a/include/configs/vexpress_ca15_tc2.h
+++ b/include/configs/vexpress_ca15_tc2.h
@@ -31,6 +31,4 @@
 #include "vexpress_common.h"
 #define CONFIG_BOOTP_VCI_STRING     "U-boot.armv7.vexpress_ca15x2_tc2"
 
-#define CONFIG_SYS_CLK_FREQ 24000000
-
3, patch finish, add Ian patch.

4, (09:22 2013-09-10)
Ian C patch, this patch is the similar for vexpress from Andre.
1), \TODO, learn:
+ifneq ($(CONFIG_ARMV7_NONSEC)$(CONFIG_ARMV7_VIRT),)
+SOBJS                           := smp.o
+endif
+
 COBJS  := $(COBJS-y)
-SRCS   := $(COBJS:.o=.c)
-OBJS   := $(addprefix $(obj),$(COBJS))
+SRCS   := $(COBJS:.o=.c) $(SOBJS:.o=.S)
+OBJS   := $(addprefix $(obj),$(COBJS) $(SOBJS))

5, boot into svc not hyper mode. 
[    0.000000] CPU: All CPU(s) started in SVC mode.

6, successful log:
1), boot with individually fdt, fail at mount rootfs.
U-Boot 2011.09-rc1-00009-g2a396c4-dirty (Sep 10 2013 - 11:51:13) Allwinner Technology 

CPU:   SUNXI Family
Board: SUN6I
DRAM:  2 GiB
MMC:   SUNXI SD/MMC: 0
In:    serial
Out:   serial
Err:   serial
MMC: block number 0x72a004 exceeds max(0x3af000)
bootcmd set setargs_mmc
Hit any key to stop autoboot:  0 
sun6i#fatload mmc 0:2 45000000 linux/uImage_dtb 
reading linux/uImage_dtb

2987723 bytes read
sun6i#fatload mmc 0:2 46000000 sun6i-a31-colombus.dtb
reading sun6i-a31-colombus.dtb

3163 bytes read
sun6i#fatload mmc 0:2 47000000 uInitrd
reading uInitrd

2980928 bytes read
sun6i#bootm 45000000 47000000 46000000
## Booting kernel from Legacy Image at 45000000 ...
   Image Name:   
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    2987659 Bytes = 2.8 MiB
   Load Address: 40008000
   Entry Point:  40008000
   Verifying Checksum ... OK
## Loading init Ramdisk from Legacy Image at 47000000 ...
   Image Name:   uInitrd
   Image Type:   ARM Linux RAMDisk Image (uncompressed)
   Data Size:    2980864 Bytes = 2.8 MiB
   Load Address: 00000000
   Entry Point:  00000000
   Verifying Checksum ... OK
## Flattened Device Tree blob at 46000000
   Booting using the fdt blob at 0x46000000
   Loading Kernel Image ... OK
OK
   Loading Ramdisk to bfb4b000, end bfe22c00 ... OK
WARNING: ignoring attempt to set core boot address bff64934 on core -1
WARNING: Not kicking secondary CPUs
   Loading Device Tree to bfb47000, end bfb4ac5a ... OK
[      83.312]

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 3.11.0-rc4-12838-gcc5d8a7-dirty (bamvor@linux-rd.site) (gcc version 4.8.1 20130401 (prerelease) (crosstool-NG linaro-1.13.1-4.8-2013.04-20130417 - Linaro GCC 2013.04) ) #54 SMP Tue Sep 10 10:46:27 CST 2013
[    0.000000] CPU: ARMv7 Processor [410fc073] revision 3 (ARMv7), cr=10c5387d
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
[    0.000000] Machine: Allwinner A1X (Device Tree), model: WITS A31 Colombus Evaluation Board
[    0.000000] bootconsole [earlycon0] enabled
[    0.000000] Memory policy: ECC disabled, Data cache writealloc
[    0.000000] call hyp_mode_check
[    0.000000] CPU: All CPU(s) started in HYP mode.
[    0.000000] CPU: Virtualization extensions available.
[    0.000000] PERCPU: Embedded 5 pages/cpu @c1882000 s7104 r0 d13376 u32768
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 522768
[    0.000000] Kernel command line: earlyprintk console=ttyS0,115200
[    0.000000] PID hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Dentry cache hash table entries: 131072 (order: 7, 524288 bytes)
[    0.000000] Inode-cache hash table entries: 65536 (order: 6, 262144 bytes)
[    0.000000] Memory: 2073844K/2097152K available (4368K kernel code, 202K rwdata, 928K rodata, 198K init, 243K bss, 23308K reserved, 1318912K highmem)
[    0.000000] Virtual kernel memory layout:
[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)
[    0.000000]     fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
[    0.000000]     vmalloc : 0xf0000000 - 0xff000000   ( 240 MB)
[    0.000000]     lowmem  : 0xc0000000 - 0xef800000   ( 760 MB)
[    0.000000]     pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)
[    0.000000]       .text : 0xc0008000 - 0xc05342dc   (5297 kB)
[    0.000000]       .init : 0xc0535000 - 0xc0566bc0   ( 199 kB)
[    0.000000]       .data : 0xc0568000 - 0xc059a9a0   ( 203 kB)
[    0.000000]        .bss : 0xc059a9a0 - 0xc05d77d4   ( 244 kB)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1
[    0.000000] Hierarchical RCU implementation.
[    0.000000] NR_IRQS:16 nr_irqs:16 16
[    0.000000] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms
[    0.000000] Console: colour dummy device 80x30
[    0.004717] Calibrating delay loop... 2007.04 BogoMIPS (lpj=10035200)
[    0.062977] pid_max: default: 32768 minimum: 301
[    0.067815] Mount-cache hash table entries: 512
[    0.073643] CPU: Testing write buffer coherency: ok
[    0.078894] /cpus/cpu@0 missing clock-frequency property
[    0.084313] /cpus/cpu@1 missing clock-frequency property
[    0.090223] /cpus/cpu@2 missing clock-frequency property
[    0.095614] /cpus/cpu@3 missing clock-frequency property
[    0.101018] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000
[    0.106782] Setting up static identity map for 0xc0426fc0 - 0xc0427018
[    0.114262] CPU1: failed to boot: -38
[    0.118595] CPU2: failed to boot: -38
[    0.122942] CPU3: failed to boot: -38
[    0.127040] Brought up 1 CPUs
[    0.130107] SMP: Total of 1 processors activated (2007.04 BogoMIPS).
[    0.137143] CPU: All CPU(s) started in HYP mode.
[    0.141845] CPU: Virtualization extensions available.
[    0.147549] devtmpfs: initialized
[    0.154851] pinctrl core: initialized pinctrl subsystem
[    0.160938] regulator-dummy: no parameters
[    0.165333] NET: Registered protocol family 16
[    0.170501] DMA: preallocated 256 KiB pool for atomic coherent allocations
[    0.182455] bio: create slab <bio-0> at 0
[    0.187769] SCSI subsystem initialized
[    0.191917] usbcore: registered new interface driver usbfs
[    0.198019] usbcore: registered new interface driver hub
[    0.203490] usbcore: registered new device driver usb
[    0.209291] pps_core: LinuxPPS API ver. 1 registered
[    0.214351] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    0.224468] PTP clock support registered
[    0.228862] EDAC MC: Ver: 3.0.0
[    0.232795] Switched to clocksource timer
[    0.243596] NET: Registered protocol family 2
[    0.248931] TCP established hash table entries: 8192 (order: 4, 65536 bytes)
[    0.256874] TCP bind hash table entries: 8192 (order: 4, 65536 bytes)
[    0.264125] TCP: Hash tables configured (established 8192 bind 8192)
[    0.271238] TCP: reno registered
[    0.274878] UDP hash table entries: 512 (order: 2, 16384 bytes)
[    0.281496] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes)
[    0.288179] NET: Registered protocol family 1
[    0.293358] RPC: Registered named UNIX socket transport module.
[    0.299356] RPC: Registered udp transport module.
[    0.304619] RPC: Registered tcp transport module.
[    0.309401] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    0.318098] bounce pool size: 64 pages
[    0.329144] NFS: Registering the id_resolver key type
[    0.334361] Key type id_resolver registered
[    0.338624] Key type id_legacy registered
[    0.342966] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)
[    0.351142] io scheduler noop registered
[    0.355160] io scheduler deadline registered
[    0.359654] io scheduler cfq registered (default)
[    0.366255] sunxi-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver
[    0.415350] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
drivers/tty/serial/8250/8250_dw.c:276:dw8250_probe: enter
[    0.428551] drivers/tty/serial/8250/8250_dw.c:276:dw8250_probe: enter
addr<f1c28008>: c1
[    0.437452] addr<f1c28008>: c1
addr<f1c28008>: c1
[    0.442599] addr<f1c28008>: c1
[    0.466543] 1c28000.serial: ttyS0 at MMIO 0x1c28000 (irq = 32) is a U6_16550A
[    0.473806] console [ttyS0] enabled, bootconsole disabled
[    0.473806] console [ttyS0] enabled, bootconsole disabled
drivers/tty/serial/8250/8250_dw.c:349:dw8250_probe: exit
[    0.490401] drivers/tty/serial/8250/8250_dw.c:349:dw8250_probe: exit
[    0.496890] serial: Freescale lpuart driver
[    0.501254] [drm] Initialized drm 1.1.0 20060810
[    0.511550] brd: module loaded
[    0.515119] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[    0.521639] ehci-platform: EHCI generic platform driver
[    0.527024] usbcore: registered new interface driver usb-storage
[    0.533581] mousedev: PS/2 mouse device common for all mice
[    0.539448] sdhci: Secure Digital Host Controller Interface driver
[    0.545646] sdhci: Copyright(c) Pierre Ossman
[    0.549998] sdhci-pltfm: SDHCI platform and OF driver helper
[    0.556056] usbcore: registered new interface driver usbhid
[    0.561619] usbhid: USB HID core driver
[    0.565675] TCP: cubic registered
[    0.569511] NET: Registered protocol family 10
[    0.574632] sit: IPv6 over IPv4 tunneling driver
[    0.579876] Key type dns_resolver registered
[    0.584242] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 3
[    0.591921] Registering SWP/SWPB emulation handler
[    0.597343] drivers/rtc/hctosys.c: unable to open rtc device (rtc0)
rd_load_image:194.
[    0.605946] rd_load_image:194.
rd_load_image:295: out
[    0.611143] rd_load_image:295: out
[    0.614687] VFS: Cannot open root device "(null)" or unknown-block(0,0): error -6
[    0.622158] Please append a correct "root=" boot option; here are the available partitions:
[    0.630524] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
[    0.638782] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 3.11.0-rc4-12838-gcc5d8a7-dirty #54
[    0.646985] [<c0014568>] (unwind_backtrace+0x0/0xf4) from [<c00114c0>] (show_stack+0x10/0x14)
[    0.655508] [<c00114c0>] (show_stack+0x10/0x14) from [<c0422d68>] (dump_stack+0x84/0x94)
[    0.663597] [<c0422d68>] (dump_stack+0x84/0x94) from [<c0420680>] (panic+0xa4/0x1f4)
[    0.671338] [<c0420680>] (panic+0xa4/0x1f4) from [<c053607c>] (mount_block_root+0x1a0/0x230)
[    0.679769] [<c053607c>] (mount_block_root+0x1a0/0x230) from [<c0536300>] (mount_root+0x108/0x110)
[    0.688719] [<c0536300>] (mount_root+0x108/0x110) from [<c0536498>] (prepare_namespace+0x190/0x1d4)
[    0.697756] [<c0536498>] (prepare_namespace+0x190/0x1d4) from [<c0535d38>] (kernel_init_freeable+0x1cc/0x1dc)
[    0.707662] [<c0535d38>] (kernel_init_freeable+0x1cc/0x1dc) from [<c041fa30>] (kernel_init+0xc/0x160)
[    0.716874] [<c041fa30>] (kernel_init+0xc/0x160) from [<c000e138>] (ret_from_fork+0x14/0x3c)

2), boot with append fdt, fail at mount rootfs.
U-Boot 2011.09-rc1-00009-g2a396c4-dirty (Sep 10 2013 - 12:21:15) Allwinner Technology 

CPU:   SUNXI Family
Board: SUN6I
DRAM:  2 GiB
MMC:   SUNXI SD/MMC: 0
*** Warning - bad CRC, using default environment

In:    serial
Out:   serial
Err:   serial
MMC: block number 0x72a004 exceeds max(0x3af000)
bootcmd set setargs_mmc
Hit any key to stop autoboot:  0 
sun6i#fatload mmc 0:2 45000000 linux/uImage_dtb
reading linux/uImage_dtb

2987723 bytes read
sun6i#fatload mmc 0:2 46000000 uInitrd
reading uInitrd

2980928 bytes read
sun6i#bootm 45000000 46000000
## Booting kernel from Legacy Image at 45000000 ...
   Image Name:   
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    2987659 Bytes = 2.8 MiB
   Load Address: 40008000
   Entry Point:  40008000
   Verifying Checksum ... OK
## Loading init Ramdisk from Legacy Image at 46000000 ...
   Image Name:   uInitrd
   Image Type:   ARM Linux RAMDisk Image (uncompressed)
   Data Size:    2980864 Bytes = 2.8 MiB
   Load Address: 00000000
   Entry Point:  00000000
   Verifying Checksum ... OK
   Loading Kernel Image ... OK
OK
WARNING: ignoring attempt to set core boot address bff64934 on core -1
WARNING: Not kicking secondary CPUs
[      56.135]

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 3.11.0-rc4-12838-gcc5d8a7-dirty (bamvor@linux-rd.site) (gcc version 4.8.1 20130401 (prerelease) (crosstool-NG linaro-1.13.1-4.8-2013.04-20130417 - Linaro GCC 2013.04) ) #54 SMP Tue Sep 10 10:46:27 CST 2013
[    0.000000] CPU: ARMv7 Processor [410fc073] revision 3 (ARMv7), cr=10c5387d
[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
[    0.000000] Machine: Allwinner A1X (Device Tree), model: WITS A31 Colombus Evaluation Board
[    0.000000] bootconsole [earlycon0] enabled
[    0.000000] Memory policy: ECC disabled, Data cache writealloc
[    0.000000] call hyp_mode_check
[    0.000000] CPU: All CPU(s) started in HYP mode.
[    0.000000] CPU: Virtualization extensions available.
[    0.000000] PERCPU: Embedded 5 pages/cpu @c1882000 s7104 r0 d13376 u32768
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 522768
[    0.000000] Kernel command line: earlyprintk console=ttyS0,115200
[    0.000000] PID hash table entries: 4096 (order: 2, 16384 bytes)
[    0.000000] Dentry cache hash table entries: 131072 (order: 7, 524288 bytes)
[    0.000000] Inode-cache hash table entries: 65536 (order: 6, 262144 bytes)
[    0.000000] Memory: 2070932K/2097152K available (4368K kernel code, 202K rwdata, 928K rodata, 198K init, 243K bss, 26220K reserved, 1318912K highmem)
[    0.000000] Virtual kernel memory layout:
[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)
[    0.000000]     fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
[    0.000000]     vmalloc : 0xf0000000 - 0xff000000   ( 240 MB)
[    0.000000]     lowmem  : 0xc0000000 - 0xef800000   ( 760 MB)
[    0.000000]     pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)
[    0.000000]       .text : 0xc0008000 - 0xc05342dc   (5297 kB)
[    0.000000]       .init : 0xc0535000 - 0xc0566bc0   ( 199 kB)
[    0.000000]       .data : 0xc0568000 - 0xc059a9a0   ( 203 kB)
[    0.000000]        .bss : 0xc059a9a0 - 0xc05d77d4   ( 244 kB)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=4, Nodes=1
[    0.000000] Hierarchical RCU implementation.
[    0.000000] NR_IRQS:16 nr_irqs:16 16
[    0.000000] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms
[    0.000000] Console: colour dummy device 80x30
[    0.004719] Calibrating delay loop... 2007.04 BogoMIPS (lpj=10035200)
[    0.062978] pid_max: default: 32768 minimum: 301
[    0.068254] Mount-cache hash table entries: 512
[    0.074092] CPU: Testing write buffer coherency: ok
[    0.079345] /cpus/cpu@0 missing clock-frequency property
[    0.084760] /cpus/cpu@1 missing clock-frequency property
[    0.090662] /cpus/cpu@2 missing clock-frequency property
[    0.096053] /cpus/cpu@3 missing clock-frequency property
[    0.101457] CPU0: thread -1, cpu 0, socket 0, mpidr 80000000
[    0.107767] Setting up static identity map for 0xc0426fc0 - 0xc0427018
[    0.115239] CPU1: failed to boot: -38
[    0.119229] CPU2: failed to boot: -38
[    0.123574] CPU3: failed to boot: -38
[    0.127326] Brought up 1 CPUs
[    0.130650] SMP: Total of 1 processors activated (2007.04 BogoMIPS).
[    0.137079] CPU: All CPU(s) started in HYP mode.
[    0.142215] CPU: Virtualization extensions available.
[    0.147918] devtmpfs: initialized
[    0.155246] pinctrl core: initialized pinctrl subsystem
[    0.160854] regulator-dummy: no parameters
[    0.165638] NET: Registered protocol family 16
[    0.170821] DMA: preallocated 256 KiB pool for atomic coherent allocations
[    0.182761] bio: create slab <bio-0> at 0
[    0.188082] SCSI subsystem initialized
[    0.192232] usbcore: registered new interface driver usbfs
[    0.198341] usbcore: registered new interface driver hub
[    0.203815] usbcore: registered new device driver usb
[    0.209622] pps_core: LinuxPPS API ver. 1 registered
[    0.214682] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti <giometti@linux.it>
[    0.224799] PTP clock support registered
[    0.229200] EDAC MC: Ver: 3.0.0
[    0.233440] Switched to clocksource timer
[    0.244612] NET: Registered protocol family 2
[    0.249541] TCP established hash table entries: 8192 (order: 4, 65536 bytes)
[    0.256815] TCP bind hash table entries: 8192 (order: 4, 65536 bytes)
[    0.263453] TCP: Hash tables configured (established 8192 bind 8192)
[    0.269940] TCP: reno registered
[    0.273257] UDP hash table entries: 512 (order: 2, 16384 bytes)
[    0.279324] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes)
[    0.286009] NET: Registered protocol family 1
[    0.291177] RPC: Registered named UNIX socket transport module.
[    0.297764] RPC: Registered udp transport module.
[    0.302546] RPC: Registered tcp transport module.
[    0.307339] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    0.314644] Trying to unpack rootfs image as initramfs...
[    0.349105] Freeing initrd memory: 2904K (c6001000 - c62d7000)
[    0.356750] bounce pool size: 64 pages
[    0.368398] NFS: Registering the id_resolver key type
[    0.373646] Key type id_resolver registered
[    0.377910] Key type id_legacy registered
[    0.382233] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)
[    0.390435] io scheduler noop registered
[    0.394456] io scheduler deadline registered
[    0.398949] io scheduler cfq registered (default)
[    0.405558] sunxi-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver
[    0.454853] Serial: 8250/16550 driver, 4 ports, IRQ sharing disabled
drivers/tty/serial/8250/8250_dw.c:276:dw8250_probe: enter
[    0.467365] drivers/tty/serial/8250/8250_dw.c:276:dw8250_probe: enter
addr<f1c28008>: c1
[    0.475643] addr<f1c28008>: c1
addr<f1c28008>: c1
[    0.480521] addr<f1c28008>: c1
[    0.504491] 1c28000.serial: ttyS0 at MMIO 0x1c28000 (irq = 32) is a U6_16550A
[    0.512409] console [ttyS0] enabled, bootconsole disabled
[    0.512409] console [ttyS0] enabled, bootconsole disabled
drivers/tty/serial/8250/8250_dw.c:349:dw8250_probe: exit
[    0.528523] drivers/tty/serial/8250/8250_dw.c:349:dw8250_probe: exit
[    0.535003] serial: Freescale lpuart driver
[    0.539365] [drm] Initialized drm 1.1.0 20060810
[    0.549656] brd: module loaded
[    0.553184] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[    0.559743] ehci-platform: EHCI generic platform driver
[    0.565124] usbcore: registered new interface driver usb-storage
[    0.571656] mousedev: PS/2 mouse device common for all mice
[    0.577557] sdhci: Secure Digital Host Controller Interface driver
[    0.583751] sdhci: Copyright(c) Pierre Ossman
[    0.588102] sdhci-pltfm: SDHCI platform and OF driver helper
[    0.594162] usbcore: registered new interface driver usbhid
[    0.599727] usbhid: USB HID core driver
[    0.603790] TCP: cubic registered
[    0.607634] NET: Registered protocol family 10
[    0.612743] sit: IPv6 over IPv4 tunneling driver
[    0.618017] Key type dns_resolver registered
[    0.622356] VFP support v0.3: implementor 41 architecture 2 part 30 variant 7 rev 3
[    0.630058] Registering SWP/SWPB emulation handler
[    0.635489] drivers/rtc/hctosys.c: unable to open rtc device (rtc0)
[    0.642589] Freeing unused kernel memory: 196K (c0535000 - c0566000)
Starting logging: OK
Initializing random number generator... done.
Starting network...

Welcome to Buildroot
buildroot login: 

3), xen boot fail. ref josh mail
U-Boot 2011.09-rc1-00009-g2a396c4-dirty (Sep 10 2013 - 12:21:15) Allwinner Technology 

CPU:   SUNXI Family
Board: SUN6I
DRAM:  2 GiB
MMC:   SUNXI SD/MMC: 0
*** Warning - bad CRC, using default environment

In:    serial
Out:   serial
Err:   serial
MMC: block number 0x72a004 exceeds max(0x3af000)
bootcmd set setargs_mmc
Hit any key to stop autoboot:  0 
sun6i#fatload mmc 0:2 50000000 xen-uImage
reading xen-uImage

** Unable to read "xen-uImage" from mmc 0:2 **
sun6i#fatload mmc 0:2 50000000 linux/xen-uImage
reading linux/xen-uImage

884118 bytes read
sun6i#fatload mmc 0:2 60000000 linux/zImage
reading linux/zImage

2984496 bytes read
sun6i#bootm 50000000
## Booting kernel from Legacy Image at 50000000 ...
   Image Name:   
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    884054 Bytes = 863.3 KiB
   Load Address: 40200000
   Entry Point:  40200000
   Verifying Checksum ... OK
   Loading Kernel Image ... OK
OK
WARNING: ignoring attempt to set core boot address bff64934 on core -1
WARNING: Not kicking secondary CPUs
[      65.876]

Starting kernel ...

- UART enabled -
- CPU 00000000 booting -
- Machine ID 00000f34 -
- Started in Hyp mode -
- Zero BSS -
- Setting up control registers -
- Turning on paging -
- Ready -
RAM: 0000000040000000 - 00000000bfffffff

MODULE[1]: 0000000060000000 - 0000000060400000 
Placing Xen at 0x00000000bfe00000-0x00000000c0000000
Xen heap: 65536 pages  Dom heap: 458752 pages
<3> -> unflatten_device_tree()
<3>Unflattening device tree:
<3>magic: 0xd00dfeed
<3>size: 0x000656
<3>version: 0x000011
<3>  size is 0x6e4 allocating...
<3>  unflattening 40003008...
<3>fixed up name for  -> 
<3>fixed up name for chosen -> chosen
<3>fixed up name for modules -> modules
<3>fixed up name for module@0 -> module
<3>fixed up name for hypervisor -> hypervisor
<3>fixed up name for aliases -> aliases
<3>fixed up name for cpus -> cpus
<3>fixed up name for cpu@0 -> cpu
<3>fixed up name for memory -> memory
<3>fixed up name for timer -> timer
<3>fixed up name for interrupt-controller@01C81000 -> interrupt-controller
<3>fixed up name for serial@01C28000 -> serial
<3>fixed up name for fixed-rate-clocks -> fixed-rate-clocks
<3>fixed up name for xxti -> xxti
<3> <- unflatten_device_tree()
<3>adding DT alias:serial0: stem=serial id=0 node=/serial@01C28000
Looking for UART console serial0
ns16550_uart_dt_init
<3>DT: ** translation for device /serial@01C28000 **
<3>DT: bus is default (na=1, ns=1) on /
<3>DT: translating address:<3> 01c28000<3>
<3>DT: reached root node
ns16550 at 1c28000-1c28100
<3>dt_device_get_raw_irq: dev=/serial@01C28000, index=0
<3> intspec=0 intlen=3
<3> intsize=3 intlen=3
<3>dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000000 0x00000000...],ointsize=3
<3>dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
<3> -> addrsize=1
<3> -> got it !
console done?
UART mapped at 10007000
 __  __            _  _   _  _                      _        _     _      
 \ \/ /___ _ __   | || | | || |     _   _ _ __  ___| |_ __ _| |__ | | ___ 
  \  // _ \ '_ \  | || |_| || |_ __| | | | '_ \/ __| __/ _` | '_ \| |/ _ \
  /  \  __/ | | | |__   _|__   _|__| |_| | | | \__ \ || (_| | |_) | |  __/
 /_/\_\___|_| |_|    |_|(_) |_|     \__,_|_| |_|___/\__\__,_|_.__/|_|\___|
                                                                          
(XEN) Xen version 4.4-unstable (bamvor@(none)) (arm-linux-gnueabihf-gcc (crosstool-NG linaro-1.13.1-4.8-2013.04-20130417 - Linaro GCC 2013.04) 4.8.1 20130401 (prerelease)) debug=y Thu Aug 29 18:00:06 CST 2013
(XEN) Latest ChangeSet: Mon Aug 26 12:40:44 2013 +0200 git:8a7769b-dirty
(XEN) Console output is synchronous.
(XEN) Processor: "ARM Limited", variant: 0x0, part 0xc07, rev 0x3
(XEN) 32-bit Execution:
(XEN)   Processor Features: 00001131:00011011
(XEN)     Instruction Sets: AArch32 Thumb Thumb-2 ThumbEE Jazelle
(XEN)     Extensions: GenericTimer Security
(XEN)   Debug Features: 02010555
(XEN)   Auxiliary Features: 00000000
(XEN)   Memory Model Features: 10101105 40000000 01240000 02102211
(XEN)  ISA Features: 02101110 13112111 21232041 11112131 10011142 00000000
(XEN) WARNING: Unrecognized/unsupported device tree compatible list
(XEN) Available platform support:
(XEN)     - VERSATILE EXPRESS
(XEN)     - SAMSUNG EXYNOS5
(XEN)     - CALXEDA MIDWAY
(XEN)     - TI OMAP5
(XEN) dt_device_get_raw_irq: dev=/timer, index=0
(XEN)  intspec=1 intlen=12
(XEN)  intsize=3 intlen=12
(XEN) dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000001 0x0000000d...],ointsize=3
(XEN) dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
(XEN)  -> addrsize=1
(XEN)  -> got it !
(XEN) dt_device_get_raw_irq: dev=/timer, index=1
(XEN)  intspec=1 intlen=12
(XEN)  intsize=3 intlen=12
(XEN) dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000001 0x0000000e...],ointsize=3
(XEN) dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
(XEN)  -> addrsize=1
(XEN)  -> got it !
(XEN) dt_device_get_raw_irq: dev=/timer, index=2
(XEN)  intspec=1 intlen=12
(XEN)  intsize=3 intlen=12
(XEN) dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000001 0x0000000b...],ointsize=3
(XEN) dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
(XEN)  -> addrsize=1
(XEN)  -> got it !
(XEN) dt_device_get_raw_irq: dev=/timer, index=3
(XEN)  intspec=1 intlen=12
(XEN)  intsize=3 intlen=12
(XEN) dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000001 0x0000000a...],ointsize=3
(XEN) dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
(XEN)  -> addrsize=1
(XEN)  -> got it !
(XEN) Generic Timer IRQ: phys=30 hyp=26 virt=27
(XEN) Using generic timer at 0 KHz
(XEN) DT: ** translation for device /interrupt-controller@01C81000 **
(XEN) DT: bus is default (na=1, ns=1) on /
(XEN) DT: translating address:<3> 01c81000<3>
(XEN) DT: reached root node
(XEN) DT: ** translation for device /interrupt-controller@01C81000 **
(XEN) DT: bus is default (na=1, ns=1) on /
(XEN) DT: translating address:<3> 01c82000<3>
(XEN) DT: reached root node
(XEN) DT: ** translation for device /interrupt-controller@01C81000 **
(XEN) DT: bus is default (na=1, ns=1) on /
(XEN) DT: translating address:<3> 01c84000<3>
(XEN) DT: reached root node
(XEN) DT: ** translation for device /interrupt-controller@01C81000 **
(XEN) DT: bus is default (na=1, ns=1) on /
(XEN) DT: translating address:<3> 01c86000<3>
(XEN) DT: reached root node
(XEN) dt_device_get_raw_irq: dev=/interrupt-controller@01C81000, index=0
(XEN)  intspec=1 intlen=3
(XEN)  intsize=3 intlen=3
(XEN) dt_irq_map_raw: par=/interrupt-controller@01C81000,intspec=[0x00000001 0x00000009...],ointsize=3
(XEN) dt_irq_map_raw: ipar=/interrupt-controller@01C81000, size=3
(XEN)  -> addrsize=1
(XEN)  -> got it !
(XEN) GIC initialization:
(XEN)         gic_dist_addr=0000000001c81000
(XEN)         gic_cpu_addr=0000000001c82000
(XEN)         gic_hyp_addr=0000000001c84000
(XEN)         gic_vcpu_addr=0000000001c86000
(XEN)         gic_maintenance_irq=25
(XEN) GIC: 160 lines, 4 cpus, secure (IID 0100043b).
(XEN) GICD_IIDR<16778299>
(XEN) i<32> GICD_ICFGR<1431655765>
(XEN) i<48> GICD_ICFGR<1431655765>
(XEN) i<64> GICD_ICFGR<1431655765>
(XEN) i<80> GICD_ICFGR<1431655765>
(XEN) i<96> GICD_ICFGR<1431655765>
(XEN) i<112> GICD_ICFGR<1431655765>
(XEN) i<128> GICD_ICFGR<1431655765>
(XEN) i<144> GICD_ICFGR<1431655765>
(XEN) i<32> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<36> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<40> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<44> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<48> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<52> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<56> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<60> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<64> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<68> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<72> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<76> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<80> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<84> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<88> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<92> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<96> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<100> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<104> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<108> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<112> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<116> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<120> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<124> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<128> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<132> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<136> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<140> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<144> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<148> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<152> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<156> GGICD_ITARGETSR<16843009>. cpumask: 16843009
(XEN) i<32> GICD_IPRIORITYR<2694881440>
(XEN) i<36> GICD_IPRIORITYR<2694881440>
(XEN) i<40> GICD_IPRIORITYR<2694881440>
(XEN) i<44> GICD_IPRIORITYR<2694881440>
(XEN) i<48> GICD_IPRIORITYR<2694881440>
(XEN) i<52> GICD_IPRIORITYR<2694881440>
(XEN) i<56> GICD_IPRIORITYR<2694881440>
(XEN) i<60> GICD_IPRIORITYR<2694881440>
(XEN) i<64> GICD_IPRIORITYR<2694881440>
(XEN) i<68> GICD_IPRIORITYR<2694881440>
(XEN) i<72> GICD_IPRIORITYR<2694881440>
(XEN) i<76> GICD_IPRIORITYR<2694881440>
(XEN) i<80> GICD_IPRIORITYR<2694881440>
(XEN) i<84> GICD_IPRIORITYR<2694881440>
(XEN) i<88> GICD_IPRIORITYR<2694881440>
(XEN) i<92> GICD_IPRIORITYR<2694881440>
(XEN) i<96> GICD_IPRIORITYR<2694881440>
(XEN) i<100> GICD_IPRIORITYR<2694881440>
(XEN) i<104> GICD_IPRIORITYR<2694881440>
(XEN) i<108> GICD_IPRIORITYR<2694881440>
(XEN) i<112> GICD_IPRIORITYR<2694881440>
(XEN) i<116> GICD_IPRIORITYR<2694881440>
(XEN) i<120> GICD_IPRIORITYR<2694881440>
(XEN) i<124> GICD_IPRIORITYR<2694881440>
(XEN) i<128> GICD_IPRIORITYR<2694881440>
(XEN) i<132> GICD_IPRIORITYR<2694881440>
(XEN) i<136> GICD_IPRIORITYR<2694881440>
(XEN) i<140> GICD_IPRIORITYR<2694881440>
(XEN) i<144> GICD_IPRIORITYR<2694881440>
(XEN) i<148> GICD_IPRIORITYR<2694881440>
(XEN) i<152> GICD_IPRIORITYR<2694881440>
(XEN) i<156> GICD_IPRIORITYR<2694881440>
(XEN) i<32> GICD_ICENABLER<0>
(XEN) i<64> GICD_ICENABLER<0>
(XEN) i<96> GICD_ICENABLER<0>
(XEN) i<128> GICD_ICENABLER<0>
(XEN) i<160> GICD_CTLR<1>
(XEN) GICD_ICENABLER<65535>
(XEN) GICD_ISENABLER<65535>
(XEN) GICD_ICENABLER<65535>
(XEN) GICD_ISENABLER<65535>
(XEN) i<0> GICD_IPRIORITYR<2694881440>
(XEN) i<4> GICD_IPRIORITYR<2694881440>
(XEN) i<8> GICD_IPRIORITYR<2694881440>
(XEN) i<12> GICD_IPRIORITYR<2694881440>
(XEN) i<16> GICD_IPRIORITYR<0>
(XEN) i<20> GICD_IPRIORITYR<0>
(XEN) i<24> GICD_IPRIORITYR<2694881280>
(XEN) i<28> GICD_IPRIORITYR<2694881440>
(XEN) GICC_PMR<240>
(XEN) GICC_BPR<3>
(XEN) GICC_CTLR<513>
(XEN) vtr<2415919107>, nr_lrs<4>, GICH_MISR<0>, lr_mask<0>
(XEN) Waiting for 0 other CPUs to be ready
(XEN) setup.c:563:start_xen
(XEN) Using scheduler: SMP Credit Scheduler (credit)
(XEN) setup.c:566:start_xen
(XEN) setup.c:569:start_xen
(XEN) setup.c:572:start_xen: print GICD ISENABLER
(XEN) i: 0: 2694881440
(XEN) i: 1: 2694881440
(XEN) i: 2: 2694881440
(XEN) i: 3: 2694881440
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 2694881280
(XEN) i: 7: 2694881440
(XEN) i: 8: 2694881440
(XEN) i: 9: 2694881440
(XEN) i: 10: 2694881440
(XEN) i: 11: 2694881440
(XEN) i: 12: 2694881440
(XEN) i: 13: 2694881440
(XEN) i: 14: 2694881440
(XEN) i: 15: 2694881440
(XEN) i: 16: 2694881440
(XEN) i: 17: 2694881440
(XEN) i: 18: 2694881440
(XEN) i: 19: 2694881440
(XEN) i: 20: 2694881440
(XEN) i: 21: 2694881440
(XEN) i: 22: 2694881440
(XEN) i: 23: 2694881440
(XEN) i: 24: 2694881440
(XEN) i: 25: 2694881440
(XEN) i: 26: 2694881440
(XEN) i: 27: 2694881440
(XEN) i: 28: 2694881440
(XEN) i: 29: 2694881440
(XEN) i: 30: 2694881440
(XEN) i: 31: 2694881440
(XEN) i: 0: 1308688383
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 0
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 1308688383
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 0
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 0
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 4194304
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 0
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 4194304
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 0
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 0
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 0
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 0
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) i: 0: 0
(XEN) i: 1: 0
(XEN) i: 2: 0
(XEN) i: 3: 0
(XEN) i: 4: 0
(XEN) i: 5: 0
(XEN) i: 6: 0
(XEN) i: 7: 0
(XEN) i: 8: 0
(XEN) i: 9: 0
(XEN) i: 10: 0
(XEN) i: 11: 0
(XEN) i: 12: 0
(XEN) i: 13: 0
(XEN) i: 14: 0
(XEN) i: 15: 0
(XEN) i: 16: 0
(XEN) i: 17: 0
(XEN) i: 18: 0
(XEN) i: 19: 0
(XEN) i: 20: 0
(XEN) i: 21: 0
(XEN) i: 22: 0
(XEN) i: 23: 0
(XEN) i: 24: 0
(XEN) i: 25: 0
(XEN) i: 26: 0
(XEN) i: 27: 0
(XEN) i: 28: 0
(XEN) i: 29: 0
(XEN) i: 30: 0
(XEN) i: 31: 0
(XEN) setup.c:574:start_xen
(XEN) setup.c:576:start_xen
(XEN) setup.c:579:start_xen
(XEN) setup.c:582:start_xen
(XEN) setup.c:585:start_xen
(XEN) Allocated console ring of 16 KiB.
(XEN) setup.c:588:start_xen
(XEN) VFP implementer 0x41 architecture 2 part 0x30 variant 0x7 rev 0x3
(XEN) setup.c:591:start_xen
(XEN) Brought up 1 CPUs
(XEN) *** LOADING DOMAIN 0 ***
(XEN) Device-tree contains "xen,xen" node. Ignoring.
(XEN) Populate P2M 0x40000000->0x50000000
(XEN) Loading kernel from boot module 1
(XEN) dt_irq_number: dev=/
(XEN) dt_irq_number: dev=/aliases
(XEN) dt_irq_number: dev=/cpus
(XEN) dt_irq_number: dev=/cpus/cpu@0
(XEN) dt_irq_number: dev=/fixed-rate-clocks
(XEN) dt_irq_number: dev=/fixed-rate-clocks/xxti
(XEN) Loading zImage from 0000000060000000 to 0000000040008000-00000000402e0a30
(XEN) Loading dom0 DTB to 0x000000004fe00000-0x000000004fe005a8
(XEN) CPU0: Unexpected Trap: Data Abort
(XEN) ----[ Xen-4.4-unstable  arm32  debug=y  Tainted:    C ]----
(XEN) CPU:    0
(XEN) PC:     0021517c free_heap_pages+0x224/0x408
(XEN) CPSR:   8000005a MODE:Hypervisor
(XEN)      R0: 002d200c R1: 00263dcc R2: 00000000 R3: 01800000
(XEN)      R4: 00000012 R5: 02000000 R6: 00000012 R7: 00100100
(XEN)      R8: 00000001 R9: 000c0000 R10:02600000 R11:0028fa14 R12:00200200
(XEN) HYP: SP: 0028f9ec LR: 00000000
(XEN) 
(XEN)   VTCR_EL2: 80002558
(XEN)  VTTBR_EL2: 00010000bfdfc000
(XEN) 
(XEN)  SCTLR_EL2: 30cd187f
(XEN)    HCR_EL2: 0000000000282835
(XEN)  TTBR0_EL2: 00000000bfed1000
(XEN) 
(XEN)    ESR_EL2: 94000006
(XEN)  HPFAR_EL2: 0000000002200020
(XEN)      HDFAR: 01800008
(XEN)      HIFAR: 45357164
(XEN) 
(XEN) Xen stack trace from sp=0028f9ec:
(XEN)    00214fe8 0029a3a0 000003ff 02407fe0 00299118 00000000 00000400 00000070
(XEN)    00000000 0028fa44 00215e58 002a210c 00299140 0028fa34 00000fff 00000000
(XEN)    00000001 00000000 00270010 00000548 00000000 0028fa54 00216134 60000000
(XEN)    00000000 0028fa74 0026e080 00000040 4fe00000 00000000 00000001 0028fb28
(XEN)    00000002 0028fee4 002455f4 4fe005a8 00000000 00020000 00000000 4ffeff58
(XEN)    40014000 00000000 00000000 00000000 00000000 000002c8 000002e8 4ffff5dc
(XEN)    4ffff000 00258f90 00258f80 fffffd18 00270010 0026033c 00000001 00000001
(XEN)    00000008 002602c8 00263dcc 00278200 00258e68 00000000 4fff6000 00260320
(XEN)    00000000 00000008 00258e28 00258f1c 00000002 0026027c 00000000 00000000
(XEN)    4ffff334 40015f08 00000000 0028fb30 01000000 0f000000 080f0000 000000b0
(XEN)    00000200 00000000 00000000 2c6e6578 2d6e6578 00342e34 2c6e6578 006e6578
(XEN)    00000000 00000001 00000001 00000001 00000000 00000000 00000000 00000000
(XEN)    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
(XEN)    00000000 00000001 00000001 00000001 00000000 00000000 00000000 00000000
(XEN)    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
(XEN)    00000000 40017300 00000000 00000000 00000000 00000001 00000000 40000000
(XEN)    00000000 10000000 00000000 00000000 00000000 00000000 00000000 00000000
(XEN)    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
(XEN)    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
(XEN)    00000000 00000000 00000000 00000000 00000000 00000000 00000000 4fe00000
(XEN) Xen call trace:
(XEN)    [<0021517c>] free_heap_pages+0x224/0x408 (PC)
(XEN)    [<00000000>] ??? (LR)
(XEN)    [<00215e58>] init_heap_pages+0x11c/0x138
(XEN)    [<00216134>] init_domheap_pages+0xa4/0xa8
(XEN)    [<0026e080>] discard_initial_modules+0x74/0x9c
(XEN)    [<002455f4>] construct_dom0+0xc68/0xe50
(XEN)    [<0026eb50>] start_xen+0xa6c/0xc6c
(XEN)    [<00200480>] paging+0xc/0x94
(XEN)    

4), try lastest xen which including Julien ceb93c7 "xen/arm: add lower-bound check in mfn_valid"
make dist-xen XEN_TARGET_ARCH=arm32 CROSS_COMPILE=arm-linux-gnueabihf- CONFIG_EARLY_PRINTK=sun6i CONFIG_DTB_FILE=/home/bamvor/Downloads_new/arm/samsung_exynos/linux/arch/arm/boot/dts/sun6i.dtb
mkimage -A arm -T kernel -a 0x40200000 -e 0x40200000 -C none -d "xen/xen" xen-uImage
hang at
(XEN) *** LOADING DOMAIN 0 ***
(XEN) Device-tree contains "xen,xen" node. Ignoring.
(XEN) Populate P2M 0x40000000->0x50000000
(XEN) Loading kernel from boot module 1
(XEN) dt_compat_cmp: cp<mele,M9>, compat<xen,xen>
(XEN) dt_compat_cmp: cp<allwinner,sun6i>, compat<xen,xen>
(XEN) dt_irq_number: dev=/
(XEN) dt_compat_cmp: cp<xen,xen-4.2>, compat<xen,xen>
(XEN) dt_irq_number: dev=/aliases
(XEN) dt_irq_number: dev=/cpus
(XEN) dt_compat_cmp: cp<arm,cortex-a15>, compat<xen,xen>
(XEN) dt_irq_number: dev=/cpus/cpu@0
(XEN) dt_compat_cmp: cp<arm,armv7-timer>, compat<xen,xen>
(XEN) dt_compat_cmp: cp<arm,cortex-a15-gic>, compat<xen,xen>
(XEN) dt_compat_cmp: cp<arm,cortex-a9-gic>, compat<xen,xen>
(XEN) dt_compat_cmp: cp<snps,dw-apb-uart>, compat<xen,xen>
(XEN) dt_irq_number: dev=/fixed-rate-clocks
(XEN) dt_compat_cmp: cp<allwinner,clock-xxti>, compat<xen,xen>
(XEN) dt_irq_number: dev=/fixed-rate-clocks/xxti
(XEN) Loading zImage from 0000000060000000 to 0000000040008000-00000000402e0a30
(XEN) Loading dom0 DTB to 0x000000004fe00000-0x000000004fe005a8
(XEN) Std. Loglevel: All
(XEN) Guest Loglevel: All
(XEN) **********************************************
(XEN) ******* WARNING: CONSOLE OUTPUT IS SYNCHRONOUS
(XEN) ******* This option is intended to aid debugging of Xen by ensuring
(XEN) ******* that all output is synchronously delivered on the serial line.
(XEN) ******* However it can introduce SIGNIFICANT latencies and affect
(XEN) ******* timekeeping. It is NOT recommended for production use!
(XEN) **********************************************
(XEN) 3... 

5), 
-compatible = "mele,M9", "allwinner,sun6i";
+compatible = "mele,M9", "allwinner,sun6i-a31";

09:21 2013-09-10
GTD
0, 9:10-14:07

1, today
1), sun6i u-boot with hypmode from Andre Przywara(aprzywara). see"17:51 2013-09-09"4

10:05 2013-09-10
Arokux X <arokux@gmail.com>
20:21 (13 小时前)

发送至 我 
Hi,

I have created page about Mele M9 on the linux-sunxi wiki. You may want to improve it similar to http://linux-sunxi.org/Mele_A1000

Thanks,
Arokux

Bamvor Zhang <bamv2005@gmail.com>
10:05 (0 分钟前)

发送至 Arokux 
hi, arokux

yeah, i saw http://linux-sunxi.org/Mele_M9.
i'd like to improve it. currently, i am trying to boot xen and dom0 on M9. 
hope i will do it soon. 

BTW, i saw u work on usb for sunxi.[1]
it is great for me having a usb storage for sun6i. i could put a distribution(e.g. opensuse) on it. it is more convenience than build root. 
do u have some patches i could try? 

regards

bamvor


[1]: http://linux-sunxi.org/Mainlining_Effort

22:55 2013-09-10
> I am wondering why the mfn will be lower than frametable_base_mfn?

RAM on ARM systems often doesn't start at address 0, we account for this in most places, e.g. by offsetting the frametable by frametable_base_mfn to save wasting a large initial region, but missed this one place.

Ian.

10:35 2013-09-11
1, bamvor
不知道这个end是否包括了append的initrd，如果没有。xen就没法支持。
kernel_try_zimage32_prepare:
    start = zimage[ZIMAGE32_START_OFFSET/4];
    end = zimage[ZIMAGE32_END_OFFSET/4];
2, Josh
(10:38:36 AM) josh zhao: 我打个printk看一下
(10:44:12 AM) josh zhao: 0-0x52c900

11:15 2013-09-11
GTD
0, 10:00-22:50

1, today
1), 1.5h Shawn security. 
2), 18:49-22:50 xen arm

11:51 2013-09-11
1, libxl_event_register_callbacks will register hooks after create successful.
how about move it before calling libxl_domain_create_xxx?

2, when domain ctc alloc?
virdomainobjlistadd -> virdomainobjlistaddlocked -> virdomainobjnew -> libxldomainobjprivatealloc

12:49 2013-09-11
gpu virtualization
1, rcuda:
http://www.hpcadvisorycouncil.com/events/2013/european-workshop/presentations/12_rcuda.pdf
2, gpu virtualization on vmware’s hosted i/o architecture
micah dowty, jeremy sugerman
vmware, inc.
3401 hillview ave, palo alto, ca 94304
micah@vmware.com, yoel@vmware.com
https://www.usenix.org/legacy/event/wiov08/tech/full_papers/dowty/dowty.pdf
3, 华为英伟达推gpu虚拟化 云桌面实现3d体验
http://it.sohu.com/20130904/n385855209.shtml
据介绍，nvidia grid解决方案的核心是 nvidia grid软件以及 nvidia grid k1 与 k2 高性能显卡。前者是一整套 gpu 虚拟化、远程连接及管理软件包，在网络上可实现最佳的捕捉、高效的压缩、快速的流式传输以及低延迟显示，让用户在任何地方都能够获得出色的体验。而k1与k2则是针对严苛的服务器环境而专门打造的高性能显卡，其虚拟化功能让 gpu 能够同时被多名用户共享，超快的流式显示功能消除了访问远程数据中心带来的迟滞现象，超高的节能性和 gpu 处理密度可大大降低企业的运营成本。
华为将在其高性能e9000刀片服务器上支持nvidia grid k1和k2高性能显卡，同时通过fusioncloud（华为云平台）支持 nvidia grid vgx软件，从而实现端到端的gpu虚拟化解决方案。

17:54 2013-09-11
[linux-sunxi] donating a20-cubietruck board
1), benn <benn.huang@gmail.com>
11:44 (6 小时前)

发送至 linux-sunxi、 wu 
dear list,

i'm benn huang from cubietech. i am very exciting to see such an active community - linux-sunxi, and i know that many guys in the community
spend many days and nights for the community grow. i think the effort is impossible to measured in money.

what i can do is to contribute my effort and ask allwinner to support us better, and i will do it continuously.
besides, i want to donate some a20-cubietruck boards and cubie t-shirts to the people who make big contribute to the community.

about the a20-cubietruck, i think the big different are, (comparing to previous cubieboard)
1. support 2.5/3.5 sata drive
2. 1000 mbps nic
3. wifi/bt on board
4. li-bat support
5. rtc support
6. vga/hdmi support

all these will make thing very interesting.

about the t-shirt, please look at
http://cubieboard.org/2013/09/07/a-colombia-friend-share-a-new-wallpaper-of-cubies/
1. that is an example make by hand, so the final t-shirt will look better
2. the logo is designed by a friend from colombia according to cubie wallpapers.


for those who want to apply, please
1. tell the list who you are, and what effort have you made for the linux-sunxi community

more to say
1. i am going to donating about 30 boards like last time, but at first i can only provide 10 pieces because of the pcbs,
next production will send out the other boards
(so please let the maintainers first)
2. the t-shirt will be more than 50 pcs

2), hans de goede <hdegoede@redhat.com> 
i would like to receive one, my name is hans de goede, and i've been doing quite a bit on
the linux-sunxi kernel lately, i also am the creator and maintainer of the fedora 18 and 19
images for a10(s) / a13 / a20 devices, so most people on the list probably already know me :)

regards,

hans

3), arokux x <arokux@gmail.com>
16:54 (1 小时前)
hi benn,

i am excited to read such a warm e-mail. please do you best to convince allwinner to work with sunxi.org as close as possible, the code piles that find their way to us (without history and commit messages) are not enough for us to mainline quickly as well as to fix bugs in the legacy kernel sunxi-3.4.

i will be very happy if you donate one cubietruck along with t-shirt (size l) to me! currently i only have a10 hardware.

my contributions are:

- support in the #linux-sunxi irc chat.
- improvements to our wiki, see http://linux-sunxi.org/special:contributions/arokux
- clean up of the usb ehci/ohci in the sunxi-3.4, you can see it with git log --author=arokux
- mainlining of the usb ehci/ohci. you can see initial code here https://github.com/arokux/linux/commits/sunxi-usb-host in last days i've found the last bit needed so, now it works flawlessly. currently i'm cleaning it and soon will post patches against mainline.
- last but not least, i test new fixes and drivers. :)

best,

arokux

18:42 2013-09-11
usb
http://www.crifan.com/files/doc/docbook/usb_basic/release/htmls/ch02_sw_hw.xml.html
1, usb 1.1:
ohci，open host controller interface，创立者是compaq，microsoft和national semiconductor。
uhci，universal host controller interface，创立者是intel。
2, usb 2.0:
ehci，enhanced host controller interface
3, usb 3.0:
xhci，extensible host controller interface

18:58 2013-09-11
hang
## booting kernel from legacy image at 50000000 ...
   image name:   
   image type:   arm linux kernel image (uncompressed)
   data size:    884058 bytes = 863.3 kib
   load address: 40200000
   entry point:  40200000
   verifying checksum ... ok
   loading kernel image ... ok
ok
warning: ignoring attempt to set core boot address bff64934 on core -1
warning: not kicking secondary cpus
[      55.564]

starting kernel ...

- uart enabled -
- cpu 00000000 booting -
- machine id 00000f34 -
- started in hyp mode -
- zero bss -
- setting up control registers -
- turning on paging -
- ready -
ram: 0000000040000000 - 00000000bfffffff

module[1]: 0000000060000000 - 0000000060400000 
placing xen at 0x00000000bfe00000-0x00000000c0000000
xen heap: 65536 pages  dom heap: 458752 pages
looking for uart console serial0

2, debug print. \todo put it in a individual git.
#if 1
#include <asm/early_printk.h>
#define bjz_debug(fmt, args...) early_printk("%s<%d>: %s"fmt, __file__, __line__, __function__, ##args)
#else
#define bjz_debug(fmt...) do { } while(0)
#endif

3, missing info in dt
        reg-shift = <2>;
        reg-io-width = <4>;

4, hang after
(xen) dom0: [    4.362689] turn off boot console earlycon0

5, 
1), add xen in kernel
--- sun6i_ok.0911	2013-09-11 21:22:36.407910784 +0800
+++ .config	2013-09-11 21:45:20.383479923 +0800
@@ -409,6 +409,7 @@ config_migration=y
 # config_phys_addr_t_64bit is not set
 config_zone_dma_flag=0
 config_bounce=y
+config_mmu_notifier=y
 # config_ksm is not set
 config_default_mmap_min_addr=4096
 config_cross_memory_attach=y
@@ -420,7 +421,8 @@ config_alignment_trap=y
 # config_uaccess_with_memcpy is not set
 # config_seccomp is not set
 # config_cc_stackprotector is not set
-# config_xen is not set
+config_xen_dom0=y
+config_xen=y
 
 #
 # boot options
@@ -630,7 +632,7 @@ config_extra_firmware=""
 config_fw_loader_user_helper=y
 # config_debug_driver is not set
 # config_debug_devres is not set
-# config_sys_hypervisor is not set
+config_sys_hypervisor=y
 # config_generic_cpu_devices is not set
 config_regmap=y
 config_regmap_i2c=y
@@ -672,6 +674,8 @@ config_blk_dev_ram_size=8192
 # config_cdrom_pktcdvd is not set
 # config_ata_over_eth is not set
 # config_mg_disk is not set
+config_xen_blkdev_frontend=y
+# config_xen_blkdev_backend is not set
 # config_blk_dev_rbd is not set
 
 #
@@ -931,6 +935,8 @@ config_wlan=y
 # enable wimax (networking options) to see the wimax drivers
 #
 # config_wan is not set
+config_xen_netdev_frontend=y
+# config_xen_netdev_backend is not set
 # config_isdn is not set
 
 #
@@ -1065,6 +1071,10 @@ config_serial_xilinx_ps_uart_console=y
 # config_serial_arc is not set
 config_serial_fsl_lpuart=y
 config_serial_fsl_lpuart_console=y
+config_hvc_driver=y
+config_hvc_irq=y
+config_hvc_xen=y
+config_hvc_xen_frontend=y
 # config_hvc_dcc is not set
 # config_ipmi_handler is not set
 config_hw_random=y
@@ -1516,7 +1526,8 @@ config_fb_sys_fillrect=y
 config_fb_sys_copyarea=y
 config_fb_sys_imageblit=y
 # config_fb_foreign_endian is not set
-# config_fb_sys_fops is not set
+config_fb_sys_fops=y
+config_fb_deferred_io=y
 # config_fb_svgalib is not set
 # config_fb_macmodes is not set
 # config_fb_backlight is not set
@@ -1531,6 +1542,7 @@ config_fb_mode_helpers=y
 # config_fb_udl is not set
 # config_fb_goldfish is not set
 # config_fb_virtual is not set
+config_xen_fbdev_frontend=y
 # config_fb_metronome is not set
 # config_fb_broadsheet is not set
 # config_fb_auo_k190x is not set
@@ -1891,6 +1903,19 @@ config_dma_of=y
 #
 # microsoft hyper-v guest support
 #
+
+#
+# xen driver support
+#
+config_xen_dev_evtchn=y
+config_xen_backend=y
+config_xenfs=y
+config_xen_compat_xenfs=y
+config_xen_sys_hypervisor=y
+config_xen_xenbus_frontend=y
+config_xen_gntdev=y
+config_xen_grant_dev_alloc=y
+config_xen_privcmd=y
 # config_staging is not set
 config_clkdev_lookup=y
 config_have_clk_prepare=y

2), remove root=/dev/mmcxxx in dom0 bootargs
	xen,dom0-bootargs = "console=hvc0,115200n8 debug ignore_loglevel rw rootwait earlyprintk=xen";

3), fail after
	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
and hang at
[    4.695087] waiting for root device ...

10:56 2013-09-12
GTD
0, 10:30

1, today
1), 20' subscribe mailing list. see"10:59 2013-09-12"
2), 12:50-13:47 read AArch64. see"12:54 2013-09-12"

10:59 2013-09-12
1, subscribe the following list from my company email. and put these into rules.
arm-netbook@lists.phcomp.co.uk
cubieboard@googlegroups.com
linux-sunxi@googlegroups.com
opensuse-factory@opensuse.org
2, subcribe to googlegroups
1), [Group Name]+subscribe@googlegroups.com
ref: http://www.mydigitallife.info/how-to-subscribe-or-join-google-groups-without-google-account/
2), it will send a link to
http://groups.google.com/group/[Group Name]/subscribe
So, i could skip the step 1 and directly access this link, the comfirmation sent to me quickly.
3, opensuse-factory+subscribe@opensuse.org

11:40 2013-09-12
1, yeah, for the currently ao_how api, we could not get more details about the long-running jobs. but maybe we could get other api when the long-running api is running.
2, in future:
how about get the progress from libxl. currently, we could get the progress from libxl.log, how about add a libxl_ao_report_progress to get the details to libvirt.
libvirt support the verbose mode. but libxl do not support it.

12:54 2013-09-12
doc, arm, AArch64, ARM ARM v8-A
1, This manual describes the ARM® architecture v8, ARMv8. The architecture describes the operation of an ARMv8-A Processing element (PE), and this manual includes descriptions of

2, RISC: 
The ARM architecture is a Reduced Instruction Set Computer (RISC) architecture with the following RISC architecture features:
• A large uniform register file.
• A load/store architecture, where data-processing operations only operate on register contents, not directly on memory contents.
• Simple addressing modes, with all load/store addresses determined from register contents and instruction fields only.

3, 31 64bits registers(including lr) plus PC and SP.
AArch64 The 64-bit Execution state. This Execution state:
• Provides 31 64-bit general-purpose registers, of which X30 is used as the procedure link register.
• Provides a 64-bit program counter (PC), stack pointers (SPs), and exception link registers (ELRs).
• Provides 32 128-bit registers for SIMD vector and scalar floating-point support.
• Provides a single instruction set, A64. For more information, see The ARM instruction sets on page A1-34.
• Defines the ARMv8 Exception model, with up to four Exception levels, EL0 - EL3, that provide an execution privilege hierarchy, see Exception levels on page D1-1408.
• Support for 64-bit virtual addressing. For more information, including the limits on address ranges, see Chapter D5 The AArch64 Virtual Memory System Architecture.
• Defines a number of PSTATE elements that hold PE state. The A64 instruction set includes instructions that operate directly on various PSTATE elements.
• Names each system register using a suffix that indicates the lowest Exception level at which the register can be accessed.

4, ARMv8 supports the conversion of a scalar floating-point to or from a signed or unsigned fixed-point value in a general-purpose register.
The instruction argument #fbits indicates that the general-purpose register holds a fixed-point number with fbits bits after the binary point, where fbits is in the range 1 to 64 for a 64-bit general-purpose register, or 1 to 32 for a 32-bit general-purpose register.

5, Cryptographic Extension
The presence of this extension in an implementation is subject to export license controls. The Cryptographic Extension is an extension of the SIMD support and operates on the vector register file. It provides instructions for the acceleration of encryption and decryption to support the following:
• AES
• SHA1
• SHA2-256

6, Typical Exception level usage model
The architecture does not specify what software uses which Exception level. Such choices are outside the scope of the architecture. However, the following is a common usage model for the Exception levels:
EL0 Applications.
EL1 OS kernel and associated functions that are typically described as privileged.
EL2 Hypervisor.
EL3 Secure monitor.

7, Stack pointer register selection
bamvor: in arm32, the stack point will changes when the exception occurrs. but in arm64, whether the sp changes or not is controlled by SPSel.SP. ref page: C4-269.  
When executing at EL0, the PE uses the EL0 stack pointer, SP_EL0.
When executing at any other Exception level, the PE can be configured to use either SP_EL0 or the stack pointer
for that Exception level, SP_ELx.
By default, taking an exception selects the stack pointer for the target Exception level, SP_ELx. For example, taking an exception to EL1 selects SP_EL1. Software executing at the target Exception level can then choose to change the stack pointer to SP_EL0 by updating PSTATE.SP.
This applies even if taking the exception does not change the Exception level. For example, if the PE is executing at EL1 and the PE is using the SP_EL0 stack pointer, then on taking an exception that targets EL1, the stack pointer changes to SP_EL1.
The selected stack pointer can be indicated by a suffix to the Exception level:
t Indicates use of the SP_EL0 stack pointer.
h Indicates use of the SP_ELx stack pointer.

8, PSR:
1), Saved Program Status Registers (SPSRs)
The Saved Program Status Registers (SPSRs) are used to save PE state on taking exceptions.  In AArch64 state, there is an SPSR at each Exception level exceptions can be taken to, as follows:
• SPSR_EL1, for exceptions taken to EL1 using AArch64.
• If EL2 is implemented, SPSR_EL2, for exceptions taken to EL2 using AArch64.
• If EL3 is implemented, SPSR_EL3, for exceptions taken to EL3 using AArch64.
2), Mode bit in PSR is changes in AArch64.
mode bit indicate the exception level(EL) and stack point(EL0 or ELx). not processor mode in AArch32.

9, Exception
1), Exception vectors
When the PE takes an exception to an Exception level that is using AArch64, execution is forced to an address that is the exception vector for the exception. The exception vector exists in a vector table at the Exception level the exception is taken to.  A vector table occupies a number of consecutive word-aligned addresses in memory, starting at the vector base address.
Each Exception level has an associated Vector Base Address Register (VBAR), that defines the exception base address for the table at that Exception level.  For exceptions taken to AArch64 state, the vector table provides the following information:
• Whether the exception is one of the following:
— Synchronous exception.
— SError.
— IRQ.
— FIQ.
• Information about the Exception level that the exception came from, combined with information about the stack pointer in use, and the state of the register file.
2), Exception classes
If the exception is a synchronous exception or an SError interrupt, information characterizing the reason for the exception is saved in the ESR_ELx at the Exception level the exception is taken to. The information saved is determined at the time the exception is taken, and is not changed as a result of the explicit synchronization that takes place at the start of taking the exception. See Synchronization requirements for system registers on page D8-1866.

14:20 2013-09-12
1, boot0
0x2000
dd if=boot0_sdcard.fex of=/dev/sdd seek=8 bs=1024
2, boot1
0x12A6000 19096
dd if=boot1_sdcard.fex of=/dev/sdd seek=19096 bs=1024
3, sunxi_mbr.fex
0x1400000 20480
dd if=sunxi_mbr.fex of=/dev/sdd seek=20480 bs=1024
4, sys_config
0x12e2000 19336
dd if=sys_config.bin of=/dev/sdd seek=19336 bs=1024
fail, try
0x1362000 19848
dd if=sys_config.bin of=/dev/sdd seek=19848 bs=1024
fail
5, fat
73728
6, Sprite start
S: 0x53
p: 0x70
r: 0x72
i: 0x69

7053 7269

7, 
ERROR! NOT find the head of Boot1.
     580:       4f525245        svcmi   0x00525245
     584:       4e202152        mcrmi   1, 1, r2, cr0, cr2, {2}
     588:       6620544f        strtvs  r5, [r0], -pc, asr #8
     58c:       20646e69        rsbcs   r6, r4, r9, ror #28
     590:       20656874        rsbcs   r6, r5, r4, ror r8
     594:       64616568        strbtvs r6, [r1], #-1384        ; 0x568


     420:       eb001319        bl      0x508c
     424:       e3500000        cmp     r0, #0
     428:       128f0e15        addne   r0, pc, #336    ; 0x150

09:39 2013-09-13
mailing list, virtualization, xen, performance turning
1, "Dario Faggioli <dario.faggioli@citrix.com>"
If you (also) mean that you want the one vcpu of such guest to be the
only thing that runs on one of the physical cores, the answer is again
yes.

From this respect, Xen sees a core, or even a hypertrhead, as a
processor, not much differently than a single core non-hyperthreaded
cpu, so you can "assign" stuff to those pretty much in he way you
prefer. Then there are differences, when it comes to the internal
implementation and behavior of the Xen scheduler, but that's a different
story.

In order to make the above happen, you should look at how vcpu to (p)cpu
pinning works.

This wiki page, for instance, contains some info about that.

http://wiki.xen.org/wiki/Tuning_Xen_for_Performance

09:43 2013-09-13
company, server team
1, "Olaf Kirch <okir@suse.com>"_email_"China Server Team - Going Forward"_20130912_1638
Dear all,

Today is Jia Ju's last working day, so let me start by thanking him for
his good work, both as a developer and as a manager. Jia Ju, thank you
very much - I wish you good luck in your next job in the future.

I would also like to give the team an update on where we are, and what's
happening right now.

I assume the question on everybody's mind is - when will we have a new
manager? Well, we're working on this, we are interviewing candidates, but
we are not done yet and have not made a decision so far. So please stay
tuned for more information.

For the time being, we need to make sure the team can continue to work
on the features for SLE12 and the bugs in HA and virtualization. To
ensure continuity, and to create a bit of High Availability here, I want
to introduce two Technical Coordinators. Li Xia has agreed to help with the
coordination of all things around HA and Storage, and Liu Chun Yan has
agreed to help with coordinating Virtualization related tasks.

The coordinators will work closely with the remote managers (Lars and Anja
for HA, Jason and Jim for Virtualization), to prioritize tasks, to resolve
open questions, and to track progress and keep the project managers informed
about progress.

To make this very clear: these roles do not include people management.
But: they represent the project management to the local team, so they will
discuss your work priorities with you - and may request that you give this
or that feature a higher priority. They will also ask you about your progress,
and about the problems you have run into.

You are a team of great engineers - please keep up the great work, and
keep our SLE 12 efforts on track by supporting Chun Yan and Li Xia in
steering the team's work.


With kind regards,
Olaf
-- 
Neo didn't bring down the Matrix. SOA did. (soafacts.com)
--------------------------------------------
Olaf Kirch - Director SUSE Linux Enterprise; R&D (okir@suse.com)
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 Nürnberg, Germany
GF: Jeff Hawn, Jennifer Guild, Felix Imendörffer, HRB 16746 (AG Nürnberg) 

10:03 2013-09-13
1, Jim_20130913_0830
Again had some time today to work on the job stuff.  I don't think patch
1 has changed much, but I added JOB_MODIFY support to all the "modify"
APIs and JOB_DESTROY to the destroy API in patch 2.  I did some testing
with one script running save/restore in a loop and another running a
bunch of query stuff (dominfo, domstate, dumpxml, etc) in a loop. 
Didn't notice any problems with this testing.

Adding a second domain to the mix caused some problems though.  After
some experimenting, it seems trying to do a start or save of two domains
at the same time results in an assert in libxl:

libvirtd: libxl_fork.c:203: libxl__sigchld_installhandler: Assertion
`!sigchld_owner' failed.

Program received signal SIGABRT, Aborted.
[Switching to Thread 0x7ffff260f700 (LWP 28588)]
0x00007ffff41d73d5 in raise () from /lib64/libc.so.6
(gdb) bt
#0  0x00007ffff41d73d5 in raise () from /lib64/libc.so.6
#1  0x00007ffff41d8858 in abort () from /lib64/libc.so.6
#2  0x00007ffff41d02e2 in __assert_fail_base () from /lib64/libc.so.6
#3  0x00007ffff41d0392 in __assert_fail () from /lib64/libc.so.6
#4  0x00007fffeb50e25b in libxl__sigchld_installhandler () from
/usr/lib64/libxenlight.so.4.3
#5  0x00007fffeb50e64d in ?? () from /usr/lib64/libxenlight.so.4.3
#6  0x00007fffeb506503 in libxl__openptys () from
/usr/lib64/libxenlight.so.4.3
#7  0x00007fffeb50eee8 in ?? () from /usr/lib64/libxenlight.so.4.3
#8  0x00007fffeb4e88c6 in ?? () from /usr/lib64/libxenlight.so.4.3
#9  0x00007fffeb5100d4 in ?? () from /usr/lib64/libxenlight.so.4.3
#10 0x00007fffeb4f27c1 in ?? () from /usr/lib64/libxenlight.so.4.3
#11 0x00007fffeb4f2834 in libxl_domain_create_new () from
/usr/lib64/libxenlight.so.4.3
#12 0x00007fffeb7466fe in libxlVmStart (driver=0x7fffe0094d30,
vm=0x7fffe00b4740, start_paused=false,
    restore_fd=-1) at libxl/libxl_driver.c:626
#13 0x00007fffeb74d156 in libxlDomainCreateWithFlags
(dom=0x7fffcc0008c0, flags=0)
    at libxl/libxl_driver.c:2753
#14 0x00007fffeb74d1b7 in libxlDomainCreate (dom=0x7fffcc0008c0) at
libxl/libxl_driver.c:2764
...

Having looked around the async code in libxl, do you have any thoughts
on this assert?

Also, what do you think about my comment of not needing to support the
async versions of libxl functions and instead just control access to a
VM's libxl_ctx using jobs, as these patches currently do?

Thanks.

2, 
i guess this is because sigchld_owner do not work if we call the api for different domains. if we do not want to change the relative code in libxl. we could use ao_how to avoid this: 
in libxl__ev_child_fork libxl__sigchld_installhandler is not called if 
    ctx->childproc_hooks->chldowner != libxl_sigchld_owner_libxl;
we could use libxl_sigchld_owner_mainloop by pass the childproc_hooks to libxl_childproc_setmode. as i do in my ao_how patches.

> Also, what do you think about my comment of not needing to support the
> async versions of libxl functions and instead just control access to a
> VM's libxl_ctx using jobs, as these patches currently do?
besides the seg fault above. i agree that we do not need the ao_how.
but, as i mention in the previous email(6 Sep,"Re: about my work in libxl driver", there are some issue while using the ao_how(e.g. the self pipe handle, the childproc handle).
do u think it is possible to contribute the relative patches to xen?


10:10 2013-09-13
GTD
0, 9:30-14:50

1, today
1), check the mail.
2), 1h write a doc about how to make a bootable sd card for sun6i. see"10:54 2013-09-13"
3), trainning: Yifan Jiang. sikuli.
4), reply Jim email.

(1), try u-boot instead of preinstalled u-boot.
(2), try mripard patch.
2), request cubietruck.
3), reply to Ian cb2 mail.

10:54 2013-09-13
doc, arm, sunxi, A31, PhoenixCard
http://linux-sunxi.org/PhoenixCard
http://linux-sunxi.org/PhoenixCard#PhoenixCard for A31
== PhoenixCard for A31 ==
i try the '''PhoenixCard 3.09''' for [[Mele M9]] STB. there are some differences between above description.

=== Make bootable sd card ===
* press '''DiskCheck''' button for scaning the removable disk.
* select your sdcard in ''disk''
* select image from '''Img File'''
* if you want to write a bootable, check ''Startup''.
* '''Burn''' Sd card

=== Resulting Card ===

boot1 will found the fat partition at 73728. but this partition is broken. i delete all other partition and re-create the fat start from 73728, size 50M.

=== make a bootable sd card without PhoenixCard(fail) ===
according to [http://linux-sunxi.org/Boot#A31 A31 boot progress], i want to make a bootable sd card by myself. but i do not success, here is my tring:

repack the image through image imgrepacker, i could get boot0_sdcard.fex, boot1_sdcard.fex, sunxi_mbr.fex and sys_config.fex. convert sys_config.fex to sys_config.bin through [https://github.com/linux-sunxi/sunxi-tools fex2bin]

* boot0 locate at 8k
    dd if=boot0_sdcard.fex of=/dev/sdd seek=8 bs=1024
* boot1 locate at 19096k
    dd if=boot1_sdcard.fex of=/dev/sdd seek=19096 bs=1024
after this, boot1 will boot successfull and found sd card. but boot into burning nand.

    [       0.210] boot1 version : 2.0.0
    [       0.215] script installed ok
    [       0.216] PMU: AXP221
    [       0.216] bat ratio = 100
    [       0.218] dcdc3 1260
    [       0.264] pll1 1008
    [       0.320] power finish
    [       0.325] dcdc1 3300
    [       0.325] dcdc2 1200
    [       0.325] dcdc4 1200
    [       0.326] dcdc5 1500
    [       0.329] flash init start
    [       0.585] [mmc]: init mmc pll6clk 600000000, clk 25000000, mclkbase 0x8151030b
    [       0.587] [mmc]: SD/MMC Card: 4bit, capacity: 968MB
    [       0.592] [mmc]: vendor: Man 0x00035344 Snr 0x00ba5beb
    [       0.598] [mmc]: product: SD01G
    [       0.601] [mmc]: revision: 8.0
    [       0.604] flash init finish
    [       0.641] fs init ok
    [       0.642] fattype FAT16
    [       0.642] fs mount ok
    [       0.649] dram_para_set start
    [       0.652] dram_para_set end
    [       0.652] type=1
    [       0.719] Sprite start
    [       0.719] 0
    [       0.719] card sprite begin
    [       0.723] display init
    [       0.885] lcd 0 timeout=50
    [       0.939] try gpio config
    [       0.939] gpio start
    [       0.939] mbr fetch
    [       0.989] lcd 1 timeout=200
    [       1.189] lcd 2 timeout=100
    [       1.289] lcd 3 timeout=0
    [       1.289] lcd 4 timeout=0
    [       1.300] erase flag=1
    [       1.301] storage type = 1
    [       1.305] burn nand
    [       1.305] dram ch=0
    [       1.305] nand ch=2
    [       1.307] nand init
compare with the right log:
    [       0.215] boot1 version : 2.0.0
    [       0.220] script installed ok
    [       0.221] PMU: AXP221
    [       0.221] bat ratio = 100
    [       0.223] dcdc3 1260
    [       0.269] pll1 1008
    [       0.325] power finish
    [       0.330] dcdc1 3300
    [       0.330] dcdc2 1200
    [       0.330] dcdc4 1200
    [       0.331] dcdc5 1500
    [       0.334] flash init start
    [       0.590] [mmc]: init mmc pll6clk 600000000, clk 25000000, mclkbase 0x8151030b
    [       0.592] [mmc]: SD/MMC Card: 4bit, capacity: 1886MB
    [       0.597] [mmc]: vendor: Man 0x00035344 Snr 0x5049ccd1
    [       0.602] [mmc]: product: SD02G
    [       0.606] [mmc]: revision: 8.0
    [       0.609] flash init finish
    [       0.647] fs init ok
    [       0.648] fattype FAT16
    [       0.649] fs mount ok
    [       0.655] dram_para_set start
    [       0.658] dram_para_set end
    [       0.658] type=1
    [       0.689] 0
    [       0.855] boot_disp.output_type=3
    [       0.855] boot_disp.output_mode=5
    [       0.857] boot_disp.auto_hpd=1
    [       0.860] hdmi open
    [       0.862] DRV_hdmi_set_display_mode,mode:5
    [       0.867] DRV_hdmi_open
    [       0.990] ERR: Parse_Pic_BMP failed
    [       0.991] key 0
    [       0.991] cant find rcvy value
    [       0.994] cant find fstbt value
    [       0.999] try to boot
    [       1.000] load kernel start
    [       1.036] load kernel successed
    [       1.036] start address = 0x4a000000

* i also the try the following things accoring the hexdump the bootable sd card. but no more luck.
    dd if=sunxi_mbr.fex of=/dev/sdd seek=20480 bs=1024
    dd if=sys_config.bin of=/dev/sdd seek=19848 bs=1024
* boot1 will load the boot.axt, and boot.axf will load u-boot according to linux/linux.ini

11:38 2013-09-13
Allwinner A31, boot rom
http://linux-sunxi.org/EGON#eGON.BRM
https://github.com/hno/Allwinner-Info/tree/master/BROM

12:39 2013-09-13
training, QA, Yifan Jiang, sikuli, opensikuli
recognize the screen through opencv(user should provide the picture, e.g. the close button picture you want to close the window.
input through java awt and local windows system(X on linux; microsoft windows)

13:53 2013-09-13
doc, arm, sunxi, A31, upstream kernel
=== For A20, A31 SoCs, worked but still in development ===
 git clone git://github.com/mripard/linux.git -b sunxi-next-a20-cubie2
 git clone git://github.com/mripard/linux.git -b sunxi-next-a31

14:06 2013-09-13
Hi, Benn

i am a allwinner soc fans, i buy lots of allwinner devices for using and hacking. Such as mele A1000, onta pad, cubieboard, mele M9.

recently, i am trying to port xen to A31[1]. meanwhile, i improve documents for mele M9[2][3].

if i could get a cubietruck, i could try xen and opensuse on it.  i know i am not a developer in linux-sunxi, I would completely understand if the above doesn't meet the conditions. 

T-shirt size is XL.

regards

bamvor

[1] http://lists.xen.org/archives/html/xen-devel/2013-07/msg01233.html
[2] http://linux-sunxi.org/Mele_M9
[3] http://linux-sunxi.org/PhoenixCard#PhoenixCard_for_A31

22:14 2013-09-14
1, this email is receviced by mailing list.
Hi, Ian

I follow the guide in [1] and your patches got the xen and dom0 kernel boot on Mele M9(A31), but fail in mount rootfs. but there is no errors. it hang after
[    4.695087] waiting for root device ...
and the "/init" check is fail:
	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
it seems that the kernel do not got the right rootfs.  
the rootfs is worked without xen.

[1] http://lists.xen.org/archives/html/xen-devel/2013-08/msg03040.html

regards
bamvor

11:05 2013-09-16
mailing list, arm, linux-sunxi, online autocad browser
1, online autocad browser
> Thanks, but cannot open Autocad files, 

try their browser version https://www.autocad360.com and then you can 
probably export the views to dxf or something else more broadly 
supported by free tools. 

13:21 2013-09-16
GTD
0, 10:30-17:34

1, today
1), 30' check the mail.
2), 13:22-17:34 job with ao_how. see"13:22 2013-09-16"
snap 30' 
3), try non virtualziation u-boot and kernel on A31. fail.

13:22 2013-09-16
virtualization, xen, ao
1, patch Jim job patches 0913.
2, patch my ao_how patches.
3, hang in libxlDriverConfigGet when try to get the DriverLock.
libxlDomainSetVcpuAffinities -> libxlDoNodeGetInfo -> libxlDriverConfigGet 
this is because i get the libxlDriverLock in ao_how_wait.
in the currently libvirt libxl driver(1.1.2), usually, i do not need to get the driver lock, only vm lock is ok.
4, i need per domain ao struct. 
\TODO: add ao with libxl ao and status into libxlDomainObjPrivate.
5, send email to Jim
> meanwhile i have request a leave in this afternoon for my baby's activity. i  
> will try to fix this issue on Monday. So that we could discuss on your  
> Monday.
today, i base my ao_how patch on the lastest libvirt and your jobs patches.
the simple test for ao for single domain is passed.
and i realized that i need the per-domain ao for handle the ao_how status in
differenct domain, i am coding it now.
the 

16:19 2013-09-16
服务器怎么用？
1, 如果考虑给虚拟化用，需要有不在openstack里面的机器。因为需要debug hyperviosr.
主要是考虑测试一些有硬件features相关的内容。
2, 做个build service的package cache, 大家build东西会方便。
要是能build包就更好了，就是这样需要每个人都有独立的虚拟机？不划算或不够用？
\TODO: build service应该支持通过xen或kvm build.

19:19 2013-9-17
xen, arm, ian c
1, dsb sy?

00:05 2013-9-19
hi. arokux

thanks your work. 
i'd like to try it on mele m9( an a31 powered stb). there are two questions i want to confirm.

first of all, i check the header of usb in the downstream kernel for sun4i and sun6i, they are almost same, so, it means that the uhost ip core in sun4i and sun6i is same, right?

secondly, i found there is no usb clock and its parent clock from emilio lastest code[1]. i only found the ahb gate for ehci0 and echi1 in emilio's code.
so, i should find the clock tree from the downstream code of sun6i, right?

i am sorry reply it on the top, it is hard to handle this on my phone.

regards

Bamvor

[1] https://bitbucket.org/emiliolopez/linux/src/2e790cd0c257cf57b9ec3b0d680ba353b4d4fef5/arch/arm/boot/dts/sun6i-a31.dtsi?at=sunxi-clk

23:22 2013-09-20
GTD, plan
1, reply to Bob. about how to make a bootable sd card for mele M9. DONE 0920
2, ao with job patch.
3, sunxi usb for sun6i: merge arokux and emilio branch for sun6i.
4, sunxi u-boot for sun6i.

