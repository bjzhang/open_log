22:29 2007-12-01
QT学习，信号和槽
1，QT的信号与槽机制介绍：
http://www-128.ibm.com/developerworks/cn/linux/guitoolkit/qt/signal-slot/index.html
在"应注意的问题"有信号机制的局限性，
1)注意效率；
2)小心死循环；
3)宏定义不能用在signal和slot的参数中。
4)构造函数不能用在signals或者slots声明区域内。
5). 函数指针不能作为信号或槽的参数。
6).信号与槽也不能携带模板类参数。
5), 6)可以通过typedef绕过这个问题。
7).友元声明不能位于信号或者槽声明区内。相反，它们应该在普通C++的private、protected或者public区内进行声明。
2，QT中关于信号与槽机制的实现原理=++.html
待做：细看，结合QT代码深入学习

09:52 2007-12-05
待做，目前项目所有待做，未完，继续总结。
"12:50 2007-11-29"
待做：
query模块需要的修改：
5，内容居中，不支持这个功能？

待做：
修改手指注册界面：
1，如何删除手指？如何控制FV模块删除一个手指的数据。
2，改为不指定手指个数？
1)现在查询，修改，删除界面其实不需要显示注册了几个手指。
2)这样可以根据数据库中有几个fv数据判断注册了几个手指。

"15:22 2007-11-29"
后来发现query程序没有问题，是表中时间插入有误（verify模块），应该是11月29日，表>格中是10月29日。
待做完成：张志霞查原因。
原因是函数使用有问题，得到的月份是从0-11。

"17:51 2007-11-29"
待做，改进findDlg
1，初始值是最小大小；
2，永远在顶层，但不是model=TRUE（允许对下面的QWidget进行操作。
3，查询失败时给出提示。
4，单击find时，如果FindDlg存在，应该显示原有FindDlg。

"10:17 2007-11-30"
待做完成，11-30：
改进UserAdmin
1，界面对齐，大小不变。

10:43 2007-12-05
待做，项目计划：
按需要解决的时间顺序。
目前需要20.5天，按每周三天计算，大约6周完成。难点主要在3，5。希望能在1-15前完成。
待做：加入前面自己的遗留问题。
1，编译arm-linux-gcc 2.95.3适用的gdb，0.5天。（完成）
2，改进用户管理，5天：
(1)，数据库：
(1)-1，存入中文；2天。（完成）
(1)-2，导入导出指静脉模板。1天
(1)-3，可以删除单个人的指静脉。1天
修改对应ID的指静脉为空即可
(1)-4，保存指静脉时第一字节代表是哪个手指。规定手指顺序。
(2)，日志记录：操作日志，出错日志。2天
(3)，国际化。1天。（完成）
对比verify/src/fv-gui和useradmin/useradmindialog.cpp中QTranslator的使用，发现前者的QTranslator是全局变量，后者的QTranslator也改为全局变量后，国际化问题解决。说明QTranslator变量在被remove前，都应该是存在的，不使用时一定removeTranslator并且ddelete该translator，否则会造成内存泄露。
useradmindialog.cpp:
//bamvor.add.2007-12-05.1_line.QTranslator must be alive during the program
//need the it. otherwise, the program cannot find the translator and no error
//reject.
QTranslator *translator;
bamvor: 按理说这种情况下应该可以用valgrind检测到内存泄露，但是没有找到与translator有关的错误。
待做：查现有发现的大量错误的原因，查为什么translator无效时QT没有提示；查这是不是内存泄露。
3，改进触摸屏定位准确性。3天。（暂时取消）
前提：找现有触摸屏驱动的源代码。（如果没有问傅立叶）
可能是没有去抖动。
4，门锁驱动，2-3天
需要符合标准（标准问张志霞）
如果标准复杂：是否需要完全实现？
估计是普通IO口或者串行通信。
5，文件系统，3天。
cramfs+yaffs。前者保存只读信息，libc，qt。后者保存驱动，配置脚本，用户文件（包括fv的数据库）
6，编写rs485驱动。3天。
7，改进串口驱动。1天。
驱动中无法加入奇校验。现在是用的内存映射把相应寄存器修改为有奇校验。
8，修改手指注册部分：1天
只有增加没有删除手指，对错除了用文字，也用对勾和叉子表示。
手指注册中两边的列表框等高，使下面的Label和上面的列表框对齐。
[次要任务]，找USB键盘驱动。1天

11:48 2007-12-05
待做完成，本周计划：
1，12-5完成gdb。完成编译，下午试验。提醒张志霞打开core dump。（完成）
arm-linux下如何查看使用了哪些动态库：
[root@localhost gdbserver]# arm-linux-readelf gdbserver -a | grep -E "Share|共享库"
 0x00000001 (NEEDED)                     Shared library: [libthread_db.so.1]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
PC机下可以用ldd（不加参数）或readelf（参数同上）。
参考法电实习期间文档"logFrTel0417-.txt:12:02 2007-04-20"。具体见："13:20 2007-12-05"编译gdb6.6运行情况
2，12-6，7，数据库可以保存中文。1.5天。

13:20 2007-12-05
编译GDB
用gcc3.2.2编译gdb6.6出错：
make[2]: Entering directory `/usr/src/fft_linux/gdb-6.6/libiberty'
if [ x"" != x ] && [ ! -d pic ]; then \
          mkdir pic; \
        else true; fi
touch stamp-picdir
if [ x"" != x ]; then \
          gcc -c -DHAVE_CONFIG_H -g -O2 -I. -I.././libiberty/../include  -W -Wall -pedantic -Wwrite-strings -Wstrict-prototypes -Wc++-compat  .././libiberty/regex.c -o pic/regex.o; \
        else true; fi
gcc -c -DHAVE_CONFIG_H -g -O2 -I. -I.././libiberty/../include  -W -Wall -pedantic -Wwrite-strings -Wstrict-prototypes -Wc++-compat .././libiberty/regex.c -o regex.o
cc1: unrecognized option `-Wc++-compat'
make[2]: *** [regex.o] 错误 1
make[2]: Leaving directory `/usr/src/fft_linux/gdb-6.6/libiberty'
make[1]: *** [all-libiberty] 错误 2
make[1]: Leaving directory `/usr/src/fft_linux/gdb-6.6'
make: *** [all] 错误 2

-Wc++-compat:
     Warn about ISO C constructs that are outside of the common subset
     of ISO C and ISO C++, e.g. request for implicit conversion from
     "void *" to a pointer to non-"void" type.
修改后编译通过，但是在张志霞笔记本（RedHat9）运行时提示找不到libtinfo.so.5库。
arm-linux-gdb使用的库文件如下：
[root@localhost useradmin]# ldd /usr/local/arm-gdb4gcc32/bin/arm-linux-gdb
        linux-gate.so.1 =>  (0x001b3000)
        libncurses.so.5 => /lib/libncurses.so.5 (0x02315000)
        libm.so.6 => /lib/libm.so.6 (0x005df000)
        libexpat.so.0 => /lib/libexpat.so.0 (0x008d6000)
        libc.so.6 => /lib/libc.so.6 (0x00489000)
        libtinfo.so.5 => /lib/libtinfo.so.5 (0x022e5000)
        libdl.so.2 => /lib/libdl.so.2 (0x0060a000)
        /lib/ld-linux.so.2 (0x0046a000)
后来，直接在张志霞笔记本编译通过，没有遇到上述编译错误。运行时可能缺少下面的库文件，复制到开发板能找到的库的目录即可，放在/lib目录比较合适。现在是临时放在了qt/lib目录。
待做：改进文件系统时把下面的库文件复制到"/lib"，gdbserver也放在合适的目录。
[root@localhost useradmin]# ls
/usr/local/arm/2.95.3/arm-linux/lib/libthread_db*/usr/local/arm/2.95.3/arm-linux/lib/libthread_db-1.0.so
/usr/local/arm/2.95.3/arm-linux/lib/libthread_db.so
/usr/local/arm/2.95.3/arm-linux/lib/libthread_db.so.1

16:40 2007-12-05
内存泄露，java
http://topic.csdn.net/t/20020626/10/830561.html
待做：细看。

16:50 2007-12-05
数据库，SQLite学习，命令行
.tables ?PATTERN?      List names of tables matching a LIKE pattern
.schema ?TABLE?        Show the CREATE statements
".tables"用来显示当前文件有几个表。".schema"用来显示create语句，可以用户查看表的结构（表项的名字，类型等）。

17:54 2007-12-05
尝试数据库中写入中文：
/usr/src/FV_Project/project/db_i18n_test
[root@localhost db_i18n_test]# g++ db_test.cpp ../fvdac/common/CppSQLite3.cpp -ggdb -Wall -o db_test -L$QPEDIR/lib -L$QTDIR/lib -lm -lsqlite3 -lqpe -lqtopia -lqte -I$QTDIR/include -I$QPEDIR/include -pipe -DQWS -fno-rtti 
测试程序中直接用latin1()即可。如果是这样useradmindialog就已经支持中文了。
尝试现有代码，出错：
USERNAME，公司和部门用中文时：
DEBUG: update USER_T set  USERNO = '17' , USERNAME = '
1:SQLITE_ERROR[1]: unrecognized token: "'"
DEBUG[TODO]: handle SQLite Exception
ret is 1
DEBUG: entering decontructor of UserAdmin
DEBUG: rollback transaction;
不用中文时：
DEBUG: write new data to DB
DEBUG: <17>
DEBUG: update USER_T set  USERNO = '17' , USERNAME = 'wwa' , COMPANY = 'ghh' , DEPARTMENT = 'u67' , BIRTHDAY = 'NULL' , GENDER = 
1:SQLITE_ERROR[1]: near " ": syntax error
DEBUG[TODO]: handle SQLite Exception
ret is 1
DEBUG: entering decontructor of UserAdmin
DEBUG: rollback transaction;
不用中文的错误是现在对于中文选项（性别，用户类别）无法处理，可能是po文件的问题。

输入中文时，如果把value改为"value  = "张健";"就没有错误。奇怪......
//                              value = UBI->valueName->text();
                                value  = "张健";
                                if ( value.isEmpty() )
                                         value = "NULL";
                                tsDML << " USERNAME = '" << value << "' ,";
待做转移：
1，明天比较这两个value的内部赋值过程和赋值结果是否相同。见"12:05 2007-12-11"待做1。
2，解决数据库写入后，解决数据库读出的问题，现在读出是乱码。（完成）

16:09 2007-12-06
待做
一，需要国际化的内容：
1，写数据库（"18:26 2007-12-06"完成）
加入Unicode2utf8c这样书写方便。
//tsDML << prefix<< " USERNO = '" << (const char*)value.utf8() << "' ,";
tsDML << prefix<< " USERNO = '" << Unicode2utf8c(value) << "' ,";

2，void UserAdmin::next()（完成）
{
        if ( currentPage()->isA("QUserBasicInfo") && ADD_c == op )
        {
                //TODO: i18n
                QString newUserID = ((QUserBasicInfo*)currentPage())->valueUserID->text();
                if ( isFieldInDB( "USERNO", newUserID.latin1() ) ) {
                        PDEBUG("DEBUG: USERNO %s is already in database.", newUserID.latin1());
                        QMessageBox::warning( 0, tr("find <%1:%2> in db").arg("USERNO").arg(newUserID.latin1()),
                                                tr("Please change your UserID"));
                        return;
                }
        }
3，读数据库（完成）
(21:00 2007-12-06)
国际化完成，代码"useradmin_12062100_i18n.tar.gz"
待做转移：解决下面疑问：
(20:52 2007-12-06)
QT，国际化疑问：
为什么写入数据库时需要使用latin1()？根据QT文档，Note that the returned value is undefined if the string contains non-Latin-1 characters.
所以使用latin1()会不会有问题？
见"12:05 2007-12-11"待做1。
"21:00 2007-12-06".end
二，写入数据库函数结构修改。

17:50 2007-12-06
整个下午试图解决数据库无法写入中文的问题，没有进展。
现有问题是写入数据库的QString没有加入从中文开始的所有字符串，感觉是编码问题。
既下面代码（value是中文）
        QString sDML;
        QTextOStream ts(&sDML);
        ts << "insert into i18n values (NULL, '" << value << "');";
的结果是
1:SQLITE_ERROR[1]: unrecognized token: "'"
就是只有"insert into i18n values (NULL, '"没有value和value以后的字符。因此一直怀疑是编码问题。下午一直思路不清楚，虽然查了一些间接资料，但仍没有进展。
步骤：
1，
        QString value = PushButton1->text();
        PushButton2->setText(value);
这样PushButton2中是中文，说明value本身是对的。
2，比较value和直接赋值的汉子。后者可以正确写入数据库：
(db_test.cpp)：
	test = "肆伍陆";
        ts << "insert into i18n values (NULL, '" << test << "');";
value的内容是"按钮"。
        QString value = PushButton1->text();
        QString directValue = "按钮";
        PushButton2->setText(value);
        if ( value.compare(directValue) != 0 )
        {
                qDebug("DEBUG: value and directValue is different.");
        }
经比较：value和directValue不同。
3，下面看directValue的字符集。
(18:14 2007-12-06)
没有找到查QString字符集的办法。
只有查char*字符集的办法：
QTextCodec* QTextCodec::codecForContent ( const char * chars, int len )
后来没有尝试，用了原来的失败的方法成功了：
没想到最后是使用原来就知道的办法实现的：
ts << "insert into i18n values (NULL, '" << (const char*)value.utf8() << "');";
原来可能是因为语法错误，就没有继续往下尝试。

19:24 2007-12-06
c语言，gcc，内联函数
见"Documents/bamvor张健的文档/micro微电子与计算机/Embeded嵌入式系统/软件设计/c语言/gcc/C语言 inline类型函数=++.txt"
inline的使用是有所限制的，inline只适合涵数体内代码简单的涵数
使用，不能包含复杂的结构控制语句例如while switch，并且不能内联函数本身不能是直接
递归函数(自己内部还调用自己的函数)。
(20:06 2007-12-06)
使用内联函数遇到问题
#define Unicode2utf8c(unicodeString) ((const char*)unicodeString.utf8())
//#include <qstring.h>
//inline const char* Unicode2utf8c(QString unicodeString)
//{
//      return (const char*)unicodeString.utf8();
//}
用内联函数是乱码，用宏定义正常：
DEBUG: valueValTo        ( class: QLineEdit )    value: ��nite
待做：查原因。
[root@localhost useradmin]# vim useradmincommon.h 
[root@localhost useradmin]# vim useradmin.cpp 

20:19 2007-12-06
测试，回归测试必要性
问题，query每次都失败：
经查，原因是writeDB中，如果某oP不需要写数据库，在default中处理，但是在加入"goto err"语句时，没有考虑到default语句内的两种情况（不需要写入数据库，出错处理）。
一是没有想到回归测试；二是结构不好，default是否应该只完成一个功能？
                        default:
                                if ( op < OP_MAX_c )
                                {
                                        qDebug("DEBUG: current opType is <%s>, "
                                                "which do not need to write db",
                                                opName[(int)op].latin1() );
                                }
                                else
                                {
                                        qDebug("DEBUG: invalid opType <%d>", op);
                                        goto err;
                                }
                        break;

10:41 2007-12-09
编译出错：
userbasicinfo.cpp:203:68: pasting "(" and ""Class name is %s."" does not give a valid preprocessing token
203：PDEBUG("Class name is %s.", ((QWidget*)newObj)->className());
原来是没有这个错误的，奇怪。

突然想起gcc3.x已经支持C99了，所以改为C99风格的可变参数宏：
#define PDEBUG(args...) qDebug(##args)
#define PDEBUG(...) qDebug(__VA_ARGS__)

11:16 2007-12-09
c语言，C99
http://predef.sourceforge.net/prestd.html
待做：保存

12:36 2007-12-09
待做完成：修改完成queryPrep，给叶涛打电话。

00:48 2007-12-10
继续完成readDB

10:46 2007-12-11
本周计划：
1，完成"10:43 2007-12-05"数据库存入中文内容；输入用户名和用户ID查询。（上午）
(12:09 2007-12-11)
项目进展：
A, 查询用户ID和用户姓名正确。
B, 点击back时，退回到QP页时，再点下一步应该从新查询。建立自己的back槽后解决问题。
C, 出现多个查询结果时，显示第一个没有删除的结果。
代码："fv/backup/useradmin_12111317.tar.gz"
2，触摸屏校准。

12:05 2007-12-11
待做：
1, 数据库写入，统一先使用fromUtf8()，最后用Unicode2utf8c()转为"char*"。现在QString保存的不一定是Unicode，这样不好。
QString value = "张健"，这样存的是utf8的。
2, 现有用定时器实现的readDB，如果放在showPage函数中，就不需要用定时器了。
重新分析现有UserAdmin类。当时没有把增删改查四个功能作为四个类，现在感觉不方便：
(1)，增和删改查的数据库操作不同，现在是用switch case，如果是四个类，就可以用虚函数，使用不同的readDB。
(2)，UserAdmin的构造函数改为分模块。QueryPrep页仅当删改查情况下独立加入。
3，bool UserAdmin::readDB(QString queryCond)的QMessageBox显示内容太长。
4，支持增删改查多个查询结果。
5，更新国际化文件。（完成）
6，QueryPrep::getInfo()改为调用validator。

12:07 2007-12-11
项目进展：
20日有人来看。

16:14 2007-12-11
拼音，FC7下使用的murphytalk拼音所需文件
fv/qt/pinyin/murphytalk-0.3_x86release.tar.gz

17:02 2007-12-11
待做完成：
1，中文软键盘改高，用unifont。这样字体好看；（完成）
QPinyinFrame::keyHeight。
修改候选区的高度，开始以为是设置的高度不合适，于是修改QPinyinFrame::init_gui_dimention：
//bamvor.modified.2007-12-11
//      m_cand_rect=QRect(0,y,width-2,rect.height()+2);
        int candHeight = metric.boundingRect(QChar(ZHONG)).height();
        m_cand_rect=QRect(0,y,width-2,candHeight+2);
//bamvor.modified.2007-12-11.end
经实验和仔细阅读代码，高度本身没有问题，问题是"QPinyinFrame::init_gui_dimention"计算有软键盘时的QPinyinFrame高度是固定值65(13*5)：
        if(sHeight>0)
                if(m_bShowKeyboard)
                      return sHeight+65;
                else
                        return sHeight;
改为"return sHeight+keyHeight*5;"，
下一步，keyHeight根据字体大小计算得到。
现在的问题是
return sHeight+keyHeight*5;
如果改为
return sHeight+keyHeight*5+PickHeight;会挡住任务栏。如果不改，键盘的最后一行只有一半，现在不知道该怎么改。
待做：完整看PinyinFram代码。
现有代码："fv/backup/murphytalk-0.3_1211.tar.gz"。
2，输入法选择的小三角能不能改大；（取消）
如果可以设定中文是默认输入法，可以不修改，中文输入法中支持英文，数字输入。
3，用户界面对齐；（完成）
4，useradmindialog改为QDialog。（转移）
5，左右手用不同颜色。保存手指信息。（取消，难以实现，以后解决，待做）

22:22 2007-12-12
QT，murthytalk学习
分析QPinyinFrame类
qwsServer->setKeyboardFilter (this);
QWSServer提供了只有QT server才拥有的函数，QWSServer在QT server的QApplication中建立，不应自己建立这个类，qwsServer是其全局指针。
void QWSServer::setKeyboardFilter ( KeyboardFilter * f ) [static]
在物理键盘事件和实际键盘事件之间加入一个KeyboardFilter。
KeyboardFilter是"QWSServer"的内部类：
class KeyboardFilter { public: virtual bool filter ( int unicode, int keycode, int modifiers, bool isPress, bool autoRepeat ) 
待做：查具体作用。
"QPinyinFrame"继承了该类：
class QPinyinFrame : public QFrame, public QWSServer::KeyboardFilter

继续分析
(23:08 2007-12-12)
 154         QPEApplication::grabKeyboard();
void QPEApplication::grabKeyboard () [static]
Grabs the physical keyboard keys, e.g. the application's launching keys.
Instead of launching applications when these keys are pressed the signals
emitted are sent to this application instead. Some games programs take over
the launch keys in this way to make interaction easier.

 157         Config config(config_file);
----------------------------------------
trim（在public.cpp中实现）:
本函数返回字符串 string 首尾的空白字符去除后的字符串。
没找到Linux下这个函数的帮助。
(23:22 2007-12-12)
下载c++帮助：
ftp://linuxforum.net/ftp.gcc.gnu.org/libstdc++/doxygen
GNU GCC 提供了一份关于 MAN 格式的 C++ 标准库的文档，可以在其镜像点（http://gcc.gnu.org/mirrors.html）中下载。展开包之后将 man/man3 中的所有文件拷贝到系统上已经存在的一个 man/man3 目录中即可使用。可首先 man C++Intro 阅读 Introduction to the GNU libstdc++-v3 man pages。
自：http://tag.csdn.net/Article/8e43b40a-da4e-45bb-8224-c5d91e8c65b1.html
仍然没找到，奇怪，后来发现这个不是标准库函数，这里的trim是在public.h/cpp中实现的。
上网找到很多trim函数的实现，待做：学习：
http://topic.csdn.net/t/20020109/13/466696.html
http://bbs.chinaunix.net/archiver/?tid-276162.html

顺便看到这篇文章：
http://blog.csdn.net/turingbook/archive/2007/09/07/1775488.aspx
讨论c和c++的优劣，有使用前十名语言的排名，java第一，c第二。
待做：下载这个网页，打印细看。

18:47 2007-12-13
用nm找到drawKeyboard函数名后，可以设置断点，需要加入调试信息，否则无法调试。
待做完成。

23:24 2007-12-13
QPinyinFrame::init_gui_dimention()
0000fab4 T _ZN12QPinyinFrame18init_gui_dimentionEv
QPinyinFrame::drawKeyboard( QPainter &p, int key )
00011f34 T _ZN12QPinyinFrame12drawKeyboardER8QPainteri
void QPinyinFrame::paintEvent(QPaintEvent * e)
00010098 T _ZN12QPinyinFrame10paintEventEP11QPaintEvent
void QPinyinFrame::show()
000129bc T _ZN12QPinyinFrame4showEv
void QPinyinFrame::hide()
000129f8 T _ZN12QPinyinFrame4hideEv
QSize QPinyinFrame::sizeHint() const
00010a84 T _ZNK12QPinyinFrame8sizeHintEv

00:01 2007-12-14
在init_gui_dimention的第一次运行中，把sHeight给PickHeight。这样暂时解决了这个问题。但是很多地方结构不好。

00:09 2007-12-14
1，10可能是margin。不是。margin是1或0
2，m_kbdbtn_rect的高度最好是键盘图标的高度。
待做：根据"painter.drawPixmap(width-2-about.width()-28,rect.height()-10,QPixmap((const char**)kb_xpm));"学习。
3，如何设置默认于洋？
4，发现一个问题，如果用小三角开启中文输入法后，关闭中文输入法，再打开，输入法软键盘显示不全，只有前三行。查原因。感觉是开启输入法的初始位置有问题。
现有代码："fv/backup/murphytalk-0.3_12140117.tar.gz"

00:33 2007-12-14
murthytalk，输入法修改
1，现有软键盘大小以及其他和汉子显示有关大小，都已经改为由keyHeight决定。进一步，如果屏幕大，调整keyHeight为2倍keyHeight：
//calculate proper font size
//bamvor.add.2007-12-13.1_line.根据字体大小设定软键盘按键大小。
        keyHeight = font_size;
        if ( screen_rect.height() >= keyHeight*7*3 )
        {
                keyHeight = keyHeight*2;
        }

2，默认打开软键盘，修改"murphytalk.conf"，加入"keyboard=1"
[bamv26@localhost inputmethods]$ cat /usr/etc/fvdac/murphytalk.conf 
font=unifont
font-size=16
keyboard=1

00:58 2007-12-14
Qtopia学习，如何向一个新平台移植QT
file:///usr/src/src2/FV_project/qt/qtopia/doc/html/devices.html
 Qtopia - Customizing Qtopia for a Device
待做：看。

01:08 2007-12-14
drawKeyboard由下面三个函数调用。
void QPinyinFrame::paintEvent(QPaintEvent * e)
void QPinyinFrame::clearHighlight()
void QPinyinFrame::mousePressEvent(QMouseEvent *e)

10:00 2007-12-14
现在完全无法显示软键盘，奇怪
(13:48 2007-12-14)
原因是没有找到正确的murthytalk.conf
对于没有错误检查的程序及其鄙视！

15:24 2007-12-14
只加入了对configfile有无的判断，
murphytalk.conf，pinyin_table.txt，murphytalk_phrase.dat，murphytalk_phrase_idx.txt这四个文件也需要判断。

15:34 2007-12-14
昨天发现的键盘显示不全的问题没有找到原因。查输入法范例。
反复查找没有头目......
但是如果总高度小于134，显示就没有问题，如果大于134。使用show和hide显示隐藏输入法时，高度只有134。

18:28 2007-12-14
使用QVBoxLayout总是出错，后来不用时也出错，可能是无意中把代码改错了。回去重做。

23:57 2007-12-17
完成界面对齐：
useradmin_12172356.tar.gz

10:55 2007-12-18
今日，待做完成
1，英文对齐(QUserBasicInfo, QUserFingerInfo)；
程序自动判断字符串长度，确定合适的宽度。（完成）
2，上传修改后的代码；（完成）
3，不存入'NULL'，而是NULL。（完成）
UserAdmin::writeDB()加入：DML.replace(QRegExp("'NULL'"), "NULL");
4，日期：写入日期后，读出是无限期（完成，原因是原来判断如果是整数0则认为是无限期，但是如果字符串不是数字toInt方法也会返回0，useradmin_12181930.tar.gz）。(14:07 2007-12-18)加入日期类，注意无限期和有限期之间修改是否正确。（转移）
参"13:15 2007-11-21"2
5，国际化，见"12:34 2007-12-18"，（完成）

12:34 2007-12-18
国际化问题：
QT_TR_NOOP和QT_TRANSLATE_NOOP的区别是前者没有指明待翻译字符串属于哪个类，只能在类内定义。因为只有在类内定义，QT才能找到待翻译字符串属于哪个类。否则应该使用QT_TRANSLATE_NOOP。
        QString FriendlyConversation::greeting( int greet_type )
        {
            static const char* greeting_strings[] = {
                QT_TR_NOOP( "Hello" ),
                QT_TR_NOOP( "Goodbye" )
            };
            return tr( greeting_strings[greet_type] );
        }

        static const char* greeting_strings[] = {
            QT_TRANSLATE_NOOP( "FriendlyConversation", "Hello" ),
            QT_TRANSLATE_NOOP( "FriendlyConversation", "Goodbye" )
        };
        QString FriendlyConversation::greeting( int greet_type )
        {
            return tr( greeting_strings[greet_type] );
        }
例如：下面的程序，如果改为"QT_TR_NOOP("op_None")"，tr翻译结果仍然是原文。
static const char* opName[OP_MAX_c] =
        {
                QT_TRANSLATE_NOOP("UserAdmin", "op_None"),
                QT_TRANSLATE_NOOP("UserAdmin", "Add User"),
                QT_TRANSLATE_NOOP("UserAdmin", "Delete User"),
                QT_TRANSLATE_NOOP("UserAdmin", "Modify User"),
                QT_TRANSLATE_NOOP("UserAdmin", "Query User")
        };
UserAdmin::UserAdmin(enum opType opT, QWidget * parent, const char *name,
                     bool modal, WFlags fl, CppSQLite3DB *sqlite3db_p)
    :QWizard(parent, name, modal, fl), db_p(0)
{
        enum editType et;
//      setName(opName[(int)opT].latin1());
        setName(opName[(int)opT]);
//      setCaption(tr(Unicode2utf8c(opName[(int)opT])));
        PDEBUG("DEBUG: %d: %s, %s", (int)opT, opName[(int)opT], Unicode2utf8c(tr(opName[(int)opT])));
        setCaption(tr(opName[(int)opT]));
//......
}
待做完成，需要建立一个类，这样才能保证所有类使用时都可以正确翻译。
(17:59 2007-12-18)
建立Operation类，完成国际化。有两个静态函数，一是返回opName[i]，二是返回i18n后的opName[i]。开始Operation没有继承QObject，国际化不成功。后来继承QObect类，并且Operation类的声明中加入Q_OBJECT，重新生产Makefile（目的是对Operation类进行moc）。
现有代码："useradmin_12181824.tar.gz",CVS信息：
////      Revision 1.1.2.2.2.9  2007/12/18 10:23:44  zhj
////      finish i18n for UserAdmin and UserAdminDialog by Operation class
////

16:09 2007-12-18
用了一个小时时间使输入法在arm板子上运行。现在输入法的词库文件在"qtfor2440/pinyin"目录下。遇到的问题仍然是词库.dat文件缺失造成的字库错误。

18:37 2007-12-18
读出信息有错（写入正确）
后来莫名其妙就正常了。

11:02 2007-12-19
c语言，QT学习，编译库文件
1，使用tmake生成工程文件：
(1)，TEMPLATE使用lib。VERSION是版本，后面生成库文件时作为库文件名字的后缀，便于使用者了解版本。后面另有说明。
#TEMPLATE        = app
TEMPLATE         = lib
VERSION         = 1.0.0
(2)源文件中去掉main.cpp。这里的main.cpp只是qtopia程序的入口，没有其他代码：
[root@localhost useradmin]# cat main.cpp 
#include "useradmindialog.h"
#include <qpe/qpeapplication.h>

QTOPIA_ADD_APPLICATION("useradmindialog", UserAdminDialog)
QTOPIA_MAIN
(3)QT工程文件参考：
qtopia/src/plugins/inputmethods/keyboard/keyboard.pro
2，如何编写Makefile，形式上和编译普通文件并无不同：
all: $(TARGET)

$(TARGET): $(OBJECTS) $(OBJMOC) $(SUBLIBS)
        -rm -f $(TARGET) $(TARGET0) $(TARGET1) $(TARGET2)
        $(LINK) $(LFLAGS) -o $(TARGETD) $(OBJECTS) $(OBJMOC) $(LIBS)
        -ln -s $(TARGET) $(TARGET0)
        -ln -s $(TARGET) $(TARGET1)
        -ln -s $(TARGET) $(TARGET2)
        $(LINK) $(LFLAGS) -o $(TARGETD) $(OBJECTS) $(OBJMOC) $(LIBS)
区别：
(1)LFLAGS  =       -shared -Wl,-soname,libuseradmindialog.so.1
A, "-shared"是编译动态链接库，代码需要是位置无关代码。需要在CFLAGS和CXXFLAGS中加入"-fPIC"。
"-fPIC"是编译位置无关代码(position independent code)，位置无关代码用于做动态链接and avoiding any limit on the size of the global offset table.  This option makes a difference on the m68k, PowerPC and SPARC. 和"-fpic"的区别是不会超过GOT( global offset table)的大小限制。
B, "-Wl,option"，把参数传递给链接器，如果参数中包含逗号，以逗号为分隔作为多个参数传给链接器。一般Makefile中链接器是gcc，在实际执行该Makefile链接过程中是gcc会调用ld。
C, "-soname=name"，这里是指定加载库时必须加载libuseradmindialog.so.1而不是libuseradmindialog.so，可以保证库的版本是正确的。
具体含义：When creating an ELF shared  object,  set  the  internal  DT_SONAME field  to  the specified name.  When an executable is linked with a shared object which has a DT_SONAME field, then when the executable is  run  the  dynamic linker will attempt to load the shared object specified by the DT_SONAME field rather than  the  using  the  file name given to the linker.
(2)注意这里输出文件并不是"TARGET"，QT是为了区分生成动态库还是静态库单独定义了“TARGETA”，"TARGETD"。另外，TARGET0，TARGET1，TARGET2是根据前面VERSION定义的三个指向TARGETD的符号链接，这个便于控制版本。上面的soname类似。
TARGET  =       libuseradmindialog.so.1.0.0
TARGETA =       libuseradmindialog.a
TARGETD =       libuseradmindialog.so.1.0.0
TARGET0 =       libuseradmindialog.so
TARGET1 =       libuseradmindialog.so.1
TARGET2 =       libuseradmindialog.so.1.0

11:53 2007-12-19
c语言学习，Linux，man
查看指定路径下的man手册：
[root@localhost useradmin]# man arm-linux-gcc -M /usr/local/arm/3.3.2/man
[root@localhost useradmin]# man arm-linux-gcc -M /usr/local/arm/3.3.2/man -w
/usr/local/arm/3.3.2/man/man1/arm-linux-gcc.1
-w表示显示所用man手册的位置。
[root@localhost useradmin]# man arm-linux-gcc -M /usr/local/arm/3.3.2/man -W
/usr/local/arm/3.3.2/man/man1/arm-linux-gcc.1
-W表示显示所用man手册的文件名。
如果调用的man手册不是单独一个文件，-w, -W是有区别的：
[root@localhost useradmin]# man gcc -w
/var/cache/man/cat1/gcc.1.bz2 (<-- /usr/share/man/man1/gcc.1.gz)
[root@localhost useradmin]# man gcc -W
/var/cache/man/cat1/gcc.1.bz2
/usr/share/man/man1/gcc.1.gz

12:03 2007-12-19
待做，进展，今日，计划
上午对于Makefile又有了进一步的了解。估计今天是没法做触摸屏驱动了。
1，QUserDateInfo：
(1)下午完成日期类的日期输入界面，进展：修改：userdateinfo.cpp:getsystime
参"13:15 2007-11-21"2
(19:23 2007-12-19)
QPEEnhanceDateTimeEdit应该是正确了，明天上午加入到valueRegTo中，QComboBox+QPEEnhanceDateTimeEdit
(2)界面对齐。待做：从四列改为两列！
(3)Reg time 改为 Enroll time
2，"17:02 2007-12-11"4，useradmindialog改为QDialog。
3，手指注册。两个listbox大小相同。label宽度变为最大宽度。查这个工作属于前面哪个待做。
4，"10:43 2007-12-05"用户管理的数据库部分。作为本周计划。完成后修改原日志。
5，"15:05 2007-12-19"删除用户后，仍然可以查到，只是信息是空。

12:09 2007-12-19
远期，待做
1，"10:55 2007-12-18"
改进实现计算界面适合宽度的方法：
userbasicinfo.cpp, QUserBasicInfo():
        //calculate the max width
        //FIXME, TODO: get the max width throuth comparing each widget.
        //there are more i18n work at "Birthday", "Department", it might be 
        //different from birthName and depart below. Under this condition,
        //we can not get the actual width of "Birthday", "Department".
2，"16:09 2007-12-18"输入法软键盘的最大高度有限制。查qpe已有的其它输入法是否可以任意调高。

14:32 2007-12-19
项目问题，待做，叶涛
verify/src/fv-gui.cpp:reqVerify(idnum)，的idnum是QString::ascii()得到的。这样没有考虑USERNO是中文的情况。

17:29 2007-12-19
待做：
1，QPEEnhanceDateTimeEdit::setText需要重构。查是否合法。

17:38 2007-12-19
c语言，QT学习，编译，编写QPEEnhanceDateTimeEdit
1，g++ -c -pipe -DQWS -fno-rtti -Wall -W -g -DX86 -DNO_FV -DPAGEDEBUG -DUADDEBUG -I/usr/src/FV_Project/qt/qt/include -I/usr/src/FV_Project/qt/qtopia/include -o enhancedatetimeedit.o enhancedatetimeedit.cpp
enhancedatetimeedit.cpp:78: `hour' was not declared in this scope
enhancedatetimeedit.cpp:78: `min' was not declared in this scope
enhancedatetimeedit.cpp:78: `sec' was not declared in this scope
enhancedatetimeedit.cpp:79: parse error before `if'
make: *** [enhancedatetimeedit.o] 错误 1
原因是文件if语句少写了一个"{"，使编译器误以为函数在"}"结束。
        if ( !date.isValid() ||  date.isNull() )
                PDEBUG("WARNING: wrong date");
                return FALSE;
        }
        QTime time(hour, min, sec);

2，测试"QPEEnhanceDateTimeEdit::setText()"，最后发现是setText中少了：
        this->setDate(date);
        this->setTime(time);
.......张健这只猪，怎么还没有进化。

3，迭代器中多了一个QHBoxLayout，不知道为什么一个valueValFr会在迭代器中加入两个对象。
Class name is QHBoxLayout, name is valueValFr.
class name is QHBoxLayout.
WARNING[udi]: unexpected widget in iterator. check it!

19:23 2007-12-19
待做，解决下面的问题：
如果加入PAGEDEBUG，在退出UserAdmin时会出错：
DEBUG: ID is 16873430
DEBUG: current opType is <Query User>, which do not need to write db
DEBUG: (null)
DEBUG: commit transaction;
ret is 1
DEBUG: entering decontructor of UserAdmin
*** glibc detected *** /usr/src/FV_Project/project/fvdac/useradmin/useradmindialog: corrupted double-linked list: 0x08c25a08 ***
UserAdmin的析构函数是在exec()函数执行后，执行的。

加入PAGEDEBUG时增加了调试界面，例如加入了"QUserDateInfo::setInfo"，感觉可能是"QUserDateInfo::setInfo"的问题。

14:16 2007-12-20
尝试用QComboBox做出时间选择，没有成功。感觉需要修改QPEDateTimeEdit类。
comboboxdatetimeedit.cpp/h代码位于："fv/backup/useradmin_12201855.tar.gz"，Makefile.cbdte是其Makefile。
想法1：
QComboBox包括无限期和具体时间两个选择。用户选择具体时间时弹出QPEEnhanceDateTimeEdit日期时间对话框。相关文件：
comboboxdatetimeedit.cpp
comboboxdatetimeedit.h
comboboxdatetimeedit.pro
想法2：
用户选择具体时间时弹出一个对话框，对话框中例化QPEEnhanceDateTimeEdit类，用户选择对话框的ok按钮时发射带有用户设置日期的信号，由QComboBox接收。这样用户相当于是多点了一次ok。
想法3：
在QUserDateInfo例华QPEEnhanceDateTimeEdit类，右边加入一个无限期按钮。

16:38 2007-12-20
待做完成：
1，QPEEnhanceDateTimeEdit超长（有限无限显示不全）；完成
2，向界面写入数据时正确处理。（完成）
修改setText
3，QPEEnhanceDateTimeEdit::change按钮, 改为pixmap（完成）
现有代码: useradmin_12201855.tar.gz

18:31 2007-12-20
QT学习，QPixmap
参：murphytalk-0.3/PinyinFrame.cpp和fvdac/useradmin/enhancedatetimeedit.cpp 
/* XPM */
static const char * pix_next[] = {
"16 11 3 1",
"       c #C0C0C0C0C0C0",
"#      c #000000000000",
".      c #00000000FFFF",
"          #     ",
"         ##     ",
"        #.#     ",
"       #..#     ",
"      #...#     ",
"     #....#     ",
"      #...#     ",
"       #..#     ",
"        #.#     ",
"         ##     ",
"          #     "};
第一行含义：16宽，11高，一共三种颜色，每像素点数。
2-4行是定义" ", "#"和"."符号的颜色。后面是实际图片。详见"fv/qt/XPM格式介绍=+.txt"
QPixmap next((const char **)pix_next);
或者直接传给按钮（change是QPushButton）
change->setPixmap(QPixmap((const char **)pixToggleInf));

18:52 2007-12-20
待做，下周计划（12-25--12-27）
下周任务是完成用户管理界面，包括指静脉和日志。
如果有时间，加入QValidator了！

10:09 2007-12-24
待做，12-24计划
"10:43 2007-12-05"
(1)-2，导入导出指静脉模板。1天
(1)-3，可以删除单个人的指静脉。1天
修改对应ID的指静脉为空即可
(1)-4，保存指静脉时第一字节代表是哪个手指。规定手指顺序。
附加：改进index。现有fingerTempIndex没有考虑删除手指的情况。

11:02 2007-12-24
fv/backup/useradmin_12201855_cvs.tar.gz是已经加入cvs服务器的"useradmin_12201855.tar.gz"。仅仅删除了"useradmindialog.pro.arm/x86"两个工程文件。都合并到了useradmindialog.pro。

11:05 2007-12-24
新建一个fingerVeinInfo类，继承自QOjbect。
有name和value两个变量。前者保存是哪个手指。后者保存对应的指静脉信息。
这样原有通过QOjbectList查找界面中需要保存数据的方法同样适用。
任务可以分为两部分，每步都需要cvs ci：
1，通过FingerVein保存的手指信息正确。
2，新建fingerVeinInfo类，并加入UserFingerInfo类。修改UserFingerInfo和UserAdmin相关代码。

11:46 2007-12-24
通过FingerVein保存正确的指静脉信息。
代码："fv/FV底层通信程序/armfv\ -beifen-ok/"。指静脉信息的上传/下载：看fvhead.c upload/download函数。经测试，两个fvhead.c的upload/download函数都能正常工作。需要把upload加入到FingerVein，把upload结果和FingerVein类enroll函数保存结果对比，如果一致，说明指静脉保存正确。

13:07 2007-12-24
CVS:
fingervein.cpp/h add recv()

15:29 2007-12-24
比较二进制文件
开始没有找到如何比较二进制文件，自己写了一个，结果很多错误：
1，应该是argc!=3
2，read(fd1, buf1, 1); 
应该是&buf1
后来才找到"cmp -l filename1 filename2"可以比较两个文件是否相同，并且输出所有不同点，序号用十六进制表示，数据用八进制表示。用八进制表示毕竟没有用十六进制表示效果好。自己这个程序位于"fv/other/hexCompare.c"。

17:37 2007-12-24
现有代码：useradmin_12241736.tar.gz
指静脉模板未完成。

23:06 2007-12-26
QT，手指，待做
手指注册图标保存在"fv/qt/pic"
http://www.letget.com/theme/1808.html
用QPixmap::convertFromImage方法和QImage类读取该图片。
修改有限期无限期图表。见moto笔记本。

14:01 2007-12-27
待做完成：
1，2410板子，能否接8寸液晶。查接口，改驱动；（完成）
2，SD卡驱动；（转移）

14:24 2007-12-27
感觉日立这组做东西挺没有计划的......
解决文件系统问题
1，先试液晶。（完成）
更换内核：arm_s3c2410_傅立叶/傅立叶提供烧写的文件/新/u2410zImage8；液晶识别正常；
2，加入可写的文件系统；yaffs
3，解决SD卡驱动。（完成）
4，更新中文输入法
5，加入USB鼠标，键盘驱动。可以在QT中正确使用。

17:00 2007-12-27
参照傅立叶yaffs中脚本，加载mmc插槽驱动，插入"mmcsd_slot.o"时出错：
# insmod mmcsd_core.o
# insmod mmcsd_disk.o
# insmod mmcsd_slot.o 
mmcsd_slot.o: init_module: Device or resource busy
Hint: insmod errors can be caused by incorrect module parameters, including invalid IO or IRQ parameters

# cat /proc/kmsg 
<4>MMC/SD Slot: request_irq(SD CD) failed
<6>NETDEV WATCHDOG: eth0: transmit timed out

修改傅立叶驱动文件"drivers/mmcsd/mmcsd_slot_s3c2410.c"：
564         set_external_irq(SD_IRQ_CD, EXT_BOTH_EDGES, GPIO_PULLUP_DIS);
565         ret = request_irq(SD_IRQ_CD, card_detect_interrupt,
566                           SA_INTERRUPT, "SD CD", (void *)&slot);
567         if (ret) {
568                 printk("MMC/SD Slot: request_irq(SD CD) failed: %d\n", ret);
569                 goto err1;
570         }
571 
572 #ifdef USE_INTERRUPT
573         ret = request_irq(IRQ_SDI, sdi_interrupt,
574                           SA_INTERRUPT, "SDI", (void *)&slot);
575         if (ret) {
576                 printk("MMC/SD Slot: request_irq(SDI) failed: %d\n", ret);
577                 goto err2;
578         }
579 #endif
插入模块后，看ret到底是多少：
# cat /proc/kmsg 
<4>MMC/SD Slot: request_irq(SD CD) failed: -16
<6>NETDEV WATCHDOG: eth0: transmit timed out
含义，"asm/errno.h"：
#define EBUSY           16      /* Device or resource busy */
这个错误是
request_irq调用的setup_arm_irq函数产生的：
driver/mmcsd/mmcsd_slot_s3c2410.c: "ret = request_irq(SD_IRQ_CD, card_detect_interrupt"
arch/arm/kernel/irq.c：setup_arm_irq：
257 int setup_arm_irq(int irq, struct irqaction * new)
//......
284         desc = irq_desc + irq;
285         spin_lock_irqsave(&irq_controller_lock, flags);
286         p = &desc->action;
287         if ((old = *p) != NULL) {
288                 /* Can't share interrupts unless both agree to */
289                 if (!(old->flags & new->flags & SA_SHIRQ)) {
290                         spin_unlock_irqrestore(&irq_controller_lock,
flags);
291                         return -EBUSY;
292                 }
其中
1, "irq_desc"是"NR_IRQS"个"irqdesc"结构体：
50 struct irqdesc irq_desc[NR_IRQS];
NR_IRQS在"include/asm/arch-s3c2410/irqs.h"定义：NR_IRQS=11+20+32=63。
2, desc指向当前所申请中断的irqdesc结构体；
3，287行，判断是否当前中断action不为空。如果不为空，说明要共享中断。允许共享中断的前提是新旧irqaction的flags都包括"SA_SHIRQ"flag，否则报"-EBUSY"错误。
4，注，request_irq函数原型为：
int request_irq(unsigned int irq, void (*handler)(int, void *, struct pt_regs
*),
                 unsigned long irq_flags, const char * devname, void *dev_id)

/-----------------------------------------------------------------------------/
尝试：
1，申请中断时加入SA_SHIRQ。错误同样。
2，如果不行，查谁使用了与sd卡同样的中断。
IRQ_nCD_SD：
include/asm-arm/arch-s3c2410/smdk.h
#define IRQ_nCD_SD              IRQ_EINT18
IRQ_EINT18（include/asm-arm/arch-s3c2410/irqs.h）：
IRQ_EINT18 = 14 + 32 = 46
查看系统中断使用情况：
# cat /proc/interrupts 
 13:          0   DMA timer
 14:     448749   timer
 16:      11162   LCD
 18:          0   IIS Record
 19:          0   I2SSDO
 21:          0   SDI
 25:          0   S3C2410 USB core
 26:          0   usb-ohci
 30:          0   RTC Alarm
 37:       9603   cs89x0
 46:          0   SD CD
 52:          0   serial_s3c2410_rx
 53:        248   serial_s3c2410_tx
 54:          0   serial_s3c2410_err
 61:          2   s3c2410-ts
 62:         14   s3c2410-ts
Err:          0
46的确已经被注册，也是被SD_CD注册。可能是原有文件系统中的sd卡驱动注册的。

18:33 2007-12-27
Linux，service命令，vsftpd
vsftpd启动不成功，不论/usr/sbin/vsftpd还是/etc/init.d/vsftpd restart都不行：
启动没有报错，但是实际并没有启动成功，查状态。
[root@localhost etc]# service vsftpd status
vsftpd 已死，但是 subsys 被锁
使用
http://richardf.spaces.live.com/blog/cns!8B8347DAD5BFE57!572.entry
和
http://www.chinaunix.net/jh/15/594039.html
方法仍然不行。
继续找......
明天继续尝试sd卡驱动问题：
下载/usr/src/fft_linux/fs_sd-test.cramfs内核，删除了其中的sd卡驱动，尝试自己编译的sd卡驱动是否可以正确加载和使用。

11:35 2007-12-28
继续解决ftp问题
从"http://ubuntuforums.org/archive/index.php/t-9936.html"查到，如果有多个ftp服务器，会有冲突。
用下面命令查看：
[root@localhost log]# netstat -ap | grep "*:ftp"
tcp        0      0 *:ftp                       *:*                         LISTEN      2470/xinetd
只好先把xinetd关闭：
service xinetd stop
此后pure-ftpd可以启动，但是登录错误。重装vsftpd后，vsftpd也可以启动。
xinetd中为什么会有ftp服务器？
无意上网找到这篇文章："Embeded嵌入式系统/软件设计/OS操作系统/linux/网络/vsftp安装中遇到的问题=++.txt"，文中提到xinetd服务中有ftp服务器，是因为建立了"/etc/xinetd.d/vsftpd"，将这个文件改名后，问题解决。
当初第一次使用时，因为没有重启机器或xinetd服务，所以"/etc/xinetd.d/vsftpd"没有生效。昨天使用时该文件已经生效，造成vsftpd无法使用。
待做完成：问题，如果通过xinetd服务启动vsftpd？参考tftpd的方法。

14:13 2007-12-28
通过xinetd管理vsftpd，ftp问题解决
1，"服务不可用"：
[root@localhost xinetd.d]# ftp 192.168.200.200
Connected to 192.168.200.200 (192.168.200.200).
421 Service not available, remote server has closed connection
ftp> 
看配置文件"/etc/vsftpd/vsftpd.conf"，其中"listen=YES"表示vsftpd独立运行（standalone模式），不通过xinetd管理，并且使用ipv4协议进行监听。"listen_ipv6=YES"类似，只是用ipv6协议监听。如果需要同时监听v4, v6，需要写两个配置文件。
此时如果直接启动vsftpd，会出现前面提到过的现象：
[root@localhost vsftpd]# service vsftpd restart
关闭 vsftpd：                                              [失败]
为 vsftpd 启动 vsftpd：                                    [确定]
[root@localhost vsftpd]# service vsftpd restart
关闭 vsftpd：                                              [失败]
为 vsftpd 启动 vsftpd：                                    [确定]
[root@localhost vsftpd]# rm /var/lock/subsys/vsftpd 
rm：是否删除 普通空文件 “/var/lock/subsys/vsftpd”? y
[root@localhost vsftpd]# netstat -ap | grep ftpd
[root@localhost vsftpd]# netstat -ap | grep ftp
tcp        1      0 host:54310                  ftp.kddlabs.co.jp:http      CLOSE_WAIT  2688/python         
tcp        0      0 *:ftp                       *:*                         LISTEN      9769/xinetd         
udp        0      0 *:tftp                      *:*                                     9769/xinetd         
2，输入zhangjian可以成功登录，输入root不可以。
看"/etc/vsftpd/user_list"其中指明：userlist_deny=YES（默认情况），"/etc/vsftpd/user_list"表中是不允许访问ftp的用户，由于里面有root，所以用root无法访问ftp，这是为了保证系统的安全。

14:45 2007-12-28
烧写昨天生产的cramfs：
[root@(none) fft_linux]# imagewrite /dev/mtd/0 fs_sd-test.cramfs:1m             
meminfo size = 67108864                                                         
size = 29331456                                                                 
size = 29331456                                                                 
nand_erase: attempt to erase a bad block at page 0x00004580                     
bad_block = 1     
加在到mmcsd_slot.o时仍然是同样错误。

15:03 2007-12-28
继续尝试sd卡驱动
把文件系统中仅有的三个驱动模块改名为：
/usr/s3c2410-uda1341.o.bak  /usr/sd_mod.o.bak  /usr/usb-storage.o.bak
但是系统启动后，中断仍然有：
 46:          0   SD CD
现在怀疑sd卡驱动在内核中，只有重新编译内核了。

16:04 2007-12-28
首先需要修改内核对液晶的配置。
drivers/video/s3c2410fb.c
选择第一个640*480液晶的配置文件。
注意到傅立叶和优龙的配置文件不同。待做：分析原因。
可以用，但是屏幕是向左偏了。
参考后面的640x480配置改，主要是把水平同步从96改为32。

17:49 2007-12-28
改液晶驱动中，
对于framebuffer不是很了解，先用framebuffer测试程序得到相关参数，使用前面已经验证过的傅立叶提供的u2410zImage8内核：
[root@(none) tmp]# ./framebuffertest.arm                                        
frame buffer: 640(1280)x480, 16bpp, 0x96000byte                                 
framebuffer: pixclock 341521.                                                   
framebuffer: hsync_len 32,       left_margin 24,         right_margin 26.       
framebuffer: vsync_len 2,        upper_margin 11,        lower_margin 1.
LCD controller: 0x05440279, 0x2177c282 0x03427f10 0x00000d60 0x00014b01.
这些参数和现有自己编译内核中采用的参数一致。
Vertical back porch:  0x21(33), front porch 0x02(2);
Horizontal back porch:0x42(68), front porch 0x10(16).
仅仅修改上面四个参数仍然显示仍然是歪的，内核：zImage_modify4_u2410zImage8_porch
完全使用上面的参数试试，内核：zImage_modify4_u2410zImage8。这次正确:)
待做：学习LCD控制器的设置方法；测试实验室液晶能否正确使用，如果不能需要学习2.4内核framebuffer驱动编写方法。
(10:21 2008-02-13)实验室液晶连接在优龙SBC2440开发板上可以使用。

18:56 2007-12-28
继续尝试sd卡驱动
查看中断
=======
利用刚才编译的内核(zImage_modify4_u2410zImage8)。这时46号中断没有被使用：
[root@(none) tmp]# cat /proc/interrupts                                         
 13:          0   DMA timer                                                     
 14:     155221   timer                                                         
 16:       3258   LCD                                                           
 30:          0   RTC Alarm                                                     
 37:       2257   cs89x0                                                        
 52:        162   serial_s3c2410_rx                                             
 53:        452   serial_s3c2410_tx                                             
 54:          0   serial_s3c2410_err                                            
 61:          2   s3c2410-ts                                                    
 62:        122   s3c2410-ts                                                    
Err:          0

加载SD卡驱动：
============
[root@(none) mmcsd]# insmod mmcsd_core.o                                        
[root@(none) mmcsd]# insmod mmcsd_disk.o                                        
[root@(none) mmcsd]# insmod mmcsd_slot.o                                        
MMC/SD Slot initialized                                                         
[root@(none) mmcsd]# Partition check:                                           
 mmca: p1 p2 p3 p0                                                              
                                                                                
[root@(none) tmp]# mkdir part1                                                  
[root@(none) tmp]# mount /dev/mmc/disc0/part1 part1/                            
end_request: I/O error, dev 3c:01 (mmc), sector 0                               
end_request: I/O error, dev 3c:01 (mmc), sector 8                               
end_request: I/O error, dev 3c:01 (mmc), sector 16                              
end_request: I/O error, dev 3c:01 (mmc), sector 24                              
cramfs: wrong magic                                                             
end_request: I/O error, dev 3c:01 (mmc), sector 0                               
FAT: unable to read boot sector                                                 
yaffs: dev is 15361 name is "3c:01"                                             
mount: Mounting /dev/mmc/disc0/part1 on /var/tmp/part1 failed: Invalid
argument 
[root@(none) tmp]# ls part1/                                                    
[root@(none) tmp]# mount /dev/mmc/disc0/part1 part1/                            
[root@(none) tmp]# mkdir part2                                                  
[root@(none) tmp]# mkdir part3                                                  
[root@(none) tmp]# mkdir disk                                                   
[root@(none) tmp]# mount /dev/mmc/disc0/disc  disk/                             
cramfs: wrong magic                                                             
modprobe: modprobe: Can't open dependencies file
/lib/modules/2.4.18-rmk7-pxa1/)
modprobe: modprobe: Can't open dependencies file
/lib/modules/2.4.18-rmk7-pxa1/)
modprobe: modprobe: Can't open dependencies file
/lib/modules/2.4.18-rmk7-pxa1/)
modprobe: modprobe: Can't open dependencies file
/lib/modules/2.4.18-rmk7-pxa1/)
[root@(none) tmp]# ls disk/                                                     
new file                                                                        
[root@(none) tmp]# ls disk/new\ file                                            
disk/new file                              

sd卡挂载初步完成！挂载方法：
==========================
参考后面的"2440开发板中挂载sd卡脚本"，应该挂在disk0/part1，如果卡拔出后在插入卡槽，需要重新加载"mmcsd_slot.o"驱动模块，否则会提示"Invalid argumenta"：
# mount /dev/mmc/disc0/part1  part1
mount: Mounting /dev/mmc/disc0/part1 on /var/tmp/part1 failed: Invalid
argument
# rmmod mmcsd_slot
# insmod driver/mmcsd/mmcsd_slot.o 
# mount /dev/mmc/disc0/part1  part1

2440开发板中挂载sd卡脚本：
=========================
注：（2410开发板用的是自己在修改的文件系统；2440开发板是傅立叶提供的，叶涛修改的文件系统，基本只是用了新Qtopia）
# cat mount-mmc 
#!/bin/sh 
# 
# Korean mount wrapper 
# 

/sbin/modprobe mmcsd_disk
/sbin/modprobe mmcsd_slot_s3c2410

sleep 1

mount -t vfat -o iocharset=euc-kr,codepage=949 /dev/mmc/disc0/part1 /mnt/ext2
&& echo "* MMC Card mounted on /mnt/ext2" 

另外，保存一份模块列表，便于建立现有文件系统时参考：
===================================================
2410开发板现有模块：
# lsmod
Module                  Size  Used by
mmcsd_slot              3492   0  (unused)
mmcsd_disk              3164   0 
mmcsd_core              6264   2  [mmcsd_slot mmcsd_disk]
2440开发板，模块：
# lsmod                                                                         
Module                  Size  Used by                                           
ide-disk               10832   0                                                
ide-probe-mod           8672   0                                                
ide-mod                51616   0  [ide-disk ide-probe-mod]                      
mousedev                4560   0  (unused)                                      
keybdev                 1968   0  (unused)                                      
usb-storage            22640   0  (unused)                                      
sd_mod                 10944   0  (unused)                                      
scsi_mod               56112   1  [usb-storage sd_mod]                          
usb-ohci-s3c2440        2928   0  (unused)                                      
usb-ohci               16704   0  [usb-ohci-s3c2440]                            
usb-ohci-pool           2128   1  [usb-ohci-s3c2440 usb-ohci]                   
hid                    19168   0  (unused)                                      
usbmouse                1920   0  (unused)                                      
input                   3776   0  [mousedev keybdev hid usbmouse]               
usbcore                35136   0  [usb-storage usb-ohci hid usbmouse]    

待做完成：文件系统建立完成后，编写适合本系统的sd卡挂载脚本。
位置："fv/kernel_driver/mmcsd"
注："/proc/driver/mmcsd"有MMC/SD卡的信息：
[root@(none) root]# cat /proc/driver/mmcsd 
read-only       : no
card type       : SD
product name    : SD01G
card size       : 952MB

19:37 2007-12-28
待做：
根据"14:24 2007-12-27"，下一步是yaffs文件系统。现在主要是不知道在yaffs挂载在什么地方。

10:17 2007-12-29
Linux移植，yaffs文件系统
"drivers/mtd/nand/nand_s3c2410.c"有此开发板的nand flash分区信息，但是很奇怪，是bon和mtd分区，而不是下面被注释的那个分区方法。
待做：查2410书，看里面2.4内核的移植过程。
static struct mtd_partition def_partition_info[] = {
        { name: "bon",
          offset: 0,
          size:   0x04000000},

        { name: "mtd",
          offset: 0x00400000,
          size:   0x03af8000},
};
/*
static struct mtd_partition def_partition_info[] = {
        { name: "vivi",
          offset: 0,
          size:   0x00020000},

        { name: "param",
          offset: 0x00020000,
          size:   0x00010000},

        { name: "kernel",
          offset: 0x00030000,
          size:   0x000c0000},

        { name: "root",
          offset: 0x00100000,  
          size:   0x00300000},

        { name: "user",
          offset: 0x00400000, 
          size:   0x03af8000}
};


10:46 2007-12-29
Linux移植，yaffs文件系统
首先确定cramfs是否可以挂载在bon/4。然后试验yaffs。
可以挂载，方法和前面烧写挂载cramfs方法想同。

13:52 2007-12-29
Linux，文件系统移植，yaffs，续
挂载yaffs出错：
yaffs: dev is 24836 name is "61:04"                                             
mount: Mounting /dev/bon/4 on /mnt/yaffs failed: Invalid argument               
mount: Mounting none on /proc/bus/usb failed: No such file or directory         
完成启动日志："fv/kernel_driver/filesystem/yaffs/boot_cramfs_fail_log"
这时内核启动后再挂载yaffs也不行。
# mount /dev/bon/4 /mnt/yaffs                                                   
mount: /proc/filesystems: No such file or directory                             
# cat /proc/                                                                    
# ls proc/                                                                      
# ls                                                                            
Qtopia  dev   lib      mnt   ramdisk  sbin       tmp  var                       
bin     home  linuxrc  proc  root     testshell  usr                            
# mount -t yaffs  /dev/bon/4  /mnt/yaffs/                                       
yaffs: dev is 24836 name is "61:04"                                             
mount: Mounting /dev/bon/4 on /mnt/yaffs failed: Invalid argument   
如果参考"YF2410/yaffs/readme.txt"，挂载mtdblock分区为yaffs可以。这可能说明yaffs要求是块设备：
[root@(none) /]# mount /dev/mtdblock/1 /tmp/yaffs/ -t yaffs                     
yaffs: dev is 7937 name is "1f:01"                                              
[root@(none) /]# ls /tmp/yaffs/                                                 
lost+found   
看来只能是改内核中flash分区了。
注：待做，YF2410/yaffs/readme.txt，是yaffs的使用方法，待看。


14:18 2007-12-29
Linux，文件系统移植，yaffs，续（修改nand flash分区）
把原有内容：
#define NUM_PARTITIONS 2
static struct mtd_partition def_partition_info[] = {
        { name: "bon",
          offset: 0,
          size:   0x04000000},

        { name: "mtd",
          offset: 0x00400000,
          size:   0x03af8000},
};
替换为：
#define NUM_PARTITIONS 5
static struct mtd_partition def_partition_info[] = {
        { name: "vivi",
          offset: 0x00000000,
          size: 0x00020000
        },
        { name: "param",
          offset: 0x00020000,
          size:  0x00010000
        },
        { name: "kernel",
          offset: 0x00030000,
          size: 0x000d0000
        },
        { name: "root",
          offset: 0x00100000,
          size: 0x021fc000
        },
        { name: "user",
          offset: 0x02300000,
          size: 0x01cfc000
        }
};

Linux启动出错：
NAND device: Manufacturer ID: 0xec, Chip ID: 0x76 (Samsung NAND 64MiB 3,3V)     
Creating 5 MTD partitions on "NAND 64MiB 3,3V":                                 
0x00000000-0x00020000 : "vivi"                                                  
0x00020000-0x00030000 : "param"                                                 
0x00030000-0x00100000 : "kernel"                                                
0x00100000-0x022fc000 : "root"                                                  
0x02300000-0x03ffc000 : "user"                                                  
bon:cannot find partition table                                                 
here use default partition                                                      
bon0: 00000000-00030000 (00030000) 00000000                                     
bon1: 00030000-00100000 (000d0000) 00000000                                     
bon2: 00100000-00400000 (00300000) 00000000                                     
bon3: 00400000-03ef8000 (03af8000) 00000001
修改命令行参数中root=/dev/bon/3为root=/dev/mtd/3或root=/dev/mtdblock/3都不行。

修改为下面分区，启动正确。
#define NUM_PARTITIONS 6
static struct mtd_partition def_partition_info[] = {
        { name: "bon",
          offset: 0,
          size:   0x04000000
        },
        { name: "vivi",
          offset: 0x00000000,
          size: 0x00020000
        },
        { name: "param",
          offset: 0x00020000,
          size:  0x00010000
        },
        { name: "kernel",
          offset: 0x00030000,
          size: 0x000d0000
        },
        { name: "root",
          offset: 0x00100000,
          size: 0x021fc000
        },
        { name: "user",
          offset: 0x02300000,
          size: 0x01cfc000
        }
};
bootloader命令行参数仍然是：initrd root=/dev/bon/3 init=/linuxrc console=ttyS0
修改后的内核代码"fv/kernel_driver/kernel/kernel_yaffs.tar.gz"

15:41 2007-12-29
Linux，文件系统移植，yaffs，续
注：yaffs文件系统所涉及资料如无特殊说明均位于"fv/kernel_driver/filesystem/yaffs/"
1，格式化
---------
yaffs文件系统使用mkyaffsimage(mkyaffsimage.tgz)格式化：
[root@host fs]# ./mkyaffsimage yaffs yaffs.img
日志："mkyaffsimage_log"
2，烧写
-------
用vivi"load flash user x"烧写yaffs不成功，挂载yaffs分区(/dev/mtdblock/5)后，看不到yaffs.img的内容。
根据傅立叶"fft2410简易板.pdf"，用p28页mkyaffs工具烧写yaffs分区。mkyaffs位于"Download/cdrom光盘/arm_s3c2410_傅立叶/傅立叶提供烧写的文件/old/mkyaffs"，对mtd字符设备分区进行擦写！！！
bin/mkyaffs  -e /dev/mtd/5 yaffs.img
日志："mkyaffs_log"

17:02 2007-12-29
Linux，文件系统移植，yaffs，续（总结）
映像和工具位置："fv/image"
0，修改nand flash分区，见"14:18 2007-12-29"
1，首先烧写"vivi-cs8900 zImage_addbon root.cramfs"，重启进入linux；
2，启动后用nfs或ftp烧写root_qtopia.cramfs（烧写工具imagewrite），重启进入linux；
3，建立和烧写yaffs文件系统。见"15:41 2007-12-29"

待解决的问题：
============
1，modprobe: modprobe: Can't open dependencies file /lib/modules/2.4.18-rmk7-pxa1/modules.dep (No such file or directory)
2，SD卡46号中断没有注册成功，也没有报错。
3，修改脚本，在合适时候自动挂载yaffs。

