.LOG
12:31 2014-06-03
mailing list, virtualization
"Wei Liu"_email_"Discussion on libxl domain configuration synchronization"

Ian and Ian

There are many open questions regarding the design and implementation of this
new feature so I think it's worthwhile having a dedicated email thread to
discuss this before I write any new code.

The new mechanism will use the new JSON infrastructure so that application can
easily consume domain configuration.

### Exposed API

From API design point of view, what API should we expose to applications? We
seem to have agreed that a "retrieve" API is certainly necessary (let's name it
libxl_retrieve_domain_configuration for ease of discussion), while a "store" /
"save" is debatable.

If we set the rule that libxl application is not allowed to manipulate domain
configuration then "store" is not necessary.

### Implementation

Further more, how should we implement the new API?

My original thought is that the JSON version of domain configuration always
contains the up to date domain configuration, so that we can get hold of that
information even without the help of our library.

Ian J pointed out that this design is bogus. If I understand correctly,
he was referring to the fact that the most up to date information is
actually stored in xenstore. So his suggestion was that we make
libxl_retrieve_domain_configuration a) use JSON version as template, b)
pull in xenstore knob values to fill in the things that need to be
updated. I think this approach is appealing, if we agree on the design
"libxl-json" is completely private to libxl, that application should not
poke at it at all. I am now keen on taking this approach.

What knobs should libxl_retrieve_domain_configuration be looking at, domain
name, memory targets and devices etc. Memory targets are easy as they are only
some integer values.

As for devices, see next session.

### Device hotplug / unplug and half-baked state

When we build a domain, the devices presented in config file (later transform
into JSON) and the devices presented in xenstore (backend entries) are
consistent, otherwise we would have failed when building a domain.

Device hotplug and unplug are a bit trickier to handle.

Hotplug steps:
1. libxl__get_domain_configuration (this reads libxl-json file and parse
   it into libxl_domain_config struct).
2. add new device to JSON config
3. hotplug device
4. if hotplug success, libx__set_domain_configuration

If 3 fails, we may end up in a situation that some xenstore entries have been
written, but that device is not presented in JSON version of configuration. 4
can also fail when libxl tries to write libxl-json file. The steps and analyse
for device unplug are similar.

Later when we do libxl_retrieve_domain_configuration, the xenstore entries and
JSON config don't agree with each other. What should we do here? We cannot say
one view is more acurate then the other, given the fact that either 3 or 4 can
fail. Ian J suggested merging the two views, I agree with him.

### Summary

1. libxl_retrieve_domain_configuration is the only public API.
2. libxl_retrieve_domain_configuration should retrieve JSON version of
   domain configuration as template and update it according to xenstore
   entries.
3. libxl_retrieve_domain_configuration should be able to merge xenstore
   view and JSON config view of a domain.
4. JSON version gets saved when creating a domain.
5. JSON version gets updated when we do device hotplug / unplug. Other
   libxl functionalities will not touch it, unless they need to save
   some user provided values as template.

Thoughts?

Wei.

14:35 2014-06-03
software skill, network, ssh, ssh-add; github, error
"Error: Agent admitted failure to sign"

     ssh-add — adds private key identities to the authentication agent

DESCRIPTION
     ssh-add adds private key identities to the authentication agent, ssh-agent(1).  When run without
     arguments, it adds the files ~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa and ~/.ssh/identity.
     After loading a private key, ssh-add will try to load corresponding certificate information from
     the filename obtained by appending -cert.pub to the name of the private key file.  Alternative
     file names can be given on the command line.

reference: https://help.github.com/articles/error-agent-admitted-failure-to-sign

15:06 2014-06-03
software skill, network, ssh, commands
1, http://blog.urfix.com/25-ssh-commands-tricks/
Chinese Translation: http://blog.csdn.net/moubenmao_jun/article/details/10392061
2, ssh port
http://zhumeng8337797.blog.163.com/blog/static/100768914201172125444948/

15:38 2014-06-03
1, Chunyan
1), budget 4000$. 30$/day.

17:43 2014-06-03
xen aarch64
http://community.arm.com/groups/processors/blog/2014/03/28/virtualization-on-arm-with-xen

10:40 2014-06-04
GTD
0, 9:30-18:05

1, today
1), 10:40-11:40 compile and test snapshot.
2), 11:40-12:28 lunch
3), 12:28-13:08 rest
4), 40' nap
5), 40' personal stuff
6), 16:29-17:52 coding excise: assert

2, next
1), study about exit and wait.

13:10 2014-06-04
#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
#define _hidden __attribute__((visibility("hidden")))
#define _protected __attribute__((visibility("protected")))
#else
#define _hidden
#define _protected
#endif

14:35 2014-06-04
suse, doc, core dump
1, application core dump
http://www.novell.com/support/kb/doc.php?id=3054866
2, kernel core dump
http://www.novell.com/support/kb/doc.php?id=3374462

14:48 2014-06-04
snapshot
1, libxl idl
libxl_domain_snapshot = Struct("domain_snapshot",[
    ("name",          string),
    ("creation_time", uint64),
    ("save",          string, {'const': True}),
    ("external",      libxl_defbool),
    ("disks", Array(libxl_disk_snapshot, "num_disks")),
    ])

15:26 2014-06-04
software skill, man page
1, list man page path
# echo $MANPATH
/usr/lib64/mpi/gcc/openmpi/share/man:/usr/local/man:/usr/local/share/man:/usr/share/man:/opt/novell/man:/opt/novell/man

15:40 2014-06-04
mailing list, forum, virtualization
1, xen
http://www.gossamer-threads.com/lists/xen/devel/
2, qemu
http://www.mail-archive.com/qemu-devel@nongnu.org/
3, libvirt
http://www.mail-archive.com/libvir-list@redhat.com/

17:07 2014-06-04
software skill, editor, vim, insert TAB
http://stackoverflow.com/questions/4781070/how-to-insert-tab-character-when-expandtab-option-is-on-in-vim

You can use <CTRL-V><Tab> in "insert mode". In insert mode <CTRL-V> inserts a literal copy of your next character.

EDIT: As noted by feedbackloop, on windows you may need to press <CTRL-Q> rather than <CTRL-V>.

17:19 2014-06-04
software skill, build service, linkdiff
  -l, --link  (osc linkdiff): compare against the base revision of
                              the link

17:42 2014-06-04
posic, linux, exit
1, exit status 134

http://stackoverflow.com/questions/2862731/when-assert-fails-what-is-the-program-exit-code

Many UNIX systems will return 128 plus the signal number (SIGABRT is signal number 6) so you may get 134. Whatever you get, it should be documented by the C implementation.

2, exit status
http://www.gnu.org/software/libc/manual/html_node/Exit-Status.html#Exit-Status

When a program exits, it can return to the parent process a small amount of information about the cause of termination, using the exit status. This is a value between 0 and 255 that the exiting process passes as an argument to exit.

Normally you should use the exit status to report very broad information about success or failure. You can't provide a lot of detail about the reasons for the failure, and most parent processes would not want much detail anyway.

There are conventions for what sorts of status values certain programs should return. The most common convention is simply 0 for success and 1 for failure. Programs that perform comparison use a different convention: they use status 1 to indicate a mismatch, and status 2 to indicate an inability to compare. Your program should follow an existing convention if an existing convention makes sense for it.

A general convention reserves status values 128 and up for special purposes. In particular, the value 128 is used to indicate failure to execute another program in a subprocess. This convention is not universally obeyed, but it is a good idea to follow it in your programs.

Warning: Don't try to use the number of errors as the exit status. This is actually not very useful; a parent process would generally not care how many errors occurred. Worse than that, it does not work, because the status value is truncated to eight bits. Thus, if the program tried to report 256 errors, the parent would receive a report of 0 errors—that is, success.

For the same reason, it does not work to use the value of errno as the exit status—these can exceed 255.

Portability note: Some non-POSIX systems use different conventions for exit status values. For greater portability, you can use the macros EXIT_SUCCESS and EXIT_FAILURE for the conventional status value for success and failure, respectively. They are declared in the file stdlib.h.

— Macro: int EXIT_SUCCESS

    This macro can be used with the exit function to indicate successful program completion.

    On POSIX systems, the value of this macro is 0. On other systems, the value might be some other (possibly non-constant) integer expression.

— Macro: int EXIT_FAILURE

    This macro can be used with the exit function to indicate unsuccessful program completion in a general sense.

    On POSIX systems, the value of this macro is 1. On other systems, the value might be some other (possibly non-constant) integer expression. Other nonzero status values also indicate failures. Certain programs use different nonzero status values to indicate particular kinds of "non-success". For example, diff uses status value 1 to mean that the files are different, and 2 or more to mean that there was difficulty in opening the files.

Don't confuse a program's exit status with a process' termination status. There are lots of ways a process can terminate besides having its program finish. In the event that the process termination is caused by program termination (i.e., exit), though, the program's exit status becomes part of the process' termination status.

3, TODO
read check-TEST
libvirt/tests/Makefile

check-TESTS: $(TESTS)
	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
	srcdir=$(srcdir); export srcdir; \
	list=' $(TESTS) '; \
	$(am__tty_colors); \
	if test -n "$$list"; then \
	  for tst in $$list; do \
	    if test -f ./$$tst; then dir=./; \
	    elif test -f $$tst; then dir=; \
	    else dir="$(srcdir)/"; fi; \
	    if $(TESTS_ENVIRONMENT) $${dir}$$tst $(AM_TESTS_FD_REDIRECT); then \
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xpass=`expr $$xpass + 1`; \
		failed=`expr $$failed + 1`; \
		col=$$red; res=XPASS; \
	      ;; \
	      *) \
		col=$$grn; res=PASS; \
	      ;; \
	      esac; \
	    elif test $$? -ne 77; then \
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xfail=`expr $$xfail + 1`; \
		col=$$lgn; res=XFAIL; \
	      ;; \
	      *) \
		failed=`expr $$failed + 1`; \
		col=$$red; res=FAIL; \
	      ;; \
	      esac; \
	    else \
	      skip=`expr $$skip + 1`; \
	      col=$$blu; res=SKIP; \
	    fi; \
	    echo "$${col}$$res$${std}: $$tst"; \
	  done; \
	  if test "$$all" -eq 1; then \
	    tests="test"; \
	    All=""; \
	  else \
	    tests="tests"; \
	    All="All "; \
	  fi; \
	  if test "$$failed" -eq 0; then \
	    if test "$$xfail" -eq 0; then \
	      banner="$$All$$all $$tests passed"; \
	    else \
	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
	    fi; \
	  else \
	    if test "$$xpass" -eq 0; then \
	      banner="$$failed of $$all $$tests failed"; \
	    else \
	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
	    fi; \
	  fi; \
	  dashes="$$banner"; \
	  skipped=""; \
	  if test "$$skip" -ne 0; then \
	    if test "$$skip" -eq 1; then \
	      skipped="($$skip test was not run)"; \
	    else \
	      skipped="($$skip tests were not run)"; \
	    fi; \
	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$skipped"; \
	  fi; \
	  report=""; \
	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
	    report="Please report to $(PACKAGE_BUGREPORT)"; \
	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$report"; \
	  fi; \
	  dashes=`echo "$$dashes" | sed s/./=/g`; \
	  if test "$$failed" -eq 0; then \
	    col="$$grn"; \
	  else \
	    col="$$red"; \
	  fi; \
	  echo "$${col}$$dashes$${std}"; \
	  echo "$${col}$$banner$${std}"; \
	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
	  test -z "$$report" || echo "$${col}$$report$${std}"; \
	  echo "$${col}$$dashes$${std}"; \
	  test "$$failed" -eq 0; \
	else :; fi


18:21 2014-6-4
mailing list, arm, linaro
kevin hilman linaro reply to will deacon
> I had a go with this, but I couldn't seem to trigger any context tracking
> without forcing CONFIG_CONTEXT_TRACKING_FORCE=y. Does that mean we're
> missing something else?

No, it just means that you never hit the conditions to trigger full
NOHZ.  Using _FORCE is a good way to do that since it forces the context
tracking paths whether or not it's actually needed by full NOHZ.

