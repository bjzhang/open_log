.LOG
12:31 2014-06-03
mailing list, virtualization
1, "Wei Liu"_email_"Discussion on libxl domain configuration synchronization"

Ian and Ian

There are many open questions regarding the design and implementation of this
new feature so I think it's worthwhile having a dedicated email thread to
discuss this before I write any new code.

The new mechanism will use the new JSON infrastructure so that application can
easily consume domain configuration.

### Exposed API

From API design point of view, what API should we expose to applications? We
seem to have agreed that a "retrieve" API is certainly necessary (let's name it
libxl_retrieve_domain_configuration for ease of discussion), while a "store" /
"save" is debatable.

If we set the rule that libxl application is not allowed to manipulate domain
configuration then "store" is not necessary.

### Implementation

Further more, how should we implement the new API?

My original thought is that the JSON version of domain configuration always
contains the up to date domain configuration, so that we can get hold of that
information even without the help of our library.

Ian J pointed out that this design is bogus. If I understand correctly,
he was referring to the fact that the most up to date information is
actually stored in xenstore. So his suggestion was that we make
libxl_retrieve_domain_configuration a) use JSON version as template, b)
pull in xenstore knob values to fill in the things that need to be
updated. I think this approach is appealing, if we agree on the design
"libxl-json" is completely private to libxl, that application should not
poke at it at all. I am now keen on taking this approach.

What knobs should libxl_retrieve_domain_configuration be looking at, domain
name, memory targets and devices etc. Memory targets are easy as they are only
some integer values.

As for devices, see next session.

### Device hotplug / unplug and half-baked state

When we build a domain, the devices presented in config file (later transform
into JSON) and the devices presented in xenstore (backend entries) are
consistent, otherwise we would have failed when building a domain.

Device hotplug and unplug are a bit trickier to handle.

Hotplug steps:
1. libxl__get_domain_configuration (this reads libxl-json file and parse
   it into libxl_domain_config struct).
2. add new device to JSON config
3. hotplug device
4. if hotplug success, libx__set_domain_configuration

If 3 fails, we may end up in a situation that some xenstore entries have been
written, but that device is not presented in JSON version of configuration. 4
can also fail when libxl tries to write libxl-json file. The steps and analyse
for device unplug are similar.

Later when we do libxl_retrieve_domain_configuration, the xenstore entries and
JSON config don't agree with each other. What should we do here? We cannot say
one view is more acurate then the other, given the fact that either 3 or 4 can
fail. Ian J suggested merging the two views, I agree with him.

### Summary

1. libxl_retrieve_domain_configuration is the only public API.
2. libxl_retrieve_domain_configuration should retrieve JSON version of
   domain configuration as template and update it according to xenstore
   entries.
3. libxl_retrieve_domain_configuration should be able to merge xenstore
   view and JSON config view of a domain.
4. JSON version gets saved when creating a domain.
5. JSON version gets updated when we do device hotplug / unplug. Other
   libxl functionalities will not touch it, unless they need to save
   some user provided values as template.

Thoughts?

Wei.

2, (09:45 2014-06-05)
"Ian Jaskson"_email_"Re: [Xen-devel] Discussion on libxl domain configuration synchronization"
Wei Liu writes ("Discussion on libxl domain configuration synchronization"):
> ### Exposed API
> 
> From API design point of view, what API should we expose to
> applications? We seem to have agreed that a "retrieve" API is
> certainly necessary (let's name it
> libxl_retrieve_domain_configuration for ease of discussion), while a
> "store" / "save" is debatable.

Right.

> If we set the rule that libxl application is not allowed to manipulate domain
> configuration then "store" is not necessary.

Indeed.  If the libxl application wants to change the domain's setup
they must make individual calls to add and remove devices, increase
and decrease memory, etc.


> ### Summary
> 
> 1. libxl_retrieve_domain_configuration is the only public API.
> 2. libxl_retrieve_domain_configuration should retrieve JSON version of
>    domain configuration as template and update it according to xenstore
>    entries.
> 3. libxl_retrieve_domain_configuration should be able to merge xenstore
>    view and JSON config view of a domain.
> 4. JSON version gets saved when creating a domain.
> 5. JSON version gets updated when we do device hotplug / unplug. Other
>    libxl functionalities will not touch it, unless they need to save
>    some user provided values as template.

Right.


> ### Implementation
> 
> Further more, how should we implement the new API?
...
> Ian J pointed out that this design is bogus. If I understand
> correctly, he was referring to the fact that the most up to date
> information is actually stored in xenstore. So his suggestion was
> that we make libxl_retrieve_domain_configuration a) use JSON version
> as template, b) pull in xenstore knob values to fill in the things
> that need to be updated. I think this approach is appealing, if we
> agree on the design "libxl-json" is completely private to libxl,
> that application should not poke at it at all. I am now keen on
> taking this approach.

Exactly.  Yes, the JSON template would be completely private to libxl.

> What knobs should libxl_retrieve_domain_configuration be looking at,
> domain name, memory targets and devices etc. Memory targets are easy
> as they are only some integer values.

I think it should be sufficient to consider every function like
  libxl_do_something_to_existing_domain

Most (but not all) of these will do something which ought to be
reflected in the results from libxl_retrieve_domain_configuration.

There should be nothing else that modifies anything that shows up in
libxl_retrieve_domain_configuration.

> ### Device hotplug / unplug and half-baked state
...
> Device hotplug and unplug are a bit trickier to handle.
> 
> Hotplug steps:
> 1. libxl__get_domain_configuration (this reads libxl-json file and parse
>    it into libxl_domain_config struct).
> 2. add new device to JSON config
> 3. hotplug device
> 4. if hotplug success, libx__set_domain_configuration
> 
> If 3 fails, we may end up in a situation that some xenstore entries
> have been written, but that device is not presented in JSON version
> of configuration. 4 can also fail when libxl tries to write
> libxl-json file. The steps and analyse for device unplug are
> similar.


There are two ways to do this:


--------------------------------------------------

[ADD] JSON FIRST

This is what you have.

You tolerate as follows:

 * Devices present in xenstore may not be present in the JSON.

   Such devices cannot be reported properly by retrieve because
   in general it is not possible to synthesize a libxl device
   backend configuration out of what appears in xenstore.

   So such devices (which may or may not be working as far
   as the guest is concerned) must be reported with some kind
   of degraded information in retreive.

Conversely you add the new invariants:

 * Any device present in the JSON is also present in xenstore.

 * Any device which has any resources allocated to it in the host or
   guest has an entry in the JSON.

In retrieve, you can use the JSON as the primary reference.

I think the degraded reporting is undesirable.  Also there is a
locking problem - see below.

--------------------------------------------------

[ADD] XENSTORE FIRST

This is what I would suggest instead.

We establish the new invariant:

 * Any device which is present in xenstore has a corresponding entry
   in the JSON (where "corresponding" relates to the virtual device
   index - ie the guest-visible "name" - not the backend info).

I believe we already have this invariant:

 * Any device which has any resources allocated to it in the host or
   guest has an entry in the xenstore.

(There is a corrollary of these two which is that a device with
resources allocated must appear in the JSON.)

Conversely, we tolerate this:

 * Devices present in JSON may not be present in xenstore.
   Such a device is to be regarded as "not present" for all purposes.

To implement this, it is necessary to write out the new JSON before
updating xenstore.

In retrieve, you use xenstore as the primary reference.  The retrieve
function would look at xenstore and simply elide any entries which
were listed in the JSON but not in xenstore.

This also avoids having to take out the lock (there has to be a lock
on the stored JSON to prevent erronous concurrent updates) across the
actual device addition.

I think the retrieval merging algorithm works a bit like this:

  * Read JSON with list of stored device configs

  * Iterate over actual devices a la libxl_device_disk_list
    * For each device, look for corresponding configuration in
      JSON.
      * If no such configuration, print a warning and make one up
        along the lines of libxl_device_disk_getinfo
      * If there is such a configuration, use the JSON information
        except:
      * Check whether the backing device is empty, and if so
        delete the backing device from the JSON.
        (This is for cdroms; see below.)
    * Add resulting device config to new list of device configs

  * Replace stored list of device configs with new one

The effect is that the pre-libxl-defaulted configuration takes
precedence but that it is safe to write a JSON configuration
containing devices which are about to be added.

--------------------------------------------------


And now some loose ends:

For hot unplug, do the operations in the reverse order.  (The reverse
of whichever order we picked above, according to which design we have
chosen.)


CDROM insert/eject presents a problem.  I think it is not possible to
reliably convert the xenstore information back into the original
backend specification.  So we have a difficulty: if we switch straight
from cdrom-has-image-A to cdrom-has-image-B, we might end up with JSON
showing image X (= A or B) and xenstore implementing image Y (= B or
A).  Retrieve wouldn't know what to return.

I propose to solve this by adding a new invariant:

 * The actual disk backend device (in xenstore) for an "ejectable"
   device (currently, only cdroms) is always the same as the JSON;
 * EXCEPT that it is permissible for the JSON to specify a
   nonempty image while the xenstore information specifies "empty".

That allows us to always return correct data: if the xenstore backend
is empty, retrieve says empty.  Otherwise we use the JSON info.

To maintain this invariant we need to change libxl_cdrom_insert.  A
"swap", ie replacement of one image with another, has to be
implemented as first an eject and then an insert.  That way we never
have a situation where xenstore contains one set of non-empty
information and JSON another.


Thanks,
Ian.

3, (19:00 2014-06-05)
Hi, Wei and Ian

sorry if i am offtopic.
i am working on add snapshot support for libxl. currently, i write my code base
on Wei's lastest libxl json patch series. i could call
libxl_domain_snapshot_from_json and libxl_domain_snapshot_to_json during
retrieve and store domain snapshot configuration. it is very useful for me.
> "Ian Jaskson"_email_"Re: [Xen-devel] Discussion on libxl domain configuration synchronization"
> Wei Liu writes ("Discussion on libxl domain configuration synchronization"):
> > ### Exposed API
> >
> > From API design point of view, what API should we expose to
> > applications? We seem to have agreed that a "retrieve" API is
> > certainly necessary (let's name it
> > libxl_retrieve_domain_configuration for ease of discussion), while a
> > "store" / "save" is debatable.
>
> Right.
>
> > If we set the rule that libxl application is not allowed to manipulate domain
> > configuration then "store" is not necessary.
>
> Indeed.  If the libxl application wants to change the domain's setup
> they must make individual calls to add and remove devices, increase
> and decrease memory, etc.
doing the domain snasphot operation is something like "change the domain's setup",
it seems not a good idea to add snapshot infor into domain configuation.


14:35 2014-06-03
software skill, network, ssh, ssh-add; github, error
"Error: Agent admitted failure to sign"

     ssh-add — adds private key identities to the authentication agent

DESCRIPTION
     ssh-add adds private key identities to the authentication agent, ssh-agent(1).  When run without
     arguments, it adds the files ~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa and ~/.ssh/identity.
     After loading a private key, ssh-add will try to load corresponding certificate information from
     the filename obtained by appending -cert.pub to the name of the private key file.  Alternative
     file names can be given on the command line.

reference: https://help.github.com/articles/error-agent-admitted-failure-to-sign

15:06 2014-06-03
software skill, network, ssh, commands
1, http://blog.urfix.com/25-ssh-commands-tricks/
Chinese Translation: http://blog.csdn.net/moubenmao_jun/article/details/10392061
2, ssh port
http://zhumeng8337797.blog.163.com/blog/static/100768914201172125444948/

15:38 2014-06-03
1, Chunyan
1), budget 4000$. 30$/day.

17:43 2014-06-03
xen aarch64
http://community.arm.com/groups/processors/blog/2014/03/28/virtualization-on-arm-with-xen

10:40 2014-06-04
GTD
0, 9:30-18:05

1, today
1), 10:40-11:40 compile and test snapshot.
2), 11:40-12:28 lunch
3), 12:28-13:08 rest
4), 40' nap
5), 40' personal stuff
6), 16:29-17:52 coding excise: assert

13:10 2014-06-04
#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
#define _hidden __attribute__((visibility("hidden")))
#define _protected __attribute__((visibility("protected")))
#else
#define _hidden
#define _protected
#endif

14:35 2014-06-04
suse, doc, core dump
1, application core dump
http://www.novell.com/support/kb/doc.php?id=3054866
2, kernel core dump
http://www.novell.com/support/kb/doc.php?id=3374462

14:48 2014-06-04
snapshot
1, libxl idl
libxl_domain_snapshot = Struct("domain_snapshot",[
    ("name",          string),
    ("creation_time", uint64),
    ("save",          string, {'const': True}),
    ("external",      libxl_defbool),
    ("disks", Array(libxl_disk_snapshot, "num_disks")),
    ])

15:26 2014-06-04
software skill, man page
1, list man page path
# echo $MANPATH
/usr/lib64/mpi/gcc/openmpi/share/man:/usr/local/man:/usr/local/share/man:/usr/share/man:/opt/novell/man:/opt/novell/man

15:40 2014-06-04
(16:41 2014-06-05)
mailing list, forum, virtualization
1, xen
http://www.gossamer-threads.com/lists/xen/devel/
2, qemu
http://www.mail-archive.com/qemu-devel@nongnu.org/
3, libvirt
http://www.mail-archive.com/libvir-list@redhat.com/
4, easy to search
markmail.org

17:07 2014-06-04
software skill, editor, vim, insert TAB
http://stackoverflow.com/questions/4781070/how-to-insert-tab-character-when-expandtab-option-is-on-in-vim

You can use <CTRL-V><Tab> in "insert mode". In insert mode <CTRL-V> inserts a literal copy of your next character.

EDIT: As noted by feedbackloop, on windows you may need to press <CTRL-Q> rather than <CTRL-V>.

17:19 2014-06-04
software skill, build service, linkdiff
  -l, --link  (osc linkdiff): compare against the base revision of
                              the link

17:42 2014-06-04
posic, linux, exit
1, exit status 134

http://stackoverflow.com/questions/2862731/when-assert-fails-what-is-the-program-exit-code

Many UNIX systems will return 128 plus the signal number (SIGABRT is signal number 6) so you may get 134. Whatever you get, it should be documented by the C implementation.

2, exit status
http://www.gnu.org/software/libc/manual/html_node/Exit-Status.html#Exit-Status

When a program exits, it can return to the parent process a small amount of information about the cause of termination, using the exit status. This is a value between 0 and 255 that the exiting process passes as an argument to exit.

Normally you should use the exit status to report very broad information about success or failure. You can't provide a lot of detail about the reasons for the failure, and most parent processes would not want much detail anyway.

There are conventions for what sorts of status values certain programs should return. The most common convention is simply 0 for success and 1 for failure. Programs that perform comparison use a different convention: they use status 1 to indicate a mismatch, and status 2 to indicate an inability to compare. Your program should follow an existing convention if an existing convention makes sense for it.

A general convention reserves status values 128 and up for special purposes. In particular, the value 128 is used to indicate failure to execute another program in a subprocess. This convention is not universally obeyed, but it is a good idea to follow it in your programs.

Warning: Don't try to use the number of errors as the exit status. This is actually not very useful; a parent process would generally not care how many errors occurred. Worse than that, it does not work, because the status value is truncated to eight bits. Thus, if the program tried to report 256 errors, the parent would receive a report of 0 errors—that is, success.

For the same reason, it does not work to use the value of errno as the exit status—these can exceed 255.

Portability note: Some non-POSIX systems use different conventions for exit status values. For greater portability, you can use the macros EXIT_SUCCESS and EXIT_FAILURE for the conventional status value for success and failure, respectively. They are declared in the file stdlib.h.

— Macro: int EXIT_SUCCESS

    This macro can be used with the exit function to indicate successful program completion.

    On POSIX systems, the value of this macro is 0. On other systems, the value might be some other (possibly non-constant) integer expression.

— Macro: int EXIT_FAILURE

    This macro can be used with the exit function to indicate unsuccessful program completion in a general sense.

    On POSIX systems, the value of this macro is 1. On other systems, the value might be some other (possibly non-constant) integer expression. Other nonzero status values also indicate failures. Certain programs use different nonzero status values to indicate particular kinds of "non-success". For example, diff uses status value 1 to mean that the files are different, and 2 or more to mean that there was difficulty in opening the files.

Don't confuse a program's exit status with a process' termination status. There are lots of ways a process can terminate besides having its program finish. In the event that the process termination is caused by program termination (i.e., exit), though, the program's exit status becomes part of the process' termination status.

3, TODO
read check-TEST
libvirt/tests/Makefile

check-TESTS: $(TESTS)
	@failed=0; all=0; xfail=0; xpass=0; skip=0; \
	srcdir=$(srcdir); export srcdir; \
	list=' $(TESTS) '; \
	$(am__tty_colors); \
	if test -n "$$list"; then \
	  for tst in $$list; do \
	    if test -f ./$$tst; then dir=./; \
	    elif test -f $$tst; then dir=; \
	    else dir="$(srcdir)/"; fi; \
	    if $(TESTS_ENVIRONMENT) $${dir}$$tst $(AM_TESTS_FD_REDIRECT); then \
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xpass=`expr $$xpass + 1`; \
		failed=`expr $$failed + 1`; \
		col=$$red; res=XPASS; \
	      ;; \
	      *) \
		col=$$grn; res=PASS; \
	      ;; \
	      esac; \
	    elif test $$? -ne 77; then \
	      all=`expr $$all + 1`; \
	      case " $(XFAIL_TESTS) " in \
	      *[\ \	]$$tst[\ \	]*) \
		xfail=`expr $$xfail + 1`; \
		col=$$lgn; res=XFAIL; \
	      ;; \
	      *) \
		failed=`expr $$failed + 1`; \
		col=$$red; res=FAIL; \
	      ;; \
	      esac; \
	    else \
	      skip=`expr $$skip + 1`; \
	      col=$$blu; res=SKIP; \
	    fi; \
	    echo "$${col}$$res$${std}: $$tst"; \
	  done; \
	  if test "$$all" -eq 1; then \
	    tests="test"; \
	    All=""; \
	  else \
	    tests="tests"; \
	    All="All "; \
	  fi; \
	  if test "$$failed" -eq 0; then \
	    if test "$$xfail" -eq 0; then \
	      banner="$$All$$all $$tests passed"; \
	    else \
	      if test "$$xfail" -eq 1; then failures=failure; else failures=failures; fi; \
	      banner="$$All$$all $$tests behaved as expected ($$xfail expected $$failures)"; \
	    fi; \
	  else \
	    if test "$$xpass" -eq 0; then \
	      banner="$$failed of $$all $$tests failed"; \
	    else \
	      if test "$$xpass" -eq 1; then passes=pass; else passes=passes; fi; \
	      banner="$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)"; \
	    fi; \
	  fi; \
	  dashes="$$banner"; \
	  skipped=""; \
	  if test "$$skip" -ne 0; then \
	    if test "$$skip" -eq 1; then \
	      skipped="($$skip test was not run)"; \
	    else \
	      skipped="($$skip tests were not run)"; \
	    fi; \
	    test `echo "$$skipped" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$skipped"; \
	  fi; \
	  report=""; \
	  if test "$$failed" -ne 0 && test -n "$(PACKAGE_BUGREPORT)"; then \
	    report="Please report to $(PACKAGE_BUGREPORT)"; \
	    test `echo "$$report" | wc -c` -le `echo "$$banner" | wc -c` || \
	      dashes="$$report"; \
	  fi; \
	  dashes=`echo "$$dashes" | sed s/./=/g`; \
	  if test "$$failed" -eq 0; then \
	    col="$$grn"; \
	  else \
	    col="$$red"; \
	  fi; \
	  echo "$${col}$$dashes$${std}"; \
	  echo "$${col}$$banner$${std}"; \
	  test -z "$$skipped" || echo "$${col}$$skipped$${std}"; \
	  test -z "$$report" || echo "$${col}$$report$${std}"; \
	  echo "$${col}$$dashes$${std}"; \
	  test "$$failed" -eq 0; \
	else :; fi

18:21 2014-6-4
mailing list, arm, linaro
kevin hilman linaro reply to will deacon
> I had a go with this, but I couldn't seem to trigger any context tracking
> without forcing CONFIG_CONTEXT_TRACKING_FORCE=y. Does that mean we're
> missing something else?

No, it just means that you never hit the conditions to trigger full
NOHZ.  Using _FORCE is a good way to do that since it forces the context
tracking paths whether or not it's actually needed by full NOHZ.

09:26 2014-06-05
Jason_email_"[devel] Welcome Juergen Gross"

Hi everyone,

I'm pleased to announce that Juergen Gross has joined SUSE this week as
a member of the Virtualization Team. Juergen will be working with the kernel and xen communities to add features to and increase the stability
of the PVOPS xen kernel.

I'd ask each of you to welcome Juergen to the company and to offer a
helping hand to him whenever possible. Thanks!

Jason


--
Jason Douglas
Sr. Engineering Manager
Virtualization Team
SUSE
jdouglas@suse.com
+1-801-861-1649

09:31 2014-06-05
virtualization, snapshot, GSoC
> Hi there,
>
> I am confused about something here.
> We have this structs.
>
> 1), libxl_snapshot
> store a disk snapshot information, it is used by disk snapshot create
> and delete.
> libxl_disk_snapshot = Struct("disk_snapshot",[
>     ("device",        string),
>     ("name",          string),
>     ("file",          string),
>     ("format",        string),
>     ])
>
> device: device name to snapshot. e.g. sda, hda...
> name: snapshot name given by user. it will the be same name as domain snapshot
> name.
>                                          <---HERE (1
> the following parameter is only useful for external snapshot.
> file: external snapshot file.
> format: the format of external snapshot file
>
> 2), libxl_domain_snapshot
> store domain snapshot information which store in the path shown above. i add
> some api for create, delete and list these information.
> libxl_domain_snapshot = Struct("domain_snapshot",[
>     ("name",          string),
>     ("creation_time", uint64),
>     ("save",          string),
>     ("disks", Array(libxl_disk_snapshot, "num_disks")),
>                        <---HERE (2
>     ])
> name: snapshot name given by user. if user do not provide the name, it will be
> the epoch seconds.
> creation_time: the epoch seconds.
> save: the memory save file for this snapshot.
> disks: store the disk snapshot information associate with this domain
>
> question
> --------------
> How should I deal with domains with multiple disks?Could I assume that
> there is only one disk?
no.
for domain snapshot with internal disk snapshot: savevm/delvm/loadvm will also
do disk snapshot.
for domain snapshot with external disk, the follow api will take disk snapshot
while libvirt will provide the disk list from snapshot.
reference libvirt qemu driver qemuDomainSnapshotCreateDiskActive for how it
works in libxl driver, and qemuMonitorJSONDiskSnapshot show add the disk into
qmp transaction.s

/* create disk snapshot with qmp transaction
 */
int libxl_disk_snapshot_create(libxl_ctx *ctx, int domid,
                               libxl_disk_snapshot *snapshot, int nb);

/* delete disk snapshot with qmp delete(TODO) one by one
 */
int libxl_disk_snapshot_delete(libxl_ctx *ctx, int domid,
                               libxl_disk_snapshot *snapshot, int nb);

> Just some clarification because in the libxl_domain_snapshot we have
> an array of libxl_disk_snapshot
> which somehow suggest you are taking care of domains with multiple disks.
yes, see my comments above.
> 
> Regards,
> David.

09:32 2014-06-05
GTD
0, 9:10-19:20

1, today
1), 9:32-11:35 16:01-17:20 snapshot testing.
2), 11:35-12:30 lunch
3), 12:54-15:42 nap 20' read LWN weekly edition.
4), 15:42 16:01 virsh network command. see"16:01 2014-06-05"
5), 18:29-18:57 reply David kiarie email. see"09:31 2014-06-05"
6), 19:00-19:13 try to write email to Wei Liu and Ian Jackson. i am not sure whether i need it or not. see"12:31 2014-06-03"3.

2, next
1), study daemon
1), study about exit and wait.
2), study about socket.

09:32 2014-06-05
snapshot
1, plan
1), test snapshot with script.
2), write code for external disk snapshot.
3), TODO
(1), only support snapshot all disks?
it will easy to implement but is different from libvirt.
(2), do i need "info snapshots"?
i would be useful for checking before snapshot operations.

2, do
1), done: recheck create and delete function.
2), done: recheck list and revert function.

12:53 2014-06-05
software skill, vnc, openstack, noVNC
http://www.vpsee.com/2013/07/integrating-novnc-with-our-vm-control-panel/
使用 noVNC 开发 Web 虚拟机控制台

http://kanaka.github.io/noVNC/noVNC/vnc.html
http://kanaka.github.io/noVNC/

16:01 2014-06-05
software skill, network, virsh, net
# virsh net-dumpxml nat
<network>
  <name>nat</name>
  <uuid>cb7b045a-3cd2-459e-8625-a754b7a60e5a</uuid>
  <forward mode='nat'>
    <nat>
      <port start='1024' end='65535'/>
    </nat>
  </forward>
  <bridge name='virbr0' stp='on' delay='0'/>
  <mac address='52:54:00:5c:aa:2d'/>
  <domain name='nat'/>
  <ip address='192.168.100.1' netmask='255.255.255.0'>
    <dhcp>
      <range start='192.168.100.128' end='192.168.100.254'/>
    </dhcp>
  </ip>
</network>

# virsh net-info nat
Name:           nat
UUID:           cb7b045a-3cd2-459e-8625-a754b7a60e5a
Active:         yes
Persistent:     yes
Autostart:      yes
Bridge:         virbr0

