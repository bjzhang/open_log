
18:08 2012-10-08
fate, virtualization, libvirt, xen
1, disk image lock
copy from https://fate.suse.com/313599
The virtual machine lock manager is a daemon which will ensure that a virtual machine's disk image cannot be written to by two QEMU/KVM processes at the same time. It provides protection against starting the same virtual machine twice, or adding the same disk to two different virtual machines. From our point view, this feature is a must to have in every production environment.

To enable this functionality the following packages are needed: kvm, qemu, libvirt and sanlock. According to the sles11 sp2 Release Notes http://www.novell.com/linux/releasenotes/x86_64/SUSE-SLES/11-SP2/ SANLOCK is not part of it. It would be very helpfull to include this sanlock into Sles11 SP2. To make make sure sanlock is working, libvirt must be updated version 0.9.9 (planned version 0.9.6) btw. sanlock is already available for RHEL6 Additional information: http://fedoraproject.org/wiki/Features/VirtLockManager http://libvirt.org/locking.html

2,
https://fate.suse.com/313519
Avaya is switching from RH to SLES because we support Xen. This revenue stream is approx 400,000USD per year.

18:23 2012-10-08
GTD
2, next
1), opensuse arm: create MK802 new image. then reply "[opensuse-arm] Cubieboard".

13:08 2012-10-09
company, career, hire
"The Attachmate Group News <Novell.Send-As@Attachmate.com>"_email_"We're Hiring!  Refer a New Hire, Reap the Reward!"_20121009_0556
Bookmark these links and visit often!
Internal Career Site https://mynetiqcareers.silkroad.com/netiqint/Home.html
Employee Referral Policy https://mytagcareers.silkroad.com/netiqint/About_Us.html

18:19 2012-10-10
(13:07 2012-10-11)
opensuse, arm, opensuse 12.2, MK802, upload MK802 image to miniand; markdown example
1, picture
log/novell/opensuse_arm/picture
2, sftp
bamvor@dump.miniand.com
password: v5v4ZQvmRTCqbf8t
3, message(ref markdown convert and example, see"13:36 2012-10-11")
Title: Install Opensuse 12.2 with xfce

here is the lastest opensuse arm on MK802 -- opensuse 12.2 -- with xfce. The current version of the images support Wifi, USB Bluetooth, USB audio, USB network adaptor.

 Download
--------------
[1GB 720p](http://dl.miniand.com/bamvor/opensuse_arm_1010__12_2__for_MK802_forum__xfce4_ok.7z) - 739MB. md5sum 423e81a198a87520ada9e33d27289e72


install and usage
-----------------------
* pls reference [Install Ubuntu Linux 12.04 - now including Droidmote](https://www.miniand.com/forums/forums/2/topics/1)
* you could write my 4G image to larger tf card through [makeSD.sh](git://github.com/cnxsoft/a10-tools.git)

detailed features
-----------------------
* 720p hdmi output
* start droidmote after x11 bootup with port 2303 and password 1234.
* kernel config
    - enable uinput
    - enable the following use network adaptor in kernel config: AX8817X, QF9700, CDCETHER, DM9601, SMSC95XX, NET1080, ZAURUS. test qf9700 and smsc95xx successful.
    - enable usb audio. test pass with CM108.
    - enable usb bluetooth.

Changelog
---------------
v1 - 2012-10-11
Initial version.

Known issues
-------------------
Hardware video decoding and 3D OpenGL isn't available.

![1](http://dl.miniand.com/bamvor/picture/1_login.jpg)
![2](http://dl.miniand.com/bamvor/picture/2_xfce_boot.jpg)
![3](http://dl.miniand.com/bamvor/picture/3_welcome_from_abiword.jpg)

4, url
https://www.miniand.com/forums/forums/development/topics/install-opensuse-12-2-with-xfce

11:34 2012-10-11
virtualization, libvirt, lock
1, Chunyan email
Hi, Bamvor,

I've read your lock patch and qemu lock functions. I have some questions:
1. Our lock patch functions are all similar to qemu functions, I think it should be OK since qemu is working. Some other functions in qemu but not in libxl like qemuDomainObjRestoreJob(). (will never used in libxl?)
2. This is the first time I'm digging in the job series code, seems the benefit of these functions is only to coordinate different jobs (when we try to do a job, it will check if there are other jobs doing and check if this job can be co-working with those jobs), right?
But "virsh list" doesn't use the job code, so live migration and "virsh list" co-working problem could not be solved by this lock mechanism. Its migration code lock driver and vm at the perform phase, and virsh list too, I doubt qemu can be virsh list and migration same time? Never tested.

Thanks,
Chunyan

2, reply
> Hi, Bamvor,
>
> I've read your lock patch and qemu lock functions. I have some questions:
> 1. Our lock patch functions are all similar to qemu functions, I think it
> should be OK since qemu is working.
yes, i think so.
> Some other functions in qemu but not in libxl like qemuDomainObjRestoreJob().
> (will never used in libxl?)
the RestoreJob will be used in libxl if i want to recover job in the libxlReconnectDomain. but i guess it is not very important for now.
> 2. This is the first time I'm digging in the job series code, seems the
> benefit of these functions is only to coordinate different jobs (when we try
> to do a job, it will check if there are other jobs doing and check if this
> job can be co-working with those jobs), right?
yes. coordinate the api which maybe change the vm state.
> But "virsh list" doesn't use the job code, so live migration and "virsh list"
> co-working problem could not be solved by this lock mechanism. Its migration
> code lock driver and vm at the perform phase, and virsh list too,
yes, because the "virsh list" only query the state, there is no need to protect. so do the qemu.
> I doubt qemu can be virsh list and migration same time? Never tested.
i test and it work.

>
> Thanks,
> Chunyan
>

12:53 2012-10-11
virtualization, xen, meeting
"Lars Kurth <lars.kurth@xen.org>"_email_"[XenARM] Xen Day Barcelona 2012, Nov 8th @ LinuxCon"_20121009_2116
http://www.xen.org/community/events/xendaybarcelona2012.html
Topics that will be covered include:
* Virtualization in the Cloud: Featuring Xen and XCP
* Xen on ARM Cortex A15
* Xen 4.2 and xl
* Xen Benchmarks
* Meet the Xen Developers

13:36 2012-10-11
software, skill, markdown
1, example
1), http://daringfireball.net/projects/markdown/basics
2),

2, tools
1), pandoc
2), sundown
https://github.com/vmg/sundown

16:36 2012-10-11
suse, release notes
"Karl Eichwalder <ke@suse.de>"_email_"[Research] Providing SLE 11 SP3 Release Notes"_20121011_1541
Here are some notes how you can help with the Release Notes.

Technical Background Info
=========================

Since SLE 11 SP2 we mostly create and maintain release notes entries in
FATE.  The "Editor" tab features an "Release Notes" sub-tab, where you
are expected to write the text: just Title, Challenge (optional), and
Solution.

Then select a "ReleaseNotes" category from the "Internal" sub-tab.  As
long as there is no ReleaseNotes category assigned, the entry does not
appear in the final release notes document.

We have FATE export scripts (written by Jürgen Weigert and Thomas
Schraitle) that merge FATE entries that are set to "Done", into the
traditional docbook document.  From the docbook document we create the
output format for yast, html, and pdf using the standard docbook xsl
style-sheets.

Thus far, in https://svn.suse.de/svn/doc/trunk we have

release-notes-sdk/
release-notes-sled/
release-notes-sles/         (also used for sles-for-vmware)
release-notes-suse-cloud/


Writing Texts
=============

Everybody is encouraged to help with writing such texts (drafts).  In
the end, the so-called stakeholders are responsible for providing the
texts.  Stakeholders are our partners (IBM is already pretty good with
providing input for their features), project and engineering managers,
and the developer.  Often even the product manager will lend a helping
hand in one or the other way ;)

If you do not feel comfortable with writing draft texts in the release
notes tab, at least try to summarize the implemented feature somehow and
either add this summary as a regular comment or add it to the
"Documentation Impact" field in the "Misc" sub-tab.

The assigned documentation editor (that's mostly me these days) cannot
wade through all the comments of a feature and write the release notes
snippets on his own.  I often simply do not actually understand what a
certain feature might be about, or it would take too much time to study
the long list of comments to get a clue about it.  Thus your help is
very much needed!


Challenges
==========

Some features apply for more than one SP and we will update the SP2
release notes document in parallel with the SP3 document for several
months.  This means you must write the entry in a way that it fits for
both SPs.

Release notes categories are often unclear.  If in doubt, select
ReleaseNotes:Features:Other (or, once available, ReleaseNotes:Misc).


Discussion
==========

This is how it looks to me.  I'd like to hear comments, either "in
general" or about some details.  Matthias, Gerald, or Jürgen, please add
what is needed!

--
Karl Eichwalder                              SUSE LINUX Products GmbH
R&D / Documentation                          Maxfeldstraße 5
                                             90409 Nürnberg, Germany
GF: Jeff Hawn, Jennifer Guild, Felix Imendörffer, HRB 16746 (AG Nürnberg)

17:31 2012-10-11
1, configure command in build service
./configure --host=x86_64-suse-linux-gnu --build=x86_64-suse-linux-gnu --target=x86_64-suse-linux --program-prefix= --prefix=/usr --exec-prefix=/usr --bindir=/usr/bin --sbindir=/usr/sbin --sysconfdir=/etc --datadir=/usr/share --includedir=/usr/include --libdir=/usr/lib64 --libexecdir=/usr/lib64 --localstatedir=/var --sharedstatedir=/usr/com --mandir=/usr/share/man --infodir=/usr/share/info --disable-static --with-pic --without-phyp --without-hyperv --without-numad --without-netcf --without-netcontrol --without-udev --without-macvtap --without-dtrace --without-libpcap --without-sanlock --without-driver-modules --libexecdir=/usr/lib64/libvirt --with-qemu-user=root --with-qemu-group=root --with-init_script=redhat ac_cv_path_MODPROBE=/sbin/modprobe ac_cv_path_UDEVADM=/sbin/udevadm ac_cv_path_SHOWMOUNT=/usr/sbin/showmount

2, commit log
1), Introduce a lock for libxl long-running api
This patch introduce a lock for protecting the long-running
api (save, dump, migration and so on) from the other api
which may update the status of the virtual machine.

Signed-off-by: Bamvor Jian Zhang <bjzhang@suse.com>

2), Add lock for libxl api

Add long-running jobs for save, dump. Add normal job for the
api maybe modify the domain.

Signed-off-by: Bamvor Jian Zhang <bjzhang@suse.com>

3, 0913之后似乎修改过我这个patch，但是忘记在哪里修改的了。

4, make check && make syntax-check

5, write cover letter, confirm format. send patch to upstream

6, check Chunyan current patch.
(17:47 2012-10-12)
discuss with Chunyan: migration still fail while "virsh list" execute. I need to compare this patch with my former patch.

23:15 2012-10-11
virtualization, libvirt, libxl, lock; git, send patch
git format-patch --cover-letter master
git send-email --cover-letter --no-chain-reply-to --annotate --to libvir-list@redhat.com --cc eblake@redhat.com --cc jfehlig@suse.com --cc cyliu@suse.com 000*.patch

12:32 2012-10-12
hackweek, security, Shawn Chang
 canary: 每个函数的堆栈的插入4byte做检查。甚至打乱系统的堆栈顺序。
kernel: 如果内核进程hang，先睡眠三十秒。这样攻击者至少需要1024x30=512小时。

17:48 2012-10-12
GTD
2, next
1), lock patch
(1), check Chunyan patch.
(2), add restore job.
(3), waiting for libvirt upstream response.

17:59 2012-10-12
opensource, China, open hardware
http://blug.chinalug.org/
http://www.open-drone.org/

13:46 2012-10-15
GTD
0, 13:46

1, today
1), check the mail.
2), work report. see"15:57 2012-10-15"
3), read Chunyan laster migration patch. see"16:11 2012-10-15"

13:54 2012-10-15
mailing list, opensuse arm
1, execute virsh connect through normal user with polkit.
jfehlig_email_"Re: [opensuse-virtual] outdated docs, kvm/libvirtd auth changes in 12.2"_20121012_1733
Olaf Hering wrote:
> While reading through the KVM documentation I noticed that the current
> version of openSuSE does not have the referenced polkit-auth anymore:
>
> http://doc.opensuse.org/documentation/html/openSUSE/opensuse-kvm/cha.libvirt.connect.html
>

Yeah, that applies to SLES11, but not for openSUSE since 11.2 or so.  I
created a comment about this outdated info as per the feedback
instructions in "About This Manual".

> Has polkit-auth a replacement in 12.2?
>

polkit-auth is part of the PolicyKit package, which was replaced with
polkit in openSUSE long ago.  Better documentation for using polkit is here

http://wiki.libvirt.org/page/SSHPolicyKitSetup

> For my own testing with libguestfs all it takes is to add the user to the
> group 'kvm' for the attach-method 'libvirt', so I dont really need
> polkit-auth.
>

Your normal user can do stuff like 'virsh -c qemu+ssh:///system' without
configuring polkit as per the libvirt wiki?  On my 12.2 machine, I must
add the following to authenticate to the system URI (even when user
jfehlig is a member of libvirt, kvm, and qemu groups)

# cat /etc/polkit-1/localauthority/50-local.d/50-libvirt-remote-access.pkla
[Remote libvirt SSH access]
 Identity=unix-user:jfehlig
 Action=org.libvirt.unix.manage
 ResultAny=yes
 ResultInactive=yes
 ResultActive=yes

14:11 2012-10-15
Linux, development, 第七届中国Linux内核开发者大会
KERNEL会议视频：http://www.tudou.com/home/item_u21107135s0p1.html

14:27 2012-10-15
1, bamvor_email_20121012_1837
I make a image for Allwinnner A10 MK802 dongle. and I upload it to MK802 forum(https://www.miniand.com/forums/forums/development/topics/install-opensuse-12-2-with-xfce). i not familiar with kiwi, so it is not available on build service.
It should be work with other A10 board with 1G memory and HDMI output.
besides it is a 3.0.38+ kernel(get it from github) in my image, it is possible to generate an official image for A10 borad?
2, "Alexander Graf <agraf@suse.de>"_email_20121012_2347
Yes, definitely!
I will need to write up some slides on how to get your own board supported for the openSUSE Conference next week anyways. Once I have those done, I can easily send them over. It's really not all that complicated :).
3, "Kai Dupke <kdupke@suse.com>"_email_20121012_2354
> I will need to write up some slides on how to get your own board supported for the openSUSE Conference next week anyways. Once I have those done, I can easily send them over. It's really not all that complicated :).
That will be cool!

15:53 2012-10-15
virtualization, xen, kvm, libvirt, HA
1, Jfehlig_email_20121012_2317, HA on xen
The xen-tools package contains the userspace pieces for remus, but for
SLES at least we don't have the required sch_plug driver.  openSUSE does
have the driver, so in theory you could use remus with openSUSE12.2.
More info on Xen and remus: http://wiki.xen.org/xenwiki/Remus

The kemari project noted by Andreas was also made to work with Xen, but
I haven't seen any activity wrt Xen+kemari in years.

FYI, some related fates

#311266: Add Kemari support (dynamic VM failover)
#306445: Stateful fail-over for Xen guests

> is it a something old ? no more maintained  ?
> did you have done any evaluation on it ?
>

AFAIK, it is still maintained.  Support for remus was added to the new
libxl toolstack in Xen, so folks are still working on it.

I experimented with remus long ago (SLES11 GA timeframe??), but had
problems getting it configured/working and never did follow through.
Chunyan, did you try remus in the early stages of SP2 development?
Perhaps it was Dong Yang that had done some investigation, but I doubt
there is any written report on his findings.

2, Chunyan
>I experimented with remus long ago (SLES11 GA timeframe??), but had
>problems getting it configured/working and never did follow through.
>Chunyan, did you try remus in the early stages of SP2 development?
Not yet. I did some experiments together with Dong Yang trying to make it work on SLES 11 SP1, but haven't touch it for a long time since then.

3, Remus
Transparent high availability ("Fault Tolerance") for Xen VMs
Remus provides transparent, comprehensive high availability to ordinary virtual machines running on the Xen virtual machine monitor. It does this by maintaining a completely up-to-date copy of a running VM on a backup server, which automatically activates if the primary server fails. Key features:
The backup VM is an exact copy of the primary VM. When failure happens, it continues running on the backup host as if failure had never occurred.
The backup is completely up-to-date. Even active TCP sessions are maintained without interruption.
Protection is transparent. Existing guests can be protected without modifying them in any way.
http://wiki.xen.org/xenwiki/Remus

15:57 2012-10-15
work report - week 41
1, [devel-server] work report - week 41
1), test and discuss with Chunyan about lock in libxl.
and send this patch to upstream for 1st time review.
2), upload a opensuse12.2 image to forum for Allwinner A10 based board -- MK802.
https://www.miniand.com/forums/forums/development/topics/install-opensuse-12-2-with-xfce

16:11 2012-10-15
virtualization
1, there is no lock if libxlVmStart fail. i guess it necessary to get driver and obj lock even if mlibxlVmStart fail.
same status for libxl_domain_suspend

10:07 2012-10-16
GTD
0, 9:50

1, today
1), 10:13 personal stuff.
2), 11:30 libxl lock improvement. see"10:43 2012-10-16"
3), 30' discuss with Jiaju about Arm Linux distribution.
4), check the mail.

2, next
1), 看看北京开源软件和硬件"17:59 2012-10-12".
2), download the video, "14:11 2012-10-15".

10:43 2012-10-16
virtualization, libvirt, migration, libxl(xenlight), lock, cont22, improve the lock according to Chunyan's suggestion
1, plan
1), add RestoreJob and SetJobPhase.

2, about qemuProcessRecoverJob
如果migration进行中libvirtd restart, libxl的migration还会继续么? 从代码看qemu会继续.

3, (09:58 2012-10-17)
plan
1), finish restore and set job phase with test code.
2), build libvirt with my lock and Chunyan migration patch. test the result while libvirtd restart.

4, notes
1), 还是想不明白, restore是怎么做的. qemuDomainObjRestoreJob是从virDomainObjPtr privateData得到的job状态. 这个东西为什么重启之后仍然有呢? 好吧, 先假设是有的.
2), payload

qemuProcessReconnectAll/libxlReconnectDomains
virHashForEach
domainCreateXML -> virDomainAssignDef -> virHashAddEntry

5, (13:41 2012-10-18)


3, \TODO
1), define enum libxlMigrationJobPhase

09:52 2012-10-17
GTD
0, 9:30

1, today
1), 9:58 libxl lock improvement. see"10:43 2012-10-16"3.

13:37 2012-10-18
GTD
0, 12:40

1, today
1), 1h lunch and rest.
2), 13:45 libxl lock improvement. see"10:43 2012-10-16"5.

13:48 2012-10-18
arm, server, quad core Cortex-A9
""Bernhard M. Wiedemann" <bernhardout@lsmod.de>"_email
http://www.phoronix.com/scan.php?page=article&item=calxeda_ubuntu_pre&num=1
quad core Cortex-A9 with 4MB L2 cache, sata, pcie, 10g ethernet.

8:01 2012-10-19
company, virtualization, suse, xen, regular meeting: US / China Virtualization Sync, meeting
1, Jim openstack conference.
2, 10/16 presantation.
1), support xen, kvm, hyvisor.
sle12. addon for sle12: ?
xen, kvm compare.
move from xen to kvm?
2), Lin Ma
kvm kernel is fully upstream kernel, it is easy for customer.
3, Lin Ma
1), review qemu new feature.
2), Jason: join to kvm meeting.
4, Bo Yang
5, jason
1), sp3 still use xend or xenlight.

11:21 2012-10-19
virtualization, libvirt, xenlight, add libxl api, discuss with Chunyan about next step works
1, Chunyan_email_20121018_1758

Following is a missing API list (comparing qemu and libxl driver in libvirt, in which those with ** ahead are missing APIs compared with xend.) Each API description can be found here:
http://libvirt.org/hvsupport.html
IMO, those in xend but missing in libxl could be implemented first.

    .supports_feature
    .getSysinfo
    .domainReset
    .domainSetMemoryParameters
    .domainGetMemoryParameters
    .domainSetBlkioParameters
    .domainGetBlkioParameters
    .domainGetControlInfo
    .domainSaveImageGetXMLDesc
    .domainSaveImageDefineXML
    .domainScreenshot
    .domainPinVcpuFlags
    .domainGetVcpuPinInfo
    .domainPinEmulator
    .domainGetEmulatorPinInfo
**  .domainGetMaxVcpus
    .domainBlockResize
**  .domainBlockStats
    .domainBlockStatsFlags
**  .domainInterfaceStats
    .domainMemoryStats
**  .domainBlockPeek
    .domainMemoryPeek
    .domainGetBlockInfo
    .nodeGetCPUStats
    .nodeGetMemoryStats
**  .nodeGetCellsFreeMemory
**  .nodeDeviceDettach
**  .nodeDeviceReAttach
**  .nodeDeviceReset
**  .domainOpenConsole
    .domainOpenGraphics
    .domainSendKey
    .domainBlockJobAbort
    .domainGetBlockJobInfo
    .domainBlockJobSetSpeed
    .domainBlockPull
    .domainBlockRebase
**  .nodeSuspendForDuration
    .domainSetBlockIoTune
    .domainGetBlockIoTune
    .domainSetNumaParameters
    .domainGetNumaParameters
    .domainGetInterfaceParameters
    .domainSetInterfaceParameters
    .domainGetDiskErrors
    .domainSetMetadata
    .domainGetMetadata
    .domainPMSuspendForDuration
    .domainPMWakeup
    .domainGetCPUStats
**  .nodeGetMemoryParameters
**  .nodeSetMemoryParameters
snapshot APIs

2, discuss with Chunyan about these API:
referece I comparision result in "15:13 2012-03-26", I will implement the following command:
domainGetMaxVcpus
domainBlockStats
domainInterfaceStats

3, (17:47 2012-10-19)
domainGetMaxVcpus
it could be called directly through libxlDomainGetVcpusFlags with VIR_DOMAIN_AFFECT_LIVE, VIR_DOMAIN_VCPU_MAXIUM.

4, domainBlockStats
xend and xenlight is different. there is no specific stats file in libxl in sysfs.
check the difference between vbd:
1), xend
(1), linux-vm5:/etc/xen/vm # xenstore-ls /local/domain/14/device/vbd
768 = ""
 backend-id = "0"
 virtual-device = "768"
 device-type = "disk"
 state = "1"
 backend = "/local/domain/0/backend/vbd/14/768"
(2), linux-vm5:/etc/xen/vm # xm block-list 14
Vdev  BE handle state evt-ch ring-ref BE-path
768    0    0     4      8      8     /local/domain/0/backend/vbd/14/768
(3), xenstore-ls /local/domain/0/backend/vbd
14 = ""
 768 = ""
  domain = "sles11_hvm_10_2"
  frontend = "/local/domain/14/device/vbd/768"
  uuid = "06f2664c-c97c-1142-2e02-fc73443a1fd1"
  bootable = "1"
  dev = "hda"
  state = "4"
  params = "/var/lib/xen/images_2/sles11_hvm_10/disk0.raw"
  mode = "w"
  online = "1"
  frontend-id = "14"
  type = "file"
  node = "/dev/loop0"
  physical-device = "7:0"
  hotplug-status = "connected"
  feature-flush-cache = "1"
  feature-barrier = "1"
  sectors = "8388608"
  info = "0"
  sector-size = "512"
2), libxl
(1), linux-vm5:/etc/xen/vm # xenstore-ls /local/domain/13/device/vbd
768 = ""
 backend = "/local/domain/0/backend/qdisk/13/768"
 backend-id = "0"
 state = "4"
 virtual-device = "768"
 device-type = "disk"
 ring-ref = "8"
 event-channel = "8"
 protocol = "x86_64-abi"
(2), linux-vm8:~ # xenstore-ls /local/domain/0/backend/qdisk
7 = ""
 768 = ""
  frontend = "/local/domain/7/device/vbd/768"
  params = "aio:/var/lib/xen/images_2/sles11_hvm_10/disk0.raw"
  frontend-id = "7"
  online = "1"
  removable = "1"
  bootable = "1"
  state = "4"
  dev = "hda"
  type = "tap"
  mode = "w"
  feature-barrier = "1"
  info = "0"
  sector-size = "512"
  sectors = "8388608"
  hotplug-status = "connected"
3), (17:43 2012-10-23)
一个是backend不同, xend是vbd, xenlight是qdisk. 
第二, backend里面, params里面xenlight多了aio. 

15:02 2012-10-19
GTD
0, 9:55-18:18

1, today
1), 30' sync meeting. see"8:01 2012-10-19"
2), China all hands. see"15:04 2012-10-19"
3), 30' discuss with Chunyan about next step works. see"11:21 2012-10-19".
4), add api. "11:21 2012-10-19"3

15:04 2012-10-19
company, all hands meeting, China, Andy
1, forcast 5.2 million, actual 5.77 million.
2, Rock Li team超预期.

16:45 2012-10-19
"Alexander Graf <agraf@suse.de>"_email
Google just announced their new Chromebook:
http://liliputing.com/2012/10/google-introduces-249-samsung-chromebook-with-arm-based-cpu.html
which features an Exynos 5 dual-core CPU, 2GB of RAM, a 16GB SSD and a high-res 11" screen for $249.

15:12 2012-10-23
GTD
0, 14:40

1, today
1), read the mail.
2), work report. "17:23 2012-10-23"

2, next
1), reply Jim email.
2), try to fix the boot fail on MK802II.

15:47 2012-10-23
virtualization, xen, arm, OMAP3
1, "Robert VanVossen <Robert.VanVossen@dornerworks.com>"_email_"[XenARM] Porting xen-arm to an OMAP3 architecture"

15:59 2012-10-23
opensuse, arm, doc, bring up your device
"Alexander Graf <agraf@suse.de>"_email_"[opensuse-arm] Bring up your device"_20121022_1821
Howdy,
I gave a workshop today on how to bring up your own ARM devices on openSUSE 12.2. You can find the slides for it here:
  http://csgraf.de/arm/openSUSE%20for%20ARM%20on%20your%20device.pdf
They contain a bunch of useful information about workflows and openSUSE specifics that are otherwise hard to find. If you want to help out, I would be more than happy to read some of that information on the WIki :).
Happy hacking,
Alex

17:23 2012-10-23
work report - week 42
1, [devel-server] work report - week 42
work for libvirt libxl driver: 
1), try to improve libxl lock after discuss with Chunyan. 
2), discuss with Chunyan about libxl api. i will try to add GetBlockStats and GetInterfaceStats api in libxl.
(1), GetBlockStats: libvirt xend driver get statics from sysfs, but there is no such file in xenlight. i will read more in xen store. 

18:05 2012-10-23
virtualization, libvirt, xen, patch, lock, upstream reply
1, Jim reply for patch 01
Bamvor Jian Zhang wrote:
> This patch introduce a lock for protecting the long-running
> api (save, dump, migration and so on) from the other api
> which may update the status of the virtual machine.
>   

Hi Bamvor,

Thanks for the patches and sorry for the delayed response.  I've been
traveling quite a bit lately and just got around to reviewing and
testing your work.

Testing so far looks good.  I can save and dump vm's while at the same
time list and retrieve info.

See my comments inline, but did want to raise a more general comment
first.  There is a quite a bit of code here borrowed from the qemu
driver, which in general is fine since the libxl driver does not need
the same locking features as the qemu one.  I'd like to hear the opinion
of other libvirt maintainers wrt the duplicated code.

> Signed-off-by: Bamvor Jian Zhang <bjzhang@suse.com>
> ---
>  src/libxl/libxl_conf.h   |  58 ++++++
>  src/libxl/libxl_driver.c | 446 +++++++++++++++++++++++++++++++++++++++++++++++
>  2 files changed, 504 insertions(+)
>
> diff --git a/src/libxl/libxl_conf.h b/src/libxl/libxl_conf.h
> index 56bf85c..dab1466 100644
> --- a/src/libxl/libxl_conf.h
> +++ b/src/libxl/libxl_conf.h
> @@ -73,6 +73,62 @@ struct _libxlDriverPrivate {
>      char *saveDir;
>  };
>  
> +# define JOB_MASK(job)                  (1 << (job - 1))
> +# define DEFAULT_JOB_MASK               \
> +    (JOB_MASK(LIBXL_JOB_DESTROY) |      \
> +     JOB_MASK(LIBXL_JOB_ABORT))
> +
> +/* Jobs which have to be tracked in domain state XML. */
> +# define LIBXL_DOMAIN_TRACK_JOBS        \
> +    (JOB_MASK(LIBXL_JOB_DESTROY) |      \
> +     JOB_MASK(LIBXL_JOB_ASYNC))
> +
> +/* Only 1 job is allowed at any time
> + * A job includes *all* libxl.so api, even those just querying
> + * information, not merely actions */
> +enum libxlDomainJob {
> +    LIBXL_JOB_NONE = 0,      /* Always set to 0 for easy if (jobActive) conditions */
> +    LIBXL_JOB_DESTROY,       /* Destroys the domain (cannot be masked out) */
> +    LIBXL_JOB_MODIFY,        /* May change state */
> +    LIBXL_JOB_ABORT,         /* Abort current async job */
> +    LIBXL_JOB_MIGRATION_OP,  /* Operation influencing outgoing migration */
> +
> +    /* The following two items must always be the last items before JOB_LAST */
> +    LIBXL_JOB_ASYNC,         /* Asynchronous job */
>   

There is only one item, so the comment needs updated.

> +
> +    LIBXL_JOB_LAST
> +};
> +VIR_ENUM_DECL(libxlDomainJob)
> +
> +/* Async job consists of a series of jobs that may change state. Independent
> + * jobs that do not change state (and possibly others if explicitly allowed by
> + * current async job) are allowed to be run even if async job is active.
> + */
> +enum libxlDomainAsyncJob {
> +    LIBXL_ASYNC_JOB_NONE = 0,
> +    LIBXL_ASYNC_JOB_MIGRATION_OUT,
> +    LIBXL_ASYNC_JOB_MIGRATION_IN,
>   

The libxl driver doesn't currently support migration.  These could be
added in a patch set implementing migration.

> +    LIBXL_ASYNC_JOB_SAVE,
> +    LIBXL_ASYNC_JOB_DUMP,
>   

imo, libxl_async_job_restore should be added to this list.  i see it is
omitted in the qemu driver as well, so perhaps there is a good reason
for it?

> +
> +    LIBXL_ASYNC_JOB_LAST
> +};
> +VIR_ENUM_DECL(libxlDomainAsyncJob)
> +
> +struct libxlDomainJobObj {
> +    virCond cond;                       /* Use to coordinate jobs */
> +    enum libxlDomainJob active;         /* Currently running job */
> +    int owner;                          /* Thread which set current job */
> +
> +    virCond asyncCond;                  /* Use to coordinate with async jobs */
> +    enum libxlDomainAsyncJob asyncJob;  /* Currently active async job */
> +    int asyncOwner;                     /* Thread which set current async job */
> +    int phase;                          /* Job phase (mainly for migrations) */
> +    unsigned long long mask;            /* Jobs allowed during async job */
> +    unsigned long long start;           /* When the async job started */
> +    virDomainJobInfo info;              /* Async job progress data */
> +};
> +
>  typedef struct _libxlDomainObjPrivate libxlDomainObjPrivate;
>  typedef libxlDomainObjPrivate *libxlDomainObjPrivatePtr;
>  struct _libxlDomainObjPrivate {
> @@ -81,6 +137,8 @@ struct _libxlDomainObjPrivate {
>      libxl_waiter *dWaiter;
>      int waiterFD;
>      int eventHdl;
> +
> +    struct libxlDomainJobObj job;
>  };
>  
>  # define LIBXL_SAVE_MAGIC "libvirt-xml\n \0 \r"
> diff --git a/src/libxl/libxl_driver.c b/src/libxl/libxl_driver.c
> index 6fe284f..d01d915 100644
> --- a/src/libxl/libxl_driver.c
> +++ b/src/libxl/libxl_driver.c
> @@ -45,6 +45,7 @@
>  #include "xen_xm.h"
>  #include "virtypedparam.h"
>  #include "viruri.h"
> +#include "virtime.h"
>  
>  #define VIR_FROM_THIS VIR_FROM_LIBXL
>  
> @@ -84,6 +85,336 @@ libxlDriverUnlock(libxlDriverPrivatePtr driver)
>      virMutexUnlock(&driver->lock);
>  }
>  
> +/* job */
> +VIR_ENUM_IMPL(libxlDomainJob, LIBXL_JOB_LAST,
> +              "none",
> +              "destroy",
> +              "modify",
> +              "abort",
> +              "migration operation",
> +              "none",   /* async job is never stored in job.active */
> +);
> +
> +VIR_ENUM_IMPL(libxlDomainAsyncJob, LIBXL_ASYNC_JOB_LAST,
> +              "none",
> +              "migration out",
> +              "migration in",
>   

Can be added with a migration implementation.

> +              "save",
> +              "dump",
>   

"restore"?

> +);
> +
> +static int
> +libxlDomainObjInitJob(libxlDomainObjPrivatePtr priv)
> +{
> +    memset(&priv->job, 0, sizeof(priv->job));
> +
> +    if (virCondInit(&priv->job.cond) < 0)
> +        return -1;
> +
> +    if (virCondInit(&priv->job.asyncCond) < 0) {
> +        ignore_value(virCondDestroy(&priv->job.cond));
> +        return -1;
> +    }
> +
> +    return 0;
> +}
> +
> +static void
> +libxlDomainObjResetJob(libxlDomainObjPrivatePtr priv)
> +{
> +    struct libxlDomainJobObj *job = &priv->job;
> +
> +    job->active = LIBXL_JOB_NONE;
> +    job->owner = 0;
> +}
> +
> +static void
> +libxlDomainObjResetAsyncJob(libxlDomainObjPrivatePtr priv)
> +{
> +    struct libxlDomainJobObj *job = &priv->job;
> +
> +    job->asyncJob = LIBXL_ASYNC_JOB_NONE;
> +    job->asyncOwner = 0;
> +    job->phase = 0;
> +    job->mask = DEFAULT_JOB_MASK;
> +    job->start = 0;
> +    memset(&job->info, 0, sizeof(job->info));
> +}
> +
> +static void
> +libxlDomainObjFreeJob(libxlDomainObjPrivatePtr priv)
> +{
> +    ignore_value(virCondDestroy(&priv->job.cond));
> +    ignore_value(virCondDestroy(&priv->job.asyncCond));
> +}
> +
> +static bool
> +libxlDomainTrackJob(enum libxlDomainJob job)
> +{
> +    return (LIBXL_DOMAIN_TRACK_JOBS & JOB_MASK(job)) != 0;
> +}
> +
> +static void
> +libxlDomainObjSaveJob(libxlDriverPrivatePtr driver, virDomainObjPtr obj)
> +{
> +    if (!virDomainObjIsActive(obj)) {
> +        /* don't write the state file yet, it will be written once the domain
> +         * gets activated */
> +        return;
> +    }
> +
> +    if (virDomainSaveStatus(driver->caps, driver->stateDir, obj) < 0)
> +        VIR_WARN("Failed to save status on vm %s", obj->def->name);
> +}
> +
> +static bool
> +libxlDomainNestedJobAllowed(libxlDomainObjPrivatePtr priv, enum libxlDomainJob job)
> +{
> +    return !priv->job.asyncJob || (priv->job.mask & JOB_MASK(job)) != 0;
> +}
> +
> +static void
> +libxlDomainObjSetAsyncJobMask(virDomainObjPtr obj,
> +                              unsigned long long allowedJobs)
> +{
> +    libxlDomainObjPrivatePtr priv = obj->privateData;
> +
> +    if (!priv->job.asyncJob)
> +        return;
> +
> +    priv->job.mask = allowedJobs | JOB_MASK(LIBXL_JOB_DESTROY);
> +}
> +
> +/* Give up waiting for mutex after 30 seconds */
> +#define LIBXL_JOB_WAIT_TIME (1000ull * 30)
> +
> +/*
> + * obj must be locked before calling; driver_locked says if libxlDriverPrivatePtr
> + * is locked or not.
> + */
> +static int ATTRIBUTE_NONNULL(1)
> +libxlDomainObjBeginJobInternal(libxlDriverPrivatePtr driver,
> +                               bool driver_locked,
> +                               virDomainObjPtr obj,
> +                               enum libxlDomainJob job,
> +                               enum libxlDomainAsyncJob asyncJob)
> +{
> +    libxlDomainObjPrivatePtr priv = obj->privateData;
> +    unsigned long long now;
> +    unsigned long long then;
> +
> +    if (virTimeMillisNow(&now) < 0)
> +        return -1;
> +    then = now + LIBXL_JOB_WAIT_TIME;
> +
> +    virObjectRef(obj);
> +    if (driver_locked) {
> +        libxlDriverUnlock(driver);
> +    }
> +
> +retry:
> +    while (!libxlDomainNestedJobAllowed(priv, job)) {
> +        VIR_DEBUG("Wait async job condition for starting job: %s (async=%s)",
> +                  libxlDomainJobTypeToString(job),
> +                  libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +        if (virCondWaitUntil(&priv->job.asyncCond, &obj->lock, then) < 0)
> +            goto error;
> +    }
> +
> +    while (priv->job.active) {
> +        VIR_DEBUG("Wait normal job condition for starting job: %s (async=%s)",
> +                  libxlDomainJobTypeToString(job),
> +                  libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +        if (virCondWaitUntil(&priv->job.cond, &obj->lock, then) < 0)
> +            goto error;
> +    }
> +
> +    /* No job is active but a new async job could have been started while obj
> +     * was unlocked, so we need to recheck it. */
> +    if (!libxlDomainNestedJobAllowed(priv, job))
> +        goto retry;
> +
> +    libxlDomainObjResetJob(priv);
> +
> +    if (job != LIBXL_JOB_ASYNC) {
> +        VIR_DEBUG("Starting job: %s (async=%s)",
> +                  libxlDomainJobTypeToString(job),
> +                  libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +        priv->job.active = job;
> +        priv->job.owner = virThreadSelfID();
> +    } else {
> +        VIR_DEBUG("Starting async job: %s",
> +                  libxlDomainAsyncJobTypeToString(asyncJob));
> +        libxlDomainObjResetAsyncJob(priv);
> +        priv->job.asyncJob = asyncJob;
> +        priv->job.asyncOwner = virThreadSelfID();
> +        priv->job.start = now;
> +    }
> +
> +    if (driver_locked) {
> +        virDomainObjUnlock(obj);
> +        libxlDriverLock(driver);
> +        virDomainObjLock(obj);
> +    }
> +
> +    if (libxlDomainTrackJob(job))
> +        libxlDomainObjSaveJob(driver, obj);
> +
> +    return 0;
> +
> +error:
> +    VIR_WARN("Cannot start job (%s, %s) for domain %s;"
> +             " current job is (%s, %s) owned by (%d, %d)",
> +             libxlDomainJobTypeToString(job),
> +             libxlDomainAsyncJobTypeToString(asyncJob),
> +             obj->def->name,
> +             libxlDomainJobTypeToString(priv->job.active),
> +             libxlDomainAsyncJobTypeToString(priv->job.asyncJob),
> +             priv->job.owner, priv->job.asyncOwner);
> +
> +    if (errno == ETIMEDOUT)
> +        virReportError(VIR_ERR_OPERATION_TIMEOUT,
> +                       "%s", _("cannot acquire state change lock"));
> +    else
> +        virReportSystemError(errno,
> +                             "%s", _("cannot acquire job mutex"));
> +    if (driver_locked) {
> +        virDomainObjUnlock(obj);
> +        libxlDriverLock(driver);
> +        virDomainObjLock(obj);
> +    }
> +    virObjectUnref(obj);
> +    return -1;
> +}
> +
> +/*
> + * obj must be locked before calling, libxlDriverPrivatePtr must NOT be locked
> + *
> + * This must be called by anything that will change the VM state
> + * in any way
> + *
> + * Upon successful return, the object will have its ref count increased,
> + * successful calls must be followed by EndJob eventually
> + */
> +static int
> +libxlDomainObjBeginJob(libxlDriverPrivatePtr driver,
> +                       virDomainObjPtr obj,
> +                       enum libxlDomainJob job)
> +{
> +    return libxlDomainObjBeginJobInternal(driver, false, obj, job,
> +                                          LIBXL_ASYNC_JOB_NONE);
> +}
> +
> +static int ATTRIBUTE_UNUSED
> +libxlDomainObjBeginAsyncJob(libxlDriverPrivatePtr driver,
> +                            virDomainObjPtr obj,
> +                            enum libxlDomainAsyncJob asyncJob)
> +{
> +    return libxlDomainObjBeginJobInternal(driver, false, obj, LIBXL_JOB_ASYNC,
> +                                          asyncJob);
> +}
> +
> +/*
> + * obj must be locked before calling. If libxlDriverPrivatePtr is passed, it
> + * MUST be locked; otherwise it MUST NOT be locked.
>   

IMO, libxlDriverPrivatePtr should always be passed, in which case it
MUST be locked.

> + *
> + * This must be called by anything that will change the VM state
> + * in any way
> + *
> + * Upon successful return, the object will have its ref count increased,
> + * successful calls must be followed by EndJob eventually
> + */
> +static int
> +libxlDomainObjBeginJobWithDriver(libxlDriverPrivatePtr driver,
> +                                 virDomainObjPtr obj,
> +                                 enum libxlDomainJob job)
> +{
> +    if (job <= LIBXL_JOB_NONE || job >= LIBXL_JOB_ASYNC) {
> +        virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
> +                       _("Attempt to start invalid job"));
> +        return -1;
> +    }
> +
> +    return libxlDomainObjBeginJobInternal(driver, true, obj, job,
> +                                          LIBXL_ASYNC_JOB_NONE);
> +}
> +
> +static int
> +libxlDomainObjBeginAsyncJobWithDriver(libxlDriverPrivatePtr driver,
> +                                      virDomainObjPtr obj,
> +                                      enum libxlDomainAsyncJob asyncJob)
> +{
> +    return libxlDomainObjBeginJobInternal(driver, true, obj, LIBXL_JOB_ASYNC,
> +                                          asyncJob);
> +}
> +
> +/*
> + * obj must be locked before calling, libxlDriverPrivatePtr does not matter
> + *
> + * To be called after completing the work associated with the
> + * earlier libxlDomainBeginJob() call
> + *
> + * Returns remaining refcount on 'obj', maybe 0 to indicated it
> + * was deleted
> + */
> +static bool
> +libxlDomainObjEndJob(libxlDriverPrivatePtr driver, virDomainObjPtr obj)
> +{
> +    libxlDomainObjPrivatePtr priv = obj->privateData;
> +    enum libxlDomainJob job = priv->job.active;
> +
> +    VIR_DEBUG("Stopping job: %s (async=%s)",
> +              libxlDomainJobTypeToString(job),
> +              libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +
> +    libxlDomainObjResetJob(priv);
> +    if (libxlDomainTrackJob(job))
> +        libxlDomainObjSaveJob(driver, obj);
> +    virCondSignal(&priv->job.cond);
> +
> +    return virObjectUnref(obj);
> +}
> +
> +static bool
> +libxlDomainObjEndAsyncJob(libxlDriverPrivatePtr driver, virDomainObjPtr obj)
> +{
> +    libxlDomainObjPrivatePtr priv = obj->privateData;
> +
> +    VIR_DEBUG("Stopping async job: %s",
> +              libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +
> +    libxlDomainObjResetAsyncJob(priv);
> +    libxlDomainObjSaveJob(driver, obj);
> +    virCondBroadcast(&priv->job.asyncCond);
> +
> +    return virObjectUnref(obj);
> +}
> +
> +static int ATTRIBUTE_UNUSED
> +libxlMigrationJobStart(libxlDriverPrivatePtr driver,
> +                       virDomainObjPtr vm,
> +                       enum libxlDomainAsyncJob job)
>   

This function is not used in the patch series and should be removed.

> +{
> +    libxlDomainObjPrivatePtr priv = vm->privateData;
> +
> +    if (libxlDomainObjBeginAsyncJobWithDriver(driver, vm, job) < 0)
> +        return -1;
> +
> +    libxlDomainObjSetAsyncJobMask(vm, DEFAULT_JOB_MASK |
> +                                  JOB_MASK(LIBXL_JOB_MIGRATION_OP));
> +
> +    priv->job.info.type = VIR_DOMAIN_JOB_UNBOUNDED;
> +
> +    return 0;
> +}
> +
> +static bool ATTRIBUTE_UNUSED
> +libxlMigrationJobFinish(libxlDriverPrivatePtr driver, virDomainObjPtr vm)
>   

Same here, not used so should be removed.

> +{
> +    return libxlDomainObjEndAsyncJob(driver, vm);
> +}
> +/* job function finish */
> +
>  static void *
>  libxlDomainObjPrivateAlloc(void)
>  {
> @@ -92,11 +423,18 @@ libxlDomainObjPrivateAlloc(void)
>      if (VIR_ALLOC(priv) < 0)
>          return NULL;
>  
> +    if (libxlDomainObjInitJob(priv) < 0)
> +        goto error;
> +
>      libxl_ctx_init(&priv->ctx, LIBXL_VERSION, libxl_driver->logger);
>      priv->waiterFD = -1;
>      priv->eventHdl = -1;
>  
>      return priv;
> +
> +error:
> +    VIR_FREE(priv);
> +    return NULL;
>  }
>  
>  static void
> @@ -114,6 +452,7 @@ libxlDomainObjPrivateFree(void *data)
>      }
>  
>      libxl_ctx_free(&priv->ctx);
> +    libxlDomainObjFreeJob(priv);
>      VIR_FREE(priv);
>  }
>  
> @@ -3830,6 +4169,111 @@ cleanup:
>  }
>  
>  static int
> +libxlDomainGetJobInfo(virDomainPtr dom,
> +                      virDomainJobInfoPtr info)
> +{
> +    libxlDriverPrivatePtr driver = dom->conn->privateData;
> +    virDomainObjPtr vm;
> +    int ret = -1;
> +    libxlDomainObjPrivatePtr priv;
> +
> +    libxlDriverLock(driver);
> +    vm = virDomainFindByUUID(&driver->domains, dom->uuid);
> +    libxlDriverUnlock(driver);
> +    if (!vm) {
> +        char uuidstr[VIR_UUID_STRING_BUFLEN];
> +        virUUIDFormat(dom->uuid, uuidstr);
> +        virReportError(VIR_ERR_NO_DOMAIN,
> +                       _("no domain with matching uuid '%s'"), uuidstr);
> +        goto cleanup;
> +    }
> +
> +    priv = vm->privateData;
> +
> +    if (virDomainObjIsActive(vm)) {
> +        if (priv->job.asyncJob) {
> +            memcpy(info, &priv->job.info, sizeof(*info));
> +
> +            /* Refresh elapsed time again just to ensure it
> +             * is fully updated. This is primarily for benefit
> +             * of incoming migration which we don't currently
> +             * monitor actively in the background thread
> +             */
> +            if (virTimeMillisNow(&info->timeElapsed) < 0)
> +                goto cleanup;
> +            info->timeElapsed -= priv->job.start;
> +        } else {
> +            memset(info, 0, sizeof(*info));
> +            info->type = VIR_DOMAIN_JOB_NONE;
> +        }
> +    } else {
> +        virReportError(VIR_ERR_OPERATION_INVALID,
> +                       "%s", _("domain is not running"));
> +        goto cleanup;
> +    }
> +
> +    ret = 0;
> +
> +cleanup:
> +    if (vm)
> +        virDomainObjUnlock(vm);
> +    return ret;
> +}
> +
> +static int
> +libxlDomainAbortJob(virDomainPtr dom)
> +{
> +    libxlDriverPrivatePtr driver = dom->conn->privateData;
> +    virDomainObjPtr vm;
> +    int ret = -1;
> +    libxlDomainObjPrivatePtr priv;
> +
> +    libxlDriverLock(driver);
> +    vm = virDomainFindByUUID(&driver->domains, dom->uuid);
> +    libxlDriverUnlock(driver);
> +    if (!vm) {
> +        char uuidstr[VIR_UUID_STRING_BUFLEN];
> +        virUUIDFormat(dom->uuid, uuidstr);
> +        virReportError(VIR_ERR_NO_DOMAIN,
> +                       _("no domain with matching uuid '%s'"), uuidstr);
> +        goto cleanup;
> +    }
> +
> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_ABORT) < 0)
> +        goto cleanup;
> +
> +    if (!virDomainObjIsActive(vm)) {
> +        virReportError(VIR_ERR_OPERATION_INVALID,
> +                       "%s", _("domain is not running"));
> +        goto endjob;
> +    }
> +
> +    priv = vm->privateData;
> +
> +    if (!priv->job.asyncJob) {
> +        virReportError(VIR_ERR_OPERATION_INVALID,
> +                       "%s", _("no job is active on the domain"));
> +        goto endjob;
> +    } else {
> +        virReportError(VIR_ERR_OPERATION_INVALID,
> +                       _("cannot abort %s; use virDomainDestroy instead"),
> +                       libxlDomainAsyncJobTypeToString(priv->job.asyncJob));
> +        goto endjob;
> +    }
>   

This function will always fail with the above logic.  ret is initialized
to -1 and is never changed.

Is it even possible to safely abort a libxl operation?  If not, this
function should probably remain unimplemented.  Maybe it will be useful
when the libxl driver supports migration.

Regards,
Jim

> +
> +    VIR_DEBUG("Not job could be cancelled at current version");
> +
> +endjob:
> +    if (libxlDomainObjEndJob(driver, vm) == 0)
> +        vm = NULL;
> +
> +cleanup:
> +    if (vm)
> +        virDomainObjUnlock(vm);
> +    return ret;
> +}
> +
> +static int
>  libxlDomainEventRegisterAny(virConnectPtr conn, virDomainPtr dom, int eventID,
>                              virConnectDomainEventGenericCallback callback,
>                              void *opaque, virFreeCallback freecb)
> @@ -3963,6 +4407,8 @@ static virDriver libxlDriver = {
>      .domainIsActive = libxlDomainIsActive, /* 0.9.0 */
>      .domainIsPersistent = libxlDomainIsPersistent, /* 0.9.0 */
>      .domainIsUpdated = libxlDomainIsUpdated, /* 0.9.0 */
> +    .domainGetJobInfo = libxlDomainGetJobInfo, /* 0.10.0 */
> +    .domainAbortJob = libxlDomainAbortJob, /* 0.10.0 */
>      .domainEventRegisterAny = libxlDomainEventRegisterAny, /* 0.9.0 */
>      .domainEventDeregisterAny = libxlDomainEventDeregisterAny, /* 0.9.0 */
>      .isAlive = libxlIsAlive, /* 0.9.8 */
>   

2, Jim reply for patch 0002
Bamvor Jian Zhang wrote:
> Add long-running jobs for save, dump. Add normal job for the
> api maybe modify the domain.
>
> Signed-off-by: Bamvor Jian Zhang <bjzhang@suse.com>
> ---
>  src/libxl/libxl_driver.c | 219 ++++++++++++++++++++++++++++++++++-------------
>  1 file changed, 158 insertions(+), 61 deletions(-)
>
> diff --git a/src/libxl/libxl_driver.c b/src/libxl/libxl_driver.c
> index d01d915..28e50b0 100644
> --- a/src/libxl/libxl_driver.c
> +++ b/src/libxl/libxl_driver.c
> @@ -1534,9 +1534,13 @@ libxlDomainCreateXML(virConnectPtr conn, const char *xml,
>          goto cleanup;
>      def = NULL;
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (libxlVmStart(driver, vm, (flags & VIR_DOMAIN_START_PAUSED) != 0,
>                       -1) < 0) {
> -        virDomainRemoveInactive(&driver->domains, vm);
> +        if (libxlDomainObjEndJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>          vm = NULL;
>          goto cleanup;
>      }
> @@ -1545,6 +1549,8 @@ libxlDomainCreateXML(virConnectPtr conn, const char *xml,
>      if (dom)
>          dom->id = vm->def->id;
>  
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
>  cleanup:
>      virDomainDefFree(def);
>      if (vm)
> @@ -1651,9 +1657,13 @@ libxlDomainSuspend(virDomainPtr dom)
>                         _("No domain with matching uuid '%s'"), uuidstr);
>          goto cleanup;
>      }
> +
> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>   

IMO, we should check if the domain is active before calling
libxlDomainObjBeginJob().

>  
>      priv = vm->privateData;
> @@ -1663,7 +1673,7 @@ libxlDomainSuspend(virDomainPtr dom)
>              virReportError(VIR_ERR_INTERNAL_ERROR,
>                             _("Failed to suspend domain '%d' with libxenlight"),
>                             dom->id);
> -            goto cleanup;
> +            goto endjob;
>          }
>  
>          virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);
> @@ -1673,10 +1683,14 @@ libxlDomainSuspend(virDomainPtr dom)
>      }
>  
>      if (virDomainSaveStatus(driver->caps, driver->stateDir, vm) < 0)
> -        goto cleanup;
> +        goto endjob;
>  
>      ret = 0;
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -1710,9 +1724,12 @@ libxlDomainResume(virDomainPtr dom)
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>   

Same here.

>  
>      priv = vm->privateData;
> @@ -1722,7 +1739,7 @@ libxlDomainResume(virDomainPtr dom)
>              virReportError(VIR_ERR_INTERNAL_ERROR,
>                             _("Failed to resume domain '%d' with libxenlight"),
>                             dom->id);
> -            goto cleanup;
> +            goto endjob;
>          }
>  
>          virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,
> @@ -1733,10 +1750,14 @@ libxlDomainResume(virDomainPtr dom)
>      }
>  
>      if (virDomainSaveStatus(driver->caps, driver->stateDir, vm) < 0)
> -        goto cleanup;
> +        goto endjob;
>  
>      ret = 0;
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -1768,10 +1789,13 @@ libxlDomainShutdownFlags(virDomainPtr dom, unsigned int flags)
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID,
>                         "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>   

And here.

>  
>      priv = vm->privateData;
> @@ -1779,7 +1803,7 @@ libxlDomainShutdownFlags(virDomainPtr dom, unsigned int flags)
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to shutdown domain '%d' with libxenlight"),
>                         dom->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      /* vm is marked shutoff (or removed from domains list if not persistent)
> @@ -1787,6 +1811,10 @@ libxlDomainShutdownFlags(virDomainPtr dom, unsigned int flags)
>       */
>      ret = 0;
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -1821,10 +1849,13 @@ libxlDomainReboot(virDomainPtr dom, unsigned int flags)
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID,
>                         "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>   

And here.

>  
>      priv = vm->privateData;
> @@ -1832,10 +1863,14 @@ libxlDomainReboot(virDomainPtr dom, unsigned int flags)
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to reboot domain '%d' with libxenlight"),
>                         dom->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>      ret = 0;
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -1864,10 +1899,13 @@ libxlDomainDestroyFlags(virDomainPtr dom,
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_DESTROY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID,
>                         "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>   

I think you get the picture :).

>  
>      event = virDomainEventNewFromObj(vm,VIR_DOMAIN_EVENT_STOPPED,
> @@ -1876,16 +1914,21 @@ libxlDomainDestroyFlags(virDomainPtr dom,
>      if (libxlVmReap(driver, vm, 1, VIR_DOMAIN_SHUTOFF_DESTROYED) != 0) {
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to destroy domain '%d'"), dom->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if (!vm->persistent) {
> -        virDomainRemoveInactive(&driver->domains, vm);
> +        if (libxlDomainObjEndJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>          vm = NULL;
>      }
>  
>      ret = 0;
>  
> +endjob:
> +    if ( vm && !libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -1975,6 +2018,9 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      isActive = virDomainObjIsActive(vm);
>  
>      if (flags == VIR_DOMAIN_MEM_CURRENT) {
> @@ -1993,17 +2039,17 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>      if (!isActive && (flags & VIR_DOMAIN_MEM_LIVE)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s",
>                         _("cannot set memory on an inactive domain"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if (flags & VIR_DOMAIN_MEM_CONFIG) {
>          if (!vm->persistent) {
>              virReportError(VIR_ERR_OPERATION_INVALID, "%s",
>                             _("cannot change persistent config of a transient domain"));
> -            goto cleanup;
> +            goto endjob;
>          }
>          if (!(persistentDef = virDomainObjGetPersistentDef(driver->caps, vm)))
> -            goto cleanup;
> +            goto endjob;
>      }
>  
>      if (flags & VIR_DOMAIN_MEM_MAXIMUM) {
> @@ -2015,7 +2061,7 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>                  virReportError(VIR_ERR_INTERNAL_ERROR,
>                                 _("Failed to set maximum memory for domain '%d'"
>                                   " with libxenlight"), dom->id);
> -                goto cleanup;
> +                goto endjob;
>              }
>          }
>  
> @@ -2026,7 +2072,7 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>              if (persistentDef->mem.cur_balloon > newmem)
>                  persistentDef->mem.cur_balloon = newmem;
>              ret = virDomainSaveConfig(driver->configDir, persistentDef);
> -            goto cleanup;
> +            goto endjob;
>          }
>  
>      } else {
> @@ -2035,7 +2081,7 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>          if (newmem > vm->def->mem.max_balloon) {
>              virReportError(VIR_ERR_INVALID_ARG, "%s",
>                             _("cannot set memory higher than max memory"));
> -            goto cleanup;
> +            goto endjob;
>          }
>  
>          if (flags & VIR_DOMAIN_MEM_LIVE) {
> @@ -2045,7 +2091,7 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>                  virReportError(VIR_ERR_INTERNAL_ERROR,
>                                 _("Failed to set memory for domain '%d'"
>                                   " with libxenlight"), dom->id);
> -                goto cleanup;
> +                goto endjob;
>              }
>          }
>  
> @@ -2053,11 +2099,14 @@ libxlDomainSetMemoryFlags(virDomainPtr dom, unsigned long newmem,
>              sa_assert(persistentDef);
>              persistentDef->mem.cur_balloon = newmem;
>              ret = virDomainSaveConfig(driver->configDir, persistentDef);
> -            goto cleanup;
> +            goto endjob;
>          }
>      }
>  
>      ret = 0;
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
>  
>  cleanup:
>      if (vm)
> @@ -2165,22 +2214,26 @@ libxlDoDomainSave(libxlDriverPrivatePtr driver, virDomainObjPtr vm,
>      int fd;
>      int ret = -1;
>  
> +    if (libxlDomainObjBeginAsyncJobWithDriver(driver, vm,
> +                                              LIBXL_ASYNC_JOB_SAVE) < 0)
> +        goto cleanup;
> +
>      if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {
>          virReportError(VIR_ERR_OPERATION_INVALID,
>                         _("Domain '%d' has to be running because libxenlight will"
>                           " suspend it"), vm->def->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if ((fd = virFileOpenAs(to, O_CREAT|O_TRUNC|O_WRONLY, S_IRUSR|S_IWUSR,
>                              -1, -1, 0)) < 0) {
>          virReportSystemError(-fd,
>                               _("Failed to create domain save file '%s'"), to);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if ((xml = virDomainDefFormat(vm->def, 0)) == NULL)
> -        goto cleanup;
> +        goto endjob;
>      xml_len = strlen(xml) + 1;
>  
>      memset(&hdr, 0, sizeof(hdr));
> @@ -2191,20 +2244,26 @@ libxlDoDomainSave(libxlDriverPrivatePtr driver, virDomainObjPtr vm,
>      if (safewrite(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {
>          virReportError(VIR_ERR_OPERATION_FAILED, "%s",
>                         _("Failed to write save file header"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if (safewrite(fd, xml, xml_len) != xml_len) {
>          virReportError(VIR_ERR_OPERATION_FAILED, "%s",
>                         _("Failed to write xml description"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
> -    if (libxl_domain_suspend(&priv->ctx, NULL, vm->def->id, fd) != 0) {
> +    virDomainObjUnlock(vm);
> +    libxlDriverUnlock(driver);
> +    ret = libxl_domain_suspend(&priv->ctx, NULL, vm->def->id, fd);
> +    libxlDriverLock(driver);
> +    virDomainObjLock(vm);
> +
> +    if (ret != 0) {
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to save domain '%d' with libxenlight"),
>                         vm->def->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      event = virDomainEventNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,
> @@ -2213,18 +2272,23 @@ libxlDoDomainSave(libxlDriverPrivatePtr driver, virDomainObjPtr vm,
>      if (libxlVmReap(driver, vm, 1, VIR_DOMAIN_SHUTOFF_SAVED) != 0) {
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to destroy domain '%d'"), vm->def->id);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      vm->hasManagedSave = true;
>  
>      if (!vm->persistent) {
> -        virDomainRemoveInactive(&driver->domains, vm);
> +        if (libxlDomainObjEndAsyncJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>          vm = NULL;
>      }
>  
>      ret = 0;
>  
> +endjob:
> +    if ( vm && !libxlDomainObjEndAsyncJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      VIR_FREE(xml);
>      if (VIR_CLOSE(fd) < 0)
> @@ -2312,12 +2376,18 @@ libxlDomainRestoreFlags(virConnectPtr conn, const char *from,
>  
>      def = NULL;
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
>   

From my testing, this prevents listing domains, getting domain info,
etc. while restoring the domain.  As mentioned in patch 1, we could use
LIBXL_ASYNC_JOB_RESTORE here.

> +
>      if ((ret = libxlVmStart(driver, vm, false, fd)) < 0 &&
>          !vm->persistent) {
> -        virDomainRemoveInactive(&driver->domains, vm);
> +        if (libxlDomainObjEndAsyncJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>   

Shouldn't we call virDomainRemoveInactive() even if
libxlDomainObjEndAsyncJob() fails?

>          vm = NULL;
>      }
>  
> +    if (vm && !libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
>  cleanup:
>      if (VIR_CLOSE(fd) < 0)
>          virReportSystemError(errno, "%s", _("cannot close file"));
> @@ -2348,7 +2418,6 @@ libxlDomainCoreDump(virDomainPtr dom, const char *to, unsigned int flags)
>  
>      libxlDriverLock(driver);
>      vm = virDomainFindByUUID(&driver->domains, dom->uuid);
> -    libxlDriverUnlock(driver);
>  
>      if (!vm) {
>          char uuidstr[VIR_UUID_STRING_BUFLEN];
> @@ -2358,9 +2427,13 @@ libxlDomainCoreDump(virDomainPtr dom, const char *to, unsigned int flags)
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginAsyncJobWithDriver(driver, vm,
> +                                              LIBXL_ASYNC_JOB_DUMP) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s", _("Domain is not running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      priv = vm->privateData;
> @@ -2372,25 +2445,29 @@ libxlDomainCoreDump(virDomainPtr dom, const char *to, unsigned int flags)
>                             _("Before dumping core, failed to suspend domain '%d'"
>                               " with libxenlight"),
>                             dom->id);
> -            goto cleanup;
> +            goto endjob;
>          }
>          virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_DUMP);
>          paused = true;
>      }
>  
> -    if (libxl_domain_core_dump(&priv->ctx, dom->id, to) != 0) {
> +    virDomainObjUnlock(vm);
> +    libxlDriverUnlock(driver);
> +    ret = libxl_domain_core_dump(&priv->ctx, dom->id, to);
> +    libxlDriverLock(driver);
> +    virDomainObjLock(vm);
> +    if (ret != 0) {
>          virReportError(VIR_ERR_INTERNAL_ERROR,
>                         _("Failed to dump core of domain '%d' with libxenlight"),
>                         dom->id);
> -        goto cleanup_unpause;
> +        goto endjob_unpause;
>      }
>  
> -    libxlDriverLock(driver);
>      if (flags & VIR_DUMP_CRASH) {
>          if (libxlVmReap(driver, vm, 1, VIR_DOMAIN_SHUTOFF_CRASHED) != 0) {
>              virReportError(VIR_ERR_INTERNAL_ERROR,
>                             _("Failed to destroy domain '%d'"), dom->id);
> -            goto cleanup_unlock;
> +            goto endjob_unpause;
>          }
>  
>          event = virDomainEventNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,
> @@ -2398,15 +2475,14 @@ libxlDomainCoreDump(virDomainPtr dom, const char *to, unsigned int flags)
>      }
>  
>      if ((flags & VIR_DUMP_CRASH) && !vm->persistent) {
> -        virDomainRemoveInactive(&driver->domains, vm);
> +        if (libxlDomainObjEndAsyncJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>   

Same comment here about conditionally calling virDomainRemoveInactive().

Regards,
Jim


>          vm = NULL;
>      }
>  
>      ret = 0;
>  
> -cleanup_unlock:
> -    libxlDriverUnlock(driver);
> -cleanup_unpause:
> +endjob_unpause:
>      if (virDomainObjIsActive(vm) && paused) {
>          if (libxl_domain_unpause(&priv->ctx, dom->id) != 0) {
>              virReportError(VIR_ERR_INTERNAL_ERROR,
> @@ -2417,14 +2493,15 @@ cleanup_unpause:
>                                   VIR_DOMAIN_RUNNING_UNPAUSED);
>          }
>      }
> +endjob:
> +    if (vm && !libxlDomainObjEndAsyncJob(driver, vm))
> +        vm = NULL;
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> -    if (event) {
> -        libxlDriverLock(driver);
> +    if (event)
>          libxlDomainEventQueue(driver, event);
> -        libxlDriverUnlock(driver);
> -    }
> +    libxlDriverUnlock(driver);
>      return ret;
>  }
>  
> @@ -2601,22 +2678,25 @@ libxlDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (!virDomainObjIsActive(vm) && (flags & VIR_DOMAIN_VCPU_LIVE)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s",
>                         _("cannot set vcpus on an inactive domain"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if (!vm->persistent && (flags & VIR_DOMAIN_VCPU_CONFIG)) {
>          virReportError(VIR_ERR_OPERATION_INVALID, "%s",
>                         _("cannot change persistent config of a transient domain"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if ((max = libxlGetMaxVcpus(dom->conn, NULL)) < 0) {
>          virReportError(VIR_ERR_INTERNAL_ERROR, "%s",
>                         _("could not determine max vcpus for the domain"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      if (!(flags & VIR_DOMAIN_VCPU_MAXIMUM) && vm->def->maxvcpus < max) {
> @@ -2627,18 +2707,18 @@ libxlDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,
>          virReportError(VIR_ERR_INVALID_ARG,
>                         _("requested vcpus is greater than max allowable"
>                           " vcpus for the domain: %d > %d"), nvcpus, max);
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      priv = vm->privateData;
>  
>      if (!(def = virDomainObjGetPersistentDef(driver->caps, vm)))
> -        goto cleanup;
> +        goto endjob;
>  
>      maplen = VIR_CPU_MAPLEN(nvcpus);
>      if (VIR_ALLOC_N(bitmask, maplen) < 0) {
>          virReportOOMError();
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      for (i = 0; i < nvcpus; ++i) {
> @@ -2665,7 +2745,7 @@ libxlDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,
>              virReportError(VIR_ERR_INTERNAL_ERROR,
>                             _("Failed to set vcpus for domain '%d'"
>                               " with libxenlight"), dom->id);
> -            goto cleanup;
> +            goto endjob;
>          }
>          break;
>  
> @@ -2674,7 +2754,7 @@ libxlDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,
>              virReportError(VIR_ERR_INTERNAL_ERROR,
>                             _("Failed to set vcpus for domain '%d'"
>                               " with libxenlight"), dom->id);
> -            goto cleanup;
> +            goto endjob;
>          }
>          def->vcpus = nvcpus;
>          break;
> @@ -2685,6 +2765,9 @@ libxlDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,
>      if (flags & VIR_DOMAIN_VCPU_CONFIG)
>          ret = virDomainSaveConfig(driver->configDir, def);
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
>  cleanup:
>      VIR_FREE(bitmask);
>       if (vm)
> @@ -3053,14 +3136,21 @@ libxlDomainCreateWithFlags(virDomainPtr dom,
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (virDomainObjIsActive(vm)) {
>          virReportError(VIR_ERR_OPERATION_INVALID,
>                         "%s", _("Domain is already running"));
> -        goto cleanup;
> +        goto endjob;
>      }
>  
>      ret = libxlVmStart(driver, vm, (flags & VIR_DOMAIN_START_PAUSED) != 0, -1);
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      if (vm)
>          virDomainObjUnlock(vm);
> @@ -3589,6 +3679,9 @@ libxlDomainModifyDeviceFlags(virDomainPtr dom, const char *xml,
>          goto cleanup;
>      }
>  
> +    if (libxlDomainObjBeginJobWithDriver(driver, vm, LIBXL_JOB_MODIFY) < 0)
> +        goto cleanup;
> +
>      if (virDomainObjIsActive(vm)) {
>          if (flags == VIR_DOMAIN_DEVICE_MODIFY_CURRENT)
>              flags |= VIR_DOMAIN_DEVICE_MODIFY_LIVE;
> @@ -3599,14 +3692,14 @@ libxlDomainModifyDeviceFlags(virDomainPtr dom, const char *xml,
>          if (flags & VIR_DOMAIN_DEVICE_MODIFY_LIVE) {
>              virReportError(VIR_ERR_OPERATION_INVALID,
>                             "%s", _("Domain is not running"));
> -            goto cleanup;
> +            goto endjob;
>          }
>      }
>  
>      if ((flags & VIR_DOMAIN_DEVICE_MODIFY_CONFIG) && !vm->persistent) {
>           virReportError(VIR_ERR_OPERATION_INVALID,
>                          "%s", _("cannot modify device on transient domain"));
> -         goto cleanup;
> +         goto endjob;
>      }
>  
>      priv = vm->privateData;
> @@ -3614,11 +3707,11 @@ libxlDomainModifyDeviceFlags(virDomainPtr dom, const char *xml,
>      if (flags & VIR_DOMAIN_DEVICE_MODIFY_CONFIG) {
>          if (!(dev = virDomainDeviceDefParse(driver->caps, vm->def, xml,
>                                              VIR_DOMAIN_XML_INACTIVE)))
> -            goto cleanup;
> +            goto endjob;
>  
>          /* Make a copy for updated domain. */
>          if (!(vmdef = virDomainObjCopyPersistentDef(driver->caps, vm)))
> -            goto cleanup;
> +            goto endjob;
>  
>          switch (action) {
>              case LIBXL_DEVICE_ATTACH:
> @@ -3642,7 +3735,7 @@ libxlDomainModifyDeviceFlags(virDomainPtr dom, const char *xml,
>          virDomainDeviceDefFree(dev);
>          if (!(dev = virDomainDeviceDefParse(driver->caps, vm->def, xml,
>                                              VIR_DOMAIN_XML_INACTIVE)))
> -            goto cleanup;
> +            goto endjob;
>  
>          switch (action) {
>              case LIBXL_DEVICE_ATTACH:
> @@ -3675,6 +3768,10 @@ libxlDomainModifyDeviceFlags(virDomainPtr dom, const char *xml,
>          }
>      }
>  
> +endjob:
> +    if (!libxlDomainObjEndJob(driver, vm))
> +        vm = NULL;
> +
>  cleanup:
>      virDomainDefFree(vmdef);
>      virDomainDeviceDefFree(dev);
>   

3, "Daniel P. Berrange" <berrange@redhat.com>""_email_20121023_2347
On Mon, Oct 22, 2012 at 04:22:53PM -0600, Jim Fehlig wrote:
> Bamvor Jian Zhang wrote:
> > This patch introduce a lock for protecting the long-running
> > api (save, dump, migration and so on) from the other api
> > which may update the status of the virtual machine.
> >   
> 
> Hi Bamvor,
> 
> Thanks for the patches and sorry for the delayed response.  I've been
> traveling quite a bit lately and just got around to reviewing and
> testing your work.
> 
> Testing so far looks good.  I can save and dump vm's while at the same
> time list and retrieve info.
> 
> See my comments inline, but did want to raise a more general comment
> first.  There is a quite a bit of code here borrowed from the qemu
> driver, which in general is fine since the libxl driver does not need
> the same locking features as the qemu one.  I'd like to hear the opinion
> of other libvirt maintainers wrt the duplicated code.

I was actually quite pleased to see that the libxl driver was following
the model used in the QEMU driver, even though there was code copying.
I don't think it is worth trying to eliminate the code duplication in
this case.


Daniel
-- 
|: http://berrange.com      -o-    http://www.flickr.com/photos/dberrange/ :|
|: http://libvirt.org              -o-             http://virt-manager.org :|
|: http://autobuild.org       -o-         http://search.cpan.org/~danberr/ :|
|: http://entangle-photo.org       -o-       http://live.gnome.org/gtk-vnc :|


4, "Eric Blake <eblake@redhat.com>"_email_20121024_1206
On 10/22/2012 05:10 PM, Jim Fehlig wrote:
> Bamvor Jian Zhang wrote:
>> Add long-running jobs for save, dump. Add normal job for the
>> api maybe modify the domain.
>>
>> Signed-off-by: Bamvor Jian Zhang <bjzhang@suse.com>

>> +
>> +    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)
>> +        goto cleanup;
>> +
>>      if (!virDomainObjIsActive(vm)) {
>>          virReportError(VIR_ERR_OPERATION_INVALID, "%s", _("Domain is not running"));
>> -        goto cleanup;
>> +        goto endjob;
>>      }
>>   
> 
> IMO, we should check if the domain is active before calling
> libxlDomainObjBeginJob().

That's a possible optimization to avoid contending for the lock, but the
point remains that libxlDomainObjBeginJob() temporarily drops locks, and
while locks are down, the domain can stop.  Therefore, you must ALWAYS
check if the domain is active after obtaining the job, even if you
already checked prior to requesting the job.  This particular section of
code looks correct to me as-is.

-- 
Eric Blake   eblake@redhat.com    +1-919-301-3266
Libvirt virtualization library http://libvirt.org

5, Jim
>> IMO, we should check if the domain is active before calling
>> libxlDomainObjBeginJob().
>>     
>
> That's a possible optimization to avoid contending for the lock, but the
> point remains that libxlDomainObjBeginJob() temporarily drops locks, and
> while locks are down, the domain can stop.
Oh, right.  Thanks for catching that.

>   Therefore, you must ALWAYS
> check if the domain is active after obtaining the job, even if you
> already checked prior to requesting the job.  This particular section of
> code looks correct to me as-is.
>   
Agreed.  Bamvor, ignore my comments about changing this pattern
throughout the patch.

6, general
1), Jim
See my comments inline, but did want to raise a more general comment
first.  There is a quite a bit of code here borrowed from the qemu
driver, which in general is fine since the libxl driver does not need
the same locking features as the qemu one.  I'd like to hear the opinion
of other libvirt maintainers wrt the duplicated code.
2), Daniel 
I was actually quite pleased to see that the libxl driver was following
the model used in the QEMU driver, even though there was code copying.
I don't think it is worth trying to eliminate the code duplication in
this case.

7, analysis the reply of Patch01
1), 
> +    /* The following two items must always be the last items before JOB_LAST */
> +    LIBXL_JOB_ASYNC,         /* Asynchronous job */
>   

There is only one item, so the comment needs updated.

2), remove migration relative patch.
The libxl driver doesn't currently support migration.  These could be
added in a patch set implementing migration.
(1), 
> +    LIBXL_ASYNC_JOB_MIGRATION_OUT,
> +    LIBXL_ASYNC_JOB_MIGRATION_IN,
>   
(2), 
> +static int ATTRIBUTE_UNUSED
> +libxlMigrationJobStart(libxlDriverPrivatePtr driver,
> +                       virDomainObjPtr vm,
> +                       enum libxlDomainAsyncJob job)
>

3), about restore job
(1), 
imo, libxl_async_job_restore should be added to this list.  i see it is
omitted in the qemu driver as well, so perhaps there is a good reason
for it?
Bamvor: libxlVmStart不好处理。好像还有其他原因?
(2),From my testing, this prevents listing domains, getting domain info,
etc. while restoring the domain.  As mentioned in patch 1, we could use
LIBXL_ASYNC_JOB_RESTORE here.

4), 
> +/*
> + * obj must be locked before calling. If libxlDriverPrivatePtr is passed, it
> + * MUST be locked; otherwise it MUST NOT be locked.
>   

IMO, libxlDriverPrivatePtr should always be passed, in which case it
MUST be locked.

5), libxlAbortJob
This function will always fail with the above logic.  ret is initialized
to -1 and is never changed.

Is it even possible to safely abort a libxl operation?  If not, this
function should probably remain unimplemented.  Maybe it will be useful
when the libxl driver supports migration.

Bamvor: missing ret because libxl could not cancel migration at this momnent. 

8, analysis the reply of Patch02
1), CreateXML
IMO, we should check if the domain is active before calling
libxlDomainObjBeginJob().
Bamvor: How can i know whether domain is active or not before this domain is not create?
2), about virDomainRemoveInactive
> +        if (libxlDomainObjEndAsyncJob(driver, vm))
> +            virDomainRemoveInactive(&driver->domains, vm);
>   

Shouldn't we call virDomainRemoveInactive() even if
libxlDomainObjEndAsyncJob() fails?
Bamvor: i do not know the reason actual. 

14:57 2012-10-25
GTD
0, 10:40

16:54 2012-10-25
virtualization, libvirt, xenlight support
"Jim Fehlig <jfehlig@suse.com>"_email_"Re: [Xen-devel] libxl drivers for libvirt?"_20121025_0211
George Dunlap wrote:
> Hey Jim,
>
> I was wondering if you or someone on your team could give me an idea
> what the status of libxl support is in libvirt, particularly wrt
> various releases?
>
> I'm asking because I'm going to UDS next week to talk about the 13.04
> release, and it would be good to get Xen 4.2 in; but that in part
> depends on whether there will be libvirt support for 4.2 in whatever
> version of libvirt they ship as well.  I know Dario has been facing
> the same kind of questions for Fedora 18.
>
> It appears that libvirt 0.10.2 has limited support for the 4.1 libxl
> driver; but:
> * This doesn't include some core features, like live migration

Right.  Chunyan has some patches to implement migration against 4.1
libxl, but IIRC she is still investigating a bug.  Chunyan, can you give
George an update on your libvirt libxl migration patches?

> * It won't compile against 4.2's libxl

Right again.  Ondrej has been looking into this.  Ondrej, do you have
any status to report?  Any questions for the Xen folks wrt 4.1 vs 4.2 libxl?

> Is that right?
>
> So I guess it would be nice to know:
> * What kind of Xen support is available in the most recent release
> (0.10.2, I believe), both xend and libxl

I've provided a table below that lists all of the libvirt hypervisor
driver functions and their implementation status for qemu/kvm, legacy
xen, and libxl drivers.

> * What kind of Xen support for libxl is in the libvirt development
> branch, and do you have an idea when full support for 4.2 (at least,
> including migration, suspend/resume, &c) might be available?

Nothing has changed in git master over what is available in 0.10.2, but
we are now starting to pick up this work.  Our priorities are to first
get the libxl driver compiling against 4.2 and all of the existing
functionality that works with 4.1 working with 4.2, followed by closing
the feature gap with the legacy xen driver, and finally closing the
feature gap with the qemu driver where it makes sense.  This is
obviously quite a bit of work and any help would be appreciated :).

BTW, we don't have any motivation to add features to the 4.1 version of
the libvirt libxl driver.  Bamvor recently sent a patchset to add
finer-grained locking to the libxl driver, but this code is independent
of underlying libxl version IMO

https://www.redhat.com/archives/libvir-list/2012-October/msg00503.html


> * Whether it would be easy for distros to backport 4.2 libxl support
> to whatever their release is?

Until we have patches to make the driver work with 4.2 libxl, I can't
speculate on the effort to backport to previous libvirt releases.

Regards,
Jim

> That would help us better advise distros whether to:
> * Stick with Xen 4.1 for the next release
> * Go with Xen 4.2 but suggest continuing to use xend if libvirt
> support is wanted
> * Go with Xen 4.2 and backport patches to make libvirt work with libxl
> * Go with Xen 4.2 and expect that libxl support will show up without
> too much effort
>
> Obviously change is the only constant, so you can't predict with
> perfect certainty; but if we have an idea what's most likely, we can
> plan on that and then adjust based on what actually happens.
>
> Thanks!
>  -George
>

libvirt hypervisor driver funcs         qemu  xend  libxl
-----------------------------------------------------------------
virDrvOpen                             |  x  |  x  |  x  |
virDrvClose                            |  x  |  x  |  x  |
virDrvDrvSupportsFeature               |  x  |  x  |     |
virDrvGetType                          |  x  |  x  |  x  |
virDrvGetVersion                       |  x  |  x  |  x  |
virDrvGetLibVersion                    |  x  |  x  |  x  |
virDrvGetHostname                      |  x  |  x  |  x  |
virDrvGetSysinfo                       |  x  |     |     |
virDrvGetMaxVcpus                      |  x  |  x  |  x  |
virDrvNodeGetInfo                      |  x  |  x  |  x  |
virDrvGetCapabilities                  |  x  |  x  |  x  |
virDrvListDomains                      |  x  |  x  |  x  |
virDrvNumOfDomains                     |  x  |  x  |  x  |
virDrvListAllDomains                   |  x  |     |  x  |
virDrvDomainCreateXML                  |  x  |  x  |  x  |
virDrvDomainLookupByID                 |  x  |  x  |  x  |
virDrvDomainLookupByUUID               |  x  |  x  |  x  |
virDrvDomainLookupByName               |  x  |  x  |  x  |
virDrvDomainSuspend                    |  x  |  x  |  x  |
virDrvDomainResume                     |  x  |  x  |  x  |
virDrvDomainPMSuspendForDuration       |  x  |     |     |
virDrvDomainPMWakeup                   |  x  |     |     |
virDrvDomainShutdown                   |  x  |  x  |  x  |
virDrvDomainShutdownFlags              |  x  |  x  |  x  |
virDrvDomainReboot                     |  x  |  x  |  x  |
virDrvDomainReset                      |  x  |     |     |
virDrvDomainDestroy                    |  x  |  x  |  x  |
virDrvDomainDestroyFlags               |  x  |  x  |  x  |
virDrvDomainGetOSType                  |  x  |  x  |  x  |
virDrvDomainGetHostname                |     |     |     |
virDrvDomainGetMaxMemory               |  x  |  x  |  x  |
virDrvDomainSetMaxMemory               |  x  |  x  |  x  |
virDrvDomainSetMemory                  |  x  |  x  |  x  |
virDrvDomainSetMemoryFlags             |  x  |     |  x  |
virDrvDomainSetMemoryParameters        |  x  |     |     |
virDrvDomainGetMemoryParameters        |  x  |     |     |
virDrvDomainSetNumaParameters          |  x  |     |     |
virDrvDomainGetNumaParameters          |  x  |     |     |
virDrvDomainSetBlkioParameters         |  x  |     |     |
virDrvDomainGetBlkioParameters         |  x  |     |     |
virDrvDomainGetInfo                    |  x  |  x  |  x  |
virDrvDomainGetState                   |  x  |  x  |  x  |
virDrvDomainGetControlInfo             |  x  |     |     |
virDrvDomainSave                       |  x  |  x  |  x  |
virDrvDomainSaveFlags                  |  x  |  x  |  x  |
virDrvDomainRestore                    |  x  |  x  |  x  |
virDrvDomainRestoreFlags               |  x  |  x  |  x  |
virDrvDomainSaveImageGetXMLDesc        |  x  |     |     |
virDrvDomainSaveImageDefineXML         |  x  |     |     |
virDrvDomainCoreDump                   |  x  |  x  |  x  |
virDrvDomainScreenshot                 |  x  |     |     |
virDrvDomainSetVcpus                   |  x  |  x  |  x  |
virDrvDomainSetVcpusFlags              |  x  |  x  |  x  |
virDrvDomainGetVcpusFlags              |  x  |  x  |  x  |
virDrvDomainPinVcpu                    |  x  |  x  |  x  |
virDrvDomainPinVcpuFlags               |  x  |     |     |
virDrvDomainGetVcpuPinInfo             |  x  |     |     |
virDrvDomainPinEmulator                |  x  |     |     |
virDrvDomainGetEmulatorPinInfo         |  x  |     |     |
virDrvDomainGetVcpus                   |  x  |  x  |  x  |
virDrvDomainGetMaxVcpus                |  x  |  x  |     |
virDrvDomainGetSecurityLabel           |  x  |     |     |
virDrvDomainGetSecurityLabelList       |  x  |     |     |
virDrvNodeGetSecurityModel             |  x  |     |     |
virDrvDomainGetXMLDesc                 |  x  |  x  |  x  |
virDrvConnectDomainXMLFromNative       |  x  |  x  |  x  |
virDrvConnectDomainXMLToNative         |  x  |  x  |  x  |
virDrvListDefinedDomains               |  x  |  x  |  x  |
virDrvNumOfDefinedDomains              |  x  |  x  |  x  |
virDrvDomainCreate                     |  x  |  x  |  x  |
virDrvDomainCreateWithFlags            |  x  |  x  |  x  |
virDrvDomainDefineXML                  |  x  |  x  |  x  |
virDrvDomainUndefine                   |  x  |  x  |  x  |
virDrvDomainUndefineFlags              |  x  |  x  |  x  |
virDrvDomainAttachDevice               |  x  |  x  |  x  |
virDrvDomainAttachDeviceFlags          |  x  |  x  |  x  |
virDrvDomainDetachDevice               |  x  |  x  |  x  |
virDrvDomainDetachDeviceFlags          |  x  |  x  |  x  |
virDrvDomainUpdateDeviceFlags          |  x  |  x  |  x  |
virDrvDomainGetAutostart               |  x  |  x  |  x  |
virDrvDomainSetAutostart               |  x  |  x  |  x  | 
virDrvDomainGetSchedulerType           |  x  |  x  |  x  |
virDrvDomainGetSchedulerParameters     |  x  |  x  |  x  |
virDrvDomainGetSchedulerParametersFlags|  x  |  x  |  x  |
virDrvDomainSetSchedulerParameters     |  x  |  x  |  x  |
virDrvDomainSetSchedulerParametersFlags|  x  |  x  |  x  |
virDrvDomainMigratePrepare             |     |  x  |     |
virDrvDomainMigratePerform             |  x  |  x  |     |
virDrvDomainMigrateFinish              |     |  x  |     |
virDrvDomainBlockResize                |  x  |     |     |
virDrvDomainBlockStats                 |  x  |     |     |
virDrvDomainBlockStatsFlags            |  x  |     |     |
virDrvDomainInterfaceStats             |  x  |  x  |     |
virDrvDomainSetInterfaceParameters     |  x  |     |     |
virDrvDomainGetInterfaceParameters     |  x  |     |     |
virDrvDomainMemoryStats                |  x  |     |     |
virDrvDomainBlockPeek                  |  x  |  x  |     |
virDrvDomainMemoryPeek                 |  x  |     |     |
virDrvDomainGetBlockInfo               |  x  |     |     |
virDrvNodeGetCPUStats                  |  x  |     |     |
virDrvNodeGetMemoryStats               |  x  |     |     |
virDrvNodeGetCellsFreeMemory           |  x  |  x  |     |
virDrvNodeGetFreeMemory                |  x  |  x  |  x  |
virDrvDomainEventRegister              |  x  |  x  |  x  |
virDrvDomainEventDeregister            |  x  |  x  |  x  |
virDrvDomainMigratePrepare2            |  x  |     |     |
virDrvDomainMigrateFinish2             |  x  |     |     |
virDrvNodeDeviceDettach                |  x  |  x  |     |
virDrvNodeDeviceReAttach               |  x  |  x  |     |
virDrvNodeDeviceReset                  |  x  |  x  |     |
virDrvDomainMigratePrepareTunnel       |  x  |     |     |
virDrvConnectIsEncrypted               |  x  |  x  |     |
virDrvConnectIsSecure                  |  x  |  x  |     |
virDrvDomainIsActive                   |  x  |  x  |  x  |
virDrvDomainIsPersistent               |  x  |  x  |  x  |
virDrvDomainIsUpdated                  |  x  |  x  |  x  |
virDrvCompareCPU                       |  x  |     |     |
virDrvBaselineCPU                      |  x  |     |     |
virDrvDomainGetJobInfo                 |  x  |     |     |
virDrvDomainAbortJob                   |  x  |     |     |
virDrvDomainMigrateSetMaxDowntime      |  x  |     |     |
virDrvDomainMigrateGetMaxSpeed         |  x  |     |     |
virDrvDomainMigrateSetMaxSpeed         |  x  |     |     |
virDrvDomainEventRegisterAny           |  x  |     |  x  |
virDrvDomainEventDeregisterAny         |  x  |     |  x  |
virDrvDomainManagedSave                |  x  |     |  x  |
virDrvDomainHasManagedSaveImage        |  x  |     |  x  |
virDrvDomainManagedSaveRemove          |  x  |     |  x  |
virDrvDomainSnapshotCreateXML          |  x  |     |     |
virDrvDomainSnapshotGetXMLDesc         |  x  |     |     |
virDrvDomainSnapshotNum                |  x  |     |     |
virDrvDomainSnapshotListNames          |  x  |     |     |
virDrvDomainListAllSnapshots           |  x  |     |     |
virDrvDomainSnapshotNumChildren        |  x  |     |     |
virDrvDomainSnapshotListChildrenNames  |  x  |     |     |
virDrvDomainSnapshotListAllChildren    |  x  |     |     |
virDrvDomainSnapshotLookupByName       |  x  |     |     |
virDrvDomainHasCurrentSnapshot         |  x  |     |     |
virDrvDomainSnapshotGetParent          |  x  |     |     |
virDrvDomainSnapshotCurrent            |  x  |     |     |
virDrvDomainSnapshotIsCurrent          |  x  |     |     |
virDrvDomainSnapshotHasMetadata        |  x  |     |     |
virDrvDomainRevertToSnapshot           |  x  |     |     |
virDrvDomainSnapshotDelete             |  x  |     |     |
virDrvDomainQemuMonitorCommand         |  x  |     |     |
virDrvDomainQemuAttach                 |  x  |     |     |
virDrvDomainQemuAgentCommand           |  x  |     |     |
virDrvDomainOpenConsole                |  x  |  x  |     |
virDrvDomainOpenGraphics               |  x  |     |     |
virDrvDomainInjectNMI                  |  x  |     |     |
virDrvDomainMigrateBegin3              |  x  |     |     |
virDrvDomainMigratePrepare3            |  x  |     |     |
virDrvDomainMigratePrepareTunnel3      |  x  |     |     |
virDrvDomainMigratePerform3            |  x  |     |     |
virDrvDomainMigrateFinish3             |  x  |     |     |
virDrvDomainMigrateConfirm3            |  x  |     |     |
virDrvDomainSendKey                    |  x  |     |     |
virDrvDomainBlockJobAbort              |  x  |     |     |
virDrvDomainGetBlockJobInfo            |  x  |     |     |
virDrvDomainBlockJobSetSpeed           |  x  |     |     |
virDrvDomainBlockPull                  |  x  |     |     |
virDrvDomainBlockRebase                |  x  |     |     |
virDrvDomainBlockCommit                |  x  |     |     |
virDrvSetKeepAlive                     |     |     |     |
virDrvConnectIsAlive                   |  x  |     |     |
virDrvNodeSuspendForDuration           |  x  |  x  |     |
virDrvDomainSetBlockIoTune             |  x  |     |     |
virDrvDomainGetBlockIoTune             |  x  |     |     |
virDrvDomainGetCPUStats                |  x  |     |     |
virDrvDomainGetDiskErrors              |  x  |     |     |
virDrvDomainSetMetadata                |  x  |     |     |
virDrvDomainGetMetadata                |  x  |     |     |
virDrvNodeGetMemoryParameters          |  x  |  x  |     |
virDrvNodeSetMemoryParameters          |  x  |  x  |     |

09:36 2012-10-26
GTD
0, 9:36

1, today
1), search about Allwinnner quad core.
2), read code in xen-arm

10:03 2012-10-29
GTD
0, -18:20

1, today
1), 20' check the mail. 
2), update my libxl lock patch. see"11:31 2012-10-29"
3), 今天还是没有认真工作，这是最后一次了。

10:04 2012-10-29
embedded, intel 

10:28 2012-10-29
virtualization, libvirt, xen, xenlight support, xenlight update in xen 4.2; doc, summary
"Ian Campbell <Ian.Campbell@citrix.com>"_email_"Re: [Xen-devel] libxl drivers for libvirt?"_20121027_0533
On Fri, 2012-10-26 at 13:54 +0100, Ondřej Holeček wrote:
> I would definitely appreciate any detailed overview what and why
> changed between 4.1 and 4.2 libxl iface. 

A whole tonne of stuff I'm afraid :-/

The bigger things which spring to mind are:
      * The event handling subsystem. This was designed specifically
        with libvirt in mind so I hope they work well for you.
      * Making APIs capable of being called asynchronously where
        necessary. This should benefit toolstacks with a daemon which
        manages multiple domains.
      * Fixes to the handling of forking and signals etc. These are
        problematic to use in a library but we think we've come up with
        a solution which works. Ian J blogged about this [1].
      * Tweaks to the API to make them more consistent and symmetric,
        mostly to file some of the rought edges/gotchas us before
        calling the API stable and to give us something which we were
        happy to support going forward.

The upside is that in 4.2 we have a libxl API which we are committed to
maintaining in a stable / backwards compatible manner, as described in
libxl.h[0].

Ian.
[0]
http://xenbits.xen.org/hg/xen-unstable.hg/file/tip/tools/libxl/libxl.h#l16
[1]
http://blog.xen.org/index.php/2012/05/22/libxl-event-api-improvements/

2, libxl event API improvements
http://blog.xen.org/index.php/2012/05/22/libxl-event-api-improvements/
The Xen 4.1 libxl API had some awkward features. Particularly, dealing with long-running operations, and getting information about events such as domain death, was difficult to do correctly in daemons such as libvirt’s virtd and XCP/XenServer. 
(Xen 4.2)
The new arrangements are intended to support everything from the simple xl command line utility, to event-callback-based daemons such as virtd, and also to be convenient for use in multithreaded programs.
For example the new event registration callbacks in libxl can be directly mapped to libvirt’s event loop registration facilities.

11:05 2012-10-29
opensuse, arm
1, "Dirk Müller<dmueller@suse.com>"_email_"[opensuse-arm] openSUSE 12.2 RC2 Release preparation"_20121027_1831
http://download.opensuse.org/ports/armv7hl/distribution/12.2-RC2/
http://download.opensuse.org/ports/armv7hl/distribution/openSUSE-stable/
2, armv8 sever
Agraf
Linaro just announced a public armv8 Linux build plus emulator:
   http://www.linaro.org/engineering/armv8/
So if anyone wants to start bootstrapping openSUSE for armv8, here's 
your chance ;)

11:31 2012-10-29
(10:29 2012-10-30)
(10:30 2012-10-31)
(16:04 2012-11-02)
virtualization, libvirt, xen, patch, lock, upstream reply, modify
1, remove migration relative job functions from lock patch. 
2, update comments according to upstream's comments. 
3, respond to comments in the previous patch
1), about libxlAbortJob
> This function will always fail with the above logic.  ret is initialized
> to -1 and is never changed.
> Is it even possible to safely abort a libxl operation?  If not, this
> function should probably remain unimplemented.  Maybe it will be useful
> when the libxl driver supports migration.
return error because of the there is no cancelation opeartion in libvirt libxl driver with xen 4.1. according to xen4.2 release document, maybe the cancelation of long-running jobs is supported. 
but it is still useful for save, dump and migration(in future), because libvirt should block the user abort operation othervise xenlight might crash
2), about restore job 
> imo, libxl_async_job_restore should be added to this list.  i see it is
> omitted in the qemu driver as well, so perhaps there is a good reason
> for it?
i do not know why it is omitted by qemu driver. but for libxl driver, it is
hard to let other operation execution even if it is a async job. because
virDomainObjPtr is used by libxlVmStart, especially by
libxl_domain_create_restore.
3), about usage of virDomainRemoveInactive
> Shouldn't we call virDomainRemoveInactive() even if
> libxlDomainObjEndAsyncJob() fails?
virDomainRemoveInactive depends on virDomainObjPtr. the failure of libxlDomainObjEndJob or libxlDomainObjEndAsyncJob lead to virDomainObjPtr non-existed. 
meanwhile libxlDomainObjEndxxxJob should not failed while it is paired with libxlDomainObjBeginxxxJob. 
4, send email to "Daniel P. Berrange" <berrange@redhat.com> and Eric Blake <eblake@redhat.com>
 git send-email --cover-letter --no-chain-reply-to --annotate --to libvir-list@redhat.com --cc eblake@redhat.com --cc berrange@redhat.com --cc jfehlig@suse.com --cc cyliu@suse.com 000*.patch

15:37 2012-10-29
suse, registration, qa local registration center
fill the following local center while registration. 
147.2.207.207:/center/regsvc
(14:09 2013-03-12)
or 
https://147.2.207.207/center/regsvc

10:22 2012-10-30
GTD
0, 10:00-11:38

1, today
1), help ZHONG LiDong. see"10:41 2012-10-30"
2), update my libxl lock patch. see"11:31 2012-10-29"

10:41 2012-10-30
virtualization, libvirt, virsh, virt-manager; storage, attach-disk do not work sometimes
1, login failed because install vm fail with some package missing.
actually, it is not a virtualization relative issue. 
fix it. by mount the partition in host then check and copy the shadow(passwd if needed) to vm disk. 
at this time, root login fail because of the root password missing in the /etc/shadow file. the right password in shadow file should be like this: 
root:$2y$0B8HERCAeyJO5U3QCVFL5k9.o36/RAuEBbSblQNi:15496::::::
2, attach-disk do not work while vm first boot.
1), attach-disk successful but it is not appear in the vm "fdisk -l". 
virsh attach-disk domid vg sda #successful
virsh domblkinfo domid sda     #successful
virsh dumpxml domid | less     #found the sda in xml
2), reboot vm then sda is appear in the vm. 
3), detach-disk and attach-disk, it is ok. 
is that a bug or not? 

10:50 2012-10-30
software skill, shell, bash, rename from 乱码; random varible; arithmatic equation
1, 
> ls 9*
9MM?%85%8D??%8C??%81?%89%88.gpk?k=4Kp80y-7RYuSX9X0CvgfJQ&t=1351491560&u=3732849306-2176031-dpefda13&s=51200&file=9MM?%85%8D??%8C??%81?%89%88.gpk
9MM?%85%8D??%8C??%81?%89%88.gpk?k=sjYaDClyDpz5m-trL1FtOg&t=1351518499&u=3732849306-2176031-dpefda13&s=51200&file=9MM?%85%8D??%8C??%81?%89%88.gpk
> for f in `ls 9* --color=none`; do mv "$f" 9MM_`echo $(($RANDOM % 10))`; done
> ls 9MM_*
9MM_2  9MM_9 

2, or
> i=0; for f in `ls 9* --color=none`; do mv "$f" 9MM_`echo $((i++))`; done
will got 
9MM_0 9MM_1

3, about bash
1), random: $RANDOM
2), arithmatic: $(( your equation ))

13:49 2012-10-30
opensuse, arm, build service
"Guillaume Gardet <guillaume.gardet@free.fr>"_email_"Re: [opensuse-arm] Re: [obs submit-request 139668] openSUSE:12.2:ARM:Contrib:Tegra/JeOS-ac100: created by worldcitizen"_20121030_1205
> Which file should be the standard template that I should commit here, or will pre_checkin.sh generate a new JeOS-ac100.kiwi file anyway?

pre_checkin will create your file.

> How/when is the script pre_checkin.sh run on the OBS server?

You have to run it manually before commit.

14:13 2012-10-30
suse, all hands meeting
Q2FY13
asia pacific: 105%, 7200 -> 7600
1half FY13
asia pacific 14500 -> 14600 13000(1half FY)
key traction
Bundesagentur fur Arbit 5400k. including 3900k product.
ongoing slaris to sles
dc automation initiative

Welcome tothe Federal Employment Agency

The Federal Employment Agency (Bundesagentur für Arbeit - BA) is the largest provider of labour market services in Germany. It has a network of more than 700 agencies and branch offices nationwide. Our most important tasks are job and training placement, career counselling and providing benefits replacing employment income such as unemployment benefit and insolvency payments. The Family Benefits Office (Familienkasse), which provides child benefit, is also part of the Federal Employment Agency. The Federal Employment Agency introduces its organisation and services on the following pages. In doing so, we focus on those topics that are important for customers from abroad.




kroger
largest grocery store chain in USA
world fouth largest retailer.
5000 server, per server up to  32cpu. 
IBM provided Financing.

1Half FY13 cross BU
attachmate 117%. 65500->76800.
suse 106% 94200->99600
novell 90%, 152700
netiq 85%  112400

 intel 4800k: sles renewal
CVS 3000k sles new and renewal
HSBC 2800k ms certs; 1100new 1700 renewal(?)
T-system 1200k suse manager

suse cloud
dell roadshow
b1 system
announcd 2.5days technical training on SUSE cloud

suse cloud 2.0 plan
openstack folsom
HA support for control nodes
Crawbar 2 alignment with dell
additional hypersivor support

lead generation
unix to linux compaign: integrated, autmated, global.

customer reference program 

web shop update
increase online sales(<5k) to 5ml in 2015

r&d update

10:13 2012-10-31
GTD
0, 10:10

1, today
1), 20' armv8 kernel. see"10:14 2012-10-31", "10:26 2012-10-31"
2), 15:34 update my libxl lock patch. see"11:31 2012-10-29"

10:14 2012-10-31
linux, arm, armv8, kernel, armv8 kernel尝鲜
1, doc
http://www.linaro.org/engineering/armv8/
https://wiki.linaro.org/HowTo/BuildArm64Kernel
2, download
1), code tree
% git clone git://git.linaro.org/kernel/linaro-aarch64.git
% cd linaro-aarch64
% git checkout -b linaro-aarch64 origin/linaro-aarch64
2), toolchain
wget http://releases.linaro.org/12.10/components/toolchain/gcc-linaro/aarch64/rc3/gcc-linaro-aarch64-linux-gnu-4.7+bzr115029-20121015+bzr2506_linux.tar.bz2
3, config
1), arch/arm64/configs/defconfig
2), arch and soc
CONFIG_PLAT_VEXPRESS:
ARMv8 software model (Versatile Express)
4, start code
arch/arm64/kernel/head.S
using xx instead of rx as register name. 
x0, x1, ... x22, ...

10:26 2012-10-31
linux, arm, arm64, run armv8 kernel
http://www.linaro.org/engineering/armv8/
Downloading assets
mkdir ~/linaro-armv8
cd ~/linaro-armv8
Download boot image:
wget http://releases.linaro.org/12.10/openembedded/aarch64/rc3/img-foundation.axf
Download and extract disk image:
wget http://releases.linaro.org/12.10/openembedded/aarch64/rc3/vexpress64-openembedded_sdk-armv8_20121019-22.img.gz
gunzip vexpress64-openembedded_sdk-armv8_20121019-22.img.gz
Fast Models are ARM’s software to provide a full virtual ARMv8 system on an x86-64 machine (there is no 32-bit x86 version).  Linaro images will work with both the free to download ARMv8 Foundation model and with commercial Versatile Express model (AEMv8 VE model).
The following instructions are for the ARMv8 Foundation model which you may obtain from ARM at:
https://silver.arm.com/download/download.tm?pv=1317469
Unpack the model in a directory of your choice, for instance in your home directory:
cd ~/linaro-armv8
tar xvf ~/Downloads/FM000-KT-00035-r0p8-44rel23.tgz

11:02 2012-10-31
suse, community, opensuse, arm, packaging
Andrew Wafaa made a nice list of people who deserve credit for their hard work on openSUSE ARM
1, Clarification & Credits for openSUSE on ARM Chromebooks
http://andrew.wafaa.eu/blog/clarification-credits-for-opensuse-on-arm-chromebooks/
26 Oct 2012 / andrew posted in ARM, openSUSE / 1 Comment

After my post yesterday on getting openSUSE on the new ARM Chromebook, a lot of interest was generated with discussions on various forms of media – heck I even got Slashdotted (thanks :-) ). I read some but not all of them and even the comments. One thing popped out to me, and I feel I need to clarify some things.

    Whilst I do indeed work for ARM, my device was a private purchase and not provided to me by my employer. Luckily as part of my role I am able to spend time doing fun things like getting openSUSE on the Chromebook.
    I have never taken credit for doing all the hard work of working out what needed to be done to get openSUSE on the Chromebook, the hard work was done by Olof Johanssen as I mentioned. He wrote up some excellent steps that were very easy to follow. I and all other people interested in getting Linux on the Chromebook regardless of distro are indebted to Olof for his work.
    I am not responsible or incharge of getting openSUSE on ARM. It is a collaborative effort by the community, and there are many others that have put in a whole heap of hard work doing things that I can only aspire to do. To name a few of the fine people in our community that have put in the time and effort would be a mistake as I will undoubtedly miss some people off the list, but it is  a mistake I’m willing to accept so here goes - Adrian Schröter, Alex Graf, Joop Boonen, Guillaume Gardet, Marcus Schäfer, Dirk Müller, Andreas Färber, Bernhard Wiedemann, Bamvor Jian Zhang, Peter Czanik, Michal Vyskocil, and many more. Without the blood, sweat and tears that these fine folk have shed we would not be in the position we are now; so thank you all for your hard work and long may it continue :-)

Hopefully that will clarify any confusion that some people may have had, and sorry to those that I missed off the list – if you feel hard done by me omitting your name off this list please let me know and I will make sure you get the credit you deserve!

2, another location
http://news.opensuse.org/?p=14500&preview=true

11:14 2012-10-31
suse, community, xen, coding
1, 20120917
http://blog.xen.org/index.php/2012/09/17/xen-4-2-0-released/
http://wiki.xen.org/wiki/Xen_4.2_Acknowledgments
Name   Commits   Changes
Bamvor Jian Zhang 	2 	201 

11:22 2012-10-31
virtualization, xen, xen 4.3, feature
http://lists.xen.org/archives/html/xen-devel/2012-08/msg01588.html
1, plan 
9 month release cycle.
2, features
* Event channel scalability
  owner: attilio@citrix
  Increase limit on event channels (currently 1024 for 32-bit guests,
  4096 for 64-bit guests)

* NUMA scheduler affinity
  owner: dario@citrix

* NUMA Memory migration
  owner: dario@citrix

* PVH mode, domU (w/ Linux)
  owner: mukesh@oracle

* PVH mode, dom0 (w/ Linux)
  owner: mukesh@oracle

* ARM server port
  owner: @citrix

* blktap3
  owner: @citrix

* Default to QEMU upstream
 - qemu-based stubdom (Linux or BSD libc)
    owner: anthony@citrix
    qemu-upstream needs a more fully-featured libc than exists in
    minios.  Either work on a minimalist linux-based stubdom with
    glibc, or port one of the BSD libcs to minios.

 - pci pass-thru
    owner: anthony@citrix

* Persistent grants
  owner: @citrix

* Multi-page blk rings
 - blkback in kernel (@intel)
 - qemu blkback

* Multi-page net protocol
  owner: ?
  expand the network ring protocol to allow multiple pages for
  increased throughput

* xl vm-{export,import}
  owner: ?
  Allow xl to import and export VMs to other formats; particularly
  ovf, perhaps the XenServer format, or more.


* xl USB pass-through for PV guests
  owner: ?
  Port the xend PV pass-through functionality to xl.

* openvswitch toostack integration
  owner: roger@citrix

* Rationalized backend scripts (incl. driver domains)
  owner: roger@citrix

* Full-VM snapshotting
  owner: ?
  Have a way of coordinating the taking and restoring of VM memory and
  disk snapshots.  This would involve some investigation into the best
  way to accomplish this.

* VM Cloning
  owner: ?
  Again, a way of coordinating the memory and disk aspects.  Research
  into the best way to do this would probably go along with the
  snapshotting feature.

* Make storage migration possible
  owner: ?
  There needs to be a way, either via command-line or via some hooks,
  that someone can build a "storage migration" feature on top of libxl
  or xl.

* PV audio (audio for stubdom qemu)
  owner: stefano.panella@citrix

* Memory: Replace PoD with paging mechanism
  owner: george@citrix

* Managed domains?

3, other features
1), Jan Beulich
- breaking the 5Tb memory barrier (for the moment aiming at
  16Tb due to certain implementation details)
- an xHCI debug port driver for the console (no Linux driver to
  clone from so far, so needs someone with good knowledge of
  the device and access to hardware, neither of which is the
  case for me, or finding out whether this is already in the works
  on the Linux side)
- if possible, a FireWire based console driver (but I've never done
  anything with FireWire, so it would depend on me finding ample
  time to first play with and then work on this)
- getting the public headers x32-clean
2), Pasi Kärkkäinen 
Another USB item:
* xl support for USB device passthru using QEMU emulated USB for HVM guests (no 
need for PVUSB drivers in the HVM guest).
  This works today in xm/xend with qemu-traditional, but is limited to USB 1.1, 
probably because 
  the old version of Qemu-dm-traditional which lacks USB 2.0/3.0.
  So xl support for emulated USB device passthru for both qemu-upstream and 
qemu-traditional.

More wishlist items:
* Nested hardware virtualization. Important for easier testing and development 
of Xen (Xen-on-Xen),
  and for running other hypervisors in Xen VMs. Interesting for labs, POCs, etc.
* VGA/GPU passthru support for AMD/NVIDIA; lots of patches on xen-devel 
archives, 
  but noone has yet stepped up to clean up and get them merged. 
  Currently Intel gfx passthru patches are merged to Xen, but primary 
ATI/NVIDIA require extra patches.
  This is actually something that a LOT of users ask often, it's discussed 
almost every day on ##xen on IRC.
  I wonder if XenClient folks could help here? 
* Dom0 Keyboard/mouse sharing to HVM guests; mainly needed by VGA/GPU passthru 
users.
  Fujitsu guys posted some patches for this in 2010, and XenClient guys in 2009 
(iirc),
  but nothing got further developed and merged to upstream Xen.
* QXL virtual GPU support for SPICE. Someone was already developing this, 
  and posted patches earlier during 4.2 development cycle to xen-devel. 
  Upstream Qemu includes QXL support.
* PVSCSI support in XL. James Harper was (semi) interested in working with this,
  because he has a PVSCSI frontend driver in Windows GPLPV drivers, and he's 
using PVSCSI for tape backups himself.
* libvirt libxl driver improvements; support more Xen features. 
  Allows better using the Ubuntu/Debian/Fedora/RHEL/CentOS "default" 
virtualization GUI also with Xen.

5, something I interested in: 
1), arm server
(1), PVH mode, domU (w/ Linux), PVH mode, dom0 (w/ Linux)
  owner: mukesh@oracle
(2), ARM server port
  owner: @citrix
(3), If allwinner A15X is mass production in time. it is a good choice for me to join in the xen arm porting for Cortex-A15/A7. 
2), Full-VM snapshotting
  owner: ?
bamvor: if this is work, i could work on snapshot in libvirt libxl driver. 
3), libvirt libxl driver improvements
Pasi Kärkkäinen 
libvirt libxl driver improvements; support more Xen features.
Allows better using the Ubuntu/Debian/Fedora/RHEL/CentOS "default" 
virtualization GUI also with Xen.

George Dunlap:
This is pretty important.  Looking at feature parity between
libvirt+KVM and libvirt+Xen on the Citrix xen.org to-do list, but to
begin with it's more of a research than a feature, so wasn't on this
particular list.  If you happen to know a specific list of missing
features, that might be something we could try to fit in for 4.3.

Pasi Kärkkäinen: 
Yeah, I've been planning to test the latest libvirt libxl driver and 
see what works and what doesn't, but haven't gotten there yet.

6, PVH mode is new mode combined with PV driver and HVM virtualization. it will be used by X86, ARM Cortex-A15, ARM v8.
relative link and video
http://blog.xen.org/index.php/2012/09/21/xensummit-sessions-new-pvh-virtualisation-mode-for-arm-cortex-a15arm-servers-and-x86/
The new PV in an HVM container virtualization mode (or PVH) proposed and developed by Mukesh Rathor, Oracle: this is a new virtualization mode called PVH aimed to be part of Xen 4.3. PVH guests are essentially PV guests using PV drivers for boot and I/O. Otherwise it uses HW virtualization extensions, without the need for emulation. PVH has the potential to combine the best trade-offs of all Xen virtualization modes, while simplifying the Xen architecture significantly. First patches are going into xen-unstable as we speak and functionality should be at least available as a preview (but hopefully ready for prime-time) in Xen 4.3.
An update on the Xen on ARM port for Servers: Stefano Stabellini (Citrix) is presenting the state of his work ARM work for the Cortex A15, design goals (and what we achieved), architecture and remaining challenges. Interestingly, the approach taken for Xen on ARM is the same as Mukesh has taken for PVH. Even if you are not interested in ARM (and merely want to understand PVH a bit more), it is worth watching this session. Stefano is upstreaming remaining patches to Linux currently, and started working on testing his port on real hardware. Ian Campbell has just started porting the code to ARM v8. Stay tuned!
Panel on ARM Servers: Representatives from ARM, Canonical, Calxeda and Citrix discuss the potential of virtualization for ARM based servers. I added this video, to provide context for Stefano’s and Ian Campbells work.

7, download the video with youtube-dl(Thanks to DongMao's help).
https://github.com/rg3/youtube-dl
git clone git://github.com/rg3/youtube-dl.git
> ./youtube-dl -l http://vimeo.com/49506288
"-l" will name the down file with the name from video website. not hashname.

it fail so frequently, write a loop for download: 
while true; do ./youtube-dl -l http://vimeo.com/49506288;  if [ $? != 0 ]; then echo fail; echo "#######################"; else echo successful; break; fi; sleep 1;done

14:40 2012-10-31
sofware skill, network, downloader, wget; 断点续传
1, -c,  --continue                resume getting a partially-downloaded file.

14:59 2012-10-31
opensuse, software; video player
1, vlc
http://download.videolan.org/pub/vlc/SuSE/12.2/

15:21 2012-10-31
conference, opensuse, video; opensuse on arm
1, "Lei Dai"_email_20121031
Full record videos of openSUSE conference 2012 are here:
http://bambuser.com/channel/opensusetv 
You also can view the session cut separately here:
http://youtube.com/opensusetv 
http://blip.tv/openSUSEtv
2, "work/opensuse_ARM/video"

15:32 2012-10-31
virtualization, xen, slideshow
1, http://www.slideshare.net/xen_com_mgr/

16:56 2012-10-31
arm, arm64, armv8, feature
1, 
ARMv8 Architecture
The ARMv8 architecture introduces 64-bit support to the ARM architecture with a focus on power-efficient implementation while maintaining compatibility with existing 32-bit software. By adopting a clean approach ARMv8 processors, such as the ARM Cortex-A57 and ARM Cortex-A53, extend the performance range available while maintaining the low power consumption characteristics of the ARM processors that will power tomorrow's most innovative and efficient devices.
2, Cortex-A50 series
http://www.arm.com/products/processors/cortex-a50/index.php
Other features include load-acquire and store-release, which are an excellent match for the C++11, C11 and Java memory models, improving performance of thread-safe by removing the need for explicit memory barrier instructions in many cases. Automatic event signaling enables power-efficient, high-performance spinlocks.
1),http://www.arm.com/products/processors/cortex-a50/cortex-a53-processor.php 
http://www.arm.com/products/processors/cortex-a50/cortex-a57-processor.php
Cortex-A53 2.3DMIPS, 看起来A53还是走的中性能地功耗路线, 下一代的中端手机首选?
Cortex-A57 48k icache with DED parity, 32k D$ with w/ECC. 512k-2M L2$ w/ECC. 
Cortex-A53 8-64k icache with DED parity, 8-64k D$ with w/ECC. 512k-2M L2$ w/ECC. 
2),http://www.techspot.com/news/50656-arm-announces-64-bit-cortex-a57-and-cortex-a53-processors.html 

